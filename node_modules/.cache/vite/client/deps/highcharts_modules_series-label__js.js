import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/series-label.js
var require_series_label = __commonJS({
  "node_modules/highcharts/modules/series-label.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/series-label", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function o(e2, o2, r, i) {
        e2.hasOwnProperty(o2) || (e2[o2] = i.apply(null, r), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: o2, module: e2[o2] } })));
      }
      o(e, "Extensions/SeriesLabel/SeriesLabelDefaults.js", [], function() {
        return { enabled: true, connectorAllowed: false, connectorNeighbourDistance: 24, format: void 0, formatter: void 0, minFontSize: null, maxFontSize: null, onArea: null, style: { fontSize: "0.8em", fontWeight: "bold" }, useHTML: false, boxesToAvoid: [] };
      }), o(e, "Extensions/SeriesLabel/SeriesLabelUtilities.js", [], function() {
        function t2(t3, e3, o2, r, i, a) {
          let n = (a - e3) * (o2 - t3) - (r - e3) * (i - t3);
          return n > 0 || !(n < 0);
        }
        function e2(e3, o2, r, i, a, n, s, l) {
          return t2(e3, o2, a, n, s, l) !== t2(r, i, a, n, s, l) && t2(e3, o2, r, i, a, n) !== t2(e3, o2, r, i, s, l);
        }
        return { boxIntersectLine: function(t3, o2, r, i, a, n, s, l) {
          return e2(t3, o2, t3 + r, o2, a, n, s, l) || e2(t3 + r, o2, t3 + r, o2 + i, a, n, s, l) || e2(t3, o2 + i, t3 + r, o2 + i, a, n, s, l) || e2(t3, o2, t3, o2 + i, a, n, s, l);
        }, intersectRect: function(t3, e3) {
          return !(e3.left > t3.right || e3.right < t3.left || e3.top > t3.bottom || e3.bottom < t3.top);
        } };
      }), o(e, "Extensions/SeriesLabel/SeriesLabel.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Templating.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Extensions/SeriesLabel/SeriesLabelDefaults.js"], e["Extensions/SeriesLabel/SeriesLabelUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, o2, r, i, a, n) {
        let { animObject: s } = t2, { format: l } = e2, { setOptions: h } = o2, { composed: c } = r, { boxIntersectLine: p, intersectRect: u } = a, { addEvent: d, extend: f, fireEvent: x, isNumber: b, pick: m, pushUnique: g, syncTimeout: y } = n;
        function X(t3, e3, o3, r2, i2) {
          let a2 = t3.chart, n2 = t3.options.label || {}, s2 = m(n2.onArea, !!t3.area), l2 = s2 || n2.connectorAllowed, h2 = a2.boxesToAvoid, c2 = Number.MAX_VALUE, d2 = Number.MAX_VALUE, f2, x2, b2, g2, y2, X2, S2;
          for (X2 = 0; h2 && X2 < h2.length; X2 += 1) if (u(h2[X2], { left: e3, right: e3 + r2.width, top: o3, bottom: o3 + r2.height })) return false;
          for (X2 = 0; X2 < a2.series.length; X2 += 1) {
            let h3 = a2.series[X2], u2 = h3.interpolatedPoints && [...h3.interpolatedPoints];
            if (h3.visible && u2) {
              let m2 = a2.plotHeight / 10;
              for (let t4 = a2.plotTop; t4 <= a2.plotTop + a2.plotHeight; t4 += m2) u2.unshift({ chartX: a2.plotLeft, chartY: t4 }), u2.push({ chartX: a2.plotLeft + a2.plotWidth, chartY: t4 });
              for (S2 = 1; S2 < u2.length; S2 += 1) {
                if (u2[S2].chartX >= e3 - 16 && u2[S2 - 1].chartX <= e3 + r2.width + 16) {
                  if (p(e3, o3, r2.width, r2.height, u2[S2 - 1].chartX, u2[S2 - 1].chartY, u2[S2].chartX, u2[S2].chartY)) return false;
                  t3 === h3 && !b2 && i2 && (b2 = p(e3 - 16, o3 - 16, r2.width + 32, r2.height + 32, u2[S2 - 1].chartX, u2[S2 - 1].chartY, u2[S2].chartX, u2[S2].chartY));
                }
                (l2 || b2) && (t3 !== h3 || s2) && (c2 = Math.min(c2, (g2 = e3 + r2.width / 2 - u2[S2].chartX) * g2 + (y2 = o3 + r2.height / 2 - u2[S2].chartY) * y2));
              }
              if (!s2 && l2 && t3 === h3 && (i2 && !b2 || c2 < Math.pow(n2.connectorNeighbourDistance || 1, 2))) {
                for (S2 = 1; S2 < u2.length; S2 += 1) (f2 = Math.min(Math.pow(e3 + r2.width / 2 - u2[S2].chartX, 2) + Math.pow(o3 + r2.height / 2 - u2[S2].chartY, 2), Math.pow(e3 - u2[S2].chartX, 2) + Math.pow(o3 - u2[S2].chartY, 2), Math.pow(e3 + r2.width - u2[S2].chartX, 2) + Math.pow(o3 - u2[S2].chartY, 2), Math.pow(e3 + r2.width - u2[S2].chartX, 2) + Math.pow(o3 + r2.height - u2[S2].chartY, 2), Math.pow(e3 - u2[S2].chartX, 2) + Math.pow(o3 + r2.height - u2[S2].chartY, 2))) < d2 && (d2 = f2, x2 = u2[S2]);
                b2 = true;
              }
            }
          }
          return (!i2 || !!b2) && { x: e3, y: o3, weight: c2 - (x2 ? d2 : 0), connectorPoint: x2 };
        }
        function S(t3) {
          if (this.renderer) {
            let e3 = this, o3 = s(e3.renderer.globalAnimation).duration;
            e3.labelSeries = [], e3.labelSeriesMaxSum = 0, e3.seriesLabelTimer && n.clearTimeout(e3.seriesLabelTimer), e3.series.forEach(function(r2) {
              let i2 = r2.options.label || {}, a2 = r2.labelBySeries, n2 = a2 && a2.closest;
              i2.enabled && r2.visible && (r2.graph || r2.area) && !r2.boosted && e3.labelSeries && (e3.labelSeries.push(r2), i2.minFontSize && i2.maxFontSize && r2.yData && (r2.sum = r2.yData.reduce((t4, e4) => (t4 || 0) + (e4 || 0), 0), e3.labelSeriesMaxSum = Math.max(e3.labelSeriesMaxSum || 0, r2.sum || 0)), "load" === t3.type && (o3 = Math.max(o3, s(r2.options.animation).duration)), n2 && (void 0 !== n2[0].plotX ? a2.animate({ x: n2[0].plotX + n2[1], y: n2[0].plotY + n2[2] }) : a2.attr({ opacity: 0 })));
            }), e3.seriesLabelTimer = y(function() {
              e3.series && e3.labelSeries && function(t4) {
                t4.boxesToAvoid = [];
                let e4 = t4.labelSeries || [], o4 = t4.boxesToAvoid;
                t4.series.forEach((t5) => (t5.points || []).forEach((e5) => (e5.dataLabels || []).forEach((e6) => {
                  let { width: r2, height: i2 } = e6.getBBox(), a2 = (e6.translateX || 0) + (t5.xAxis ? t5.xAxis.pos : t5.chart.plotLeft), n2 = (e6.translateY || 0) + (t5.yAxis ? t5.yAxis.pos : t5.chart.plotTop);
                  o4.push({ left: a2, top: n2, right: a2 + r2, bottom: n2 + i2 });
                }))), e4.forEach(function(t5) {
                  let e5 = t5.options.label || {};
                  t5.interpolatedPoints = function(t6) {
                    let e6, o5, r2, i2, a2;
                    if (!t6.xAxis && !t6.yAxis) return;
                    let n2 = t6.points, s2 = [], l2 = t6.graph || t6.area, h2 = l2 && l2.element, c2 = t6.chart.inverted, p2 = t6.xAxis, u2 = t6.yAxis, d2 = c2 ? u2.pos : p2.pos, f2 = c2 ? p2.pos : u2.pos, x2 = c2 ? p2.len : u2.len, g2 = c2 ? u2.len : p2.len, y2 = m((t6.options.label || {}).onArea, !!t6.area), X2 = u2.getThreshold(t6.options.threshold), S2 = {}, M2 = c2 ? "chartCenterX" : "chartCenterY";
                    function w(t7) {
                      let e7 = Math.round((t7.plotX || 0) / 8) + "," + Math.round((t7.plotY || 0) / 8);
                      S2[e7] || (S2[e7] = 1, s2.push(t7));
                    }
                    if (t6.getPointSpline && h2 && h2.getPointAtLength && !y2 && n2.length < (t6.chart.plotSizeX || 0) / 16) {
                      let t7 = l2.toD && l2.attr("d");
                      for (l2.toD && l2.attr({ d: l2.toD }), r2 = h2.getTotalLength(), e6 = 0; e6 < r2; e6 += 16) {
                        let t8 = h2.getPointAtLength(e6), o7 = c2 ? g2 - t8.y : t8.x, r3 = c2 ? x2 - t8.x : t8.y;
                        w({ chartX: d2 + o7, chartY: f2 + r3, plotX: o7, plotY: r3 });
                      }
                      t7 && l2.attr({ d: t7 });
                      let o6 = n2[n2.length - 1].pos();
                      w({ chartX: d2 + ((o6 == null ? void 0 : o6[0]) || 0), chartY: f2 + ((o6 == null ? void 0 : o6[1]) || 0) });
                    } else {
                      let t7;
                      for (e6 = 0, r2 = n2.length; e6 < r2; e6 += 1) {
                        let r3 = n2[e6], [s3, l3] = r3.pos() || [], { plotHigh: h3 } = r3;
                        if (b(s3) && b(l3)) {
                          let e7 = { plotX: s3, plotY: l3, chartX: d2 + s3, chartY: f2 + l3 };
                          if (y2 && (h3 && (e7.plotY = h3, e7.chartY = f2 + h3), c2 ? e7.chartCenterX = d2 + g2 - ((h3 || r3.plotY || 0) + m(r3.yBottom, X2)) / 2 : e7.chartCenterY = f2 + ((h3 || l3) + m(r3.yBottom, X2)) / 2), t7 && (o5 = Math.max(Math.abs(e7.chartX - t7.chartX), Math.abs(e7.chartY - t7.chartY))) > 16) for (a2 = 1, i2 = Math.ceil(o5 / 16); a2 < i2; a2 += 1) w({ chartX: t7.chartX + (e7.chartX - t7.chartX) * (a2 / i2), chartY: t7.chartY + (e7.chartY - t7.chartY) * (a2 / i2), [M2]: (t7[M2] || 0) + ((e7[M2] || 0) - (t7[M2] || 0)) * (a2 / i2), plotX: (t7.plotX || 0) + (s3 - (t7.plotX || 0)) * (a2 / i2), plotY: (t7.plotY || 0) + (l3 - (t7.plotY || 0)) * (a2 / i2) });
                          w(e7), t7 = e7;
                        }
                      }
                    }
                    return s2;
                  }(t5), o4.push(...e5.boxesToAvoid || []);
                }), t4.series.forEach(function(e5) {
                  let o5 = e5.options.label;
                  if (!o5 || !e5.xAxis && !e5.yAxis) return;
                  let r2 = "highcharts-color-" + m(e5.colorIndex, "none"), i2 = !e5.labelBySeries, a2 = o5.minFontSize, n2 = o5.maxFontSize, h2 = t4.inverted, c2 = h2 ? e5.yAxis.pos : e5.xAxis.pos, p2 = h2 ? e5.xAxis.pos : e5.yAxis.pos, u2 = t4.inverted ? e5.yAxis.len : e5.xAxis.len, d2 = t4.inverted ? e5.xAxis.len : e5.yAxis.len, x2 = e5.interpolatedPoints, b2 = m(o5.onArea, !!e5.area), g2 = [], y2 = e5.xData || [], S2, M2, w, A, Y, L, v = e5.labelBySeries, E, T, C;
                  function P(t5, e6, o6) {
                    let r3 = Math.max(c2, m(T, -1 / 0)), i3 = Math.min(c2 + u2, m(C, 1 / 0));
                    return t5 > r3 && t5 <= i3 - o6.width && e6 >= p2 && e6 <= p2 + d2 - o6.height;
                  }
                  function j() {
                    v && (e5.labelBySeries = v.destroy());
                  }
                  if (b2 && !h2 && (E = [e5.xAxis.toPixels(y2[0]), e5.xAxis.toPixels(y2[y2.length - 1])], T = Math.min.apply(Math, E), C = Math.max.apply(Math, E)), e5.visible && !e5.boosted && x2) {
                    if (!v) {
                      let i3 = e5.name;
                      if ("string" == typeof o5.format ? i3 = l(o5.format, e5, t4) : o5.formatter && (i3 = o5.formatter.call(e5)), e5.labelBySeries = v = t4.renderer.label(i3, 0, 0, "connector", 0, 0, o5.useHTML).addClass("highcharts-series-label highcharts-series-label-" + e5.index + " " + (e5.options.className || "") + " " + r2), !t4.renderer.styledMode) {
                        let r3 = "string" == typeof e5.color ? e5.color : "#666666";
                        v.css(f({ color: b2 ? t4.renderer.getContrast(r3) : r3 }, o5.style || {})), v.attr({ opacity: t4.renderer.forExport ? 1 : 0, stroke: e5.color, "stroke-width": 1 });
                      }
                      a2 && n2 && v.css({ fontSize: a2 + (e5.sum || 0) / (e5.chart.labelSeriesMaxSum || 0) * (n2 - a2) + "px" }), v.attr({ padding: 0, zIndex: 3 }).add();
                    }
                    for ((S2 = v.getBBox()).width = Math.round(S2.width), Y = x2.length - 1; Y > 0; Y -= 1) b2 ? P(M2 = (x2[Y].chartCenterX ?? x2[Y].chartX) - S2.width / 2, w = (x2[Y].chartCenterY ?? x2[Y].chartY) - S2.height / 2, S2) && (L = X(e5, M2, w, S2)) : (P(M2 = x2[Y].chartX + 3, w = x2[Y].chartY - S2.height - 3, S2) && (L = X(e5, M2, w, S2, true)), L && g2.push(L), P(M2 = x2[Y].chartX + 3, w = x2[Y].chartY + 3, S2) && (L = X(e5, M2, w, S2, true)), L && g2.push(L), P(M2 = x2[Y].chartX - S2.width - 3, w = x2[Y].chartY + 3, S2) && (L = X(e5, M2, w, S2, true)), L && g2.push(L), P(M2 = x2[Y].chartX - S2.width - 3, w = x2[Y].chartY - S2.height - 3, S2) && (L = X(e5, M2, w, S2, true))), L && g2.push(L);
                    if (o5.connectorAllowed && !g2.length && !b2) for (M2 = c2 + u2 - S2.width; M2 >= c2; M2 -= 16) for (w = p2; w < p2 + d2 - S2.height; w += 16) (A = X(e5, M2, w, S2, true)) && g2.push(A);
                    if (g2.length) {
                      g2.sort((t5, e6) => e6.weight - t5.weight), L = g2[0], (t4.boxesToAvoid || []).push({ left: L.x, right: L.x + S2.width, top: L.y, bottom: L.y + S2.height });
                      let o6 = Math.sqrt(Math.pow(Math.abs(L.x - (v.x || 0)), 2) + Math.pow(Math.abs(L.y - (v.y || 0)), 2));
                      if (o6 && e5.labelBySeries) {
                        let r3, a3 = { opacity: t4.renderer.forExport ? 1 : 0, x: L.x, y: L.y }, n3 = { opacity: 1 };
                        o6 <= 10 && (n3 = { x: a3.x, y: a3.y }, a3 = {}), i2 && (r3 = s(e5.options.animation), r3.duration *= 0.2), e5.labelBySeries.attr(f(a3, { anchorX: L.connectorPoint && (L.connectorPoint.plotX || 0) + c2, anchorY: L.connectorPoint && (L.connectorPoint.plotY || 0) + p2 })).animate(n3, r3), e5.options.kdNow = true, e5.buildKDTree();
                        let l2 = e5.searchPoint({ chartX: L.x, chartY: L.y }, true);
                        l2 && (v.closest = [l2, L.x - (l2.plotX || 0), L.y - (l2.plotY || 0)]);
                      }
                    } else j();
                  } else j();
                }), x(t4, "afterDrawSeriesLabels");
              }(e3);
            }, e3.renderer.forExport || !o3 ? 0 : o3);
          }
        }
        function M(t3, e3, o3, r2, i2) {
          let a2 = i2 && i2.anchorX, n2 = i2 && i2.anchorY, s2, l2, h2 = o3 / 2;
          return b(a2) && b(n2) && (s2 = [["M", a2, n2]], (l2 = e3 - n2) < 0 && (l2 = -r2 - l2), l2 < o3 && (h2 = a2 < t3 + o3 / 2 ? l2 : o3 - l2), n2 > e3 + r2 ? s2.push(["L", t3 + h2, e3 + r2]) : n2 < e3 ? s2.push(["L", t3 + h2, e3]) : a2 < t3 ? s2.push(["L", t3, e3 + r2 / 2]) : a2 > t3 + o3 && s2.push(["L", t3 + o3, e3 + r2 / 2])), s2 || [];
        }
        return { compose: function(t3, e3) {
          g(c, "SeriesLabel") && (d(t3, "load", S), d(t3, "redraw", S), e3.prototype.symbols.connector = M, h({ plotOptions: { series: { label: i } } }));
        } };
      }), o(e, "masters/modules/series-label.src.js", [e["Core/Globals.js"], e["Extensions/SeriesLabel/SeriesLabel.js"]], function(t2, e2) {
        return e2.compose(t2.Chart, t2.SVGRenderer), t2;
      });
    });
  }
});
export default require_series_label();
//# sourceMappingURL=highcharts_modules_series-label__js.js.map
