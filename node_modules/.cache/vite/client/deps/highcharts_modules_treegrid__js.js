import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/treegrid.js
var require_treegrid = __commonJS({
  "node_modules/highcharts/modules/treegrid.js"(exports, module) {
    !/**
    * Highcharts Gantt JS v11.4.7 (2024-08-14)
    *
    * Tree Grid
    *
    * (c) 2016-2024 Jon Arild Nygard
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/treegrid", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function i(t2, i2, s, o) {
        t2.hasOwnProperty(i2) || (t2[i2] = o.apply(null, s), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: t2[i2] } })));
      }
      i(t, "Core/Axis/BrokenAxis.js", [t["Core/Axis/Stacking/StackItem.js"], t["Core/Utilities.js"]], function(e2, t2) {
        var i2;
        let { addEvent: s, find: o, fireEvent: r, isArray: n, isNumber: l, pick: a } = t2;
        return function(t3) {
          function i3() {
            void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, false);
          }
          function d() {
            var _a;
            ((_a = this.brokenAxis) == null ? void 0 : _a.hasBreaks) && (this.options.ordinal = false);
          }
          function h() {
            let e3 = this.brokenAxis;
            if (e3 == null ? void 0 : e3.hasBreaks) {
              let t4 = this.tickPositions, i4 = this.tickPositions.info, s2 = [];
              for (let i5 = 0; i5 < t4.length; i5++) e3.isInAnyBreak(t4[i5]) || s2.push(t4[i5]);
              this.tickPositions = s2, this.tickPositions.info = i4;
            }
          }
          function c() {
            this.brokenAxis || (this.brokenAxis = new k(this));
          }
          function p() {
            var _a, _b;
            let { isDirty: e3, options: { connectNulls: t4 }, points: i4, xAxis: s2, yAxis: o2 } = this;
            if (e3) {
              let e4 = i4.length;
              for (; e4--; ) {
                let r2 = i4[e4], n2 = !(null === r2.y && false === t4) && (((_a = s2 == null ? void 0 : s2.brokenAxis) == null ? void 0 : _a.isInAnyBreak(r2.x, true)) || ((_b = o2 == null ? void 0 : o2.brokenAxis) == null ? void 0 : _b.isInAnyBreak(r2.y, true)));
                r2.visible = !n2 && false !== r2.options.visible;
              }
            }
          }
          function f() {
            this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, a(this.pointArrayMap, ["y"]));
          }
          function u(e3, t4) {
            var _a;
            let i4, s2, o2;
            let n2 = this, d2 = n2.points;
            if ((_a = e3 == null ? void 0 : e3.brokenAxis) == null ? void 0 : _a.hasBreaks) {
              let h2 = e3.brokenAxis;
              t4.forEach(function(t5) {
                var _a2, _b;
                i4 = (h2 == null ? void 0 : h2.breakArray) || [], s2 = e3.isXAxis ? e3.min : a(n2.options.threshold, e3.min);
                let c2 = (_b = (_a2 = e3 == null ? void 0 : e3.options) == null ? void 0 : _a2.breaks) == null ? void 0 : _b.filter(function(e4) {
                  let t6 = true;
                  for (let s3 = 0; s3 < i4.length; s3++) {
                    let o3 = i4[s3];
                    if (o3.from === e4.from && o3.to === e4.to) {
                      t6 = false;
                      break;
                    }
                  }
                  return t6;
                });
                d2.forEach(function(n3) {
                  o2 = a(n3["stack" + t5.toUpperCase()], n3[t5]), i4.forEach(function(t6) {
                    if (l(s2) && l(o2)) {
                      let i5 = "";
                      s2 < t6.from && o2 > t6.to || s2 > t6.from && o2 < t6.from ? i5 = "pointBreak" : (s2 < t6.from && o2 > t6.from && o2 < t6.to || s2 > t6.from && o2 > t6.to && o2 < t6.from) && (i5 = "pointInBreak"), i5 && r(e3, i5, { point: n3, brk: t6 });
                    }
                  }), c2 == null ? void 0 : c2.forEach(function(t6) {
                    r(e3, "pointOutsideOfBreak", { point: n3, brk: t6 });
                  });
                });
              });
            }
          }
          function g() {
            let t4 = this.currentDataGrouping, i4 = t4 == null ? void 0 : t4.gapSize, s2 = this.points.slice(), o2 = this.yAxis, r2 = this.options.gapSize, n2 = s2.length - 1;
            if (r2 && n2 > 0) {
              let t5, l2;
              for ("value" !== this.options.gapUnit && (r2 *= this.basePointRange), i4 && i4 > r2 && i4 >= this.basePointRange && (r2 = i4); n2--; ) if (l2 && false !== l2.visible || (l2 = s2[n2 + 1]), t5 = s2[n2], false !== l2.visible && false !== t5.visible) {
                if (l2.x - t5.x > r2) {
                  let i5 = (t5.x + l2.x) / 2;
                  s2.splice(n2 + 1, 0, { isNull: true, x: i5 }), o2.stacking && this.options.stacking && ((o2.stacking.stacks[this.stackKey][i5] = new e2(o2, o2.options.stackLabels, false, i5, this.stack)).total = 0);
                }
                l2 = t5;
              }
            }
            return this.getGraphPath(s2);
          }
          t3.compose = function(e3, t4) {
            if (!e3.keepProps.includes("brokenAxis")) {
              e3.keepProps.push("brokenAxis"), s(e3, "init", c), s(e3, "afterInit", i3), s(e3, "afterSetTickPositions", h), s(e3, "afterSetOptions", d);
              let o2 = t4.prototype;
              o2.drawBreaks = u, o2.gappedPath = g, s(t4, "afterGeneratePoints", p), s(t4, "afterRender", f);
            }
            return e3;
          };
          class k {
            static isInBreak(e3, t4) {
              let i4 = e3.repeat || 1 / 0, s2 = e3.from, o2 = e3.to - e3.from, r2 = t4 >= s2 ? (t4 - s2) % i4 : i4 - (s2 - t4) % i4;
              return e3.inclusive ? r2 <= o2 : r2 < o2 && 0 !== r2;
            }
            static lin2Val(e3) {
              let t4 = this.brokenAxis, i4 = t4 && t4.breakArray;
              if (!i4 || !l(e3)) return e3;
              let s2 = e3, o2, r2;
              for (r2 = 0; r2 < i4.length && !((o2 = i4[r2]).from >= s2); r2++) o2.to < s2 ? s2 += o2.len : k.isInBreak(o2, s2) && (s2 += o2.len);
              return s2;
            }
            static val2Lin(e3) {
              let t4 = this.brokenAxis, i4 = t4 && t4.breakArray;
              if (!i4 || !l(e3)) return e3;
              let s2 = e3, o2, r2;
              for (r2 = 0; r2 < i4.length; r2++) if ((o2 = i4[r2]).to <= e3) s2 -= o2.len;
              else if (o2.from >= e3) break;
              else if (k.isInBreak(o2, e3)) {
                s2 -= e3 - o2.from;
                break;
              }
              return s2;
            }
            constructor(e3) {
              this.hasBreaks = false, this.axis = e3;
            }
            findBreakAt(e3, t4) {
              return o(t4, function(t5) {
                return t5.from < e3 && e3 < t5.to;
              });
            }
            isInAnyBreak(e3, t4) {
              let i4 = this.axis, s2 = i4.options.breaks || [], o2 = s2.length, r2, n2, d2;
              if (o2 && l(e3)) {
                for (; o2--; ) k.isInBreak(s2[o2], e3) && (r2 = true, n2 || (n2 = a(s2[o2].showPoints, !i4.isXAxis)));
                d2 = r2 && t4 ? r2 && !n2 : r2;
              }
              return d2;
            }
            setBreaks(e3, t4) {
              let i4 = this, s2 = i4.axis, o2 = n(e3) && !!e3.length && !!Object.keys(e3[0]).length;
              s2.isDirty = i4.hasBreaks !== o2, i4.hasBreaks = o2, e3 !== s2.options.breaks && (s2.options.breaks = s2.userOptions.breaks = e3), s2.forceRedraw = true, s2.series.forEach(function(e4) {
                e4.isDirty = true;
              }), o2 || s2.val2lin !== k.val2Lin || (delete s2.val2lin, delete s2.lin2val), o2 && (s2.userOptions.ordinal = false, s2.lin2val = k.lin2Val, s2.val2lin = k.val2Lin, s2.setExtremes = function(e4, t5, o3, r2, n2) {
                if (i4.hasBreaks) {
                  let s3;
                  let o4 = this.options.breaks || [];
                  for (; s3 = i4.findBreakAt(e4, o4); ) e4 = s3.to;
                  for (; s3 = i4.findBreakAt(t5, o4); ) t5 = s3.from;
                  t5 < e4 && (t5 = e4);
                }
                s2.constructor.prototype.setExtremes.call(this, e4, t5, o3, r2, n2);
              }, s2.setAxisTranslation = function() {
                if (s2.constructor.prototype.setAxisTranslation.call(this), i4.unitLength = void 0, i4.hasBreaks) {
                  let e4 = s2.options.breaks || [], t5 = [], o3 = [], n2 = a(s2.pointRangePadding, 0), d2 = 0, h2, c2, p2 = s2.userMin || s2.min, f2 = s2.userMax || s2.max, u2, g2;
                  e4.forEach(function(e5) {
                    c2 = e5.repeat || 1 / 0, l(p2) && l(f2) && (k.isInBreak(e5, p2) && (p2 += e5.to % c2 - p2 % c2), k.isInBreak(e5, f2) && (f2 -= f2 % c2 - e5.from % c2));
                  }), e4.forEach(function(e5) {
                    if (u2 = e5.from, c2 = e5.repeat || 1 / 0, l(p2) && l(f2)) {
                      for (; u2 - c2 > p2; ) u2 -= c2;
                      for (; u2 < p2; ) u2 += c2;
                      for (g2 = u2; g2 < f2; g2 += c2) t5.push({ value: g2, move: "in" }), t5.push({ value: g2 + e5.to - e5.from, move: "out", size: e5.breakSize });
                    }
                  }), t5.sort(function(e5, t6) {
                    return e5.value === t6.value ? ("in" === e5.move ? 0 : 1) - ("in" === t6.move ? 0 : 1) : e5.value - t6.value;
                  }), h2 = 0, u2 = p2, t5.forEach(function(e5) {
                    1 === (h2 += "in" === e5.move ? 1 : -1) && "in" === e5.move && (u2 = e5.value), 0 === h2 && l(u2) && (o3.push({ from: u2, to: e5.value, len: e5.value - u2 - (e5.size || 0) }), d2 += e5.value - u2 - (e5.size || 0));
                  }), i4.breakArray = o3, l(p2) && l(f2) && l(s2.min) && (i4.unitLength = f2 - p2 - d2 + n2, r(s2, "afterBreaks"), s2.staticScale ? s2.transA = s2.staticScale : i4.unitLength && (s2.transA *= (f2 - s2.min + n2) / i4.unitLength), n2 && (s2.minPixelPadding = s2.transA * (s2.minPointOffset || 0)), s2.min = p2, s2.max = f2);
                }
              }), a(t4, true) && s2.chart.redraw();
            }
          }
          t3.Additions = k;
        }(i2 || (i2 = {})), i2;
      }), i(t, "Core/Axis/GridAxis.js", [t["Core/Axis/Axis.js"], t["Core/Globals.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        var s, o;
        let { dateFormats: r } = t2, { addEvent: n, defined: l, erase: a, find: d, isArray: h, isNumber: c, merge: p, pick: f, timeUnits: u, wrap: g } = i2;
        function k(e3) {
          return i2.isObject(e3, true);
        }
        function m(e3, t3) {
          let i3 = { width: 0, height: 0 };
          if (t3.forEach(function(t4) {
            let s2 = e3[t4], o2 = 0, r2 = 0, n2;
            k(s2) && (o2 = (n2 = k(s2.label) ? s2.label : {}).getBBox ? n2.getBBox().height : 0, n2.textStr && !c(n2.textPxLength) && (n2.textPxLength = n2.getBBox().width), r2 = c(n2.textPxLength) ? Math.round(n2.textPxLength) : 0, n2.textStr && (r2 = Math.round(n2.getBBox().width)), i3.height = Math.max(o2, i3.height), i3.width = Math.max(r2, i3.width));
          }), "treegrid" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode) {
            let e4 = this.treeGrid.mapOfPosToGridNode[-1].height || 0;
            i3.width += this.options.labels.indentation * (e4 - 1);
          }
          return i3;
        }
        function x(e3) {
          let { grid: t3 } = this, i3 = 3 === this.side;
          if (i3 || e3.apply(this), !(t3 == null ? void 0 : t3.isColumn)) {
            let e4 = (t3 == null ? void 0 : t3.columns) || [];
            i3 && (e4 = e4.slice().reverse()), e4.forEach((e5) => {
              e5.getOffset();
            });
          }
          i3 && e3.apply(this);
        }
        function b(e3) {
          if (true === (this.options.grid || {}).enabled) {
            let { axisTitle: t3, height: i3, horiz: o2, left: r2, offset: n2, opposite: l2, options: a2, top: d2, width: h2 } = this, c2 = this.tickSize(), p2 = t3 && t3.getBBox().width, u2 = a2.title.x, g2 = a2.title.y, k2 = f(a2.title.margin, o2 ? 5 : 10), m2 = t3 ? this.chart.renderer.fontMetrics(t3).f : 0, x2 = (o2 ? d2 + i3 : r2) + (o2 ? 1 : -1) * (l2 ? -1 : 1) * (c2 ? c2[0] / 2 : 0) + (this.side === s.bottom ? m2 : 0);
            e3.titlePosition.x = o2 ? r2 - (p2 || 0) / 2 - k2 + u2 : x2 + (l2 ? h2 : 0) + n2 + u2, e3.titlePosition.y = o2 ? x2 - (l2 ? i3 : 0) + (l2 ? m2 : -m2) / 2 + n2 + g2 : d2 - k2 + g2;
          }
        }
        function y() {
          let { chart: t3, options: { grid: i3 = {} }, userOptions: s2 } = this;
          if (i3.enabled && function(e3) {
            let t4 = e3.options;
            t4.labels.align = f(t4.labels.align, "center"), e3.categories || (t4.showLastLabel = false), e3.labelRotation = 0, t4.labels.rotation = 0, t4.minTickInterval = 1;
          }(this), i3.columns) {
            let o2 = this.grid.columns = [], r2 = this.grid.columnIndex = 0;
            for (; ++r2 < i3.columns.length; ) {
              let n2 = p(s2, i3.columns[r2], { isInternal: true, linkedTo: 0, scrollbar: { enabled: false } }, { grid: { columns: void 0 } }), l2 = new e2(this.chart, n2, "yAxis");
              l2.grid.isColumn = true, l2.grid.columnIndex = r2, a(t3.axes, l2), a(t3[this.coll] || [], l2), o2.push(l2);
            }
          }
        }
        function v() {
          let { axisTitle: e3, grid: t3, options: i3 } = this;
          if (true === (i3.grid || {}).enabled) {
            let o2 = this.min || 0, r2 = this.max || 0, n2 = this.ticks[this.tickPositions[0]];
            if (e3 && !this.chart.styledMode && (n2 == null ? void 0 : n2.slotWidth) && !this.options.title.style.width && e3.css({ width: `${n2.slotWidth}px` }), this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions), this.rightWall && this.rightWall.destroy(), this.grid && this.grid.isOuterAxis() && this.axisLine) {
              let e4 = i3.lineWidth;
              if (e4) {
                let t4 = this.getLinePath(e4), n3 = t4[0], l2 = t4[1], a2 = (this.tickSize("tick") || [1])[0] * (this.side === s.top || this.side === s.left ? -1 : 1);
                if ("M" === n3[0] && "L" === l2[0] && (this.horiz ? (n3[2] += a2, l2[2] += a2) : (n3[1] += a2, l2[1] += a2)), !this.horiz && this.chart.marginRight) {
                  let e5 = ["L", this.left, n3[2] || 0], t5 = [n3, e5], s2 = ["L", this.chart.chartWidth - this.chart.marginRight, this.toPixels(r2 + this.tickmarkOffset)], a3 = [["M", l2[1] || 0, this.toPixels(r2 + this.tickmarkOffset)], s2];
                  this.grid.upperBorder || o2 % 1 == 0 || (this.grid.upperBorder = this.grid.renderBorder(t5)), this.grid.upperBorder && (this.grid.upperBorder.attr({ stroke: i3.lineColor, "stroke-width": i3.lineWidth }), this.grid.upperBorder.animate({ d: t5 })), this.grid.lowerBorder || r2 % 1 == 0 || (this.grid.lowerBorder = this.grid.renderBorder(a3)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({ stroke: i3.lineColor, "stroke-width": i3.lineWidth }), this.grid.lowerBorder.animate({ d: a3 }));
                }
                this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({ stroke: i3.lineColor, "stroke-width": i3.lineWidth }), this.grid.axisLineExtra.animate({ d: t4 })) : this.grid.axisLineExtra = this.grid.renderBorder(t4), this.axisLine[this.showAxis ? "show" : "hide"]();
              }
            }
            if ((t3 && t3.columns || []).forEach((e4) => e4.render()), !this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar) && this.tickPositions.length) {
              let e4, t4;
              let i4 = this.tickmarkOffset, s2 = this.tickPositions[this.tickPositions.length - 1], n3 = this.tickPositions[0];
              for (; (e4 = this.hiddenLabels.pop()) && e4.element; ) e4.show();
              for (; (t4 = this.hiddenMarks.pop()) && t4.element; ) t4.show();
              (e4 = this.ticks[n3].label) && (o2 - n3 > i4 ? this.hiddenLabels.push(e4.hide()) : e4.show()), (e4 = this.ticks[s2].label) && (s2 - r2 > i4 ? this.hiddenLabels.push(e4.hide()) : e4.show());
              let l2 = this.ticks[s2].mark;
              l2 && s2 - r2 < i4 && s2 - r2 > 0 && this.ticks[s2].isLast && this.hiddenMarks.push(l2.hide());
            }
          }
        }
        function P() {
          let e3 = this.tickPositions && this.tickPositions.info, t3 = this.options, i3 = t3.grid || {}, s2 = this.userOptions.labels || {};
          i3.enabled && (this.horiz ? (this.series.forEach((e4) => {
            e4.options.pointRange = 0;
          }), e3 && t3.dateTimeLabelFormats && t3.labels && !l(s2.align) && (false === t3.dateTimeLabelFormats[e3.unitName].range || e3.count > 1) && (t3.labels.align = "left", l(s2.x) || (t3.labels.x = 3))) : "treegrid" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));
        }
        function G(e3) {
          let t3;
          let i3 = this.options, s2 = e3.userOptions, o2 = i3 && k(i3.grid) ? i3.grid : {};
          true === o2.enabled && (t3 = p(true, { className: "highcharts-grid-axis " + (s2.className || ""), dateTimeLabelFormats: { hour: { list: ["%H:%M", "%H"] }, day: { list: ["%A, %e. %B", "%a, %e. %b", "%E"] }, week: { list: ["Week %W", "W%W"] }, month: { list: ["%B", "%b", "%o"] } }, grid: { borderWidth: 1 }, labels: { padding: 2, style: { fontSize: "0.9em" } }, margin: 0, title: { text: null, reserveSpace: false, rotation: 0, style: { textOverflow: "ellipsis" } }, units: [["millisecond", [1, 10, 100]], ["second", [1, 10]], ["minute", [1, 5, 15]], ["hour", [1, 6]], ["day", [1]], ["week", [1]], ["month", [1]], ["year", null]] }, s2), "xAxis" !== this.coll || (l(s2.linkedTo) && !l(s2.tickPixelInterval) && (t3.tickPixelInterval = 350), !(!l(s2.tickPixelInterval) && l(s2.linkedTo)) || l(s2.tickPositioner) || l(s2.tickInterval) || l(s2.units) || (t3.tickPositioner = function(e4, i4) {
            let s3 = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;
            if (s3) {
              let o3 = t3.units || [], r2, n2 = 1, l2 = "year";
              for (let e5 = 0; e5 < o3.length; e5++) {
                let t4 = o3[e5];
                if (t4 && t4[0] === s3.unitName) {
                  r2 = e5;
                  break;
                }
              }
              let a2 = c(r2) && o3[r2 + 1];
              if (a2) {
                l2 = a2[0] || "year";
                let e5 = a2[1];
                n2 = e5 && e5[0] || 1;
              } else "year" === s3.unitName && (n2 = 10 * s3.count);
              let d2 = u[l2];
              return this.tickInterval = d2 * n2, this.chart.time.getTimeTicks({ unitRange: d2, count: n2, unitName: l2 }, e4, i4, this.options.startOfWeek);
            }
          })), p(true, this.options, t3), this.horiz && (i3.minPadding = f(s2.minPadding, 0), i3.maxPadding = f(s2.maxPadding, 0)), c(i3.grid.borderWidth) && (i3.tickWidth = i3.lineWidth = o2.borderWidth));
        }
        function A(e3) {
          let t3 = e3.userOptions, i3 = t3 && t3.grid || {}, s2 = i3.columns;
          i3.enabled && s2 && p(true, this.options, s2[0]);
        }
        function T() {
          (this.grid.columns || []).forEach((e3) => e3.setScale());
        }
        function C(e3) {
          let { horiz: t3, maxLabelDimensions: i3, options: { grid: s2 = {} } } = this;
          if (s2.enabled && i3) {
            let o2 = 2 * this.options.labels.distance, r2 = t3 ? s2.cellHeight || o2 + i3.height : o2 + i3.width;
            h(e3.tickSize) ? e3.tickSize[0] = r2 : e3.tickSize = [r2, 0];
          }
        }
        function B() {
          this.axes.forEach((e3) => {
            (e3.grid && e3.grid.columns || []).forEach((e4) => {
              e4.setAxisSize(), e4.setAxisTranslation();
            });
          });
        }
        function O(e3) {
          let { grid: t3 } = this;
          (t3.columns || []).forEach((t4) => t4.destroy(e3.keepEvents)), t3.columns = void 0;
        }
        function w(e3) {
          let t3 = e3.userOptions || {}, i3 = t3.grid || {};
          i3.enabled && l(i3.borderColor) && (t3.tickColor = t3.lineColor = i3.borderColor), this.grid || (this.grid = new M(this)), this.hiddenLabels = [], this.hiddenMarks = [];
        }
        function I(e3) {
          let t3 = this.label, i3 = this.axis, o2 = i3.reversed, r2 = i3.chart, n2 = i3.options.grid || {}, l2 = i3.options.labels, a2 = l2.align, d2 = s[i3.side], h2 = e3.tickmarkOffset, p2 = i3.tickPositions, f2 = this.pos - h2, u2 = c(p2[e3.index + 1]) ? p2[e3.index + 1] - h2 : (i3.max || 0) + h2, g2 = i3.tickSize("tick"), k2 = g2 ? g2[0] : 0, m2 = g2 ? g2[1] / 2 : 0;
          if (true === n2.enabled) {
            let s2, n3, h3, c2;
            if ("top" === d2 ? n3 = (s2 = i3.top + i3.offset) - k2 : "bottom" === d2 ? s2 = (n3 = r2.chartHeight - i3.bottom + i3.offset) + k2 : (s2 = i3.top + i3.len - (i3.translate(o2 ? u2 : f2) || 0), n3 = i3.top + i3.len - (i3.translate(o2 ? f2 : u2) || 0)), "right" === d2 ? c2 = (h3 = r2.chartWidth - i3.right + i3.offset) + k2 : "left" === d2 ? h3 = (c2 = i3.left + i3.offset) - k2 : (h3 = Math.round(i3.left + (i3.translate(o2 ? u2 : f2) || 0)) - m2, c2 = Math.min(Math.round(i3.left + (i3.translate(o2 ? f2 : u2) || 0)) - m2, i3.left + i3.len)), this.slotWidth = c2 - h3, e3.pos.x = "left" === a2 ? h3 : "right" === a2 ? c2 : h3 + (c2 - h3) / 2, e3.pos.y = n3 + (s2 - n3) / 2, t3) {
              let i4 = r2.renderer.fontMetrics(t3), s3 = t3.getBBox().height;
              if (l2.useHTML) e3.pos.y += i4.b + -(s3 / 2);
              else {
                let t4 = Math.round(s3 / i4.h);
                e3.pos.y += (i4.b - (i4.h - i4.f)) / 2 + -((t4 - 1) * i4.h / 2);
              }
            }
            e3.pos.x += i3.horiz && l2.x || 0;
          }
        }
        function E(e3) {
          let { axis: i3, value: s2 } = e3;
          if (i3.options.grid && i3.options.grid.enabled) {
            let o2;
            let r2 = i3.tickPositions, n2 = (i3.linkedParent || i3).series[0], l2 = s2 === r2[0], a2 = s2 === r2[r2.length - 1], h2 = n2 && d(n2.options.data, function(e4) {
              return e4[i3.isXAxis ? "x" : "y"] === s2;
            });
            h2 && n2.is("gantt") && (o2 = p(h2), t2.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(o2)), e3.isFirst = l2, e3.isLast = a2, e3.point = o2;
          }
        }
        function N() {
          let e3 = this.options, t3 = e3.grid || {}, i3 = this.categories, s2 = this.tickPositions, o2 = s2[0], r2 = s2[1], n2 = s2[s2.length - 1], l2 = s2[s2.length - 2], a2 = this.linkedParent && this.linkedParent.min, d2 = this.linkedParent && this.linkedParent.max, h2 = a2 || this.min, p2 = d2 || this.max, f2 = this.tickInterval, u2 = c(h2) && h2 >= o2 + f2 && h2 < r2, g2 = c(h2) && o2 < h2 && o2 + f2 > h2, k2 = c(p2) && n2 > p2 && n2 - f2 < p2, m2 = c(p2) && p2 <= n2 - f2 && p2 > l2;
          true === t3.enabled && !i3 && (this.isXAxis || this.isLinked) && ((g2 || u2) && !e3.startOnTick && (s2[0] = h2), (k2 || m2) && !e3.endOnTick && (s2[s2.length - 1] = p2));
        }
        function L(e3) {
          var t3;
          let { options: { grid: i3 = {} } } = this;
          return true === i3.enabled && this.categories ? this.tickInterval : e3.apply(this, (t3 = arguments, Array.prototype.slice.call(t3, 1)));
        }
        (o = s || (s = {}))[o.top = 0] = "top", o[o.right = 1] = "right", o[o.bottom = 2] = "bottom", o[o.left = 3] = "left";
        class M {
          constructor(e3) {
            this.axis = e3;
          }
          isOuterAxis() {
            var _a;
            let e3 = this.axis, t3 = e3.chart, i3 = e3.grid.columnIndex, s2 = ((_a = e3.linkedParent) == null ? void 0 : _a.grid.columns) || e3.grid.columns || [], o2 = i3 ? e3.linkedParent : e3, r2 = -1, n2 = 0;
            return 3 === e3.side && !t3.inverted && s2.length ? !e3.linkedParent : ((t3[e3.coll] || []).forEach((t4, i4) => {
              t4.side !== e3.side || t4.options.isInternal || (n2 = i4, t4 !== o2 || (r2 = i4));
            }), n2 === r2 && (!c(i3) || s2.length === i3));
          }
          renderBorder(e3) {
            let t3 = this.axis, i3 = t3.chart.renderer, s2 = t3.options, o2 = i3.path(e3).addClass("highcharts-axis-line").add(t3.axisGroup);
            return i3.styledMode || o2.attr({ stroke: s2.lineColor, "stroke-width": s2.lineWidth, zIndex: 7 }), o2;
          }
        }
        return r.E = function(e3) {
          return this.dateFormat("%a", e3, true).charAt(0);
        }, r.W = function(e3) {
          let t3 = this, i3 = new this.Date(e3);
          ["Hours", "Milliseconds", "Minutes", "Seconds"].forEach(function(e4) {
            t3.set(e4, i3, 0);
          });
          let s2 = (this.get("Day", i3) + 6) % 7, o2 = new this.Date(i3.valueOf());
          this.set("Date", o2, this.get("Date", i3) - s2 + 3);
          let r2 = new this.Date(this.get("FullYear", o2), 0, 1);
          return 4 !== this.get("Day", r2) && (this.set("Month", i3, 0), this.set("Date", i3, 1 + (11 - this.get("Day", r2)) % 7)), (1 + Math.floor((o2.valueOf() - r2.valueOf()) / 6048e5)).toString();
        }, { compose: function(e3, t3, i3) {
          return e3.keepProps.includes("grid") || (e3.keepProps.push("grid"), e3.prototype.getMaxLabelDimensions = m, g(e3.prototype, "unsquish", L), g(e3.prototype, "getOffset", x), n(e3, "init", w), n(e3, "afterGetTitlePosition", b), n(e3, "afterInit", y), n(e3, "afterRender", v), n(e3, "afterSetAxisTranslation", P), n(e3, "afterSetOptions", G), n(e3, "afterSetOptions", A), n(e3, "afterSetScale", T), n(e3, "afterTickSize", C), n(e3, "trimTicks", N), n(e3, "destroy", O), n(t3, "afterSetChartSize", B), n(i3, "afterGetLabelPosition", I), n(i3, "labelFormat", E)), e3;
        } };
      }), i(t, "Gantt/Tree.js", [t["Core/Utilities.js"]], function(e2) {
        let { extend: t2, isNumber: i2, pick: s } = e2;
        function o(e3, r, n, l, a, d) {
          let h = d && d.after, c = d && d.before, p = { data: l, depth: n - 1, id: e3, level: n, parent: r || "" }, f = 0, u = 0, g, k;
          "function" == typeof c && c(p, d);
          let m = (a[e3] || []).map((t3) => {
            let s2 = o(t3.id, e3, n + 1, t3, a, d), r2 = t3.start || NaN, l2 = true === t3.milestone ? r2 : t3.end || NaN;
            return g = !i2(g) || r2 < g ? r2 : g, k = !i2(k) || l2 > k ? l2 : k, f = f + 1 + s2.descendants, u = Math.max(s2.height + 1, u), s2;
          });
          return l && (l.start = s(l.start, g), l.end = s(l.end, k)), t2(p, { children: m, descendants: f, height: u }), "function" == typeof h && h(p, d), p;
        }
        return { getNode: o, getTree: function(e3, t3) {
          return o("", null, 1, null, function(e4) {
            let t4 = [], i3 = e4.reduce((e5, i4) => {
              let { parent: s2 = "", id: o2 } = i4;
              return void 0 === e5[s2] && (e5[s2] = []), e5[s2].push(i4), o2 && t4.push(o2), e5;
            }, {});
            return Object.keys(i3).forEach((e5) => {
              if ("" !== e5 && -1 === t4.indexOf(e5)) {
                let t5 = i3[e5].map(function(e6) {
                  let { ...t6 } = e6;
                  return t6;
                });
                i3[""].push(...t5), delete i3[e5];
              }
            }), i3;
          }(e3), t3);
        } };
      }), i(t, "Core/Axis/TreeGrid/TreeGridTick.js", [t["Core/Utilities.js"]], function(e2) {
        let { addEvent: t2, removeEvent: i2, isObject: s, isNumber: o, pick: r, wrap: n } = e2;
        function l() {
          this.treeGrid || (this.treeGrid = new h(this));
        }
        function a(e3, t3, i3, n2, l2, a2, d2, h2, c) {
          let p, f, u;
          let g = r(this.options && this.options.labels, a2), k = this.pos, m = this.axis, x = "treegrid" === m.options.type, b = e3.apply(this, [t3, i3, n2, l2, g, d2, h2, c]);
          if (x) {
            let { width: e4 = 0, padding: t4 = m.linkedParent ? 0 : 5 } = g && s(g.symbol, true) ? g.symbol : {}, i4 = g && o(g.indentation) ? g.indentation : 0;
            u = (f = (p = m.treeGrid.mapOfPosToGridNode) && p[k]) && f.depth || 1, b.x += e4 + 2 * t4 + (u - 1) * i4;
          }
          return b;
        }
        function d(e3) {
          let n2, l2, a2;
          let { pos: d2, axis: h2, label: c, treeGrid: p, options: f } = this, u = p == null ? void 0 : p.labelIcon, g = c == null ? void 0 : c.element, { treeGrid: k, options: m, chart: x, tickPositions: b } = h2, y = k.mapOfPosToGridNode, v = r(f == null ? void 0 : f.labels, m == null ? void 0 : m.labels), P = v && s(v.symbol, true) ? v.symbol : {}, G = y && y[d2], { descendants: A, depth: T } = G || {}, C = G && A && A > 0, B = "treegrid" === m.type && g, O = b.indexOf(d2) > -1, w = "highcharts-treegrid-node-", I = w + "level-", E = x.styledMode;
          B && G && c.removeClass(RegExp(I + ".*")).addClass(I + T), e3.apply(this, Array.prototype.slice.call(arguments, 1)), B && C ? (n2 = k.isCollapsed(G), function(e4, t3) {
            let i3 = e4.treeGrid, s2 = !i3.labelIcon, n3 = t3.renderer, l3 = t3.xy, a3 = t3.options, d3 = a3.width || 0, h3 = a3.height || 0, c2 = a3.padding ?? e4.axis.linkedParent ? 0 : 5, p2 = { x: l3.x - d3 / 2 - c2, y: l3.y - h3 / 2 }, f2 = t3.collapsed ? 90 : 180, u2 = t3.show && o(p2.y), g2 = i3.labelIcon;
            g2 || (i3.labelIcon = g2 = n3.path(n3.symbols[a3.type](a3.x || 0, a3.y || 0, d3, h3)).addClass("highcharts-label-icon").add(t3.group)), g2[u2 ? "show" : "hide"](), n3.styledMode || g2.attr({ cursor: "pointer", fill: r(t3.color, "#666666"), "stroke-width": 1, stroke: a3.lineColor, strokeWidth: a3.lineWidth || 0 }), g2[s2 ? "attr" : "animate"]({ translateX: p2.x, translateY: p2.y, rotation: f2 });
          }(this, { color: !E && c.styles.color || "", collapsed: n2, group: c.parentGroup, options: P, renderer: c.renderer, show: O, xy: c.xy }), l2 = w + (n2 ? "collapsed" : "expanded"), a2 = w + (n2 ? "expanded" : "collapsed"), c.addClass(l2).removeClass(a2), E || c.css({ cursor: "pointer" }), [c, u].forEach((e4) => {
            e4 && !e4.attachedTreeGridEvents && (t2(e4.element, "mouseover", function() {
              c.addClass("highcharts-treegrid-node-active"), c.renderer.styledMode || c.css({ textDecoration: "underline" });
            }), t2(e4.element, "mouseout", function() {
              !function(e5, t3) {
                let i3 = s(t3.style) ? t3.style : {};
                e5.removeClass("highcharts-treegrid-node-active"), e5.renderer.styledMode || e5.css({ textDecoration: i3.textDecoration || "none" });
              }(c, v);
            }), t2(e4.element, "click", function() {
              p.toggleCollapse();
            }), e4.attachedTreeGridEvents = true);
          })) : u && (i2(g), c == null ? void 0 : c.css({ cursor: "default" }), u.destroy());
        }
        class h {
          static compose(e3) {
            let i3 = e3.prototype;
            i3.toggleCollapse || (t2(e3, "init", l), n(i3, "getLabelPosition", a), n(i3, "renderLabel", d), i3.collapse = function(e4) {
              this.treeGrid.collapse(e4);
            }, i3.expand = function(e4) {
              this.treeGrid.expand(e4);
            }, i3.toggleCollapse = function(e4) {
              this.treeGrid.toggleCollapse(e4);
            });
          }
          constructor(e3) {
            this.tick = e3;
          }
          collapse(e3) {
            let t3 = this.tick, i3 = t3.axis, s2 = i3.brokenAxis;
            if (s2 && i3.treeGrid.mapOfPosToGridNode) {
              let o2 = t3.pos, n2 = i3.treeGrid.mapOfPosToGridNode[o2], l2 = i3.treeGrid.collapse(n2);
              s2.setBreaks(l2, r(e3, true));
            }
          }
          destroy() {
            this.labelIcon && this.labelIcon.destroy();
          }
          expand(e3) {
            let { pos: t3, axis: i3 } = this.tick, { treeGrid: s2, brokenAxis: o2 } = i3, n2 = s2.mapOfPosToGridNode;
            if (o2 && n2) {
              let i4 = n2[t3], l2 = s2.expand(i4);
              o2.setBreaks(l2, r(e3, true));
            }
          }
          toggleCollapse(e3) {
            let t3 = this.tick, i3 = t3.axis, s2 = i3.brokenAxis;
            if (s2 && i3.treeGrid.mapOfPosToGridNode) {
              let o2 = t3.pos, n2 = i3.treeGrid.mapOfPosToGridNode[o2], l2 = i3.treeGrid.toggleCollapse(n2);
              s2.setBreaks(l2, r(e3, true));
            }
          }
        }
        return h;
      }), i(t, "Series/TreeUtilities.js", [t["Core/Color/Color.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { extend: i2, isArray: s, isNumber: o, isObject: r, merge: n, pick: l, relativeLength: a } = t2;
        return { getColor: function(t3, i3) {
          let s2, o2, r2, n2, a2, d;
          let h = i3.index, c = i3.mapOptionsToLevel, p = i3.parentColor, f = i3.parentColorIndex, u = i3.series, g = i3.colors, k = i3.siblings, m = u.points, x = u.chart.options.chart;
          return t3 && (s2 = m[t3.i], o2 = c[t3.level] || {}, s2 && o2.colorByPoint && (n2 = s2.index % (g ? g.length : x.colorCount), r2 = g && g[n2]), u.chart.styledMode || (a2 = l(s2 && s2.options.color, o2 && o2.color, r2, p && ((t4) => {
            let i4 = o2 && o2.colorVariation;
            return i4 && "brightness" === i4.key && h && k ? e2.parse(t4).brighten(i4.to * (h / k)).get() : t4;
          })(p), u.color)), d = l(s2 && s2.options.colorIndex, o2 && o2.colorIndex, n2, f, i3.colorIndex)), { color: a2, colorIndex: d };
        }, getLevelOptions: function(e3) {
          let t3, i3, a2, d, h, c;
          let p = {};
          if (r(e3)) for (d = o(e3.from) ? e3.from : 1, c = e3.levels, i3 = {}, t3 = r(e3.defaults) ? e3.defaults : {}, s(c) && (i3 = c.reduce((e4, i4) => {
            let s2, a3, h2;
            return r(i4) && o(i4.level) && (a3 = l((h2 = n({}, i4)).levelIsConstant, t3.levelIsConstant), delete h2.levelIsConstant, delete h2.level, r(e4[s2 = i4.level + (a3 ? 0 : d - 1)]) ? n(true, e4[s2], h2) : e4[s2] = h2), e4;
          }, {})), h = o(e3.to) ? e3.to : 1, a2 = 0; a2 <= h; a2++) p[a2] = n({}, t3, r(i3[a2]) ? i3[a2] : {});
          return p;
        }, getNodeWidth: function(e3, t3) {
          let { chart: i3, options: s2 } = e3, { nodeDistance: o2 = 0, nodeWidth: r2 = 0 } = s2, { plotSizeX: n2 = 1 } = i3;
          if ("auto" === r2) {
            if ("string" == typeof o2 && /%$/.test(o2)) return n2 / (t3 + parseFloat(o2) / 100 * (t3 - 1));
            let e4 = Number(o2);
            return (n2 + e4) / (t3 || 1) - e4;
          }
          return a(r2, n2);
        }, setTreeValues: function e3(t3, s2) {
          let o2 = s2.before, r2 = s2.idRoot, n2 = s2.mapIdToNode[r2], a2 = false !== s2.levelIsConstant, d = s2.points[t3.i], h = d && d.options || {}, c = [], p = 0;
          t3.levelDynamic = t3.level - (a2 ? 0 : n2.level), t3.name = l(d && d.name, ""), t3.visible = r2 === t3.id || true === s2.visible, "function" == typeof o2 && (t3 = o2(t3, s2)), t3.children.forEach((o3, r3) => {
            let n3 = i2({}, s2);
            i2(n3, { index: r3, siblings: t3.children.length, visible: t3.visible }), o3 = e3(o3, n3), c.push(o3), o3.visible && (p += o3.val);
          });
          let f = l(h.value, p);
          return t3.visible = f >= 0 && (p > 0 || t3.visible), t3.children = c, t3.childrenTotal = p, t3.isLeaf = t3.visible && !p, t3.val = f, t3;
        }, updateRootId: function(e3) {
          let t3, i3;
          return r(e3) && (i3 = r(e3.options) ? e3.options : {}, t3 = l(e3.rootNode, i3.rootId, ""), r(e3.userOptions) && (e3.userOptions.rootId = t3), e3.rootNode = t3), t3;
        } };
      }), i(t, "Core/Axis/TreeGrid/TreeGridAxis.js", [t["Core/Axis/BrokenAxis.js"], t["Core/Axis/GridAxis.js"], t["Gantt/Tree.js"], t["Core/Axis/TreeGrid/TreeGridTick.js"], t["Series/TreeUtilities.js"], t["Core/Utilities.js"]], function(e2, t2, i2, s, o, r) {
        let n;
        let { getLevelOptions: l } = o, { addEvent: a, find: d, fireEvent: h, isArray: c, isObject: p, isString: f, merge: u, pick: g, removeEvent: k, wrap: m } = r;
        function x(e3, t3) {
          let i3 = e3.collapseEnd || 0, s2 = e3.collapseStart || 0;
          return i3 >= t3 && (s2 -= 0.5), { from: s2, to: i3, showPoints: false };
        }
        function b(e3, t3, s2) {
          let o2 = [], r2 = [], n2 = {}, l2 = "boolean" == typeof t3 && t3, a2 = {}, h2 = -1, c2 = i2.getTree(e3, { after: function(e4) {
            let t4 = a2[e4.pos], i3 = 0, s3 = 0;
            t4.children.forEach(function(e5) {
              s3 += (e5.descendants || 0) + 1, i3 = Math.max((e5.height || 0) + 1, i3);
            }), t4.descendants = s3, t4.height = i3, t4.collapsed && r2.push(t4);
          }, before: function(e4) {
            let t4, i3;
            let s3 = p(e4.data, true) ? e4.data : {}, r3 = f(s3.name) ? s3.name : "", c3 = n2[e4.parent], u2 = p(c3, true) ? a2[c3.pos] : null;
            l2 && p(u2, true) && (t4 = d(u2.children, function(e5) {
              return e5.name === r3;
            })) ? (i3 = t4.pos, t4.nodes.push(e4)) : i3 = h2++, !a2[i3] && (a2[i3] = t4 = { depth: u2 ? u2.depth + 1 : 0, name: r3, id: s3.id, nodes: [e4], children: [], pos: i3 }, -1 !== i3 && o2.push(r3), p(u2, true) && u2.children.push(t4)), f(e4.id) && (n2[e4.id] = e4), t4 && true === s3.collapsed && (t4.collapsed = true), e4.pos = i3;
          } });
          return { categories: o2, mapOfIdToNode: n2, mapOfPosToGridNode: a2 = function(e4, t4) {
            let i3 = function(e5, s3, o3) {
              let r3 = e5.nodes, n3 = s3 + (-1 === s3 ? 0 : t4 - 1), l3 = (n3 - s3) / 2, a3 = s3 + l3;
              return r3.forEach(function(e6) {
                let t5 = e6.data;
                p(t5, true) && (t5.y = s3 + (t5.seriesIndex || 0), delete t5.seriesIndex), e6.pos = a3;
              }), o3[a3] = e5, e5.pos = a3, e5.tickmarkOffset = l3 + 0.5, e5.collapseStart = n3 + 0.5, e5.children.forEach(function(e6) {
                i3(e6, n3 + 1, o3), n3 = (e6.collapseEnd || 0) - 0.5;
              }), e5.collapseEnd = n3 + 0.5, o3;
            };
            return i3(e4["-1"], -1, {});
          }(a2, s2), collapsedNodes: r2, tree: c2 };
        }
        function y(e3) {
          e3.target.axes.filter(function(e4) {
            return "treegrid" === e4.options.type;
          }).forEach(function(t3) {
            let i3 = t3.options || {}, s2 = i3.labels, o2 = i3.uniqueNames, r2 = i3.max, n2 = !t3.treeGrid.mapOfPosToGridNode || t3.series.some(function(e4) {
              return !e4.hasRendered || e4.isDirtyData || e4.isDirty;
            }), a2 = 0, d2, h2;
            if (n2) {
              if (d2 = t3.series.reduce(function(e4, t4) {
                return t4.visible && ((t4.options.data || []).forEach(function(i4) {
                  t4.options.keys && t4.options.keys.length && (i4 = t4.pointClass.prototype.optionsToObject.call({ series: t4 }, i4), t4.pointClass.setGanttPointAliases(i4)), p(i4, true) && (i4.seriesIndex = a2, e4.push(i4));
                }), true === o2 && a2++), e4;
              }, []), r2 && d2.length < r2) for (let e4 = d2.length; e4 <= r2; e4++) d2.push({ name: e4 + "â€‹" });
              h2 = b(d2, o2 || false, true === o2 ? a2 : 1), t3.categories = h2.categories, t3.treeGrid.mapOfPosToGridNode = h2.mapOfPosToGridNode, t3.hasNames = true, t3.treeGrid.tree = h2.tree, t3.series.forEach(function(e4) {
                let t4 = (e4.options.data || []).map(function(t5) {
                  return c(t5) && e4.options.keys && e4.options.keys.length && d2.forEach(function(e5) {
                    t5.indexOf(e5.x) >= 0 && t5.indexOf(e5.x2) >= 0 && (t5 = e5);
                  }), p(t5, true) ? u(t5) : t5;
                });
                e4.visible && e4.setData(t4, false);
              }), t3.treeGrid.mapOptionsToLevel = l({ defaults: s2, from: 1, levels: s2 && s2.levels, to: t3.treeGrid.tree && t3.treeGrid.tree.height }), "beforeRender" === e3.type && (t3.treeGrid.collapsedNodes = h2.collapsedNodes);
            }
          });
        }
        function v(e3, t3) {
          let i3 = this.treeGrid.mapOptionsToLevel || {}, s2 = "treegrid" === this.options.type, o2 = this.ticks, r2 = o2[t3], l2, a2, d2;
          s2 && this.treeGrid.mapOfPosToGridNode ? ((l2 = i3[(d2 = this.treeGrid.mapOfPosToGridNode[t3]).depth]) && (a2 = { labels: l2 }), !r2 && n ? o2[t3] = r2 = new n(this, t3, void 0, void 0, { category: d2.name, tickmarkOffset: d2.tickmarkOffset, options: a2 }) : (r2.parameters.category = d2.name, r2.options = a2, r2.addLabel())) : e3.apply(this, Array.prototype.slice.call(arguments, 1));
        }
        function P(e3, t3, i3, s2) {
          let o2 = this, r2 = "treegrid" === i3.type;
          o2.treeGrid || (o2.treeGrid = new T(o2)), r2 && (a(t3, "beforeRender", y), a(t3, "beforeRedraw", y), a(t3, "addSeries", function(e4) {
            if (e4.options.data) {
              let t4 = b(e4.options.data, i3.uniqueNames || false, 1);
              o2.treeGrid.collapsedNodes = (o2.treeGrid.collapsedNodes || []).concat(t4.collapsedNodes);
            }
          }), a(o2, "foundExtremes", function() {
            o2.treeGrid.collapsedNodes && o2.treeGrid.collapsedNodes.forEach(function(e4) {
              let t4 = o2.treeGrid.collapse(e4);
              o2.brokenAxis && (o2.brokenAxis.setBreaks(t4, false), o2.treeGrid.collapsedNodes && (o2.treeGrid.collapsedNodes = o2.treeGrid.collapsedNodes.filter((t5) => e4.collapseStart !== t5.collapseStart || e4.collapseEnd !== t5.collapseEnd)));
            });
          }), a(o2, "afterBreaks", function() {
            "yAxis" === o2.coll && !o2.staticScale && o2.chart.options.chart.height && (o2.isDirty = true);
          }), i3 = u({ grid: { enabled: true }, labels: { align: "left", levels: [{ level: void 0 }, { level: 1, style: { fontWeight: "bold" } }], symbol: { type: "triangle", x: -5, y: -5, height: 10, width: 10 } }, uniqueNames: false }, i3, { reversed: true })), e3.apply(o2, [t3, i3, s2]), r2 && (o2.hasNames = true, o2.options.showLastLabel = true);
        }
        function G(e3) {
          var _a;
          let t3 = this.options, i3 = "number" == typeof t3.linkedTo ? (_a = this.chart[this.coll]) == null ? void 0 : _a[t3.linkedTo] : void 0;
          if ("treegrid" === t3.type) {
            if (this.min = g(this.userMin, t3.min, this.dataMin), this.max = g(this.userMax, t3.max, this.dataMax), h(this, "foundExtremes"), this.setAxisTranslation(), this.tickInterval = 1, this.tickmarkOffset = 0.5, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : [], i3) {
              let e4 = i3.getExtremes();
              this.min = g(e4.min, e4.dataMin), this.max = g(e4.max, e4.dataMax), this.tickPositions = i3.tickPositions;
            }
            this.linkedParent = i3;
          } else e3.apply(this, Array.prototype.slice.call(arguments, 1));
        }
        function A(e3) {
          let t3 = this;
          "treegrid" === t3.options.type && t3.visible && t3.tickPositions.forEach(function(e4) {
            let i3 = t3.ticks[e4];
            i3.label && i3.label.attachedTreeGridEvents && (k(i3.label.element), i3.label.attachedTreeGridEvents = false);
          }), e3.apply(t3, Array.prototype.slice.call(arguments, 1));
        }
        class T {
          static compose(o2, r2, l2, a2) {
            if (!o2.keepProps.includes("treeGrid")) {
              let e3 = o2.prototype;
              o2.keepProps.push("treeGrid"), m(e3, "generateTick", v), m(e3, "init", P), m(e3, "setTickInterval", G), m(e3, "redraw", A), e3.utils = { getNode: i2.getNode }, n || (n = a2);
            }
            return t2.compose(o2, r2, a2), e2.compose(o2, l2), s.compose(a2), o2;
          }
          constructor(e3) {
            this.axis = e3;
          }
          setCollapsedStatus(e3) {
            let t3 = this.axis, i3 = t3.chart;
            t3.series.forEach(function(t4) {
              let s2 = t4.options.data;
              if (e3.id && s2) {
                let o2 = i3.get(e3.id), r2 = s2[t4.data.indexOf(o2)];
                o2 && r2 && (o2.collapsed = e3.collapsed, r2.collapsed = e3.collapsed);
              }
            });
          }
          collapse(e3) {
            let t3 = this.axis, i3 = t3.options.breaks || [], s2 = x(e3, t3.max);
            return i3.push(s2), e3.collapsed = true, t3.treeGrid.setCollapsedStatus(e3), i3;
          }
          expand(e3) {
            let t3 = this.axis, i3 = t3.options.breaks || [], s2 = x(e3, t3.max);
            return e3.collapsed = false, t3.treeGrid.setCollapsedStatus(e3), i3.reduce(function(e4, t4) {
              return (t4.to !== s2.to || t4.from !== s2.from) && e4.push(t4), e4;
            }, []);
          }
          getTickPositions() {
            let e3 = this.axis, t3 = Math.floor(e3.min / e3.tickInterval) * e3.tickInterval, i3 = Math.ceil(e3.max / e3.tickInterval) * e3.tickInterval;
            return Object.keys(e3.treeGrid.mapOfPosToGridNode || {}).reduce(function(s2, o2) {
              let r2 = +o2;
              return r2 >= t3 && r2 <= i3 && !(e3.brokenAxis && e3.brokenAxis.isInAnyBreak(r2)) && s2.push(r2), s2;
            }, []);
          }
          isCollapsed(e3) {
            let t3 = this.axis, i3 = t3.options.breaks || [], s2 = x(e3, t3.max);
            return i3.some(function(e4) {
              return e4.from === s2.from && e4.to === s2.to;
            });
          }
          toggleCollapse(e3) {
            return this.isCollapsed(e3) ? this.expand(e3) : this.collapse(e3);
          }
        }
        return T;
      }), i(t, "masters/modules/treegrid.src.js", [t["Core/Globals.js"], t["Core/Axis/TreeGrid/TreeGridAxis.js"]], function(e2, t2) {
        return t2.compose(e2.Axis, e2.Chart, e2.Series, e2.Tick), e2;
      });
    });
  }
});
export default require_treegrid();
//# sourceMappingURL=highcharts_modules_treegrid__js.js.map
