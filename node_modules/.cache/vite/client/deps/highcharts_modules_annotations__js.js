import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/annotations.js
var require_annotations = __commonJS({
  "node_modules/highcharts/modules/annotations.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Annotations module
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/annotations", ["highcharts"], function(i) {
        return t(i), t.Highcharts = i, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var i = t ? t._modules : {};
      function s(i2, s2, e, o) {
        i2.hasOwnProperty(s2) || (i2[s2] = o.apply(null, e), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: i2[s2] } })));
      }
      s(i, "Extensions/Annotations/AnnotationChart.js", [i["Core/Utilities.js"]], function(t2) {
        var i2;
        let { addEvent: s2, erase: e, find: o, fireEvent: n, pick: a, wrap: r } = t2;
        function l(t3, i3) {
          let s3 = this.initAnnotation(t3);
          return this.options.annotations.push(s3.options), a(i3, true) && (s3.redraw(), s3.graphic.attr({ opacity: 1 })), s3;
        }
        function h() {
          let t3 = this;
          t3.plotBoxClip = this.renderer.clipRect(this.plotBox), t3.controlPointsGroup = t3.renderer.g("control-points").attr({ zIndex: 99 }).clip(t3.plotBoxClip).add(), t3.options.annotations.forEach((i3, s3) => {
            if (!t3.annotations.some((t4) => t4.options === i3)) {
              let e2 = t3.initAnnotation(i3);
              t3.options.annotations[s3] = e2.options;
            }
          }), t3.drawAnnotations(), s2(t3, "redraw", t3.drawAnnotations), s2(t3, "destroy", function() {
            t3.plotBoxClip.destroy(), t3.controlPointsGroup.destroy();
          }), s2(t3, "exportData", function(i3) {
            let s3 = t3.annotations, e2 = (this.options.exporting && this.options.exporting.csv || {}).columnHeaderFormatter, o2 = !i3.dataRows[1].xValues, n2 = t3.options.lang && t3.options.lang.exportData && t3.options.lang.exportData.annotationHeader, a2 = i3.dataRows[0].length, r2 = t3.options.exporting && t3.options.exporting.csv && t3.options.exporting.csv.annotations && t3.options.exporting.csv.annotations.itemDelimiter, l2 = t3.options.exporting && t3.options.exporting.csv && t3.options.exporting.csv.annotations && t3.options.exporting.csv.annotations.join;
            s3.forEach((t4) => {
              t4.options.labelOptions && t4.options.labelOptions.includeInDataExport && t4.labels.forEach((t5) => {
                if (t5.options.text) {
                  let s4 = t5.options.text;
                  t5.points.forEach((t6) => {
                    let e3 = t6.x, o3 = t6.series.xAxis ? t6.series.xAxis.index : -1, n3 = false;
                    if (-1 === o3) {
                      let t7 = i3.dataRows[0].length, a3 = Array(t7);
                      for (let i4 = 0; i4 < t7; ++i4) a3[i4] = "";
                      a3.push(s4), a3.xValues = [], a3.xValues[o3] = e3, i3.dataRows.push(a3), n3 = true;
                    }
                    if (n3 || i3.dataRows.forEach((t7) => {
                      !n3 && t7.xValues && void 0 !== o3 && e3 === t7.xValues[o3] && (l2 && t7.length > a2 ? t7[t7.length - 1] += r2 + s4 : t7.push(s4), n3 = true);
                    }), !n3) {
                      let t7 = i3.dataRows[0].length, n4 = Array(t7);
                      for (let i4 = 0; i4 < t7; ++i4) n4[i4] = "";
                      n4[0] = e3, n4.push(s4), n4.xValues = [], void 0 !== o3 && (n4.xValues[o3] = e3), i3.dataRows.push(n4);
                    }
                  });
                }
              });
            });
            let h2 = 0;
            i3.dataRows.forEach((t4) => {
              h2 = Math.max(h2, t4.length);
            });
            let c2 = h2 - i3.dataRows[0].length;
            for (let t4 = 0; t4 < c2; t4++) {
              let s4 = function(t5) {
                let i4;
                return e2 && false !== (i4 = e2(t5)) ? i4 : (i4 = n2 + " " + t5, o2) ? { columnTitle: i4, topLevelColumnTitle: i4 } : i4;
              }(t4 + 1);
              o2 ? (i3.dataRows[0].push(s4.topLevelColumnTitle), i3.dataRows[1].push(s4.columnTitle)) : i3.dataRows[0].push(s4);
            }
          });
        }
        function c() {
          this.plotBoxClip.attr(this.plotBox), this.annotations.forEach((t3) => {
            t3.redraw(), t3.graphic.animate({ opacity: 1 }, t3.animationConfig);
          });
        }
        function p(t3) {
          let i3 = this.annotations, s3 = "annotations" === t3.coll ? t3 : o(i3, function(i4) {
            return i4.options.id === t3;
          });
          s3 && (n(s3, "remove"), e(this.options.annotations, s3.options), e(i3, s3), s3.destroy());
        }
        function d() {
          this.annotations = [], this.options.annotations || (this.options.annotations = []);
        }
        function u(t3) {
          this.chart.hasDraggedAnnotation || t3.apply(this, Array.prototype.slice.call(arguments, 1));
        }
        return (i2 || (i2 = {})).compose = function(t3, i3, e2) {
          let o2 = i3.prototype;
          if (!o2.addAnnotation) {
            let n2 = e2.prototype;
            s2(i3, "afterInit", d), o2.addAnnotation = l, o2.callbacks.push(h), o2.collectionsWithInit.annotations = [l], o2.collectionsWithUpdate.push("annotations"), o2.drawAnnotations = c, o2.removeAnnotation = p, o2.initAnnotation = function(i4) {
              let s3 = new (t3.types[i4.type] || t3)(this, i4);
              return this.annotations.push(s3), s3;
            }, r(n2, "onContainerMouseDown", u);
          }
        }, i2;
      }), s(i, "Extensions/Annotations/AnnotationDefaults.js", [i["Core/Utilities.js"]], function(t2) {
        let { defined: i2 } = t2;
        return { visible: true, animation: {}, crop: true, draggable: "xy", labelOptions: { align: "center", allowOverlap: false, backgroundColor: "rgba(0, 0, 0, 0.75)", borderColor: "#000000", borderRadius: 3, borderWidth: 1, className: "highcharts-no-tooltip", crop: false, formatter: function() {
          return i2(this.y) ? "" + this.y : "Annotation label";
        }, includeInDataExport: true, overflow: "justify", padding: 5, shadow: false, shape: "callout", style: { fontSize: "0.7em", fontWeight: "normal", color: "contrast" }, useHTML: false, verticalAlign: "bottom", x: 0, y: -16 }, shapeOptions: { stroke: "rgba(0, 0, 0, 0.75)", strokeWidth: 1, fill: "rgba(0, 0, 0, 0.75)", r: 0, snap: 2 }, controlPointOptions: { events: {}, style: { cursor: "pointer", fill: "#ffffff", stroke: "#000000", "stroke-width": 2 }, height: 10, symbol: "circle", visible: false, width: 10 }, events: {}, zIndex: 6 };
      }), s(i, "Extensions/Annotations/EventEmitter.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { doc: s2, isTouchDevice: e } = t2, { addEvent: o, fireEvent: n, objectEach: a, pick: r, removeEvent: l } = i2;
        return class {
          addEvents() {
            let t3 = this, i3 = function(i4) {
              o(i4, e ? "touchstart" : "mousedown", (i5) => {
                t3.onMouseDown(i5);
              }, { passive: false });
            };
            if (i3(this.graphic.element), (t3.labels || []).forEach((t4) => {
              t4.options.useHTML && t4.graphic.text && i3(t4.graphic.text.element);
            }), a(t3.options.events, (i4, s3) => {
              let e2 = function(e3) {
                var _a;
                "click" === s3 && t3.cancelClick || i4.call(t3, (_a = t3.chart.pointer) == null ? void 0 : _a.normalize(e3), t3.target);
              };
              -1 === (t3.nonDOMEvents || []).indexOf(s3) ? (o(t3.graphic.element, s3, e2, { passive: false }), t3.graphic.div && o(t3.graphic.div, s3, e2, { passive: false })) : o(t3, s3, e2, { passive: false });
            }), t3.options.draggable && (o(t3, "drag", t3.onDrag), !t3.graphic.renderer.styledMode)) {
              let i4 = { cursor: { x: "ew-resize", y: "ns-resize", xy: "move" }[t3.options.draggable] };
              t3.graphic.css(i4), (t3.labels || []).forEach((t4) => {
                t4.options.useHTML && t4.graphic.text && t4.graphic.text.css(i4);
              });
            }
            t3.isUpdating || n(t3, "add");
          }
          destroy() {
            this.removeDocEvents(), l(this), this.hcEvents = null;
          }
          mouseMoveToRadians(t3, i3, s3) {
            let e2 = t3.prevChartY - s3, o2 = t3.prevChartX - i3, n2 = t3.chartY - s3, a2 = t3.chartX - i3, r2;
            return this.chart.inverted && (r2 = o2, o2 = e2, e2 = r2, r2 = a2, a2 = n2, n2 = r2), Math.atan2(n2, a2) - Math.atan2(e2, o2);
          }
          mouseMoveToScale(t3, i3, s3) {
            let e2 = t3.prevChartX - i3, o2 = t3.prevChartY - s3, n2 = t3.chartX - i3, a2 = t3.chartY - s3, r2 = (n2 || 1) / (e2 || 1), l2 = (a2 || 1) / (o2 || 1);
            if (this.chart.inverted) {
              let t4 = l2;
              l2 = r2, r2 = t4;
            }
            return { x: r2, y: l2 };
          }
          mouseMoveToTranslation(t3) {
            let i3 = t3.chartX - t3.prevChartX, s3 = t3.chartY - t3.prevChartY, e2;
            return this.chart.inverted && (e2 = s3, s3 = i3, i3 = e2), { x: i3, y: s3 };
          }
          onDrag(t3) {
            if (this.chart.isInsidePlot(t3.chartX - this.chart.plotLeft, t3.chartY - this.chart.plotTop, { visiblePlotOnly: true })) {
              let i3 = this.mouseMoveToTranslation(t3);
              "x" === this.options.draggable && (i3.y = 0), "y" === this.options.draggable && (i3.x = 0), this.points.length ? this.translate(i3.x, i3.y) : (this.shapes.forEach((t4) => t4.translate(i3.x, i3.y)), this.labels.forEach((t4) => t4.translate(i3.x, i3.y))), this.redraw(false);
            }
          }
          onMouseDown(t3) {
            var _a;
            if (t3.preventDefault && t3.preventDefault(), 2 === t3.button) return;
            let i3 = this, a2 = i3.chart.pointer, l2 = ((_a = t3 == null ? void 0 : t3.sourceCapabilities) == null ? void 0 : _a.firesTouchEvents) || false, h = (t3 = (a2 == null ? void 0 : a2.normalize(t3)) || t3).chartX, c = t3.chartY;
            i3.cancelClick = false, i3.chart.hasDraggedAnnotation = true, i3.removeDrag = o(s2, e || l2 ? "touchmove" : "mousemove", function(t4) {
              i3.hasDragged = true, (t4 = (a2 == null ? void 0 : a2.normalize(t4)) || t4).prevChartX = h, t4.prevChartY = c, n(i3, "drag", t4), h = t4.chartX, c = t4.chartY;
            }, e || l2 ? { passive: false } : void 0), i3.removeMouseUp = o(s2, e || l2 ? "touchend" : "mouseup", function() {
              let t4 = r(i3.target && i3.target.annotation, i3.target);
              t4 && (t4.cancelClick = i3.hasDragged), i3.cancelClick = i3.hasDragged, i3.chart.hasDraggedAnnotation = false, i3.hasDragged && n(r(t4, i3), "afterUpdate"), i3.hasDragged = false, i3.onMouseUp();
            }, e || l2 ? { passive: false } : void 0);
          }
          onMouseUp() {
            this.removeDocEvents();
          }
          removeDocEvents() {
            this.removeDrag && (this.removeDrag = this.removeDrag()), this.removeMouseUp && (this.removeMouseUp = this.removeMouseUp());
          }
        };
      }), s(i, "Extensions/Annotations/ControlPoint.js", [i["Extensions/Annotations/EventEmitter.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { merge: s2, pick: e } = i2;
        return class extends t2 {
          constructor(t3, i3, s3, o) {
            super(), this.nonDOMEvents = ["drag"], this.chart = t3, this.target = i3, this.options = s3, this.index = e(s3.index, o);
          }
          destroy() {
            super.destroy(), this.graphic && (this.graphic = this.graphic.destroy()), this.chart = null, this.target = null, this.options = null;
          }
          redraw(t3) {
            this.graphic[t3 ? "animate" : "attr"](this.options.positioner.call(this, this.target));
          }
          render() {
            let t3 = this.chart, i3 = this.options;
            this.graphic = t3.renderer.symbol(i3.symbol, 0, 0, i3.width, i3.height).add(t3.controlPointsGroup).css(i3.style), this.setVisibility(i3.visible), this.addEvents();
          }
          setVisibility(t3) {
            this.graphic[t3 ? "show" : "hide"](), this.options.visible = t3;
          }
          update(t3) {
            let i3 = this.chart, e2 = this.target, o = this.index, n = s2(true, this.options, t3);
            this.destroy(), this.constructor(i3, e2, n, o), this.render(i3.controlPointsGroup), this.redraw();
          }
        };
      }), s(i, "Extensions/Annotations/MockPoint.js", [i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { series: { prototype: s2 } } = t2, { defined: e, fireEvent: o } = i2;
        class n {
          static fromPoint(t3) {
            return new n(t3.series.chart, null, { x: t3.x, y: t3.y, xAxis: t3.series.xAxis, yAxis: t3.series.yAxis });
          }
          static pointToPixels(t3, i3) {
            let s3 = t3.series, e2 = s3.chart, o2 = t3.plotX || 0, n2 = t3.plotY || 0, a;
            return e2.inverted && (t3.mock ? (o2 = t3.plotY, n2 = t3.plotX) : (o2 = e2.plotWidth - (t3.plotY || 0), n2 = e2.plotHeight - (t3.plotX || 0))), s3 && !i3 && (o2 += (a = s3.getPlotBox()).translateX, n2 += a.translateY), { x: o2, y: n2 };
          }
          static pointToOptions(t3) {
            return { x: t3.x, y: t3.y, xAxis: t3.series.xAxis, yAxis: t3.series.yAxis };
          }
          constructor(t3, i3, e2) {
            this.mock = true, this.series = { visible: true, chart: t3, getPlotBox: s2.getPlotBox }, this.target = i3 || null, this.options = e2, this.applyOptions(this.getOptions());
          }
          applyOptions(t3) {
            this.command = t3.command, this.setAxis(t3, "x"), this.setAxis(t3, "y"), this.refresh();
          }
          getLabelConfig() {
            return { x: this.x, y: this.y, point: this };
          }
          getOptions() {
            return this.hasDynamicOptions() ? this.options(this.target) : this.options;
          }
          hasDynamicOptions() {
            return "function" == typeof this.options;
          }
          isInsidePlot() {
            let t3 = this.plotX, i3 = this.plotY, s3 = this.series.xAxis, n2 = this.series.yAxis, a = { x: t3, y: i3, isInsidePlot: true, options: {} };
            return s3 && (a.isInsidePlot = e(t3) && t3 >= 0 && t3 <= s3.len), n2 && (a.isInsidePlot = a.isInsidePlot && e(i3) && i3 >= 0 && i3 <= n2.len), o(this.series.chart, "afterIsInsidePlot", a), a.isInsidePlot;
          }
          refresh() {
            let t3 = this.series, i3 = t3.xAxis, s3 = t3.yAxis, e2 = this.getOptions();
            i3 ? (this.x = e2.x, this.plotX = i3.toPixels(e2.x, true)) : (this.x = void 0, this.plotX = e2.x), s3 ? (this.y = e2.y, this.plotY = s3.toPixels(e2.y, true)) : (this.y = null, this.plotY = e2.y), this.isInside = this.isInsidePlot();
          }
          refreshOptions() {
            let t3 = this.series, i3 = t3.xAxis, s3 = t3.yAxis;
            this.x = this.options.x = i3 ? this.options.x = i3.toValue(this.plotX, true) : this.plotX, this.y = this.options.y = s3 ? s3.toValue(this.plotY, true) : this.plotY;
          }
          rotate(t3, i3, s3) {
            if (!this.hasDynamicOptions()) {
              let e2 = Math.cos(s3), o2 = Math.sin(s3), n2 = this.plotX - t3, a = this.plotY - i3;
              this.plotX = n2 * e2 - a * o2 + t3, this.plotY = n2 * o2 + a * e2 + i3, this.refreshOptions();
            }
          }
          scale(t3, i3, s3, e2) {
            if (!this.hasDynamicOptions()) {
              let o2 = this.plotX * s3, n2 = this.plotY * e2;
              this.plotX = (1 - s3) * t3 + o2, this.plotY = (1 - e2) * i3 + n2, this.refreshOptions();
            }
          }
          setAxis(t3, i3) {
            let s3 = i3 + "Axis", o2 = t3[s3], n2 = this.series.chart;
            this.series[s3] = "object" == typeof o2 ? o2 : e(o2) ? n2[s3][o2] || n2.get(o2) : null;
          }
          toAnchor() {
            let t3 = [this.plotX, this.plotY, 0, 0];
            return this.series.chart.inverted && (t3[0] = this.plotY, t3[1] = this.plotX), t3;
          }
          translate(t3, i3, s3, e2) {
            this.hasDynamicOptions() || (this.plotX += s3, this.plotY += e2, this.refreshOptions());
          }
        }
        return n;
      }), s(i, "Extensions/Annotations/ControlTarget.js", [i["Extensions/Annotations/ControlPoint.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        var e;
        return function(e2) {
          function o() {
            let i3 = this.controlPoints, e3 = this.options.controlPoints || [];
            e3.forEach((o2, n2) => {
              let a2 = s2.merge(this.options.controlPointOptions, o2);
              a2.index || (a2.index = n2), e3[n2] = a2, i3.push(new t2(this.chart, this, a2));
            });
          }
          function n(t3) {
            let i3 = t3.series.getPlotBox(), e3 = t3.series.chart, o2 = t3.mock ? t3.toAnchor() : e3.tooltip && e3.tooltip.getAnchor.call({ chart: t3.series.chart }, t3) || [0, 0, 0, 0], n2 = { x: o2[0] + (this.options.x || 0), y: o2[1] + (this.options.y || 0), height: o2[2] || 0, width: o2[3] || 0 };
            return { relativePosition: n2, absolutePosition: s2.merge(n2, { x: n2.x + (t3.mock ? i3.translateX : e3.plotLeft), y: n2.y + (t3.mock ? i3.translateY : e3.plotTop) }) };
          }
          function a() {
            this.controlPoints.forEach((t3) => t3.destroy()), this.chart = null, this.controlPoints = null, this.points = null, this.options = null, this.annotation && (this.annotation = null);
          }
          function r() {
            let t3 = this.options;
            return t3.points || t3.point && s2.splat(t3.point);
          }
          function l() {
            let t3, i3;
            let s3 = this.getPointsOptions(), e3 = this.points, o2 = s3 && s3.length || 0;
            for (t3 = 0; t3 < o2; t3++) {
              if (!(i3 = this.point(s3[t3], e3[t3]))) {
                e3.length = 0;
                return;
              }
              i3.mock && i3.refresh(), e3[t3] = i3;
            }
            return e3;
          }
          function h(t3, e3) {
            if (t3 && t3.series) return t3;
            if (!e3 || null === e3.series) {
              if (s2.isObject(t3)) e3 = new i2(this.chart, this, t3);
              else if (s2.isString(t3)) e3 = this.chart.get(t3) || null;
              else if ("function" == typeof t3) {
                let s3 = t3.call(e3, this);
                e3 = s3.series ? s3 : new i2(this.chart, this, t3);
              }
            }
            return e3;
          }
          function c(t3) {
            this.controlPoints.forEach((i3) => i3.redraw(t3));
          }
          function p() {
            this.controlPoints.forEach((t3) => t3.render());
          }
          function d(t3, i3, s3, e3, o2) {
            if (this.chart.inverted) {
              let t4 = i3;
              i3 = s3, s3 = t4;
            }
            this.points.forEach((n2, a2) => this.transformPoint(t3, i3, s3, e3, o2, a2), this);
          }
          function u(t3, s3, e3, o2, n2, a2) {
            let r2 = this.points[a2];
            r2.mock || (r2 = this.points[a2] = i2.fromPoint(r2)), r2[t3](s3, e3, o2, n2);
          }
          function g(t3, i3) {
            this.transform("translate", null, null, t3, i3);
          }
          function m(t3, i3, s3) {
            this.transformPoint("translate", null, null, t3, i3, s3);
          }
          e2.compose = function(t3) {
            let i3 = t3.prototype;
            i3.addControlPoints || s2.merge(true, i3, { addControlPoints: o, anchor: n, destroyControlTarget: a, getPointsOptions: r, linkPoints: l, point: h, redrawControlPoints: c, renderControlPoints: p, transform: d, transformPoint: u, translate: g, translatePoint: m });
          };
        }(e || (e = {})), e;
      }), s(i, "Extensions/Annotations/Controllables/Controllable.js", [i["Extensions/Annotations/ControlTarget.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { merge: s2 } = i2;
        class e {
          constructor(t3, i3, s3, e2) {
            this.annotation = t3, this.chart = t3.chart, this.collection = "label" === e2 ? "labels" : "shapes", this.controlPoints = [], this.options = i3, this.points = [], this.index = s3, this.itemType = e2, this.init(t3, i3, s3);
          }
          attr(...t3) {
            this.graphic.attr.apply(this.graphic, arguments);
          }
          attrsFromOptions(t3) {
            let i3, s3;
            let e2 = this.constructor.attrsMap, o = {}, n = this.chart.styledMode;
            for (i3 in t3) s3 = e2[i3], void 0 === e2[i3] || n && -1 !== ["fill", "stroke", "stroke-width"].indexOf(s3) || (o[s3] = t3[i3]);
            return o;
          }
          destroy() {
            this.graphic && (this.graphic = this.graphic.destroy()), this.tracker && (this.tracker = this.tracker.destroy()), this.destroyControlTarget();
          }
          init(t3, i3, s3) {
            this.annotation = t3, this.chart = t3.chart, this.options = i3, this.points = [], this.controlPoints = [], this.index = s3, this.linkPoints(), this.addControlPoints();
          }
          redraw(t3) {
            this.redrawControlPoints(t3);
          }
          render(t3) {
            this.options.className && this.graphic && this.graphic.addClass(this.options.className), this.renderControlPoints();
          }
          rotate(t3, i3, s3) {
            this.transform("rotate", t3, i3, s3);
          }
          scale(t3, i3, s3, e2) {
            this.transform("scale", t3, i3, s3, e2);
          }
          setControlPointsVisibility(t3) {
            this.controlPoints.forEach((i3) => {
              i3.setVisibility(t3);
            });
          }
          shouldBeDrawn() {
            return !!this.points.length;
          }
          translateShape(t3, i3, s3) {
            let e2 = this.annotation.chart, o = this.annotation.userOptions, n = e2.annotations.indexOf(this.annotation), a = e2.options.annotations[n];
            this.translatePoint(t3, i3, 0), s3 && this.translatePoint(t3, i3, 1), a[this.collection][this.index].point = this.options.point, o[this.collection][this.index].point = this.options.point;
          }
          update(t3) {
            let i3 = this.annotation, e2 = s2(true, this.options, t3), o = this.graphic.parentGroup, n = this.constructor;
            this.destroy(), s2(true, this, new n(i3, e2, this.index, this.itemType)), this.render(o), this.redraw();
          }
        }
        return t2.compose(e), e;
      }), s(i, "Extensions/Annotations/Controllables/ControllableDefaults.js", [], function() {
        return { defaultMarkers: { arrow: { tagName: "marker", attributes: { id: "arrow", refY: 5, refX: 9, markerWidth: 10, markerHeight: 10 }, children: [{ tagName: "path", attributes: { d: "M 0 0 L 10 5 L 0 10 Z", "stroke-width": 0 } }] }, "reverse-arrow": { tagName: "marker", attributes: { id: "reverse-arrow", refY: 5, refX: 1, markerWidth: 10, markerHeight: 10 }, children: [{ tagName: "path", attributes: { d: "M 0 5 L 10 0 L 10 10 Z", "stroke-width": 0 } }] } } };
      }), s(i, "Extensions/Annotations/Controllables/ControllablePath.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllableDefaults.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2, s2, e) {
        let { defaultMarkers: o } = i2, { addEvent: n, defined: a, extend: r, merge: l, uniqueKey: h } = e, c = u("marker-end"), p = u("marker-start"), d = "rgba(192,192,192," + (s2.svg ? 1e-4 : 2e-3) + ")";
        function u(t3) {
          return function(i3) {
            this.attr(t3, "url(#" + i3 + ")");
          };
        }
        function g() {
          this.options.defs = l(o, this.options.defs || {});
        }
        function m(t3, i3) {
          let s3 = { attributes: { id: t3 } }, e2 = { stroke: i3.color || "none", fill: i3.color || "rgba(0, 0, 0, 0.75)" };
          s3.children = i3.children && i3.children.map(function(t4) {
            return l(e2, t4);
          });
          let o2 = l(true, { attributes: { markerWidth: 20, markerHeight: 20, refX: 0, refY: 0, orient: "auto" } }, i3, s3), n2 = this.definition(o2);
          return n2.id = t3, n2;
        }
        class f extends t2 {
          static compose(t3, i3) {
            let s3 = i3.prototype;
            s3.addMarker || (n(t3, "afterGetContainer", g), s3.addMarker = m);
          }
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "path";
          }
          toD() {
            let t3 = this.options.d;
            if (t3) return "function" == typeof t3 ? t3.call(this) : t3;
            let i3 = this.points, s3 = i3.length, e2 = [], o2 = s3, n2 = i3[0], a2 = o2 && this.anchor(n2).absolutePosition, r2 = 0, l2;
            if (a2) for (e2.push(["M", a2.x, a2.y]); ++r2 < s3 && o2; ) l2 = (n2 = i3[r2]).command || "L", a2 = this.anchor(n2).absolutePosition, "M" === l2 ? e2.push([l2, a2.x, a2.y]) : "L" === l2 ? e2.push([l2, a2.x, a2.y]) : "Z" === l2 && e2.push([l2]), o2 = n2.series.visible;
            return o2 && this.graphic ? this.chart.renderer.crispLine(e2, this.graphic.strokeWidth()) : null;
          }
          shouldBeDrawn() {
            return super.shouldBeDrawn() || !!this.options.d;
          }
          render(t3) {
            let i3 = this.options, s3 = this.attrsFromOptions(i3);
            this.graphic = this.annotation.chart.renderer.path([["M", 0, 0]]).attr(s3).add(t3), this.tracker = this.annotation.chart.renderer.path([["M", 0, 0]]).addClass("highcharts-tracker-line").attr({ zIndex: 2 }).add(t3), this.annotation.chart.styledMode || this.tracker.attr({ "stroke-linejoin": "round", stroke: d, fill: d, "stroke-width": this.graphic.strokeWidth() + 2 * i3.snap }), super.render(), r(this.graphic, { markerStartSetter: p, markerEndSetter: c }), this.setMarkers(this);
          }
          redraw(t3) {
            if (this.graphic) {
              let i3 = this.toD(), s3 = t3 ? "animate" : "attr";
              i3 ? (this.graphic[s3]({ d: i3 }), this.tracker[s3]({ d: i3 })) : (this.graphic.attr({ d: "M 0 -9000000000" }), this.tracker.attr({ d: "M 0 -9000000000" })), this.graphic.placed = this.tracker.placed = !!i3;
            }
            super.redraw(t3);
          }
          setMarkers(t3) {
            let i3 = t3.options, s3 = t3.chart, e2 = s3.options.defs, o2 = i3.fill, n2 = a(o2) && "none" !== o2 ? o2 : i3.stroke;
            ["markerStart", "markerEnd"].forEach(function(o3) {
              let a2, r2, c2, p2;
              let d2 = i3[o3];
              if (d2) {
                for (c2 in e2) if ((d2 === ((a2 = e2[c2]).attributes && a2.attributes.id) || d2 === a2.id) && "marker" === a2.tagName) {
                  r2 = a2;
                  break;
                }
                r2 && (p2 = t3[o3] = s3.renderer.addMarker((i3.id || h()) + "-" + d2, l(r2, { color: n2 })), t3.attr(o3, p2.getAttribute("id")));
              }
            });
          }
        }
        return f.attrsMap = { dashStyle: "dashstyle", strokeWidth: "stroke-width", stroke: "stroke", fill: "fill", zIndex: "zIndex" }, f;
      }), s(i, "Extensions/Annotations/Controllables/ControllableRect.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllablePath.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: e } = s2;
        class o extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "rect", this.translate = super.translateShape;
          }
          render(t3) {
            let i3 = this.attrsFromOptions(this.options);
            this.graphic = this.annotation.chart.renderer.rect(0, -9e9, 0, 0).attr(i3).add(t3), super.render();
          }
          redraw(t3) {
            if (this.graphic) {
              let i3 = this.anchor(this.points[0]).absolutePosition;
              i3 ? this.graphic[t3 ? "animate" : "attr"]({ x: i3.x, y: i3.y, width: this.options.width, height: this.options.height }) : this.attr({ x: 0, y: -9e9 }), this.graphic.placed = !!i3;
            }
            super.redraw(t3);
          }
        }
        return o.attrsMap = e(i2.attrsMap, { width: "width", height: "height" }), o;
      }), s(i, "Extensions/Annotations/Controllables/ControllableCircle.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllablePath.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: e } = s2;
        class o extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "circle", this.translate = super.translateShape;
          }
          redraw(t3) {
            if (this.graphic) {
              let i3 = this.anchor(this.points[0]).absolutePosition;
              i3 ? this.graphic[t3 ? "animate" : "attr"]({ x: i3.x, y: i3.y, r: this.options.r }) : this.graphic.attr({ x: 0, y: -9e9 }), this.graphic.placed = !!i3;
            }
            super.redraw.call(this, t3);
          }
          render(t3) {
            let i3 = this.attrsFromOptions(this.options);
            this.graphic = this.annotation.chart.renderer.circle(0, -9e9, 0).attr(i3).add(t3), super.render();
          }
          setRadius(t3) {
            this.options.r = t3;
          }
        }
        return o.attrsMap = e(i2.attrsMap, { r: "r" }), o;
      }), s(i, "Extensions/Annotations/Controllables/ControllableEllipse.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllablePath.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: e, defined: o } = s2;
        class n extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "ellipse";
          }
          init(t3, i3, s3) {
            o(i3.yAxis) && i3.points.forEach((t4) => {
              t4.yAxis = i3.yAxis;
            }), o(i3.xAxis) && i3.points.forEach((t4) => {
              t4.xAxis = i3.xAxis;
            }), super.init(t3, i3, s3);
          }
          render(t3) {
            this.graphic = this.annotation.chart.renderer.createElement("ellipse").attr(this.attrsFromOptions(this.options)).add(t3), super.render();
          }
          translate(t3, i3) {
            super.translateShape(t3, i3, true);
          }
          getDistanceFromLine(t3, i3, s3, e2) {
            return Math.abs((i3.y - t3.y) * s3 - (i3.x - t3.x) * e2 + i3.x * t3.y - i3.y * t3.x) / Math.sqrt((i3.y - t3.y) * (i3.y - t3.y) + (i3.x - t3.x) * (i3.x - t3.x));
          }
          getAttrs(t3, i3) {
            let s3 = t3.x, e2 = t3.y, o2 = i3.x, n2 = i3.y, a = (s3 + o2) / 2, r = Math.sqrt((s3 - o2) * (s3 - o2) / 4 + (e2 - n2) * (e2 - n2) / 4), l = 180 * Math.atan((n2 - e2) / (o2 - s3)) / Math.PI;
            return a < s3 && (l += 180), { cx: a, cy: (e2 + n2) / 2, rx: r, ry: this.getRY(), angle: l };
          }
          getRY() {
            let t3 = this.getYAxis();
            return o(t3) ? Math.abs(t3.toPixels(this.options.ry) - t3.toPixels(0)) : this.options.ry;
          }
          getYAxis() {
            let t3 = this.options.yAxis;
            return this.chart.yAxis[t3];
          }
          getAbsolutePosition(t3) {
            return this.anchor(t3).absolutePosition;
          }
          redraw(t3) {
            if (this.graphic) {
              let i3 = this.getAbsolutePosition(this.points[0]), s3 = this.getAbsolutePosition(this.points[1]), e2 = this.getAttrs(i3, s3);
              i3 ? this.graphic[t3 ? "animate" : "attr"]({ cx: e2.cx, cy: e2.cy, rx: e2.rx, ry: e2.ry, rotation: e2.angle, rotationOriginX: e2.cx, rotationOriginY: e2.cy }) : this.graphic.attr({ x: 0, y: -9e9 }), this.graphic.placed = !!i3;
            }
            super.redraw(t3);
          }
          setYRadius(t3) {
            let i3 = this.annotation.userOptions.shapes;
            this.options.ry = t3, i3 && i3[0] && (i3[0].ry = t3, i3[0].ry = t3);
          }
        }
        return n.attrsMap = e(i2.attrsMap, { ry: "ry" }), n;
      }), s(i, "Extensions/Annotations/Controllables/ControllableLabel.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Core/Templating.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2, e) {
        let { format: o } = i2, { extend: n, isNumber: a, pick: r } = e;
        function l(t3, i3, s3, e2, o2) {
          let n2 = o2 && o2.anchorX, r2 = o2 && o2.anchorY, l2, h2, c = s3 / 2;
          return a(n2) && a(r2) && (l2 = [["M", n2, r2]], (h2 = i3 - r2) < 0 && (h2 = -e2 - h2), h2 < s3 && (c = n2 < t3 + s3 / 2 ? h2 : s3 - h2), r2 > i3 + e2 ? l2.push(["L", t3 + c, i3 + e2]) : r2 < i3 ? l2.push(["L", t3 + c, i3]) : n2 < t3 ? l2.push(["L", t3, i3 + e2 / 2]) : n2 > t3 + s3 && l2.push(["L", t3 + s3, i3 + e2 / 2])), l2 || [];
        }
        class h extends t2 {
          static alignedPosition(t3, i3) {
            let s3 = t3.align, e2 = t3.verticalAlign, o2 = (i3.x || 0) + (t3.x || 0), n2 = (i3.y || 0) + (t3.y || 0), a2, r2;
            return "right" === s3 ? a2 = 1 : "center" === s3 && (a2 = 2), a2 && (o2 += (i3.width - (t3.width || 0)) / a2), "bottom" === e2 ? r2 = 1 : "middle" === e2 && (r2 = 2), r2 && (n2 += (i3.height - (t3.height || 0)) / r2), { x: Math.round(o2), y: Math.round(n2) };
          }
          static compose(t3) {
            t3.prototype.symbols.connector = l;
          }
          static justifiedOptions(t3, i3, s3, e2) {
            let o2;
            let n2 = s3.align, a2 = s3.verticalAlign, r2 = i3.box ? 0 : i3.padding || 0, l2 = i3.getBBox(), h2 = { align: n2, verticalAlign: a2, x: s3.x, y: s3.y, width: i3.width, height: i3.height }, c = (e2.x || 0) - t3.plotLeft, p = (e2.y || 0) - t3.plotTop;
            return (o2 = c + r2) < 0 && ("right" === n2 ? h2.align = "left" : h2.x = (h2.x || 0) - o2), (o2 = c + l2.width - r2) > t3.plotWidth && ("left" === n2 ? h2.align = "right" : h2.x = (h2.x || 0) + t3.plotWidth - o2), (o2 = p + r2) < 0 && ("bottom" === a2 ? h2.verticalAlign = "top" : h2.y = (h2.y || 0) - o2), (o2 = p + l2.height - r2) > t3.plotHeight && ("top" === a2 ? h2.verticalAlign = "bottom" : h2.y = (h2.y || 0) + t3.plotHeight - o2), h2;
          }
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "label");
          }
          translatePoint(t3, i3) {
            super.translatePoint(t3, i3, 0);
          }
          translate(t3, i3) {
            let s3 = this.annotation.chart, e2 = this.annotation.userOptions, o2 = s3.annotations.indexOf(this.annotation), n2 = s3.options.annotations[o2];
            if (s3.inverted) {
              let s4 = t3;
              t3 = i3, i3 = s4;
            }
            this.options.x += t3, this.options.y += i3, n2[this.collection][this.index].x = this.options.x, n2[this.collection][this.index].y = this.options.y, e2[this.collection][this.index].x = this.options.x, e2[this.collection][this.index].y = this.options.y;
          }
          render(t3) {
            let i3 = this.options, s3 = this.attrsFromOptions(i3), e2 = i3.style;
            this.graphic = this.annotation.chart.renderer.label("", 0, -9999, i3.shape, null, null, i3.useHTML, null, "annotation-label").attr(s3).add(t3), this.annotation.chart.styledMode || ("contrast" === e2.color && (e2.color = this.annotation.chart.renderer.getContrast(h.shapesWithoutBackground.indexOf(i3.shape) > -1 ? "#FFFFFF" : i3.backgroundColor)), this.graphic.css(i3.style).shadow(i3.shadow)), this.graphic.labelrank = i3.labelrank, super.render();
          }
          redraw(t3) {
            let i3 = this.options, s3 = this.text || i3.format || i3.text, e2 = this.graphic, n2 = this.points[0];
            if (!e2) {
              this.redraw(t3);
              return;
            }
            e2.attr({ text: s3 ? o(String(s3), n2.getLabelConfig(), this.annotation.chart) : i3.formatter.call(n2, this) });
            let a2 = this.anchor(n2), r2 = this.position(a2);
            r2 ? (e2.alignAttr = r2, r2.anchorX = a2.absolutePosition.x, r2.anchorY = a2.absolutePosition.y, e2[t3 ? "animate" : "attr"](r2)) : e2.attr({ x: 0, y: -9999 }), e2.placed = !!r2, super.redraw(t3);
          }
          anchor(t3) {
            let i3 = super.anchor.apply(this, arguments), s3 = this.options.x || 0, e2 = this.options.y || 0;
            return i3.absolutePosition.x -= s3, i3.absolutePosition.y -= e2, i3.relativePosition.x -= s3, i3.relativePosition.y -= e2, i3;
          }
          position(t3) {
            let i3 = this.graphic, e2 = this.annotation.chart, o2 = e2.tooltip, a2 = this.points[0], l2 = this.options, c = t3.absolutePosition, p = t3.relativePosition, d, u, g, m, f = a2.series.visible && s2.prototype.isInsidePlot.call(a2);
            if (i3 && f) {
              let { width: t4 = 0, height: s3 = 0 } = i3;
              l2.distance && o2 ? d = o2.getPosition.call({ chart: e2, distance: r(l2.distance, 16), getPlayingField: o2.getPlayingField, pointer: o2.pointer }, t4, s3, { plotX: p.x, plotY: p.y, negative: a2.negative, ttBelow: a2.ttBelow, h: p.height || p.width }) : l2.positioner ? d = l2.positioner.call(this) : (u = { x: c.x, y: c.y, width: 0, height: 0 }, d = h.alignedPosition(n(l2, { width: t4, height: s3 }), u), "justify" === this.options.overflow && (d = h.alignedPosition(h.justifiedOptions(e2, i3, l2, d), u))), l2.crop && (g = d.x - e2.plotLeft, m = d.y - e2.plotTop, f = e2.isInsidePlot(g, m) && e2.isInsidePlot(g + t4, m + s3));
            }
            return f ? d : null;
          }
        }
        return h.attrsMap = { backgroundColor: "fill", borderColor: "stroke", borderWidth: "stroke-width", zIndex: "zIndex", borderRadius: "r", padding: "padding" }, h.shapesWithoutBackground = ["connector"], h;
      }), s(i, "Extensions/Annotations/Controllables/ControllableImage.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllableLabel.js"]], function(t2, i2) {
        class s2 extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "image", this.translate = super.translateShape;
          }
          render(t3) {
            let i3 = this.attrsFromOptions(this.options), s3 = this.options;
            this.graphic = this.annotation.chart.renderer.image(s3.src, 0, -9e9, s3.width, s3.height).attr(i3).add(t3), this.graphic.width = s3.width, this.graphic.height = s3.height, super.render();
          }
          redraw(t3) {
            if (this.graphic) {
              let s3 = this.anchor(this.points[0]), e = i2.prototype.position.call(this, s3);
              e ? this.graphic[t3 ? "animate" : "attr"]({ x: e.x, y: e.y }) : this.graphic.attr({ x: 0, y: -9e9 }), this.graphic.placed = !!e;
            }
            super.redraw(t3);
          }
        }
        return s2.attrsMap = { width: "width", height: "height", zIndex: "zIndex" }, s2;
      }), s(i, "Shared/BaseForm.js", [i["Core/Renderer/HTML/AST.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { addEvent: s2, createElement: e } = i2;
        return class {
          constructor(t3, i3) {
            this.iconsURL = i3, this.container = this.createPopupContainer(t3), this.closeButton = this.addCloseButton();
          }
          createPopupContainer(t3, i3 = "highcharts-popup highcharts-no-tooltip") {
            return e("div", { className: i3 }, void 0, t3);
          }
          addCloseButton(t3 = "highcharts-popup-close") {
            let i3 = this, o = this.iconsURL, n = e("button", { className: t3 }, void 0, this.container);
            return n.style["background-image"] = "url(" + (o.match(/png|svg|jpeg|jpg|gif/ig) ? o : o + "close.svg") + ")", ["click", "touchstart"].forEach((t4) => {
              s2(n, t4, i3.closeButtonEvents.bind(i3));
            }), s2(document, "keydown", function(t4) {
              "Escape" === t4.code && i3.closeButtonEvents();
            }), n;
          }
          closeButtonEvents() {
            this.closePopup();
          }
          showPopup(i3 = "highcharts-annotation-toolbar") {
            let s3 = this.container, e2 = this.closeButton;
            this.type = void 0, s3.innerHTML = t2.emptyHTML, s3.className.indexOf(i3) >= 0 && (s3.classList.remove(i3), s3.removeAttribute("style")), s3.appendChild(e2), s3.style.display = "block", s3.style.height = "";
          }
          closePopup() {
            this.container.style.display = "none";
          }
        };
      }), s(i, "Extensions/Annotations/Popup/PopupAnnotations.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { doc: s2, isFirefox: e } = t2, { createElement: o, isArray: n, isObject: a, objectEach: r, pick: l, stableSort: h } = i2;
        function c(t3, i3, l2, p, d, u) {
          let g, m;
          if (!i3) return;
          let f = this.addInput, x = this.lang;
          r(p, (s3, e2) => {
            g = "" !== l2 ? l2 + "." + e2 : e2, a(s3) && (!n(s3) || n(s3) && a(s3[0]) ? ((m = x[e2] || e2).match(/\d/g) || d.push([true, m, t3]), c.call(this, t3, i3, g, s3, d, false)) : d.push([this, g, "annotation", t3, s3]));
          }), u && (h(d, (t4) => t4[1].match(/format/g) ? -1 : 1), e && d.reverse(), d.forEach((t4) => {
            true === t4[0] ? o("span", { className: "highcharts-annotation-title" }, void 0, t4[2]).appendChild(s2.createTextNode(t4[1])) : (t4[4] = { value: t4[4][0], type: t4[4][1] }, f.apply(t4[0], t4.splice(1)));
          }));
        }
        return { addForm: function(t3, i3, e2, n2) {
          if (!t3) return;
          let a2 = this.container, r2 = this.lang, l2 = o("h2", { className: "highcharts-popup-main-title" }, void 0, a2);
          l2.appendChild(s2.createTextNode(r2[i3.langKey] || i3.langKey || "")), l2 = o("div", { className: "highcharts-popup-lhs-col highcharts-popup-lhs-full" }, void 0, a2);
          let h2 = o("div", { className: "highcharts-popup-bottom-row" }, void 0, a2);
          c.call(this, l2, t3, "", i3, [], true), this.addButton(h2, n2 ? r2.addButton || "Add" : r2.saveButton || "Save", n2 ? "add" : "save", a2, e2);
        }, addToolbar: function(t3, i3, e2) {
          let n2 = this.lang, a2 = this.container, r2 = this.showForm, h2 = "highcharts-annotation-toolbar";
          -1 === a2.className.indexOf(h2) && (a2.className += " " + h2 + " highcharts-no-mousewheel"), t3 && (a2.style.top = t3.plotTop + 10 + "px");
          let c2 = o("p", { className: "highcharts-annotation-label" }, void 0, a2);
          c2.setAttribute("aria-label", "Annotation type"), c2.appendChild(s2.createTextNode(l(n2[i3.langKey] || i3.langKey, i3.shapes && i3.shapes[0].type, "")));
          let p = this.addButton(a2, n2.editButton || "Edit", "edit", a2, () => {
            r2.call(this, "annotation-edit", t3, i3, e2);
          });
          p.className += " highcharts-annotation-edit-button", p.style["background-image"] = "url(" + this.iconsURL + "edit.svg)", p = this.addButton(a2, n2.removeButton || "Remove", "remove", a2, e2), p.className += " highcharts-annotation-remove-button", p.style["background-image"] = "url(" + this.iconsURL + "destroy.svg)";
        } };
      }), s(i, "Extensions/Annotations/Popup/PopupIndicators.js", [i["Core/Renderer/HTML/AST.js"], i["Core/Globals.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function(t2, i2, s2, e) {
        var o, n;
        let { doc: a } = i2, { seriesTypes: r } = s2, { addEvent: l, createElement: h, defined: c, isArray: p, isObject: d, objectEach: u, stableSort: g } = e;
        (n = o || (o = {}))[n["params.algorithm"] = 0] = "params.algorithm", n[n["params.average"] = 1] = "params.average";
        let m = { "algorithm-pivotpoints": ["standard", "fibonacci", "camarilla"], "average-disparityindex": ["sma", "ema", "dema", "tema", "wma"] };
        function f(t3) {
          let i3 = h("div", { className: "highcharts-popup-lhs-col" }, void 0, t3), s3 = h("div", { className: "highcharts-popup-rhs-col" }, void 0, t3);
          return h("div", { className: "highcharts-popup-rhs-col-wrapper" }, void 0, s3), { lhsCol: i3, rhsCol: s3 };
        }
        function x(i3, s3, e2, o2) {
          let n2 = s3.params || s3.options.params;
          o2.innerHTML = t2.emptyHTML, h("h3", { className: "highcharts-indicator-title" }, void 0, o2).appendChild(a.createTextNode(k(s3, e2).indicatorFullName)), h("input", { type: "hidden", name: "highcharts-type-" + e2, value: e2 }, void 0, o2), w.call(this, e2, "series", i3, o2, s3, s3.linkedParent && s3.linkedParent.options.id), n2.volumeSeriesID && w.call(this, e2, "volume", i3, o2, s3, s3.linkedParent && n2.volumeSeriesID), v.call(this, i3, "params", n2, e2, o2);
        }
        function b(i3, s3, e2, o2) {
          function n2(t3, s4) {
            let e3 = y2.parentNode.children[1];
            x.call(a2, i3, t3, s4, y2), e3 && (e3.style.display = "block"), u2 && t3.options && h("input", { type: "hidden", name: "highcharts-id-" + s4, value: t3.options.id }, void 0, y2).setAttribute("highcharts-data-series-id", t3.options.id);
          }
          let a2 = this, r2 = a2.lang, c2 = s3.querySelectorAll(".highcharts-popup-lhs-col")[0], d2 = s3.querySelectorAll(".highcharts-popup-rhs-col")[0], u2 = "edit" === e2, m2 = u2 ? i3.series : i3.options.plotOptions || {};
          if (!i3 && m2) return;
          let f2, b2 = [];
          u2 || p(m2) ? p(m2) && (b2 = P.call(this, m2)) : b2 = E.call(this, m2, o2), g(b2, (t3, i4) => {
            let s4 = t3.indicatorFullName.toLowerCase(), e3 = i4.indicatorFullName.toLowerCase();
            return s4 < e3 ? -1 : s4 > e3 ? 1 : 0;
          }), c2.children[1] && c2.children[1].remove();
          let v2 = h("ul", { className: "highcharts-indicator-list" }, void 0, c2), y2 = d2.querySelectorAll(".highcharts-popup-rhs-col-wrapper")[0];
          if (b2.forEach((t3) => {
            let { indicatorFullName: i4, indicatorType: s4, series: e3 } = t3;
            f2 = h("li", { className: "highcharts-indicator-list" }, void 0, v2);
            let o3 = h("button", { className: "highcharts-indicator-list-item", textContent: i4 }, void 0, f2);
            ["click", "touchstart"].forEach((t4) => {
              l(o3, t4, function() {
                n2(e3, s4);
              });
            });
          }), b2.length > 0) {
            let { series: t3, indicatorType: i4 } = b2[0];
            n2(t3, i4);
          } else u2 || (t2.setElementHTML(y2.parentNode.children[0], r2.noFilterMatch || ""), y2.parentNode.children[1].style.display = "none");
        }
        function v(t3, i3, s3, e2, n2) {
          if (!t3) return;
          let a2 = this.addInput;
          u(s3, (s4, r2) => {
            let l2 = i3 + "." + r2;
            if (c(s4) && l2) {
              if (d(s4) && (a2.call(this, l2, e2, n2, {}), v.call(this, t3, l2, s4, e2, n2)), l2 in o) {
                let o2 = A.call(this, e2, l2, n2);
                C.call(this, t3, i3, o2, e2, r2, s4);
              } else "params.volumeSeriesID" === l2 || p(s4) || a2.call(this, l2, e2, n2, { value: s4, type: "number" });
            }
          });
        }
        function y(t3, i3) {
          let s3 = this, e2 = i3.querySelectorAll(".highcharts-popup-lhs-col")[0], o2 = this.lang.clearFilter, n2 = h("div", { className: "highcharts-input-wrapper" }, void 0, e2), a2 = function(i4) {
            b.call(s3, t3, s3.container, "add", i4);
          }, r2 = this.addInput("searchIndicators", "input", n2, { value: "", type: "text", htmlFor: "search-indicators", labelClassName: "highcharts-input-search-indicators-label" }), c2 = h("a", { textContent: o2 }, void 0, n2);
          r2.classList.add("highcharts-input-search-indicators"), c2.classList.add("clear-filter-button"), l(r2, "input", function() {
            a2(this.value), this.value.length ? c2.style.display = "inline-block" : c2.style.display = "none";
          }), ["click", "touchstart"].forEach((t4) => {
            l(c2, t4, function() {
              r2.value = "", a2(""), c2.style.display = "none";
            });
          });
        }
        function A(t3, i3, s3) {
          let e2 = i3.split("."), o2 = e2[e2.length - 1], n2 = "highcharts-" + i3 + "-type-" + t3, r2 = this.lang;
          h("label", { htmlFor: n2 }, null, s3).appendChild(a.createTextNode(r2[o2] || i3));
          let l2 = h("select", { name: n2, className: "highcharts-popup-field", id: "highcharts-select-" + i3 }, null, s3);
          return l2.setAttribute("id", "highcharts-select-" + i3), l2;
        }
        function C(t3, i3, s3, e2, o2, n2, r2) {
          "series" === i3 || "volume" === i3 ? t3.series.forEach((t4) => {
            let e3 = t4.options, o3 = e3.name || e3.params ? t4.name : e3.id || "";
            "highcharts-navigator-series" !== e3.id && e3.id !== (r2 && r2.options && r2.options.id) && (c(n2) || "volume" !== i3 || "column" !== t4.type || (n2 = e3.id), h("option", { value: e3.id }, void 0, s3).appendChild(a.createTextNode(o3)));
          }) : e2 && o2 && m[o2 + "-" + e2].forEach((t4) => {
            h("option", { value: t4 }, void 0, s3).appendChild(a.createTextNode(t4));
          }), c(n2) && (s3.value = n2);
        }
        function E(t3, i3) {
          let s3;
          let e2 = this.chart && this.chart.options.lang, o2 = e2 && e2.navigation && e2.navigation.popup && e2.navigation.popup.indicatorAliases, n2 = [];
          return u(t3, (t4, e3) => {
            let a2 = t4 && t4.options;
            if (t4.params || a2 && a2.params) {
              let { indicatorFullName: a3, indicatorType: r2 } = k(t4, e3);
              if (i3) {
                let e4 = RegExp(i3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i"), l2 = o2 && o2[r2] && o2[r2].join(" ") || "";
                (a3.match(e4) || l2.match(e4)) && (s3 = { indicatorFullName: a3, indicatorType: r2, series: t4 }, n2.push(s3));
              } else s3 = { indicatorFullName: a3, indicatorType: r2, series: t4 }, n2.push(s3);
            }
          }), n2;
        }
        function P(t3) {
          let i3 = [];
          return t3.forEach((t4) => {
            t4.is("sma") && i3.push({ indicatorFullName: t4.name, indicatorType: t4.type, series: t4 });
          }), i3;
        }
        function k(t3, i3) {
          let s3 = t3.options, e2 = r[i3] && r[i3].prototype.nameBase || i3.toUpperCase(), o2 = i3;
          return s3 && s3.type && (o2 = t3.options.type, e2 = t3.name), { indicatorFullName: e2, indicatorType: o2 };
        }
        function w(t3, i3, s3, e2, o2, n2) {
          if (!s3) return;
          let a2 = A.call(this, t3, i3, e2);
          C.call(this, s3, i3, a2, void 0, void 0, void 0, o2), c(n2) && (a2.value = n2);
        }
        return { addForm: function(t3, i3, s3) {
          let e2;
          let o2 = this.lang;
          if (!t3) return;
          this.tabs.init.call(this, t3);
          let n2 = this.container.querySelectorAll(".highcharts-tab-item-content");
          f(n2[0]), y.call(this, t3, n2[0]), b.call(this, t3, n2[0], "add"), e2 = n2[0].querySelectorAll(".highcharts-popup-rhs-col")[0], this.addButton(e2, o2.addButton || "add", "add", e2, s3), f(n2[1]), b.call(this, t3, n2[1], "edit"), e2 = n2[1].querySelectorAll(".highcharts-popup-rhs-col")[0], this.addButton(e2, o2.saveButton || "save", "edit", e2, s3), this.addButton(e2, o2.removeButton || "remove", "remove", e2, s3);
        }, getAmount: function() {
          let t3 = 0;
          return this.series.forEach((i3) => {
            (i3.params || i3.options.params) && t3++;
          }), t3;
        } };
      }), s(i, "Extensions/Annotations/Popup/PopupTabs.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { doc: s2 } = t2, { addEvent: e, createElement: o } = i2;
        function n() {
          return o("div", { className: "highcharts-tab-item-content highcharts-no-mousewheel" }, void 0, this.container);
        }
        function a(t3, i3) {
          let e2 = this.container, n2 = this.lang, a2 = "highcharts-tab-item";
          0 === i3 && (a2 += " highcharts-tab-disabled");
          let r2 = o("button", { className: a2 }, void 0, e2);
          return r2.appendChild(s2.createTextNode(n2[t3 + "Button"] || t3)), r2.setAttribute("highcharts-data-tab-type", t3), r2;
        }
        function r() {
          let t3 = this.container, i3 = t3.querySelectorAll(".highcharts-tab-item"), s3 = t3.querySelectorAll(".highcharts-tab-item-content");
          for (let t4 = 0; t4 < i3.length; t4++) i3[t4].classList.remove("highcharts-tab-item-active"), s3[t4].classList.remove("highcharts-tab-item-show");
        }
        function l(t3, i3) {
          let s3 = this.container.querySelectorAll(".highcharts-tab-item-content");
          t3.className += " highcharts-tab-item-active", s3[i3].className += " highcharts-tab-item-show";
        }
        function h(t3) {
          let i3 = this;
          this.container.querySelectorAll(".highcharts-tab-item").forEach((s3, o2) => {
            (0 !== t3 || "edit" !== s3.getAttribute("highcharts-data-tab-type")) && ["click", "touchstart"].forEach((t4) => {
              e(s3, t4, function() {
                r.call(i3), l.call(i3, this, o2);
              });
            });
          });
        }
        return { init: function(t3) {
          if (!t3) return;
          let i3 = this.indicators.getAmount.call(t3), s3 = a.call(this, "add");
          a.call(this, "edit", i3), n.call(this), n.call(this), h.call(this, i3), l.call(this, s3, 0);
        } };
      }), s(i, "Extensions/Annotations/Popup/Popup.js", [i["Shared/BaseForm.js"], i["Core/Globals.js"], i["Core/Defaults.js"], i["Extensions/Annotations/Popup/PopupAnnotations.js"], i["Extensions/Annotations/Popup/PopupIndicators.js"], i["Extensions/Annotations/Popup/PopupTabs.js"], i["Core/Utilities.js"]], function(t2, i2, s2, e, o, n, a) {
        let { doc: r } = i2, { getOptions: l } = s2, { addEvent: h, createElement: c, extend: p, fireEvent: d, pick: u } = a;
        class g extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3), this.chart = s3, this.lang = (l().lang.navigation || {}).popup || {}, h(this.container, "mousedown", () => {
              let t4 = s3 && s3.navigationBindings && s3.navigationBindings.activeAnnotation;
              if (t4) {
                t4.cancelClick = true;
                let i4 = h(r, "click", () => {
                  setTimeout(() => {
                    t4.cancelClick = false;
                  }, 0), i4();
                });
              }
            });
          }
          addInput(t3, i3, s3, e2) {
            let o2 = t3.split("."), n2 = o2[o2.length - 1], a2 = this.lang, l2 = "highcharts-" + i3 + "-" + u(e2.htmlFor, n2);
            n2.match(/^\d+$/) || c("label", { htmlFor: l2, className: e2.labelClassName }, void 0, s3).appendChild(r.createTextNode(a2[n2] || n2));
            let h2 = c("input", { name: l2, value: e2.value, type: e2.type, className: "highcharts-popup-field" }, void 0, s3);
            return h2.setAttribute("highcharts-data-name", t3), h2;
          }
          closeButtonEvents() {
            if (this.chart) {
              let t3 = this.chart.navigationBindings;
              d(t3, "closePopup"), t3 && t3.selectedButtonElement && d(t3, "deselectButton", { button: t3.selectedButtonElement });
            } else super.closeButtonEvents();
          }
          addButton(t3, i3, s3, e2, o2) {
            let n2 = c("button", void 0, void 0, t3);
            return n2.appendChild(r.createTextNode(i3)), o2 && ["click", "touchstart"].forEach((t4) => {
              h(n2, t4, () => (this.closePopup(), o2(function(t5, i4) {
                let s4 = Array.prototype.slice.call(t5.querySelectorAll("input")), e3 = Array.prototype.slice.call(t5.querySelectorAll("select")), o3 = t5.querySelectorAll("#highcharts-select-series > option:checked")[0], n3 = t5.querySelectorAll("#highcharts-select-volume > option:checked")[0], a2 = { actionType: i4, linkedTo: o3 && o3.getAttribute("value") || "", fields: {} };
                return s4.forEach((t6) => {
                  let i5 = t6.getAttribute("highcharts-data-name");
                  t6.getAttribute("highcharts-data-series-id") ? a2.seriesId = t6.value : i5 ? a2.fields[i5] = t6.value : a2.type = t6.value;
                }), e3.forEach((t6) => {
                  let i5 = t6.id;
                  if ("highcharts-select-series" !== i5 && "highcharts-select-volume" !== i5) {
                    let s5 = i5.split("highcharts-select-")[1];
                    a2.fields[s5] = t6.value;
                  }
                }), n3 && (a2.fields["params.volumeSeriesID"] = n3.getAttribute("value") || ""), a2;
              }(e2, s3))));
            }), n2;
          }
          showForm(t3, i3, s3, e2) {
            i3 && (this.showPopup(), "indicators" === t3 && this.indicators.addForm.call(this, i3, s3, e2), "annotation-toolbar" === t3 && this.annotations.addToolbar.call(this, i3, s3, e2), "annotation-edit" === t3 && this.annotations.addForm.call(this, i3, s3, e2), "flag" === t3 && this.annotations.addForm.call(this, i3, s3, e2, true), this.type = t3, this.container.style.height = this.container.offsetHeight + "px");
          }
        }
        return p(g.prototype, { annotations: e, indicators: o, tabs: n }), g;
      }), s(i, "Extensions/Annotations/Popup/PopupComposition.js", [i["Core/Globals.js"], i["Extensions/Annotations/Popup/Popup.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { composed: e } = t2, { addEvent: o, pushUnique: n, wrap: a } = s2;
        function r() {
          this.popup && this.popup.closePopup();
        }
        function l(t3) {
          this.popup || (this.popup = new i2(this.chart.container, this.chart.options.navigation.iconsURL || this.chart.options.stockTools && this.chart.options.stockTools.gui.iconsURL || "https://code.highcharts.com/11.4.7/gfx/stock-icons/", this.chart)), this.popup.showForm(t3.formType, this.chart, t3.options, t3.onSubmit);
        }
        function h(t3, i3) {
          this.inClass(i3.target, "highcharts-popup") || t3.apply(this, Array.prototype.slice.call(arguments, 1));
        }
        return { compose: function(t3, i3) {
          n(e, "Popup") && (o(t3, "closePopup", r), o(t3, "showPopup", l), a(i3.prototype, "onContainerMouseDown", h));
        } };
      }), s(i, "Extensions/Annotations/Annotation.js", [i["Core/Animation/AnimationUtilities.js"], i["Extensions/Annotations/AnnotationChart.js"], i["Extensions/Annotations/AnnotationDefaults.js"], i["Extensions/Annotations/Controllables/ControllableRect.js"], i["Extensions/Annotations/Controllables/ControllableCircle.js"], i["Extensions/Annotations/Controllables/ControllableEllipse.js"], i["Extensions/Annotations/Controllables/ControllablePath.js"], i["Extensions/Annotations/Controllables/ControllableImage.js"], i["Extensions/Annotations/Controllables/ControllableLabel.js"], i["Extensions/Annotations/ControlPoint.js"], i["Extensions/Annotations/ControlTarget.js"], i["Extensions/Annotations/EventEmitter.js"], i["Extensions/Annotations/MockPoint.js"], i["Extensions/Annotations/Popup/PopupComposition.js"], i["Core/Utilities.js"]], function(t2, i2, s2, e, o, n, a, r, l, h, c, p, d, u, g) {
        let { getDeferredAnimation: m } = t2, { destroyObjectProperties: f, erase: x, fireEvent: b, merge: v, pick: y, splat: A } = g;
        function C(t3, i3) {
          let s3 = {};
          return ["labels", "shapes"].forEach((e2) => {
            let o2 = t3[e2];
            o2 && (i3[e2] ? s3[e2] = A(i3[e2]).map(function(t4, i4) {
              return v(o2[i4], t4);
            }) : s3[e2] = t3[e2]);
          }), s3;
        }
        class E extends p {
          static compose(t3, s3, e2, o2) {
            i2.compose(E, t3, e2), l.compose(o2), a.compose(t3, o2), s3.compose(E, t3), u.compose(s3, e2);
          }
          constructor(t3, i3) {
            super(), this.coll = "annotations", this.chart = t3, this.points = [], this.controlPoints = [], this.coll = "annotations", this.index = -1, this.labels = [], this.shapes = [], this.options = v(this.defaultOptions, i3), this.userOptions = i3;
            let s3 = C(this.options, i3);
            this.options.labels = s3.labels, this.options.shapes = s3.shapes, this.init(t3, this.options);
          }
          addClipPaths() {
            this.setClipAxes(), this.clipXAxis && this.clipYAxis && this.options.crop && (this.clipRect = this.chart.renderer.clipRect(this.getClipBox()));
          }
          addLabels() {
            let t3 = this.options.labels || [];
            t3.forEach((i3, s3) => {
              let e2 = this.initLabel(i3, s3);
              v(true, t3[s3], e2.options);
            });
          }
          addShapes() {
            let t3 = this.options.shapes || [];
            t3.forEach((i3, s3) => {
              let e2 = this.initShape(i3, s3);
              v(true, t3[s3], e2.options);
            });
          }
          destroy() {
            let t3 = this.chart, i3 = function(t4) {
              t4.destroy();
            };
            this.labels.forEach(i3), this.shapes.forEach(i3), this.clipXAxis = null, this.clipYAxis = null, x(t3.labelCollectors, this.labelCollector), super.destroy(), this.destroyControlTarget(), f(this, t3);
          }
          destroyItem(t3) {
            x(this[t3.itemType + "s"], t3), t3.destroy();
          }
          getClipBox() {
            if (this.clipXAxis && this.clipYAxis) return { x: this.clipXAxis.left, y: this.clipYAxis.top, width: this.clipXAxis.width, height: this.clipYAxis.height };
          }
          initProperties(t3, i3) {
            this.setOptions(i3);
            let s3 = C(this.options, i3);
            this.options.labels = s3.labels, this.options.shapes = s3.shapes, this.chart = t3, this.points = [], this.controlPoints = [], this.coll = "annotations", this.userOptions = i3, this.labels = [], this.shapes = [];
          }
          init(t3, i3, s3 = this.index) {
            let e2 = this.chart, o2 = this.options.animation;
            this.index = s3, this.linkPoints(), this.addControlPoints(), this.addShapes(), this.addLabels(), this.setLabelCollector(), this.animationConfig = m(e2, o2);
          }
          initLabel(t3, i3) {
            let s3 = new l(this, v(this.options.labelOptions, { controlPointOptions: this.options.controlPointOptions }, t3), i3);
            return s3.itemType = "label", this.labels.push(s3), s3;
          }
          initShape(t3, i3) {
            let s3 = v(this.options.shapeOptions, { controlPointOptions: this.options.controlPointOptions }, t3), e2 = new E.shapesMap[s3.type](this, s3, i3);
            return e2.itemType = "shape", this.shapes.push(e2), e2;
          }
          redraw(t3) {
            this.linkPoints(), this.graphic || this.render(), this.clipRect && this.clipRect.animate(this.getClipBox()), this.redrawItems(this.shapes, t3), this.redrawItems(this.labels, t3), this.redrawControlPoints(t3);
          }
          redrawItem(t3, i3) {
            t3.linkPoints(), t3.shouldBeDrawn() ? (t3.graphic || this.renderItem(t3), t3.redraw(y(i3, true) && t3.graphic.placed), t3.points.length && function(t4) {
              let i4 = t4.graphic, s3 = t4.points.some((t5) => false !== t5.series.visible && false !== t5.visible);
              i4 && (s3 ? "hidden" === i4.visibility && i4.show() : i4.hide());
            }(t3)) : this.destroyItem(t3);
          }
          redrawItems(t3, i3) {
            let s3 = t3.length;
            for (; s3--; ) this.redrawItem(t3[s3], i3);
          }
          remove() {
            return this.chart.removeAnnotation(this);
          }
          render() {
            let t3 = this.chart.renderer;
            this.graphic = t3.g("annotation").attr({ opacity: 0, zIndex: this.options.zIndex, visibility: this.options.visible ? "inherit" : "hidden" }).add(), this.shapesGroup = t3.g("annotation-shapes").add(this.graphic), this.options.crop && this.shapesGroup.clip(this.chart.plotBoxClip), this.labelsGroup = t3.g("annotation-labels").attr({ translateX: 0, translateY: 0 }).add(this.graphic), this.addClipPaths(), this.clipRect && this.graphic.clip(this.clipRect), this.renderItems(this.shapes), this.renderItems(this.labels), this.addEvents(), this.renderControlPoints();
          }
          renderItem(t3) {
            t3.render("label" === t3.itemType ? this.labelsGroup : this.shapesGroup);
          }
          renderItems(t3) {
            let i3 = t3.length;
            for (; i3--; ) this.renderItem(t3[i3]);
          }
          setClipAxes() {
            let t3 = this.chart.xAxis, i3 = this.chart.yAxis, s3 = (this.options.labels || []).concat(this.options.shapes || []).reduce((s4, e2) => {
              let o2 = e2 && (e2.point || e2.points && e2.points[0]);
              return [t3[o2 && o2.xAxis] || s4[0], i3[o2 && o2.yAxis] || s4[1]];
            }, []);
            this.clipXAxis = s3[0], this.clipYAxis = s3[1];
          }
          setControlPointsVisibility(t3) {
            let i3 = function(i4) {
              i4.setControlPointsVisibility(t3);
            };
            this.controlPoints.forEach((i4) => {
              i4.setVisibility(t3);
            }), this.shapes.forEach(i3), this.labels.forEach(i3);
          }
          setLabelCollector() {
            let t3 = this;
            t3.labelCollector = function() {
              return t3.labels.reduce(function(t4, i3) {
                return i3.options.allowOverlap || t4.push(i3.graphic), t4;
              }, []);
            }, t3.chart.labelCollectors.push(t3.labelCollector);
          }
          setOptions(t3) {
            this.options = v(this.defaultOptions, t3);
          }
          setVisibility(t3) {
            let i3 = this.options, s3 = this.chart.navigationBindings, e2 = y(t3, !i3.visible);
            if (this.graphic.attr("visibility", e2 ? "inherit" : "hidden"), !e2) {
              let t4 = function(t5) {
                t5.setControlPointsVisibility(e2);
              };
              this.shapes.forEach(t4), this.labels.forEach(t4), s3.activeAnnotation === this && s3.popup && "annotation-toolbar" === s3.popup.type && b(s3, "closePopup");
            }
            i3.visible = e2;
          }
          update(t3, i3) {
            let s3 = this.chart, e2 = C(this.userOptions, t3), o2 = s3.annotations.indexOf(this), n2 = v(true, this.userOptions, t3);
            n2.labels = e2.labels, n2.shapes = e2.shapes, this.destroy(), this.initProperties(s3, n2), this.init(s3, n2), s3.options.annotations[o2] = this.options, this.isUpdating = true, y(i3, true) && s3.drawAnnotations(), b(this, "afterUpdate"), this.isUpdating = false;
          }
        }
        return E.ControlPoint = h, E.MockPoint = d, E.shapesMap = { rect: e, circle: o, ellipse: n, path: a, image: r }, E.types = {}, E.prototype.defaultOptions = s2, E.prototype.nonDOMEvents = ["add", "afterUpdate", "drag", "remove"], c.compose(E), E;
      }), s(i, "Core/Chart/ChartNavigationComposition.js", [], function() {
        var t2;
        return function(t3) {
          t3.compose = function(t4) {
            return t4.navigation || (t4.navigation = new i2(t4)), t4;
          };
          class i2 {
            constructor(t4) {
              this.updates = [], this.chart = t4;
            }
            addUpdate(t4) {
              this.chart.navigation.updates.push(t4);
            }
            update(t4, i3) {
              this.updates.forEach((s2) => {
                s2.call(this.chart, t4, i3);
              });
            }
          }
          t3.Additions = i2;
        }(t2 || (t2 = {})), t2;
      }), s(i, "Extensions/Annotations/NavigationBindingsUtilities.js", [i["Core/Utilities.js"]], function(t2) {
        let { defined: i2, isNumber: s2, pick: e } = t2, o = { backgroundColor: "string", borderColor: "string", borderRadius: "string", color: "string", fill: "string", fontSize: "string", labels: "string", name: "string", stroke: "string", title: "string" };
        return { annotationsFieldsTypes: o, getAssignedAxis: function(t3) {
          return t3.filter((t4) => {
            let i3 = t4.axis.getExtremes(), o2 = i3.min, n = i3.max, a = e(t4.axis.minPointOffset, 0);
            return s2(o2) && s2(n) && t4.value >= o2 - a && t4.value <= n + a && !t4.axis.options.isInternal;
          })[0];
        }, getFieldType: function(t3, s3) {
          let e2 = o[t3], n = typeof s3;
          return i2(e2) && (n = e2), { string: "text", number: "number", boolean: "checkbox" }[n];
        } };
      }), s(i, "Extensions/Annotations/NavigationBindingsDefaults.js", [i["Extensions/Annotations/NavigationBindingsUtilities.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { getAssignedAxis: s2 } = t2, { isNumber: e, merge: o } = i2;
        return { lang: { navigation: { popup: { simpleShapes: "Simple shapes", lines: "Lines", circle: "Circle", ellipse: "Ellipse", rectangle: "Rectangle", label: "Label", shapeOptions: "Shape options", typeOptions: "Details", fill: "Fill", format: "Text", strokeWidth: "Line width", stroke: "Line color", title: "Title", name: "Name", labelOptions: "Label options", labels: "Labels", backgroundColor: "Background color", backgroundColors: "Background colors", borderColor: "Border color", borderRadius: "Border radius", borderWidth: "Border width", style: "Style", padding: "Padding", fontSize: "Font size", color: "Color", height: "Height", shapes: "Shape options" } } }, navigation: { bindingsClassName: "highcharts-bindings-container", bindings: { circleAnnotation: { className: "highcharts-circle-annotation", start: function(t3) {
          var _a;
          let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), e2 = i3 && s2(i3.xAxis), n = i3 && s2(i3.yAxis), a = this.chart.options.navigation;
          if (e2 && n) return this.chart.addAnnotation(o({ langKey: "circle", type: "basicAnnotation", shapes: [{ type: "circle", point: { x: e2.value, y: n.value, xAxis: e2.axis.index, yAxis: n.axis.index }, r: 5 }] }, a.annotationsOptions, a.bindings.circleAnnotation.annotationsOptions));
        }, steps: [function(t3, i3) {
          let s3;
          let o2 = i3.options.shapes, n = o2 && o2[0] && o2[0].point || {};
          if (e(n.xAxis) && e(n.yAxis)) {
            let i4 = this.chart.inverted, e2 = this.chart.xAxis[n.xAxis].toPixels(n.x), o3 = this.chart.yAxis[n.yAxis].toPixels(n.y);
            s3 = Math.max(Math.sqrt(Math.pow(i4 ? o3 - t3.chartX : e2 - t3.chartX, 2) + Math.pow(i4 ? e2 - t3.chartY : o3 - t3.chartY, 2)), 5);
          }
          i3.update({ shapes: [{ r: s3 }] });
        }] }, ellipseAnnotation: { className: "highcharts-ellipse-annotation", start: function(t3) {
          var _a;
          let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), e2 = i3 && s2(i3.xAxis), n = i3 && s2(i3.yAxis), a = this.chart.options.navigation;
          if (e2 && n) return this.chart.addAnnotation(o({ langKey: "ellipse", type: "basicAnnotation", shapes: [{ type: "ellipse", xAxis: e2.axis.index, yAxis: n.axis.index, points: [{ x: e2.value, y: n.value }, { x: e2.value, y: n.value }], ry: 1 }] }, a.annotationsOptions, a.bindings.ellipseAnnotation.annotationOptions));
        }, steps: [function(t3, i3) {
          let s3 = i3.shapes[0], e2 = s3.getAbsolutePosition(s3.points[1]);
          s3.translatePoint(t3.chartX - e2.x, t3.chartY - e2.y, 1), s3.redraw(false);
        }, function(t3, i3) {
          let s3 = i3.shapes[0], e2 = s3.getAbsolutePosition(s3.points[0]), o2 = s3.getAbsolutePosition(s3.points[1]), n = s3.getDistanceFromLine(e2, o2, t3.chartX, t3.chartY), a = s3.getYAxis(), r = Math.abs(a.toValue(0) - a.toValue(n));
          s3.setYRadius(r), s3.redraw(false);
        }] }, rectangleAnnotation: { className: "highcharts-rectangle-annotation", start: function(t3) {
          var _a;
          let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), e2 = i3 && s2(i3.xAxis), n = i3 && s2(i3.yAxis);
          if (!e2 || !n) return;
          let a = e2.value, r = n.value, l = e2.axis.index, h = n.axis.index, c = this.chart.options.navigation;
          return this.chart.addAnnotation(o({ langKey: "rectangle", type: "basicAnnotation", shapes: [{ type: "path", points: [{ xAxis: l, yAxis: h, x: a, y: r }, { xAxis: l, yAxis: h, x: a, y: r }, { xAxis: l, yAxis: h, x: a, y: r }, { xAxis: l, yAxis: h, x: a, y: r }, { command: "Z" }] }] }, c.annotationsOptions, c.bindings.rectangleAnnotation.annotationsOptions));
        }, steps: [function(t3, i3) {
          var _a;
          let e2 = i3.options.shapes, o2 = e2 && e2[0] && e2[0].points || [], n = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), a = n && s2(n.xAxis), r = n && s2(n.yAxis);
          if (a && r) {
            let t4 = a.value, s3 = r.value;
            o2[1].x = t4, o2[2].x = t4, o2[2].y = s3, o2[3].y = s3, i3.update({ shapes: [{ points: o2 }] });
          }
        }] }, labelAnnotation: { className: "highcharts-label-annotation", start: function(t3) {
          var _a;
          let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), e2 = i3 && s2(i3.xAxis), n = i3 && s2(i3.yAxis), a = this.chart.options.navigation;
          if (e2 && n) return this.chart.addAnnotation(o({ langKey: "label", type: "basicAnnotation", labelOptions: { format: "{y:.2f}", overflow: "none", crop: true }, labels: [{ point: { xAxis: e2.axis.index, yAxis: n.axis.index, x: e2.value, y: n.value } }] }, a.annotationsOptions, a.bindings.labelAnnotation.annotationsOptions));
        } } }, events: {}, annotationsOptions: { animation: { defer: 0 } } } };
      }), s(i, "Extensions/Annotations/NavigationBindings.js", [i["Core/Chart/ChartNavigationComposition.js"], i["Core/Defaults.js"], i["Core/Templating.js"], i["Core/Globals.js"], i["Extensions/Annotations/NavigationBindingsDefaults.js"], i["Extensions/Annotations/NavigationBindingsUtilities.js"], i["Core/Utilities.js"]], function(t2, i2, s2, e, o, n, a) {
        let { setOptions: r } = i2, { format: l } = s2, { composed: h, doc: c, win: p } = e, { getAssignedAxis: d, getFieldType: u } = n, { addEvent: g, attr: m, defined: f, fireEvent: x, isArray: b, isFunction: v, isNumber: y, isObject: A, merge: C, objectEach: E, pick: P, pushUnique: k } = a;
        function w() {
          this.chart.navigationBindings && this.chart.navigationBindings.deselectAnnotation();
        }
        function j() {
          this.navigationBindings && this.navigationBindings.destroy();
        }
        function B() {
          let t3 = this.options;
          t3 && t3.navigation && t3.navigation.bindings && (this.navigationBindings = new D(this, t3.navigation), this.navigationBindings.initEvents(), this.navigationBindings.initUpdate());
        }
        function O() {
          let t3 = this.navigationBindings, i3 = "highcharts-disabled-btn";
          if (this && t3) {
            let s3 = false;
            if (this.series.forEach((t4) => {
              !t4.options.isInternal && t4.visible && (s3 = true);
            }), this.navigationBindings && this.navigationBindings.container && this.navigationBindings.container[0]) {
              let e2 = this.navigationBindings.container[0];
              E(t3.boundClassNames, (t4, o2) => {
                let n2 = e2.querySelectorAll("." + o2);
                if (n2) for (let e3 = 0; e3 < n2.length; e3++) {
                  let o3 = n2[e3], a2 = o3.className;
                  "normal" === t4.noDataState ? -1 !== a2.indexOf(i3) && o3.classList.remove(i3) : s3 ? -1 !== a2.indexOf(i3) && o3.classList.remove(i3) : -1 === a2.indexOf(i3) && (o3.className += " " + i3);
                }
              });
            }
          }
        }
        function M() {
          this.deselectAnnotation();
        }
        function N() {
          this.selectedButtonElement = null;
        }
        function T(t3) {
          let i3, s3;
          let e2 = t3.prototype.defaultOptions.events && t3.prototype.defaultOptions.events.click;
          function o2(t4) {
            let i4 = this, s4 = i4.chart.navigationBindings, o3 = s4.activeAnnotation;
            e2 && e2.call(i4, t4), o3 !== i4 ? (s4.deselectAnnotation(), s4.activeAnnotation = i4, i4.setControlPointsVisibility(true), x(s4, "showPopup", { annotation: i4, formType: "annotation-toolbar", options: s4.annotationToFields(i4), onSubmit: function(t5) {
              if ("remove" === t5.actionType) s4.activeAnnotation = false, s4.chart.removeAnnotation(i4);
              else {
                let e3 = {};
                s4.fieldsToOptions(t5.fields, e3), s4.deselectAnnotation();
                let o4 = e3.typeOptions;
                "measure" === i4.options.type && (o4.crosshairY.enabled = 0 !== o4.crosshairY.strokeWidth, o4.crosshairX.enabled = 0 !== o4.crosshairX.strokeWidth), i4.update(e3);
              }
            } })) : x(s4, "closePopup"), t4.activeAnnotation = true;
          }
          C(true, t3.prototype.defaultOptions.events, { click: o2, touchstart: function(t4) {
            i3 = t4.touches[0].clientX, s3 = t4.touches[0].clientY;
          }, touchend: function(t4) {
            i3 && Math.sqrt(Math.pow(i3 - t4.changedTouches[0].clientX, 2) + Math.pow(s3 - t4.changedTouches[0].clientY, 2)) >= 4 || o2.call(this, t4);
          } });
        }
        class D {
          static compose(t3, i3) {
            k(h, "NavigationBindings") && (g(t3, "remove", w), T(t3), E(t3.types, (t4) => {
              T(t4);
            }), g(i3, "destroy", j), g(i3, "load", B), g(i3, "render", O), g(D, "closePopup", M), g(D, "deselectButton", N), r(o));
          }
          constructor(t3, i3) {
            this.boundClassNames = void 0, this.chart = t3, this.options = i3, this.eventsToUnbind = [], this.container = this.chart.container.getElementsByClassName(this.options.bindingsClassName || ""), this.container.length || (this.container = c.getElementsByClassName(this.options.bindingsClassName || ""));
          }
          getCoords(t3) {
            var _a;
            let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3);
            return [i3 && d(i3.xAxis), i3 && d(i3.yAxis)];
          }
          initEvents() {
            let t3 = this, i3 = t3.chart, s3 = t3.container, o2 = t3.options;
            t3.boundClassNames = {}, E(o2.bindings || {}, (i4) => {
              t3.boundClassNames[i4.className] = i4;
            }), [].forEach.call(s3, (i4) => {
              t3.eventsToUnbind.push(g(i4, "click", (s4) => {
                let e2 = t3.getButtonEvents(i4, s4);
                e2 && !e2.button.classList.contains("highcharts-disabled-btn") && t3.bindingsButtonClick(e2.button, e2.events, s4);
              }));
            }), E(o2.events || {}, (i4, s4) => {
              v(i4) && t3.eventsToUnbind.push(g(t3, s4, i4, { passive: false }));
            }), t3.eventsToUnbind.push(g(i3.container, "click", function(s4) {
              !i3.cancelClick && i3.isInsidePlot(s4.chartX - i3.plotLeft, s4.chartY - i3.plotTop, { visiblePlotOnly: true }) && t3.bindingsChartClick(this, s4);
            })), t3.eventsToUnbind.push(g(i3.container, e.isTouchDevice ? "touchmove" : "mousemove", function(i4) {
              t3.bindingsContainerMouseMove(this, i4);
            }, e.isTouchDevice ? { passive: false } : void 0));
          }
          initUpdate() {
            let i3 = this;
            t2.compose(this.chart).navigation.addUpdate((t3) => {
              i3.update(t3);
            });
          }
          bindingsButtonClick(t3, i3, s3) {
            let e2 = this.chart, o2 = e2.renderer.boxWrapper, n2 = true;
            this.selectedButtonElement && (this.selectedButtonElement.classList === t3.classList && (n2 = false), x(this, "deselectButton", { button: this.selectedButtonElement }), this.nextEvent && (this.currentUserDetails && "annotations" === this.currentUserDetails.coll && e2.removeAnnotation(this.currentUserDetails), this.mouseMoveEvent = this.nextEvent = false)), n2 ? (this.selectedButton = i3, this.selectedButtonElement = t3, x(this, "selectButton", { button: t3 }), i3.init && i3.init.call(this, t3, s3), (i3.start || i3.steps) && e2.renderer.boxWrapper.addClass("highcharts-draw-mode")) : (e2.stockTools && t3.classList.remove("highcharts-active"), o2.removeClass("highcharts-draw-mode"), this.nextEvent = false, this.mouseMoveEvent = false, this.selectedButton = null);
          }
          bindingsChartClick(t3, i3) {
            t3 = this.chart;
            let s3 = this.activeAnnotation, e2 = this.selectedButton, o2 = t3.renderer.boxWrapper;
            s3 && (s3.cancelClick || i3.activeAnnotation || !i3.target.parentNode || function(t4, i4) {
              let s4 = p.Element.prototype, e3 = s4.matches || s4.msMatchesSelector || s4.webkitMatchesSelector, o3 = null;
              if (s4.closest) o3 = s4.closest.call(t4, i4);
              else do {
                if (e3.call(t4, i4)) return t4;
                t4 = t4.parentElement || t4.parentNode;
              } while (null !== t4 && 1 === t4.nodeType);
              return o3;
            }(i3.target, ".highcharts-popup") ? s3.cancelClick && setTimeout(() => {
              s3.cancelClick = false;
            }, 0) : x(this, "closePopup")), e2 && e2.start && (this.nextEvent ? (this.nextEvent(i3, this.currentUserDetails), this.steps && (this.stepIndex++, e2.steps[this.stepIndex] ? this.mouseMoveEvent = this.nextEvent = e2.steps[this.stepIndex] : (x(this, "deselectButton", { button: this.selectedButtonElement }), o2.removeClass("highcharts-draw-mode"), e2.end && e2.end.call(this, i3, this.currentUserDetails), this.nextEvent = false, this.mouseMoveEvent = false, this.selectedButton = null))) : (this.currentUserDetails = e2.start.call(this, i3), this.currentUserDetails && e2.steps ? (this.stepIndex = 0, this.steps = true, this.mouseMoveEvent = this.nextEvent = e2.steps[this.stepIndex]) : (x(this, "deselectButton", { button: this.selectedButtonElement }), o2.removeClass("highcharts-draw-mode"), this.steps = false, this.selectedButton = null, e2.end && e2.end.call(this, i3, this.currentUserDetails))));
          }
          bindingsContainerMouseMove(t3, i3) {
            this.mouseMoveEvent && this.mouseMoveEvent(i3, this.currentUserDetails);
          }
          fieldsToOptions(t3, i3) {
            return E(t3, (t4, s3) => {
              let e2 = parseFloat(t4), o2 = s3.split("."), n2 = o2.length - 1;
              if (!y(e2) || t4.match(/px|em/g) || s3.match(/format/g) || (t4 = e2), "undefined" !== t4) {
                let s4 = i3;
                o2.forEach((i4, e3) => {
                  if ("__proto__" !== i4 && "constructor" !== i4) {
                    let a2 = P(o2[e3 + 1], "");
                    n2 === e3 ? s4[i4] = t4 : (s4[i4] || (s4[i4] = a2.match(/\d/g) ? [] : {}), s4 = s4[i4]);
                  }
                });
              }
            }), i3;
          }
          deselectAnnotation() {
            this.activeAnnotation && (this.activeAnnotation.setControlPointsVisibility(false), this.activeAnnotation = false);
          }
          annotationToFields(t3) {
            let i3 = t3.options, s3 = D.annotationsEditable, e2 = s3.nestedOptions, o2 = P(i3.type, i3.shapes && i3.shapes[0] && i3.shapes[0].type, i3.labels && i3.labels[0] && i3.labels[0].type, "label"), n2 = D.annotationsNonEditable[i3.langKey] || [], a2 = { langKey: i3.langKey, type: o2 };
            function r2(i4, s4, o3, a3, h2) {
              let c2;
              o3 && f(i4) && -1 === n2.indexOf(s4) && ((o3.indexOf && o3.indexOf(s4)) >= 0 || o3[s4] || true === o3) && (b(i4) ? (a3[s4] = [], i4.forEach((t4, i5) => {
                A(t4) ? (a3[s4][i5] = {}, E(t4, (t5, o4) => {
                  r2(t5, o4, e2[s4], a3[s4][i5], s4);
                })) : r2(t4, 0, e2[s4], a3[s4], s4);
              })) : A(i4) ? (c2 = {}, b(a3) ? (a3.push(c2), c2[s4] = {}, c2 = c2[s4]) : a3[s4] = c2, E(i4, (t4, i5) => {
                r2(t4, i5, 0 === s4 ? o3 : e2[s4], c2, s4);
              })) : "format" === s4 ? a3[s4] = [l(i4, t3.labels[0].points[0]).toString(), "text"] : b(a3) ? a3.push([i4, u(h2, i4)]) : a3[s4] = [i4, u(s4, i4)]);
            }
            return E(i3, (t4, n3) => {
              "typeOptions" === n3 ? (a2[n3] = {}, E(i3[n3], (t5, i4) => {
                r2(t5, i4, e2, a2[n3], i4);
              })) : r2(t4, n3, s3[o2], a2, n3);
            }), a2;
          }
          getClickedClassNames(t3, i3) {
            let s3 = i3.target, e2 = [], o2;
            for (; s3 && s3.tagName && ((o2 = m(s3, "class")) && (e2 = e2.concat(o2.split(" ").map((t4) => [t4, s3]))), (s3 = s3.parentNode) !== t3); ) ;
            return e2;
          }
          getButtonEvents(t3, i3) {
            let s3;
            let e2 = this;
            return this.getClickedClassNames(t3, i3).forEach((t4) => {
              e2.boundClassNames[t4[0]] && !s3 && (s3 = { events: e2.boundClassNames[t4[0]], button: t4[1] });
            }), s3;
          }
          update(t3) {
            this.options = C(true, this.options, t3), this.removeEvents(), this.initEvents();
          }
          removeEvents() {
            this.eventsToUnbind.forEach((t3) => t3());
          }
          destroy() {
            this.removeEvents();
          }
        }
        return D.annotationsEditable = { nestedOptions: { labelOptions: ["style", "format", "backgroundColor"], labels: ["style"], label: ["style"], style: ["fontSize", "color"], background: ["fill", "strokeWidth", "stroke"], innerBackground: ["fill", "strokeWidth", "stroke"], outerBackground: ["fill", "strokeWidth", "stroke"], shapeOptions: ["fill", "strokeWidth", "stroke"], shapes: ["fill", "strokeWidth", "stroke"], line: ["strokeWidth", "stroke"], backgroundColors: [true], connector: ["fill", "strokeWidth", "stroke"], crosshairX: ["strokeWidth", "stroke"], crosshairY: ["strokeWidth", "stroke"] }, circle: ["shapes"], ellipse: ["shapes"], verticalLine: [], label: ["labelOptions"], measure: ["background", "crosshairY", "crosshairX"], fibonacci: [], tunnel: ["background", "line", "height"], pitchfork: ["innerBackground", "outerBackground"], rect: ["shapes"], crookedLine: [], basicAnnotation: ["shapes", "labelOptions"] }, D.annotationsNonEditable = { rectangle: ["crosshairX", "crosshairY", "labelOptions"], ellipse: ["labelOptions"], circle: ["labelOptions"] }, D;
      }), s(i, "masters/modules/annotations.src.js", [i["Core/Globals.js"], i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/NavigationBindings.js"]], function(t2, i2, s2) {
        return t2.Annotation = t2.Annotation || i2, t2.NavigationBindings = t2.NavigationBindings || s2, t2.Annotation.compose(t2.Chart, t2.NavigationBindings, t2.Pointer, t2.SVGRenderer), t2;
      });
    });
  }
});
export default require_annotations();
//# sourceMappingURL=highcharts_modules_annotations__js.js.map
