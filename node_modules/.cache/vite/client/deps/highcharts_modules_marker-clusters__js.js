import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/marker-clusters.js
var require_marker_clusters = __commonJS({
  "node_modules/highcharts/modules/marker-clusters.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Marker clusters module for Highcharts
    *
    * (c) 2010-2024 Wojciech Chmiel
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/marker-clusters", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, s, a) {
        e2.hasOwnProperty(i2) || (e2[i2] = a.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Extensions/MarkerClusters/MarkerClusterDefaults.js", [], function() {
        return { cluster: { enabled: false, allowOverlap: true, animation: { duration: 500 }, drillToCluster: true, minimumClusterSize: 2, layoutAlgorithm: { gridSize: 50, distance: 40, kmeansThreshold: 100 }, marker: { symbol: "cluster", radius: 15, lineWidth: 0, lineColor: "#ffffff" }, dataLabels: { enabled: true, format: "{point.clusterPointsAmount}", verticalAlign: "middle", align: "center", style: { color: "contrast" }, inside: true } }, tooltip: { clusterFormat: "<span>Clustered points: {point.clusterPointsAmount}</span><br/>" } };
      }), i(e, "Extensions/MarkerClusters/MarkerClusterScatter.js", [e["Core/Animation/AnimationUtilities.js"], e["Extensions/MarkerClusters/MarkerClusterDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let s;
        let { animObject: a } = t2, { cluster: r } = e2, { addEvent: o, defined: n, error: l, isArray: p, isFunction: u, isObject: d, isNumber: h, merge: c, objectEach: f, relativeLength: m, syncTimeout: g } = i2, x = { grid: function(t3, e3, i3, s2) {
          let a2, r2, o2, n2, l2;
          let p2 = {}, u2 = this.getGridOffset(), d2 = this.getScaledGridSize(s2);
          for (l2 = 0; l2 < t3.length; l2++) {
            let s3 = Z(this, { x: t3[l2], y: e3[l2] });
            a2 = s3.x - u2.plotLeft, r2 = s3.y - u2.plotTop, o2 = Math.floor(a2 / d2), p2[n2 = Math.floor(r2 / d2) + "-" + o2] || (p2[n2] = []), p2[n2].push({ dataIndex: i3[l2], x: t3[l2], y: e3[l2] });
          }
          return p2;
        }, kmeans: function(t3, e3, i3, s2) {
          let a2 = [], o2 = [], n2 = {}, l2 = s2.processedDistance || r.layoutAlgorithm.distance, p2 = s2.iterations, u2 = 0, d2 = true, h2 = 0, c2 = 0, f2, m2 = [];
          s2.processedGridSize = s2.processedDistance;
          let g2 = this.markerClusterAlgorithms ? this.markerClusterAlgorithms.grid.call(this, t3, e3, i3, s2) : {};
          for (let t4 in g2) g2[t4].length > 1 && (f2 = S(g2[t4]), a2.push({ posX: f2.x, posY: f2.y, oldX: 0, oldY: 0, startPointsLen: g2[t4].length, points: [] }));
          for (; d2; ) {
            for (let t4 of a2) t4.points.length = 0;
            o2.length = 0;
            for (let s3 = 0; s3 < t3.length; s3++) h2 = t3[s3], c2 = e3[s3], (m2 = this.getClusterDistancesFromPoint(a2, h2, c2)).length && m2[0].distance < l2 ? a2[m2[0].clusterIndex].points.push({ x: h2, y: c2, dataIndex: i3[s3] }) : o2.push({ x: h2, y: c2, dataIndex: i3[s3] });
            for (let t4 = 0; t4 < a2.length; t4++) 1 === a2[t4].points.length && (m2 = this.getClusterDistancesFromPoint(a2, a2[t4].points[0].x, a2[t4].points[0].y))[1].distance < l2 && (a2[m2[1].clusterIndex].points.push(a2[t4].points[0]), a2[m2[0].clusterIndex].points.length = 0);
            d2 = false;
            for (let t4 = 0; t4 < a2.length; t4++) f2 = S(a2[t4].points), a2[t4].oldX = a2[t4].posX, a2[t4].oldY = a2[t4].posY, a2[t4].posX = f2.x, a2[t4].posY = f2.y, (a2[t4].posX > a2[t4].oldX + 1 || a2[t4].posX < a2[t4].oldX - 1 || a2[t4].posY > a2[t4].oldY + 1 || a2[t4].posY < a2[t4].oldY - 1) && (d2 = true);
            p2 && (d2 = u2 < p2 - 1), u2++;
          }
          for (let t4 = 0, e4 = a2.length; t4 < e4; ++t4) n2["cluster" + t4] = a2[t4].points;
          for (let t4 = 0, e4 = o2.length; t4 < e4; ++t4) n2["noise" + t4] = [o2[t4]];
          return n2;
        }, optimizedKmeans: function(t3, e3, i3, s2) {
          let a2 = s2.processedDistance || r.layoutAlgorithm.gridSize, o2 = this.getRealExtremes(), l2 = (this.options.cluster || {}).marker, p2, u2 = {}, d2, h2;
          if (!this.markerClusterInfo || this.initMaxX && this.initMaxX < o2.maxX || this.initMinX && this.initMinX > o2.minX || this.initMaxY && this.initMaxY < o2.maxY || this.initMinY && this.initMinY > o2.minY) this.initMaxX = o2.maxX, this.initMinX = o2.minX, this.initMaxY = o2.maxY, this.initMinY = o2.minY, u2 = this.markerClusterAlgorithms ? this.markerClusterAlgorithms.kmeans.call(this, t3, e3, i3, s2) : {}, this.baseClusters = null;
          else {
            for (let t4 of (this.baseClusters || (this.baseClusters = { clusters: this.markerClusterInfo.clusters, noise: this.markerClusterInfo.noise }), this.baseClusters.clusters)) {
              for (let e5 of (t4.pointsOutside = [], t4.pointsInside = [], t4.data)) {
                let i4 = Z(this, e5), s3 = Z(this, t4);
                p2 = Math.sqrt(Math.pow(i4.x - s3.x, 2) + Math.pow(i4.y - s3.y, 2)), d2 = a2 - (h2 = t4.clusterZone && t4.clusterZone.marker && t4.clusterZone.marker.radius ? t4.clusterZone.marker.radius : l2 && l2.radius ? l2.radius : r.marker.radius) >= 0 ? a2 - h2 : h2, p2 > h2 + d2 && n(t4.pointsOutside) ? t4.pointsOutside.push(e5) : n(t4.pointsInside) && t4.pointsInside.push(e5);
              }
              t4.pointsInside.length && (u2[t4.id] = t4.pointsInside);
              let e4 = 0;
              for (let i4 of t4.pointsOutside) u2[t4.id + "_noise" + e4++] = [i4];
            }
            for (let t4 of this.baseClusters.noise) u2[t4.id] = t4.data;
          }
          return u2;
        } }, y = [], C = 0;
        function k(t3, e3, i3) {
          t3.attr({ opacity: e3 }).animate({ opacity: 1 }, i3);
        }
        function M(t3, e3, i3, s2) {
          for (let a2 of (I(t3, s2, i3, true, true), e3)) a2.point && a2.point.destroy && a2.point.destroy();
        }
        function I(t3, e3, i3, s2, a2) {
          t3.point && (s2 && t3.point.graphic && (t3.point.graphic.show(), k(t3.point.graphic, e3, i3)), a2 && t3.point.dataLabel && (t3.point.dataLabel.show(), k(t3.point.dataLabel, e3, i3)));
        }
        function S(t3) {
          let e3 = t3.length, i3 = 0, s2 = 0;
          for (let a2 = 0; a2 < e3; a2++) i3 += t3[a2].x, s2 += t3[a2].y;
          return { x: i3 / e3, y: s2 / e3 };
        }
        function b(t3, e3) {
          let i3 = [];
          return i3.length = e3, t3.clusters.forEach(function(t4) {
            t4.data.forEach(function(t5) {
              i3[t5.dataIndex] = t5;
            });
          }), t3.noise.forEach(function(t4) {
            i3[t4.data[0].dataIndex] = t4.data[0];
          }), i3;
        }
        function A() {
          return Math.random().toString(36).substring(2, 7) + "-" + C++;
        }
        function X(t3, e3, i3) {
          t3.point && (e3 && t3.point.graphic && t3.point.graphic.hide(), i3 && t3.point.dataLabel && t3.point.dataLabel.hide());
        }
        function Y(t3) {
          (t3.point || t3.target).firePointEvent("drillToCluster", t3, function(t4) {
            let e3 = t4.point || t4.target, i3 = e3.series, s2 = e3.series.xAxis, a2 = e3.series.yAxis, r2 = e3.series.chart, { inverted: o2, mapView: n2, pointer: l2 } = r2;
            if ((i3.options.cluster || {}).drillToCluster && e3.clusteredData) {
              let t5 = e3.clusteredData.map((t6) => t6.x).sort((t6, e4) => t6 - e4), i4 = e3.clusteredData.map((t6) => t6.y).sort((t6, e4) => t6 - e4), p2 = t5[0], u2 = t5[t5.length - 1], d2 = i4[0], h2 = i4[i4.length - 1], c2 = Math.abs((u2 - p2) * 0.1), f2 = Math.abs((h2 - d2) * 0.1), m2 = Math.min(p2, u2) - c2, g2 = Math.max(p2, u2) + c2, x2 = Math.min(d2, h2) - f2, y2 = Math.max(d2, h2) + f2;
              if (n2) n2.fitToBounds({ x1: m2, x2: g2, y1: x2, y2 });
              else if (s2 && a2) {
                let t6 = s2.toPixels(m2), e4 = s2.toPixels(g2), i5 = a2.toPixels(x2), n3 = a2.toPixels(y2);
                o2 && ([t6, e4, i5, n3] = [i5, n3, t6, e4]), t6 > e4 && ([t6, e4] = [e4, t6]), i5 > n3 && ([i5, n3] = [n3, i5]), l2 && (l2.zoomX = true, l2.zoomY = true), r2.transform({ from: { x: t6, y: i5, width: e4 - t6, height: n3 - i5 } });
              }
            }
          });
        }
        function D(t3, e3) {
          let { chart: i3, xAxis: s2, yAxis: a2 } = t3;
          return i3.mapView ? i3.mapView.pixelsToProjectedUnits(e3) : { x: s2 ? s2.toValue(e3.x) : 0, y: a2 ? a2.toValue(e3.y) : 0 };
        }
        function L(t3) {
          let e3 = this.chart, i3 = e3.mapView, s2 = a((this.options.cluster || {}).animation), r2 = s2.duration || 500, o2 = (this.markerClusterInfo || {}).pointsState, n2 = (o2 || {}).newState, l2 = (o2 || {}).oldState, p2 = [], u2, d2, h2, c2 = 0, f2 = 0, m2 = 0, x2 = false, y2 = false;
          if (l2 && n2) {
            let a2 = Z(this, d2 = n2[t3.stateId]);
            f2 = a2.x - (i3 ? 0 : e3.plotLeft), m2 = a2.y - (i3 ? 0 : e3.plotTop), 1 === d2.parentsId.length ? (u2 = l2[(n2 || {})[t3.stateId].parentsId[0]], d2.point && d2.point.graphic && u2 && u2.point && u2.point.plotX && u2.point.plotY && u2.point.plotX !== d2.point.plotX && u2.point.plotY !== d2.point.plotY && (h2 = d2.point.graphic.getBBox(), c2 = d2.point.graphic && d2.point.graphic.isImg ? 0 : h2.width / 2, d2.point.graphic.attr({ x: u2.point.plotX - c2, y: u2.point.plotY - c2 }), d2.point.graphic.animate({ x: f2 - (d2.point.graphic.radius || 0), y: m2 - (d2.point.graphic.radius || 0) }, s2, function() {
              y2 = true, u2.point && u2.point.destroy && u2.point.destroy();
            }), d2.point.dataLabel && d2.point.dataLabel.alignAttr && u2.point.dataLabel && u2.point.dataLabel.alignAttr && (d2.point.dataLabel.attr({ x: u2.point.dataLabel.alignAttr.x, y: u2.point.dataLabel.alignAttr.y }), d2.point.dataLabel.animate({ x: d2.point.dataLabel.alignAttr.x, y: d2.point.dataLabel.alignAttr.y }, s2)))) : 0 === d2.parentsId.length ? (X(d2, true, true), g(function() {
              I(d2, 0.1, s2, true, true);
            }, r2 / 2)) : (X(d2, true, true), d2.parentsId.forEach(function(t4) {
              l2 && l2[t4] && (u2 = l2[t4], p2.push(u2), u2.point && u2.point.graphic && (x2 = true, u2.point.graphic.show(), u2.point.graphic.animate({ x: f2 - (u2.point.graphic.radius || 0), y: m2 - (u2.point.graphic.radius || 0), opacity: 0.4 }, s2, function() {
                y2 = true, M(d2, p2, s2, 0.7);
              }), u2.point.dataLabel && -9999 !== u2.point.dataLabel.y && d2.point && d2.point.dataLabel && d2.point.dataLabel.alignAttr && (u2.point.dataLabel.show(), u2.point.dataLabel.animate({ x: d2.point.dataLabel.alignAttr.x, y: d2.point.dataLabel.alignAttr.y, opacity: 0.4 }, s2))));
            }), g(function() {
              y2 || M(d2, p2, s2, 0.85);
            }, r2), x2 || g(function() {
              M(d2, p2, s2, 0.1);
            }, r2 / 2));
          }
        }
        function P() {
          (this.markerClusterSeriesData || []).forEach(function(t3) {
            t3 && t3.destroy && t3.destroy();
          }), this.markerClusterSeriesData = null;
        }
        function z() {
          let t3, e3, i3, a2, l2, p2, d2, c2, f2, g2, x2, y2, C2, k2, M2, I2;
          let S2 = this, b2 = S2.chart, A2 = b2.mapView, X2 = S2.xData, L2 = S2.yData, P2 = S2.options.cluster, z2 = S2.getRealExtremes(), w2 = [], E2 = [], j2 = [];
          if (A2 && S2.is("mappoint") && X2 && L2 && (S2.options.data || []).forEach((t4, e4) => {
            let i4 = S2.projectPoint(t4);
            i4 && (X2[e4] = i4.x, L2[e4] = i4.y);
          }), P2 && P2.enabled && X2 && X2.length && L2 && L2.length && !b2.polar) {
            x2 = P2.layoutAlgorithm.type, (k2 = P2.layoutAlgorithm).processedGridSize = m(k2.gridSize || r.layoutAlgorithm.gridSize, b2.plotWidth), k2.processedDistance = m(k2.distance || r.layoutAlgorithm.distance, b2.plotWidth), a2 = k2.kmeansThreshold || r.layoutAlgorithm.kmeansThreshold;
            let A3 = k2.processedGridSize / 2, O2 = D(S2, { x: 0, y: 0 }), T2 = D(S2, { x: A3, y: A3 });
            for (I2 = 0, l2 = Math.abs(O2.x - T2.x), p2 = Math.abs(O2.y - T2.y); I2 < X2.length; I2++) !S2.dataMaxX && (n(c2) && n(d2) && n(g2) && n(f2) ? h(L2[I2]) && h(g2) && h(f2) && (c2 = Math.max(X2[I2], c2), d2 = Math.min(X2[I2], d2), g2 = Math.max(L2[I2] || g2, g2), f2 = Math.min(L2[I2] || f2, f2)) : (c2 = d2 = X2[I2], g2 = f2 = L2[I2])), X2[I2] >= z2.minX - l2 && X2[I2] <= z2.maxX + l2 && (L2[I2] || z2.minY) >= z2.minY - p2 && (L2[I2] || z2.maxY) <= z2.maxY + p2 && (w2.push(X2[I2]), E2.push(L2[I2]), j2.push(I2));
            n(c2) && n(d2) && h(g2) && h(f2) && (S2.dataMaxX = c2, S2.dataMinX = d2, S2.dataMaxY = g2, S2.dataMinY = f2), y2 = (C2 = (u(x2) ? x2 : S2.markerClusterAlgorithms ? x2 && S2.markerClusterAlgorithms[x2] ? S2.markerClusterAlgorithms[x2] : w2.length < a2 ? S2.markerClusterAlgorithms.kmeans : S2.markerClusterAlgorithms.grid : function() {
              return false;
            }).call(this, w2, E2, j2, k2)) ? S2.getClusteredData(C2, P2) : C2, P2.animation && S2.markerClusterInfo && S2.markerClusterInfo.pointsState && S2.markerClusterInfo.pointsState.oldState ? (function(t4) {
              if (t4) {
                let e4;
                for (let i4 of Object.keys(t4)) (e4 = t4[i4]).point && e4.point.destroy && e4.point.destroy();
              }
            }(S2.markerClusterInfo.pointsState.oldState), t3 = S2.markerClusterInfo.pointsState.newState) : t3 = {}, e3 = X2.length, i3 = S2.markerClusterInfo, y2 && (S2.processedXData = y2.groupedXData, S2.processedYData = y2.groupedYData, S2.hasGroupedData = true, S2.markerClusterInfo = y2, S2.groupMap = y2.groupMap), s.apply(this), y2 && S2.markerClusterInfo && ((S2.markerClusterInfo.clusters || []).forEach(function(t4) {
              (M2 = S2.points[t4.index]).isCluster = true, M2.clusteredData = t4.data, M2.clusterPointsAmount = t4.data.length, t4.point = M2, o(M2, "click", Y);
            }), (S2.markerClusterInfo.noise || []).forEach(function(t4) {
              t4.point = S2.points[t4.index];
            }), P2.animation && S2.markerClusterInfo && (S2.markerClusterInfo.pointsState = { oldState: t3, newState: S2.getPointsState(y2, i3, e3) }), P2.animation ? this.hideClusteredData() : this.destroyClusteredData(), this.markerClusterSeriesData = this.hasGroupedData ? this.points : null);
          } else s.apply(this);
        }
        function w(t3, e3, i3) {
          let s2 = [];
          for (let a2 = 0; a2 < t3.length; a2++) {
            let r2 = Z(this, { x: e3, y: i3 }), o2 = Z(this, { x: t3[a2].posX, y: t3[a2].posY }), n2 = Math.sqrt(Math.pow(r2.x - o2.x, 2) + Math.pow(r2.y - o2.y, 2));
            s2.push({ clusterIndex: a2, distance: n2 });
          }
          return s2.sort((t4, e4) => t4.distance - e4.distance);
        }
        function E(t3, e3) {
          let i3 = [], s2 = [], a2 = [], o2 = [], n2 = [], h2 = Math.max(2, e3.minimumClusterSize || 2), f2 = 0, m2, g2, x2, y2, C2, k2, M2, I2, b2, X2, Y2, D2, L2, P2;
          if (u(e3.layoutAlgorithm.type) && !this.isValidGroupedDataObject(t3)) return l("Highcharts marker-clusters module: The custom algorithm result is not valid!", false, this.chart), false;
          for (P2 in t3) if (t3[P2].length >= h2) {
            if (x2 = t3[P2], m2 = A(), C2 = x2.length, e3.zones) for (L2 = 0; L2 < e3.zones.length; L2++) C2 >= e3.zones[L2].from && C2 <= e3.zones[L2].to && ((Y2 = e3.zones[L2]).zoneIndex = L2, X2 = e3.zones[L2].marker, D2 = e3.zones[L2].className);
            for (b2 = S(x2), "grid" !== e3.layoutAlgorithm.type || e3.allowOverlap ? M2 = { x: b2.x, y: b2.y } : (k2 = this.options.marker || {}, M2 = this.preventClusterCollisions({ x: b2.x, y: b2.y, key: P2, groupedData: t3, gridSize: this.getScaledGridSize(e3.layoutAlgorithm), defaultRadius: k2.radius || 3 + (k2.lineWidth || 0), clusterRadius: X2 && X2.radius ? X2.radius : (e3.marker || {}).radius || r.marker.radius })), L2 = 0; L2 < C2; L2++) x2[L2].parentStateId = m2;
            if (a2.push({ x: M2.x, y: M2.y, id: P2, stateId: m2, index: f2, data: x2, clusterZone: Y2, clusterZoneClassName: D2 }), i3.push(M2.x), s2.push(M2.y), n2.push({ options: { formatPrefix: "cluster", dataLabels: e3.dataLabels, marker: c(e3.marker, { states: e3.states }, X2 || {}) } }), this.options.data && this.options.data.length) for (L2 = 0; L2 < C2; L2++) d(this.options.data[x2[L2].dataIndex]) && (x2[L2].options = this.options.data[x2[L2].dataIndex]);
            f2++, X2 = null;
          } else for (L2 = 0; L2 < t3[P2].length; L2++) g2 = t3[P2][L2], m2 = A(), I2 = null, y2 = ((this.options || {}).data || [])[g2.dataIndex], i3.push(g2.x), s2.push(g2.y), g2.parentStateId = m2, o2.push({ x: g2.x, y: g2.y, id: P2, stateId: m2, index: f2, data: t3[P2] }), I2 = y2 && "object" == typeof y2 && !p(y2) ? c(y2, { x: g2.x, y: g2.y }) : { userOptions: y2, x: g2.x, y: g2.y }, n2.push({ options: I2 }), f2++;
          return { clusters: a2, noise: o2, groupedXData: i3, groupedYData: s2, groupMap: n2 };
        }
        function j() {
          let t3 = this.chart, e3 = this.xAxis, i3 = this.yAxis, s2 = 0;
          return { plotLeft: e3 && this.dataMinX && this.dataMaxX ? e3.reversed ? e3.toPixels(this.dataMaxX) : e3.toPixels(this.dataMinX) : t3.plotLeft, plotTop: i3 && this.dataMinY && this.dataMaxY ? i3.reversed ? i3.toPixels(this.dataMinY) : i3.toPixels(this.dataMaxY) : t3.plotTop };
        }
        function O(t3, e3, i3) {
          let s2, a2;
          let r2 = e3 ? b(e3, i3) : [], o2 = b(t3, i3), n2 = {};
          y = [], t3.clusters.forEach(function(t4) {
            n2[t4.stateId] = { x: t4.x, y: t4.y, id: t4.stateId, point: t4.point, parentsId: [] };
          }), t3.noise.forEach(function(t4) {
            n2[t4.stateId] = { x: t4.x, y: t4.y, id: t4.stateId, point: t4.point, parentsId: [] };
          });
          for (let t4 = 0; t4 < o2.length; t4++) s2 = o2[t4], a2 = r2[t4], s2 && a2 && s2.parentStateId && a2.parentStateId && n2[s2.parentStateId] && -1 === n2[s2.parentStateId].parentsId.indexOf(a2.parentStateId) && (n2[s2.parentStateId].parentsId.push(a2.parentStateId), -1 === y.indexOf(a2.parentStateId) && y.push(a2.parentStateId));
          return n2;
        }
        function T() {
          let t3 = this.chart, e3 = t3.mapView ? 0 : t3.plotLeft, i3 = D(this, { x: e3, y: t3.mapView ? 0 : t3.plotTop }), s2 = D(this, { x: e3 + t3.plotWidth, y: e3 + t3.plotHeight }), a2 = i3.x, r2 = s2.x, o2 = i3.y, n2 = s2.y;
          return { minX: Math.min(a2, r2), maxX: Math.max(a2, r2), minY: Math.min(o2, n2), maxY: Math.max(o2, n2) };
        }
        function V(t3) {
          let e3 = this.xAxis, i3 = this.chart.mapView, s2 = t3.processedGridSize || r.layoutAlgorithm.gridSize, a2 = true, o2 = 1, n2 = 1;
          this.gridValueSize || (i3 ? this.gridValueSize = s2 / i3.getScale() : this.gridValueSize = Math.abs(e3.toValue(s2) - e3.toValue(0)));
          let l2 = +(s2 / (i3 ? this.gridValueSize * i3.getScale() : e3.toPixels(this.gridValueSize) - e3.toPixels(0))).toFixed(14);
          for (; a2 && 1 !== l2; ) {
            let t4 = Math.pow(2, o2);
            l2 > 0.75 && l2 < 1.25 ? a2 = false : l2 >= 1 / t4 && l2 < 1 / t4 * 2 ? (a2 = false, n2 = t4) : l2 <= t4 && l2 > t4 / 2 && (a2 = false, n2 = 1 / t4), o2++;
          }
          return s2 / n2 / l2;
        }
        function G() {
          let t3 = this.markerClusterSeriesData, e3 = ((this.markerClusterInfo || {}).pointsState || {}).oldState || {}, i3 = y.map((t4) => (e3[t4].point || {}).id || "");
          (t3 || []).forEach(function(t4) {
            t4 && -1 !== i3.indexOf(t4.id) ? (t4.graphic && t4.graphic.hide(), t4.dataLabel && t4.dataLabel.hide()) : t4 && t4.destroy && t4.destroy();
          });
        }
        function v(t3) {
          let e3 = false, i3;
          return !!d(t3) && (f(t3, function(t4) {
            if (e3 = true, !p(t4) || !t4.length) {
              e3 = false;
              return;
            }
            for (i3 = 0; i3 < t4.length; i3++) if (!d(t4[i3]) || !t4[i3].x || !t4[i3].y) {
              e3 = false;
              return;
            }
          }), e3);
        }
        function R(t3) {
          let [e3, i3] = t3.key.split("-").map(parseFloat), s2 = t3.gridSize, a2 = t3.groupedData, o2 = t3.defaultRadius, l2 = t3.clusterRadius, p2 = i3 * s2, u2 = e3 * s2, d2 = Z(this, t3), h2 = [], c2 = (this.options.cluster || {}).marker, f2 = (this.options.cluster || {}).zones, m2 = this.getGridOffset(), g2 = d2.x, x2 = d2.y, y2 = 0, C2 = 0, k2, M2, I2, b2, A2, X2, Y2, L2, P2, z2, w2, E2, j2;
          for (g2 -= m2.plotLeft, x2 -= m2.plotTop, Y2 = 1; Y2 < 5; Y2++) for (L2 = 0, I2 = Y2 % 2 ? -1 : 1, b2 = Y2 < 3 ? -1 : 1, A2 = Math.floor((g2 + I2 * l2) / s2), j2 = [(X2 = Math.floor((x2 + b2 * l2) / s2)) + "-" + A2, X2 + "-" + i3, e3 + "-" + A2]; L2 < j2.length; L2++) -1 === h2.indexOf(j2[L2]) && j2[L2] !== t3.key && h2.push(j2[L2]);
          for (let t4 of h2) if (a2[t4]) {
            a2[t4].posX || (w2 = S(a2[t4]), a2[t4].posX = w2.x, a2[t4].posY = w2.y);
            let d3 = Z(this, { x: a2[t4].posX || 0, y: a2[t4].posY || 0 });
            if (k2 = d3.x - m2.plotLeft, M2 = d3.y - m2.plotTop, [z2, P2] = t4.split("-").map(parseFloat), f2) for (Y2 = 0, y2 = a2[t4].length; Y2 < f2.length; Y2++) y2 >= f2[Y2].from && y2 <= f2[Y2].to && (C2 = n((f2[Y2].marker || {}).radius) ? f2[Y2].marker.radius || 0 : c2 && c2.radius ? c2.radius : r.marker.radius);
            a2[t4].length > 1 && 0 === C2 && c2 && c2.radius ? C2 = c2.radius : 1 === a2[t4].length && (C2 = o2), E2 = l2 + C2, C2 = 0, P2 !== i3 && Math.abs(g2 - k2) < E2 && (g2 = P2 - i3 < 0 ? p2 + l2 : p2 + s2 - l2), z2 !== e3 && Math.abs(x2 - M2) < E2 && (x2 = z2 - e3 < 0 ? u2 + l2 : u2 + s2 - l2);
          }
          let O2 = D(this, { x: g2 + m2.plotLeft, y: x2 + m2.plotTop });
          return a2[t3.key].posX = O2.x, a2[t3.key].posY = O2.y, O2;
        }
        function Z(t3, e3) {
          let { chart: i3, xAxis: s2, yAxis: a2 } = t3;
          return i3.mapView ? i3.mapView.projectedUnitsToPixels(e3) : { x: s2 ? s2.toPixels(e3.x) : 0, y: a2 ? a2.toPixels(e3.y) : 0 };
        }
        return { compose: function(t3, i3) {
          let a2 = i3.prototype;
          a2.markerClusterAlgorithms || (s = a2.generatePoints, a2.markerClusterAlgorithms = x, a2.animateClusterPoint = L, a2.destroyClusteredData = P, a2.generatePoints = z, a2.getClusterDistancesFromPoint = w, a2.getClusteredData = E, a2.getGridOffset = j, a2.getPointsState = O, a2.getRealExtremes = T, a2.getScaledGridSize = V, a2.hideClusteredData = G, a2.isValidGroupedDataObject = v, a2.preventClusterCollisions = R, o(i3, "destroy", a2.destroyClusteredData), (t3.plotOptions || {}).series = c((t3.plotOptions || {}).series, e2));
        } };
      }), i(e, "Extensions/MarkerClusters/MarkerClusters.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Extensions/MarkerClusters/MarkerClusterDefaults.js"], e["Extensions/MarkerClusters/MarkerClusterScatter.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, a, r) {
        let { animObject: o } = t2, { defaultOptions: n } = e2, { composed: l } = i2, { addEvent: p, defined: u, error: d, isFunction: h, merge: c, pushUnique: f, syncTimeout: m } = r;
        function g() {
          let t3 = this.chart, e3 = 0;
          for (let i3 of t3.series) i3.markerClusterInfo && (e3 = o((i3.options.cluster || {}).animation).duration || 0);
          m(() => {
            t3.tooltip && t3.tooltip.destroy();
          }, e3);
        }
        function x() {
          var _a;
          for (let t3 of this.series || []) if (t3.markerClusterInfo) {
            let e3 = t3.options.cluster, i3 = ((t3.markerClusterInfo || {}).pointsState || {}).oldState;
            if ((e3 || {}).animation && t3.markerClusterInfo && 0 === (((_a = t3.chart.pointer) == null ? void 0 : _a.pinchDown) || []).length && "pan" !== ((t3.xAxis || {}).eventArgs || {}).trigger && i3 && Object.keys(i3).length) {
              for (let e4 of t3.markerClusterInfo.clusters) t3.animateClusterPoint(e4);
              for (let e4 of t3.markerClusterInfo.noise) t3.animateClusterPoint(e4);
            }
          }
        }
        function y(t3) {
          let e3 = (((t3.point || t3.target).series.options.cluster || {}).events || {}).drillToCluster;
          h(e3) && e3.call(this, t3);
        }
        function C() {
          if (this.dataGroup) return d("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.", false, this.series.chart), false;
        }
        function k() {
          let t3 = (this.options.cluster || {}).drillToCluster;
          if (this.markerClusterInfo && this.markerClusterInfo.clusters) for (let e3 of this.markerClusterInfo.clusters) e3.point && e3.point.graphic && (e3.point.graphic.addClass("highcharts-cluster-point"), t3 && e3.point && (e3.point.graphic.css({ cursor: "pointer" }), e3.point.dataLabel && e3.point.dataLabel.css({ cursor: "pointer" })), u(e3.clusterZone) && e3.point.graphic.addClass(e3.clusterZoneClassName || "highcharts-cluster-zone-" + e3.clusterZone.zoneIndex));
        }
        return (n.plotOptions || {}).series = c((n.plotOptions || {}).series, s), { compose: function(t3, e3, i3, s2) {
          if (f(l, "MarkerClusters")) {
            let r2 = s2.prototype.pointClass, { scatter: o2 } = s2.types;
            p(t3, "setExtremes", g), p(e3, "render", x), p(r2, "drillToCluster", y), p(r2, "update", C), p(s2, "afterRender", k), o2 && a.compose(i3, o2);
          }
        } };
      }), i(e, "Extensions/MarkerClusters/MarkerClusterSymbols.js", [], function() {
        let t2;
        function e2(e3, i2, s, a) {
          let r = s / 2, o = a / 2, n = t2.arc(e3 + r, i2 + o, r - 4, o - 4, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: false }), l = t2.arc(e3 + r, i2 + o, r - 3, o - 3, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, innerR: r - 2, open: false });
          return t2.arc(e3 + r, i2 + o, r - 1, o - 1, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, innerR: r, open: false }).concat(l, n);
        }
        return { compose: function(i2) {
          (t2 = i2.prototype.symbols).cluster = e2;
        } };
      }), i(e, "masters/modules/marker-clusters.src.js", [e["Core/Globals.js"], e["Extensions/MarkerClusters/MarkerClusters.js"], e["Extensions/MarkerClusters/MarkerClusterSymbols.js"]], function(t2, e2, i2) {
        return e2.compose(t2.Axis, t2.Chart, t2.defaultOptions, t2.Series), i2.compose(t2.SVGRenderer), t2;
      });
    });
  }
});
export default require_marker_clusters();
//# sourceMappingURL=highcharts_modules_marker-clusters__js.js.map
