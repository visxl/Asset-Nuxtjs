import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/solid-gauge.js
var require_solid_gauge = __commonJS({
  "node_modules/highcharts/modules/solid-gauge.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Solid angular gauge module
    *
    * (c) 2010-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/solid-gauge", ["highcharts", "highcharts/highcharts-more"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function o(e2, o2, s, i) {
        e2.hasOwnProperty(o2) || (e2[o2] = i.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: o2, module: e2[o2] } })));
      }
      o(e, "Core/Axis/Color/ColorAxisLike.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var o2, s;
        let { parse: i } = t2, { merge: r } = e2;
        return (s = o2 || (o2 = {})).initDataClasses = function(t3) {
          let e3 = this.chart, o3 = this.legendItem = this.legendItem || {}, s2 = this.options, a = t3.dataClasses || [], l, n, d = e3.options.chart.colorCount, h = 0, u;
          this.dataClasses = n = [], o3.labels = [];
          for (let t4 = 0, o4 = a.length; t4 < o4; ++t4) l = r(l = a[t4]), n.push(l), (e3.styledMode || !l.color) && ("category" === s2.dataClassColor ? (e3.styledMode || (d = (u = e3.options.colors || []).length, l.color = u[h]), l.colorIndex = h, ++h === d && (h = 0)) : l.color = i(s2.minColor).tweenTo(i(s2.maxColor), o4 < 2 ? 0.5 : t4 / (o4 - 1)));
        }, s.initStops = function() {
          let t3 = this.options, e3 = this.stops = t3.stops || [[0, t3.minColor || ""], [1, t3.maxColor || ""]];
          for (let t4 = 0, o3 = e3.length; t4 < o3; ++t4) e3[t4].color = i(e3[t4][1]);
        }, s.normalizedValue = function(t3) {
          let e3 = this.max || 0, o3 = this.min || 0;
          return this.logarithmic && (t3 = this.logarithmic.log2lin(t3)), 1 - (e3 - t3) / (e3 - o3 || 1);
        }, s.toColor = function(t3, e3) {
          let o3, s2, i2, r2, a, l;
          let n = this.dataClasses, d = this.stops;
          if (n) {
            for (l = n.length; l--; ) if (s2 = (a = n[l]).from, i2 = a.to, (void 0 === s2 || t3 >= s2) && (void 0 === i2 || t3 <= i2)) {
              r2 = a.color, e3 && (e3.dataClass = l, e3.colorIndex = a.colorIndex);
              break;
            }
          } else {
            for (o3 = this.normalizedValue(t3), l = d.length; l-- && !(o3 > d[l][0]); ) ;
            s2 = d[l] || d[l + 1], o3 = 1 - ((i2 = d[l + 1] || s2)[0] - o3) / (i2[0] - s2[0] || 1), r2 = s2.color.tweenTo(i2.color, o3);
          }
          return r2;
        }, o2;
      }), o(e, "Core/Axis/SolidGaugeAxis.js", [e["Core/Axis/Color/ColorAxisLike.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { extend: o2 } = e2;
        return { init: function(e3) {
          o2(e3, t2);
        } };
      }), o(e, "Series/SolidGauge/SolidGaugeSeriesDefaults.js", [], function() {
        return { colorByPoint: true, dataLabels: { y: 0 } };
      }), o(e, "Series/SolidGauge/SolidGaugeSeries.js", [e["Extensions/BorderRadius.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Axis/SolidGaugeAxis.js"], e["Series/SolidGauge/SolidGaugeSeriesDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, o2, s, i) {
        let { gauge: r, pie: a } = e2.seriesTypes, { clamp: l, extend: n, isNumber: d, merge: h, pick: u, pInt: c } = i;
        class g extends r {
          translate() {
            let t3 = this.yAxis;
            o2.init(t3), !t3.dataClasses && t3.options.dataClasses && t3.initDataClasses(t3.options), t3.initStops(), r.prototype.translate.call(this);
          }
          drawPoints() {
            let e3;
            let o3 = this.yAxis, s2 = o3.center, i2 = this.options, r2 = this.chart.renderer, a2 = i2.overshoot, h2 = i2.rounded && void 0 === i2.borderRadius, g2 = d(a2) ? a2 / 180 * Math.PI : 0;
            for (let a3 of (d(i2.threshold) && (e3 = o3.startAngleRad + o3.translate(i2.threshold, void 0, void 0, void 0, true)), this.thresholdAngleRad = u(e3, o3.startAngleRad), this.points)) if (!a3.isNull) {
              let e4 = c(u(a3.options.radius, i2.radius, 100)) * s2[2] / 200, d2 = c(u(a3.options.innerRadius, i2.innerRadius, 60)) * s2[2] / 200, p = Math.min(o3.startAngleRad, o3.endAngleRad), f = Math.max(o3.startAngleRad, o3.endAngleRad), C = a3.graphic, m = o3.startAngleRad + o3.translate(a3.y, void 0, void 0, void 0, true), x, A, y = o3.toColor(a3.y, a3);
              "none" === y && (y = a3.color || this.color || "none"), "none" !== y && (a3.color = y), m = l(m, p - g2, f + g2), false === i2.wrap && (m = l(m, p, f));
              let R = h2 ? (e4 - d2) / 2 / e4 : 0, S = Math.min(m, this.thresholdAngleRad) - R, j = Math.max(m, this.thresholdAngleRad) + R;
              j - S > 2 * Math.PI && (j = S + 2 * Math.PI);
              let v = h2 ? "50%" : 0;
              i2.borderRadius && (v = t2.optionsToObject(i2.borderRadius).radius), a3.shapeArgs = x = { x: s2[0], y: s2[1], r: e4, innerR: d2, start: S, end: j, borderRadius: v }, a3.startR = e4, C ? (A = x.d, C.animate(n({ fill: y }, x)), A && (x.d = A)) : a3.graphic = C = r2.arc(x).attr({ fill: y, "sweep-flag": 0 }).add(this.group), this.chart.styledMode || ("square" !== i2.linecap && C.attr({ "stroke-linecap": "round", "stroke-linejoin": "round" }), C.attr({ stroke: i2.borderColor || "none", "stroke-width": i2.borderWidth || 0 })), C && C.addClass(a3.getClassName(), true);
            }
          }
          animate(t3) {
            t3 || (this.startAngleRad = this.thresholdAngleRad, a.prototype.animate.call(this, t3));
          }
        }
        return g.defaultOptions = h(r.defaultOptions, s), e2.registerSeriesType("solidgauge", g), g;
      }), o(e, "masters/modules/solid-gauge.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_solid_gauge();
//# sourceMappingURL=highcharts_modules_solid-gauge__js.js.map
