import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/navigator.js
var require_navigator = __commonJS({
  "node_modules/highcharts/modules/navigator.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Standalone navigator module
    *
    * (c) 2009-2024 Mateusz Bernacik
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/navigator", ["highcharts"], function(i) {
        return t(i), t.Highcharts = i, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var i = t ? t._modules : {};
      function e(i2, e2, s, a) {
        i2.hasOwnProperty(e2) || (i2[e2] = a.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: e2, module: i2[e2] } })));
      }
      e(i, "Stock/Navigator/ChartNavigatorComposition.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let e2;
        let { isTouchDevice: s } = t2, { addEvent: a, merge: r, pick: o } = i2, n = [];
        function h() {
          this.navigator && this.navigator.setBaseSeries(null, false);
        }
        function l() {
          var _a;
          let t3, i3, e3;
          let s2 = this.legend, a2 = this.navigator;
          if (a2) {
            t3 = s2 && s2.options, i3 = a2.xAxis, e3 = a2.yAxis;
            let { scrollbarHeight: r2, scrollButtonSize: n2 } = a2;
            this.inverted ? (a2.left = a2.opposite ? this.chartWidth - r2 - a2.height : this.spacing[3] + r2, a2.top = this.plotTop + n2) : (a2.left = o(i3.left, this.plotLeft + n2), a2.top = a2.navigatorOptions.top || this.chartHeight - a2.height - r2 - (((_a = this.scrollbar) == null ? void 0 : _a.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t3 && "bottom" === t3.verticalAlign && "proximate" !== t3.layout && t3.enabled && !t3.floating ? s2.legendHeight + o(t3.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), i3 && e3 && (this.inverted ? i3.options.left = e3.options.left = a2.left : i3.options.top = e3.options.top = a2.top, i3.setAxisSize(), e3.setAxisSize());
          }
        }
        function d(t3) {
          !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new e2(this), o(t3.redraw, true) && this.redraw(t3.animation));
        }
        function c() {
          let t3 = this.options;
          (t3.navigator.enabled || t3.scrollbar.enabled) && (this.scroller = this.navigator = new e2(this));
        }
        function g() {
          let t3 = this.options, i3 = t3.navigator, e3 = t3.rangeSelector;
          if ((i3 && i3.enabled || e3 && e3.enabled) && (!s && "x" === this.zooming.type || s && "x" === this.zooming.pinchType)) return false;
        }
        function p(t3) {
          let i3 = t3.navigator;
          if (i3 && t3.xAxis[0]) {
            let e3 = t3.xAxis[0].getExtremes();
            i3.render(e3.min, e3.max);
          }
        }
        function u(t3) {
          let i3 = t3.options.navigator || {}, e3 = t3.options.scrollbar || {};
          !this.navigator && !this.scroller && (i3.enabled || e3.enabled) && (r(true, this.options.navigator, i3), r(true, this.options.scrollbar, e3), delete t3.options.navigator, delete t3.options.scrollbar);
        }
        return { compose: function(t3, s2) {
          if (i2.pushUnique(n, t3)) {
            let i3 = t3.prototype;
            e2 = s2, i3.callbacks.push(p), a(t3, "afterAddSeries", h), a(t3, "afterSetChartSize", l), a(t3, "afterUpdate", d), a(t3, "beforeRender", c), a(t3, "beforeShowResetZoom", g), a(t3, "update", u);
          }
        } };
      }), e(i, "Core/Axis/NavigatorAxisComposition.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { isTouchDevice: e2 } = t2, { addEvent: s, correctFloat: a, defined: r, isNumber: o, pick: n } = i2;
        function h() {
          this.navigatorAxis || (this.navigatorAxis = new d(this));
        }
        function l(t3) {
          let i3;
          let s2 = this.chart, a2 = s2.options, o2 = a2.navigator, n2 = this.navigatorAxis, h2 = s2.zooming.pinchType, l2 = a2.rangeSelector, d2 = s2.zooming.type;
          if (this.isXAxis && ((o2 == null ? void 0 : o2.enabled) || (l2 == null ? void 0 : l2.enabled))) {
            if ("y" === d2 && "zoom" === t3.trigger) i3 = false;
            else if (("zoom" === t3.trigger && "xy" === d2 || e2 && "xy" === h2) && this.options.range) {
              let i4 = n2.previousZoom;
              r(t3.min) ? n2.previousZoom = [this.min, this.max] : i4 && (t3.min = i4[0], t3.max = i4[1], n2.previousZoom = void 0);
            }
          }
          void 0 !== i3 && t3.preventDefault();
        }
        class d {
          static compose(t3) {
            t3.keepProps.includes("navigatorAxis") || (t3.keepProps.push("navigatorAxis"), s(t3, "init", h), s(t3, "setExtremes", l));
          }
          constructor(t3) {
            this.axis = t3;
          }
          destroy() {
            this.axis = void 0;
          }
          toFixedRange(t3, i3, e3, s2) {
            let h2 = this.axis, l2 = (h2.pointRange || 0) / 2, d2 = n(e3, h2.translate(t3, true, !h2.horiz)), c = n(s2, h2.translate(i3, true, !h2.horiz));
            return r(e3) || (d2 = a(d2 + l2)), r(s2) || (c = a(c - l2)), o(d2) && o(c) || (d2 = c = void 0), { min: d2, max: c };
          }
        }
        return d;
      }), e(i, "Stock/Navigator/NavigatorDefaults.js", [i["Core/Color/Color.js"], i["Core/Series/SeriesRegistry.js"]], function(t2, i2) {
        let { parse: e2 } = t2, { seriesTypes: s } = i2;
        return { height: 40, margin: 25, maskInside: true, handles: { width: 7, borderRadius: 0, height: 15, symbols: ["navigator-handle", "navigator-handle"], enabled: true, lineWidth: 1, backgroundColor: "#f2f2f2", borderColor: "#999999" }, maskFill: e2("#667aff").setOpacity(0.3).get(), outlineColor: "#999999", outlineWidth: 1, series: { type: void 0 === s.areaspline ? "line" : "areaspline", fillOpacity: 0.05, lineWidth: 1, compare: null, sonification: { enabled: false }, dataGrouping: { approximation: "average", enabled: true, groupPixelWidth: 2, firstAnchor: "firstPoint", anchor: "middle", lastAnchor: "lastPoint", units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]] }, dataLabels: { enabled: false, zIndex: 2 }, id: "highcharts-navigator-series", className: "highcharts-navigator-series", lineColor: null, marker: { enabled: false }, threshold: null }, xAxis: { className: "highcharts-navigator-xaxis", tickLength: 0, lineWidth: 0, gridLineColor: "#e6e6e6", id: "navigator-x-axis", gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", style: { color: "#000000", fontSize: "0.7em", opacity: 0.6, textOutline: "2px contrast" }, x: 3, y: -4 }, crosshair: false }, yAxis: { className: "highcharts-navigator-yaxis", gridLineWidth: 0, startOnTick: false, endOnTick: false, minPadding: 0.1, id: "navigator-y-axis", maxPadding: 0.1, labels: { enabled: false }, crosshair: false, title: { text: null }, tickLength: 0, tickWidth: 0 } };
      }), e(i, "Stock/Navigator/NavigatorSymbols.js", [i["Core/Renderer/SVG/Symbols.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { relativeLength: e2 } = i2;
        return { "navigator-handle": function(i3, s, a, r, o = {}) {
          let n = o.width ? o.width / 2 : a, h = e2(o.borderRadius || 0, Math.min(2 * n, r));
          return [["M", -1.5, (r = o.height || r) / 2 - 3.5], ["L", -1.5, r / 2 + 4.5], ["M", 0.5, r / 2 - 3.5], ["L", 0.5, r / 2 + 4.5], ...t2.rect(-n - 1, 0.5, 2 * n + 1, r, { r: h })];
        } };
      }), e(i, "Stock/Utilities/StockUtilities.js", [i["Core/Utilities.js"]], function(t2) {
        let { defined: i2 } = t2;
        return { setFixedRange: function(t3) {
          let e2 = this.xAxis[0];
          i2(e2.dataMax) && i2(e2.dataMin) && t3 ? this.fixedRange = Math.min(t3, e2.dataMax - e2.dataMin) : this.fixedRange = t3;
        } };
      }), e(i, "Stock/Navigator/NavigatorComposition.js", [i["Core/Defaults.js"], i["Core/Globals.js"], i["Core/Axis/NavigatorAxisComposition.js"], i["Stock/Navigator/NavigatorDefaults.js"], i["Stock/Navigator/NavigatorSymbols.js"], i["Core/Renderer/RendererRegistry.js"], i["Stock/Utilities/StockUtilities.js"], i["Core/Utilities.js"]], function(t2, i2, e2, s, a, r, o, n) {
        let { setOptions: h } = t2, { composed: l } = i2, { getRendererType: d } = r, { setFixedRange: c } = o, { addEvent: g, extend: p, pushUnique: u } = n;
        function x() {
          this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, false);
        }
        return { compose: function(t3, i3, r2) {
          e2.compose(i3), u(l, "Navigator") && (t3.prototype.setFixedRange = c, p(d().prototype.symbols, a), g(r2, "afterUpdate", x), h({ navigator: s }));
        } };
      }), e(i, "Core/Axis/ScrollbarAxis.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        var e2;
        let { composed: s } = t2, { addEvent: a, defined: r, pick: o, pushUnique: n } = i2;
        return function(t3) {
          let i3;
          function e3(t4) {
            let i4 = o(t4.options && t4.options.min, t4.min), e4 = o(t4.options && t4.options.max, t4.max);
            return { axisMin: i4, axisMax: e4, scrollMin: r(t4.dataMin) ? Math.min(i4, t4.min, t4.dataMin, o(t4.threshold, 1 / 0)) : i4, scrollMax: r(t4.dataMax) ? Math.max(e4, t4.max, t4.dataMax, o(t4.threshold, -1 / 0)) : e4 };
          }
          function h() {
            let t4 = this.scrollbar, i4 = t4 && !t4.options.opposite, e4 = this.horiz ? 2 : i4 ? 3 : 1;
            t4 && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[e4] += t4.size + (t4.options.margin || 0));
          }
          function l() {
            let t4 = this;
            t4.options && t4.options.scrollbar && t4.options.scrollbar.enabled && (t4.options.scrollbar.vertical = !t4.horiz, t4.options.startOnTick = t4.options.endOnTick = false, t4.scrollbar = new i3(t4.chart.renderer, t4.options.scrollbar, t4.chart), a(t4.scrollbar, "changed", function(i4) {
              let s2, a2;
              let { axisMin: o2, axisMax: n2, scrollMin: h2, scrollMax: l2 } = e3(t4), d2 = l2 - h2;
              if (r(o2) && r(n2)) {
                if (t4.horiz && !t4.reversed || !t4.horiz && t4.reversed ? (s2 = h2 + d2 * this.to, a2 = h2 + d2 * this.from) : (s2 = h2 + d2 * (1 - this.from), a2 = h2 + d2 * (1 - this.to)), this.shouldUpdateExtremes(i4.DOMType)) {
                  let e4 = "mousemove" !== i4.DOMType && "touchmove" !== i4.DOMType && void 0;
                  t4.setExtremes(a2, s2, true, e4, i4);
                } else this.setRange(this.from, this.to);
              }
            }));
          }
          function d() {
            let t4, i4, s2;
            let { scrollMin: a2, scrollMax: o2 } = e3(this), n2 = this.scrollbar, h2 = this.axisTitleMargin + (this.titleOffset || 0), l2 = this.chart.scrollbarsOffsets, d2 = this.options.margin || 0;
            if (n2 && l2) {
              if (this.horiz) this.opposite || (l2[1] += h2), n2.position(this.left, this.top + this.height + 2 + l2[1] - (this.opposite ? d2 : 0), this.width, this.height), this.opposite || (l2[1] += d2), t4 = 1;
              else {
                let i5;
                this.opposite && (l2[0] += h2), i5 = n2.options.opposite ? this.left + this.width + 2 + l2[0] - (this.opposite ? 0 : d2) : this.opposite ? 0 : d2, n2.position(i5, this.top, this.width, this.height), this.opposite && (l2[0] += d2), t4 = 0;
              }
              l2[t4] += n2.size + (n2.options.margin || 0), isNaN(a2) || isNaN(o2) || !r(this.min) || !r(this.max) || this.min === this.max ? n2.setRange(0, 1) : (i4 = (this.min - a2) / (o2 - a2), s2 = (this.max - a2) / (o2 - a2), this.horiz && !this.reversed || !this.horiz && this.reversed ? n2.setRange(i4, s2) : n2.setRange(1 - s2, 1 - i4));
            }
          }
          t3.compose = function(t4, e4) {
            n(s, "Axis.Scrollbar") && (i3 = e4, a(t4, "afterGetOffset", h), a(t4, "afterInit", l), a(t4, "afterRender", d));
          };
        }(e2 || (e2 = {})), e2;
      }), e(i, "Stock/Scrollbar/ScrollbarDefaults.js", [], function() {
        return { height: 10, barBorderRadius: 5, buttonBorderRadius: 0, buttonsEnabled: false, liveRedraw: void 0, margin: void 0, minWidth: 6, opposite: true, step: 0.2, zIndex: 3, barBackgroundColor: "#cccccc", barBorderWidth: 0, barBorderColor: "#cccccc", buttonArrowColor: "#333333", buttonBackgroundColor: "#e6e6e6", buttonBorderColor: "#cccccc", buttonBorderWidth: 1, rifleColor: "none", trackBackgroundColor: "rgba(255, 255, 255, 0.001)", trackBorderColor: "#cccccc", trackBorderRadius: 5, trackBorderWidth: 1 };
      }), e(i, "Stock/Scrollbar/Scrollbar.js", [i["Core/Defaults.js"], i["Core/Globals.js"], i["Core/Axis/ScrollbarAxis.js"], i["Stock/Scrollbar/ScrollbarDefaults.js"], i["Core/Utilities.js"]], function(t2, i2, e2, s, a) {
        let { defaultOptions: r } = t2, { addEvent: o, correctFloat: n, crisp: h, defined: l, destroyObjectProperties: d, fireEvent: c, merge: g, pick: p, removeEvent: u } = a;
        class x {
          static compose(t3) {
            e2.compose(t3, x);
          }
          static swapXY(t3, i3) {
            return i3 && t3.forEach((t4) => {
              let i4;
              let e3 = t4.length;
              for (let s2 = 0; s2 < e3; s2 += 2) "number" == typeof (i4 = t4[s2 + 1]) && (t4[s2 + 1] = t4[s2 + 2], t4[s2 + 2] = i4);
            }), t3;
          }
          constructor(t3, i3, e3) {
            this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t3, i3, e3);
          }
          addEvents() {
            let t3 = this.options.inverted ? [1, 0] : [0, 1], i3 = this.scrollbarButtons, e3 = this.scrollbarGroup.element, s2 = this.track.element, a2 = this.mouseDownHandler.bind(this), r2 = this.mouseMoveHandler.bind(this), n2 = this.mouseUpHandler.bind(this), h2 = [[i3[t3[0]].element, "click", this.buttonToMinClick.bind(this)], [i3[t3[1]].element, "click", this.buttonToMaxClick.bind(this)], [s2, "click", this.trackClick.bind(this)], [e3, "mousedown", a2], [e3.ownerDocument, "mousemove", r2], [e3.ownerDocument, "mouseup", n2], [e3, "touchstart", a2], [e3.ownerDocument, "touchmove", r2], [e3.ownerDocument, "touchend", n2]];
            h2.forEach(function(t4) {
              o.apply(null, t4);
            }), this._events = h2;
          }
          buttonToMaxClick(t3) {
            let i3 = (this.to - this.from) * p(this.options.step, 0.2);
            this.updatePosition(this.from + i3, this.to + i3), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          buttonToMinClick(t3) {
            let i3 = n(this.to - this.from) * p(this.options.step, 0.2);
            this.updatePosition(n(this.from - i3), n(this.to - i3)), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          cursorToScrollbarPosition(t3) {
            let i3 = this.options, e3 = i3.minWidth > this.calculatedWidth ? i3.minWidth : 0;
            return { chartX: (t3.chartX - this.x - this.xOffset) / (this.barWidth - e3), chartY: (t3.chartY - this.y - this.yOffset) / (this.barWidth - e3) };
          }
          destroy() {
            let t3 = this, i3 = t3.chart.scroller;
            t3.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function(i4) {
              t3[i4] && t3[i4].destroy && (t3[i4] = t3[i4].destroy());
            }), i3 && t3 === i3.scrollbar && (i3.scrollbar = null, d(i3.scrollbarButtons));
          }
          drawScrollbarButton(t3) {
            let i3 = this.renderer, e3 = this.scrollbarButtons, s2 = this.options, a2 = this.size, r2 = i3.g().add(this.group);
            if (e3.push(r2), s2.buttonsEnabled) {
              let o2 = i3.rect().addClass("highcharts-scrollbar-button").add(r2);
              this.chart.styledMode || o2.attr({ stroke: s2.buttonBorderColor, "stroke-width": s2.buttonBorderWidth, fill: s2.buttonBackgroundColor }), o2.attr(o2.crisp({ x: -0.5, y: -0.5, width: a2, height: a2, r: s2.buttonBorderRadius }, o2.strokeWidth()));
              let n2 = i3.path(x.swapXY([["M", a2 / 2 + (t3 ? -1 : 1), a2 / 2 - 3], ["L", a2 / 2 + (t3 ? -1 : 1), a2 / 2 + 3], ["L", a2 / 2 + (t3 ? 2 : -2), a2 / 2]], s2.vertical)).addClass("highcharts-scrollbar-arrow").add(e3[t3]);
              this.chart.styledMode || n2.attr({ fill: s2.buttonArrowColor });
            }
          }
          init(t3, i3, e3) {
            this.scrollbarButtons = [], this.renderer = t3, this.userOptions = i3, this.options = g(s, r.scrollbar, i3), this.options.margin = p(this.options.margin, 10), this.chart = e3, this.size = p(this.options.size, this.options.height), i3.enabled && (this.render(), this.addEvents());
          }
          mouseDownHandler(t3) {
            var _a;
            let i3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3, e3 = this.cursorToScrollbarPosition(i3);
            this.chartX = e3.chartX, this.chartY = e3.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = true;
          }
          mouseMoveHandler(t3) {
            var _a;
            let i3;
            let e3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3, s2 = this.options.vertical ? "chartY" : "chartX", a2 = this.initPositions || [];
            this.grabbedCenter && (!t3.touches || 0 !== t3.touches[0][s2]) && (i3 = this.cursorToScrollbarPosition(e3)[s2] - this[s2], this.hasDragged = true, this.updatePosition(a2[0] + i3, a2[1] + i3), this.hasDragged && c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t3.type, DOMEvent: t3 }));
          }
          mouseUpHandler(t3) {
            this.hasDragged && c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t3.type, DOMEvent: t3 }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
          }
          position(t3, i3, e3, s2) {
            let { buttonsEnabled: a2, margin: r2 = 0, vertical: o2 } = this.options, n2 = this.rendered ? "animate" : "attr", h2 = s2, l2 = 0;
            this.group.show(), this.x = t3, this.y = i3 + this.trackBorderWidth, this.width = e3, this.height = s2, this.xOffset = h2, this.yOffset = l2, o2 ? (this.width = this.yOffset = e3 = l2 = this.size, this.xOffset = h2 = 0, this.yOffset = l2 = a2 ? this.size : 0, this.barWidth = s2 - (a2 ? 2 * e3 : 0), this.x = t3 += r2) : (this.height = s2 = this.size, this.xOffset = h2 = a2 ? this.size : 0, this.barWidth = e3 - (a2 ? 2 * s2 : 0), this.y = this.y + r2), this.group[n2]({ translateX: t3, translateY: this.y }), this.track[n2]({ width: e3, height: s2 }), this.scrollbarButtons[1][n2]({ translateX: o2 ? 0 : e3 - h2, translateY: o2 ? s2 - l2 : 0 });
          }
          removeEvents() {
            this._events.forEach(function(t3) {
              u.apply(null, t3);
            }), this._events.length = 0;
          }
          render() {
            let t3 = this.renderer, i3 = this.options, e3 = this.size, s2 = this.chart.styledMode, a2 = t3.g("scrollbar").attr({ zIndex: i3.zIndex }).hide().add();
            this.group = a2, this.track = t3.rect().addClass("highcharts-scrollbar-track").attr({ r: i3.trackBorderRadius || 0, height: e3, width: e3 }).add(a2), s2 || this.track.attr({ fill: i3.trackBackgroundColor, stroke: i3.trackBorderColor, "stroke-width": i3.trackBorderWidth });
            let r2 = this.trackBorderWidth = this.track.strokeWidth();
            this.track.attr({ x: -h(0, r2), y: -h(0, r2) }), this.scrollbarGroup = t3.g().add(a2), this.scrollbar = t3.rect().addClass("highcharts-scrollbar-thumb").attr({ height: e3 - r2, width: e3 - r2, r: i3.barBorderRadius || 0 }).add(this.scrollbarGroup), this.scrollbarRifles = t3.path(x.swapXY([["M", -3, e3 / 4], ["L", -3, 2 * e3 / 3], ["M", 0, e3 / 4], ["L", 0, 2 * e3 / 3], ["M", 3, e3 / 4], ["L", 3, 2 * e3 / 3]], i3.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s2 || (this.scrollbar.attr({ fill: i3.barBackgroundColor, stroke: i3.barBorderColor, "stroke-width": i3.barBorderWidth }), this.scrollbarRifles.attr({ stroke: i3.rifleColor, "stroke-width": 1 })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-h(0, this.scrollbarStrokeWidth), -h(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);
          }
          setRange(t3, i3) {
            let e3, s2;
            let a2 = this.options, r2 = a2.vertical, o2 = a2.minWidth, h2 = this.barWidth, d2 = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
            if (!l(h2)) return;
            let c2 = h2 * Math.min(i3, 1);
            e3 = Math.ceil(h2 * (t3 = Math.max(t3, 0))), this.calculatedWidth = s2 = n(c2 - e3), s2 < o2 && (e3 = (h2 - o2 + s2) * t3, s2 = o2);
            let g2 = Math.floor(e3 + this.xOffset + this.yOffset), p2 = s2 / 2 - 0.5;
            this.from = t3, this.to = i3, r2 ? (this.scrollbarGroup[d2]({ translateY: g2 }), this.scrollbar[d2]({ height: s2 }), this.scrollbarRifles[d2]({ translateY: p2 }), this.scrollbarTop = g2, this.scrollbarLeft = 0) : (this.scrollbarGroup[d2]({ translateX: g2 }), this.scrollbar[d2]({ width: s2 }), this.scrollbarRifles[d2]({ translateX: p2 }), this.scrollbarLeft = g2, this.scrollbarTop = 0), s2 <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), false === a2.showFull && (t3 <= 0 && i3 >= 1 ? this.group.hide() : this.group.show()), this.rendered = true;
          }
          shouldUpdateExtremes(t3) {
            return p(this.options.liveRedraw, i2.svg && !i2.isTouchDevice && !this.chart.boosted) || "mouseup" === t3 || "touchend" === t3 || !l(t3);
          }
          trackClick(t3) {
            var _a;
            let i3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3, e3 = this.to - this.from, s2 = this.y + this.scrollbarTop, a2 = this.x + this.scrollbarLeft;
            this.options.vertical && i3.chartY > s2 || !this.options.vertical && i3.chartX > a2 ? this.updatePosition(this.from + e3, this.to + e3) : this.updatePosition(this.from - e3, this.to - e3), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          update(t3) {
            this.destroy(), this.init(this.chart.renderer, g(true, this.options, t3), this.chart);
          }
          updatePosition(t3, i3) {
            i3 > 1 && (t3 = n(1 - n(i3 - t3)), i3 = 1), t3 < 0 && (i3 = n(i3 - t3), t3 = 0), this.from = t3, this.to = i3;
          }
        }
        return x.defaultOptions = s, r.scrollbar = g(true, x.defaultOptions, r.scrollbar), x;
      }), e(i, "Stock/Navigator/Navigator.js", [i["Core/Axis/Axis.js"], i["Stock/Navigator/ChartNavigatorComposition.js"], i["Core/Defaults.js"], i["Core/Globals.js"], i["Core/Axis/NavigatorAxisComposition.js"], i["Stock/Navigator/NavigatorComposition.js"], i["Stock/Scrollbar/Scrollbar.js"], i["Core/Renderer/SVG/SVGRenderer.js"], i["Core/Utilities.js"]], function(t2, i2, e2, s, a, r, o, n, h) {
        let { defaultOptions: l } = e2, { isTouchDevice: d } = s, { prototype: { symbols: c } } = n, { addEvent: g, clamp: p, correctFloat: u, defined: x, destroyObjectProperties: m, erase: v, extend: b, find: f, fireEvent: M, isArray: A, isNumber: S, merge: y, pick: k, removeEvent: E, splat: w } = h;
        function C(t3, ...i3) {
          let e3 = [].filter.call(i3, S);
          if (e3.length) return Math[t3].apply(0, e3);
        }
        class O {
          static compose(t3, e3, s2) {
            i2.compose(t3, O), r.compose(t3, e3, s2);
          }
          constructor(t3) {
            this.isDirty = false, this.scrollbarHeight = 0, this.init(t3);
          }
          drawHandle(t3, i3, e3, s2) {
            let a2 = this.navigatorOptions.handles.height;
            this.handles[i3][s2](e3 ? { translateX: Math.round(this.left + this.height / 2), translateY: Math.round(this.top + parseInt(t3, 10) + 0.5 - a2) } : { translateX: Math.round(this.left + parseInt(t3, 10)), translateY: Math.round(this.top + this.height / 2 - a2 / 2 - 1) });
          }
          drawOutline(t3, i3, e3, s2) {
            let a2 = this.navigatorOptions.maskInside, r2 = this.outline.strokeWidth(), o2 = r2 / 2, n2 = r2 % 2 / 2, h2 = this.scrollButtonSize, l2 = this.size, d2 = this.top, c2 = this.height, g2 = d2 - o2, p2 = d2 + c2, u2 = this.left, x2, m2;
            e3 ? (x2 = d2 + i3 + n2, i3 = d2 + t3 + n2, m2 = [["M", u2 + c2, d2 - h2 - n2], ["L", u2 + c2, x2], ["L", u2, x2], ["M", u2, i3], ["L", u2 + c2, i3], ["L", u2 + c2, d2 + l2 + h2]], a2 && m2.push(["M", u2 + c2, x2 - o2], ["L", u2 + c2, i3 + o2])) : (u2 -= h2, t3 += u2 + h2 - n2, i3 += u2 + h2 - n2, m2 = [["M", u2, g2], ["L", t3, g2], ["L", t3, p2], ["M", i3, p2], ["L", i3, g2], ["L", u2 + l2 + 2 * h2, g2]], a2 && m2.push(["M", t3 - o2, g2], ["L", i3 + o2, g2])), this.outline[s2]({ d: m2 });
          }
          drawMasks(t3, i3, e3, s2) {
            let a2, r2, o2, n2;
            let h2 = this.left, l2 = this.top, d2 = this.height;
            e3 ? (o2 = [h2, h2, h2], n2 = [l2, l2 + t3, l2 + i3], r2 = [d2, d2, d2], a2 = [t3, i3 - t3, this.size - i3]) : (o2 = [h2, h2 + t3, h2 + i3], n2 = [l2, l2, l2], r2 = [t3, i3 - t3, this.size - i3], a2 = [d2, d2, d2]), this.shades.forEach((t4, i4) => {
              t4[s2]({ x: o2[i4], y: n2[i4], width: r2[i4], height: a2[i4] });
            });
          }
          renderElements() {
            var _a;
            let t3 = this, i3 = t3.navigatorOptions, e3 = i3.maskInside, s2 = t3.chart, a2 = s2.inverted, r2 = s2.renderer, o2 = { cursor: a2 ? "ns-resize" : "ew-resize" }, n2 = t3.navigatorGroup ?? (t3.navigatorGroup = r2.g("navigator").attr({ zIndex: 8, visibility: "hidden" }).add());
            if ([!e3, e3, !e3].forEach((e4, a3) => {
              let h2 = t3.shades[a3] ?? (t3.shades[a3] = r2.rect().addClass("highcharts-navigator-mask" + (1 === a3 ? "-inside" : "-outside")).add(n2));
              s2.styledMode || (h2.attr({ fill: e4 ? i3.maskFill : "rgba(0,0,0,0)" }), 1 === a3 && h2.css(o2));
            }), t3.outline || (t3.outline = r2.path().addClass("highcharts-navigator-outline").add(n2)), s2.styledMode || t3.outline.attr({ "stroke-width": i3.outlineWidth, stroke: i3.outlineColor }), (_a = i3.handles) == null ? void 0 : _a.enabled) {
              let e4 = i3.handles, { height: a3, width: h2 } = e4;
              [0, 1].forEach((i4) => {
                let l2 = e4.symbols[i4];
                if (t3.handles[i4]) {
                  if (l2 !== t3.handles[i4].symbolName) {
                    let e5 = c[l2].call(c, -h2 / 2 - 1, 0, h2, a3);
                    t3.handles[i4].attr({ d: e5 }), t3.handles[i4].symbolName = l2;
                  }
                } else t3.handles[i4] = r2.symbol(l2, -h2 / 2 - 1, 0, h2, a3, e4), t3.handles[i4].attr({ zIndex: 7 - i4 }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][i4]).add(n2);
                s2.inverted && t3.handles[i4].attr({ rotation: 90, rotationOriginX: Math.floor(-h2 / 2), rotationOriginY: (a3 + h2) / 2 }), s2.styledMode || t3.handles[i4].attr({ fill: e4.backgroundColor, stroke: e4.borderColor, "stroke-width": e4.lineWidth, width: e4.width, height: e4.height, x: -h2 / 2 - 1, y: 0 }).css(o2);
              });
            }
          }
          update(t3, i3 = false) {
            var _a;
            let e3 = this.chart, s2 = e3.options.chart.inverted !== ((_a = e3.scrollbar) == null ? void 0 : _a.options.vertical);
            if (y(true, e3.options.navigator, t3), this.navigatorOptions = e3.options.navigator || {}, this.setOpposite(), x(t3.enabled) || s2) return this.destroy(), this.navigatorEnabled = t3.enabled || this.navigatorEnabled, this.init(e3);
            if (this.navigatorEnabled && (this.isDirty = true, false === t3.adaptToUpdatedData && this.baseSeries.forEach((t4) => {
              E(t4, "updatedData", this.updatedDataHandler);
            }, this), t3.adaptToUpdatedData && this.baseSeries.forEach((t4) => {
              t4.eventsToUnbind.push(g(t4, "updatedData", this.updatedDataHandler));
            }, this), (t3.series || t3.baseSeries) && this.setBaseSeries(void 0, false), t3.height || t3.xAxis || t3.yAxis)) {
              this.height = t3.height ?? this.height;
              let i4 = this.getXAxisOffsets();
              this.xAxis.update({ ...t3.xAxis, offsets: i4, [e3.inverted ? "width" : "height"]: this.height, [e3.inverted ? "height" : "width"]: void 0 }, false), this.yAxis.update({ ...t3.yAxis, [e3.inverted ? "width" : "height"]: this.height }, false);
            }
            i3 && e3.redraw();
          }
          render(t3, i3, e3, s2) {
            let a2 = this.chart, r2 = this.xAxis, o2 = r2.pointRange || 0, n2 = r2.navigatorAxis.fake ? a2.xAxis[0] : r2, h2 = this.navigatorEnabled, l2 = this.rendered, d2 = a2.inverted, c2 = a2.xAxis[0].minRange, g2 = a2.xAxis[0].options.maxRange, m2 = this.scrollButtonSize, v2, b2, f2, A2 = this.scrollbarHeight, y2, E2;
            if (this.hasDragged && !x(e3)) return;
            if (this.isDirty && this.renderElements(), t3 = u(t3 - o2 / 2), i3 = u(i3 + o2 / 2), !S(t3) || !S(i3)) {
              if (!l2) return;
              e3 = 0, s2 = k(r2.width, n2.width);
            }
            this.left = k(r2.left, a2.plotLeft + m2 + (d2 ? a2.plotWidth : 0));
            let w2 = this.size = y2 = k(r2.len, (d2 ? a2.plotHeight : a2.plotWidth) - 2 * m2);
            v2 = d2 ? A2 : y2 + 2 * m2, e3 = k(e3, r2.toPixels(t3, true)), s2 = k(s2, r2.toPixels(i3, true)), S(e3) && Math.abs(e3) !== 1 / 0 || (e3 = 0, s2 = v2);
            let C2 = r2.toValue(e3, true), O2 = r2.toValue(s2, true), D = Math.abs(u(O2 - C2));
            D < c2 ? this.grabbedLeft ? e3 = r2.toPixels(O2 - c2 - o2, true) : this.grabbedRight && (s2 = r2.toPixels(C2 + c2 + o2, true)) : x(g2) && u(D - o2) > g2 && (this.grabbedLeft ? e3 = r2.toPixels(O2 - g2 - o2, true) : this.grabbedRight && (s2 = r2.toPixels(C2 + g2 + o2, true))), this.zoomedMax = p(Math.max(e3, s2), 0, w2), this.zoomedMin = p(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(e3, s2), 0, w2), this.range = this.zoomedMax - this.zoomedMin, w2 = Math.round(this.zoomedMax);
            let z = Math.round(this.zoomedMin);
            h2 && (this.navigatorGroup.attr({ visibility: "inherit" }), E2 = l2 && !this.hasDragged ? "animate" : "attr", this.drawMasks(z, w2, d2, E2), this.drawOutline(z, w2, d2, E2), this.navigatorOptions.handles.enabled && (this.drawHandle(z, 0, d2, E2), this.drawHandle(w2, 1, d2, E2))), this.scrollbar && (d2 ? (f2 = this.top - m2, b2 = this.left - A2 + (h2 || !n2.opposite ? 0 : (n2.titleOffset || 0) + n2.axisTitleMargin), A2 = y2 + 2 * m2) : (f2 = this.top + (h2 ? this.height : -A2), b2 = this.left - m2), this.scrollbar.position(b2, f2, v2, A2), this.scrollbar.setRange(this.zoomedMin / (y2 || 1), this.zoomedMax / (y2 || 1))), this.rendered = true, this.isDirty = false, M(this, "afterRender");
          }
          addMouseEvents() {
            let t3 = this, i3 = t3.chart, e3 = i3.container, s2 = [], a2, r2;
            t3.mouseMoveHandler = a2 = function(i4) {
              t3.onMouseMove(i4);
            }, t3.mouseUpHandler = r2 = function(i4) {
              t3.onMouseUp(i4);
            }, (s2 = t3.getPartsEvents("mousedown")).push(g(i3.renderTo, "mousemove", a2), g(e3.ownerDocument, "mouseup", r2), g(i3.renderTo, "touchmove", a2), g(e3.ownerDocument, "touchend", r2)), s2.concat(t3.getPartsEvents("touchstart")), t3.eventsToUnbind = s2, t3.series && t3.series[0] && s2.push(g(t3.series[0].xAxis, "foundExtremes", function() {
              i3.navigator.modifyNavigatorAxisExtremes();
            }));
          }
          getPartsEvents(t3) {
            let i3 = this, e3 = [];
            return ["shades", "handles"].forEach(function(s2) {
              i3[s2].forEach(function(a2, r2) {
                e3.push(g(a2.element, t3, function(t4) {
                  i3[s2 + "Mousedown"](t4, r2);
                }));
              });
            }), e3;
          }
          shadesMousedown(t3, i3) {
            var _a;
            t3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3;
            let e3 = this.chart, s2 = this.xAxis, a2 = this.zoomedMin, r2 = this.size, o2 = this.range, n2 = this.left, h2 = t3.chartX, l2, d2, c2, g2;
            e3.inverted && (h2 = t3.chartY, n2 = this.top), 1 === i3 ? (this.grabbedCenter = h2, this.fixedWidth = o2, this.dragOffset = h2 - a2) : (g2 = h2 - n2 - o2 / 2, 0 === i3 ? g2 = Math.max(0, g2) : 2 === i3 && g2 + o2 >= r2 && (g2 = r2 - o2, this.reversedExtremes ? (g2 -= o2, d2 = this.getUnionExtremes().dataMin) : l2 = this.getUnionExtremes().dataMax), g2 !== a2 && (this.fixedWidth = o2, x((c2 = s2.navigatorAxis.toFixedRange(g2, g2 + o2, d2, l2)).min) && M(this, "setRange", { min: Math.min(c2.min, c2.max), max: Math.max(c2.min, c2.max), redraw: true, eventArguments: { trigger: "navigator" } })));
          }
          handlesMousedown(t3, i3) {
            var _a;
            t3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3;
            let e3 = this.chart, s2 = e3.xAxis[0], a2 = this.reversedExtremes;
            0 === i3 ? (this.grabbedLeft = true, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = a2 ? s2.min : s2.max) : (this.grabbedRight = true, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = a2 ? s2.max : s2.min), e3.setFixedRange(void 0);
          }
          onMouseMove(t3) {
            var _a;
            let i3 = this, e3 = i3.chart, s2 = i3.navigatorSize, a2 = i3.range, r2 = i3.dragOffset, o2 = e3.inverted, n2 = i3.left, h2;
            (!t3.touches || 0 !== t3.touches[0].pageX) && (h2 = (t3 = ((_a = e3.pointer) == null ? void 0 : _a.normalize(t3)) || t3).chartX, o2 && (n2 = i3.top, h2 = t3.chartY), i3.grabbedLeft ? (i3.hasDragged = true, i3.render(0, 0, h2 - n2, i3.otherHandlePos)) : i3.grabbedRight ? (i3.hasDragged = true, i3.render(0, 0, i3.otherHandlePos, h2 - n2)) : i3.grabbedCenter && (i3.hasDragged = true, h2 < r2 ? h2 = r2 : h2 > s2 + r2 - a2 && (h2 = s2 + r2 - a2), i3.render(0, 0, h2 - r2, h2 - r2 + a2)), i3.hasDragged && i3.scrollbar && k(i3.scrollbar.options.liveRedraw, !d && !this.chart.boosted) && (t3.DOMType = t3.type, setTimeout(function() {
              i3.onMouseUp(t3);
            }, 0)));
          }
          onMouseUp(t3) {
            let i3, e3, s2, a2, r2, o2;
            let n2 = this.chart, h2 = this.xAxis, l2 = this.scrollbar, d2 = t3.DOMEvent || t3, c2 = n2.inverted, g2 = this.rendered && !this.hasDragged ? "animate" : "attr";
            (this.hasDragged && (!l2 || !l2.hasDragged) || "scrollbar" === t3.trigger) && (s2 = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? a2 = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r2 = this.fixedExtreme), this.zoomedMax === this.size && (r2 = this.reversedExtremes ? s2.dataMin : s2.dataMax), 0 === this.zoomedMin && (a2 = this.reversedExtremes ? s2.dataMax : s2.dataMin), x((o2 = h2.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, a2, r2)).min) && M(this, "setRange", { min: Math.min(o2.min, o2.max), max: Math.max(o2.min, o2.max), redraw: true, animation: !this.hasDragged && null, eventArguments: { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: d2 } })), "mousemove" !== t3.DOMType && "touchmove" !== t3.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && S(this.zoomedMin) && S(this.zoomedMax) && (e3 = Math.round(this.zoomedMin), i3 = Math.round(this.zoomedMax), this.shades && this.drawMasks(e3, i3, c2, g2), this.outline && this.drawOutline(e3, i3, c2, g2), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(e3, 0, c2, g2), this.drawHandle(i3, 1, c2, g2)));
          }
          removeEvents() {
            this.eventsToUnbind && (this.eventsToUnbind.forEach(function(t3) {
              t3();
            }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();
          }
          removeBaseSeriesEvents() {
            let t3 = this.baseSeries || [];
            this.navigatorEnabled && t3[0] && (false !== this.navigatorOptions.adaptToUpdatedData && t3.forEach(function(t4) {
              E(t4, "updatedData", this.updatedDataHandler);
            }, this), t3[0].xAxis && E(t3[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
          }
          getXAxisOffsets() {
            return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];
          }
          init(i3) {
            var _a;
            let e3 = i3.options, s2 = e3.navigator || {}, r2 = s2.enabled, n2 = e3.scrollbar || {}, h2 = n2.enabled, l2 = r2 && s2.height || 0, d2 = h2 && n2.height || 0, c2 = n2.buttonsEnabled && d2 || 0;
            this.handles = [], this.shades = [], this.chart = i3, this.setBaseSeries(), this.height = l2, this.scrollbarHeight = d2, this.scrollButtonSize = c2, this.scrollbarEnabled = h2, this.navigatorEnabled = r2, this.navigatorOptions = s2, this.scrollbarOptions = n2, this.setOpposite();
            let p2 = this, u2 = p2.baseSeries, x2 = i3.xAxis.length, m2 = i3.yAxis.length, v2 = u2 && u2[0] && u2[0].xAxis || i3.xAxis[0] || { options: {} };
            if (i3.isDirtyBox = true, p2.navigatorEnabled) {
              let e4 = this.getXAxisOffsets();
              p2.xAxis = new t2(i3, y({ breaks: v2.options.breaks, ordinal: v2.options.ordinal, overscroll: v2.options.overscroll }, s2.xAxis, { type: "datetime", yAxis: (_a = s2.yAxis) == null ? void 0 : _a.id, index: x2, isInternal: true, offset: 0, keepOrdinalPadding: true, startOnTick: false, endOnTick: false, minPadding: v2.options.ordinal ? 0 : v2.options.minPadding, maxPadding: v2.options.ordinal ? 0 : v2.options.maxPadding, zoomEnabled: false }, i3.inverted ? { offsets: e4, width: l2 } : { offsets: e4, height: l2 }), "xAxis"), p2.yAxis = new t2(i3, y(s2.yAxis, { alignTicks: false, offset: 0, index: m2, isInternal: true, reversed: k(s2.yAxis && s2.yAxis.reversed, i3.yAxis[0] && i3.yAxis[0].reversed, false), zoomEnabled: false }, i3.inverted ? { width: l2 } : { height: l2 }), "yAxis"), u2 || s2.series.data ? p2.updateNavigatorSeries(false) : 0 === i3.series.length && (p2.unbindRedraw = g(i3, "beforeRedraw", function() {
                i3.series.length > 0 && !p2.series && (p2.setBaseSeries(), p2.unbindRedraw());
              })), p2.reversedExtremes = i3.inverted && !p2.xAxis.reversed || !i3.inverted && p2.xAxis.reversed, p2.renderElements(), p2.addMouseEvents();
            } else p2.xAxis = { chart: i3, navigatorAxis: { fake: true }, translate: function(t3, e4) {
              let s3 = i3.xAxis[0], a2 = s3.getExtremes(), r3 = s3.len - 2 * c2, o2 = C("min", s3.options.min, a2.dataMin), n3 = C("max", s3.options.max, a2.dataMax) - o2;
              return e4 ? t3 * n3 / r3 + o2 : r3 * (t3 - o2) / n3;
            }, toPixels: function(t3) {
              return this.translate(t3);
            }, toValue: function(t3) {
              return this.translate(t3, true);
            } }, p2.xAxis.navigatorAxis.axis = p2.xAxis, p2.xAxis.navigatorAxis.toFixedRange = a.prototype.toFixedRange.bind(p2.xAxis.navigatorAxis);
            if (i3.options.scrollbar.enabled) {
              let t3 = y(i3.options.scrollbar, { vertical: i3.inverted });
              !S(t3.margin) && p2.navigatorEnabled && (t3.margin = i3.inverted ? -3 : 3), i3.scrollbar = p2.scrollbar = new o(i3.renderer, t3, i3), g(p2.scrollbar, "changed", function(t4) {
                let i4 = p2.size, e4 = i4 * this.to, s3 = i4 * this.from;
                p2.hasDragged = p2.scrollbar.hasDragged, p2.render(0, 0, s3, e4), this.shouldUpdateExtremes(t4.DOMType) && setTimeout(function() {
                  p2.onMouseUp(t4);
                });
              });
            }
            p2.addBaseSeriesEvents(), p2.addChartEvents();
          }
          setOpposite() {
            let t3 = this.navigatorOptions, i3 = this.navigatorEnabled, e3 = this.chart;
            this.opposite = k(t3.opposite, !!(!i3 && e3.inverted));
          }
          getUnionExtremes(t3) {
            let i3;
            let e3 = this.chart.xAxis[0], s2 = this.xAxis, a2 = s2.options, r2 = e3.options;
            return t3 && null === e3.dataMin || (i3 = { dataMin: k(a2 && a2.min, C("min", r2.min, e3.dataMin, s2.dataMin, s2.min)), dataMax: k(a2 && a2.max, C("max", r2.max, e3.dataMax, s2.dataMax, s2.max)) }), i3;
          }
          setBaseSeries(t3, i3) {
            let e3 = this.chart, s2 = this.baseSeries = [];
            t3 = t3 || e3.options && e3.options.navigator.baseSeries || (e3.series.length ? f(e3.series, (t4) => !t4.options.isInternal).index : 0), (e3.series || []).forEach((i4, e4) => {
              !i4.options.isInternal && (i4.options.showInNavigator || (e4 === t3 || i4.options.id === t3) && false !== i4.options.showInNavigator) && s2.push(i4);
            }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(true, i3);
          }
          updateNavigatorSeries(t3, i3) {
            var _a, _b;
            let e3 = this, s2 = e3.chart, a2 = e3.baseSeries, r2 = { enableMouseTracking: false, index: null, linkedTo: null, group: "nav", padXAxis: false, xAxis: (_a = this.navigatorOptions.xAxis) == null ? void 0 : _a.id, yAxis: (_b = this.navigatorOptions.yAxis) == null ? void 0 : _b.id, showInLegend: false, stacking: void 0, isInternal: true, states: { inactive: { opacity: 1 } } }, o2 = e3.series = (e3.series || []).filter((t4) => {
              let i4 = t4.baseSeries;
              return !(0 > a2.indexOf(i4)) || (i4 && (E(i4, "updatedData", e3.updatedDataHandler), delete i4.navigatorSeries), t4.chart && t4.destroy(), false);
            }), n2, h2, d2 = e3.navigatorOptions.series, c2;
            a2 && a2.length && a2.forEach((t4) => {
              let g2 = t4.navigatorSeries, p2 = b({ color: t4.color, visible: t4.visible }, A(d2) ? l.navigator.series : d2);
              if (g2 && false === e3.navigatorOptions.adaptToUpdatedData) return;
              r2.name = "Navigator " + a2.length, c2 = (n2 = t4.options || {}).navigatorOptions || {}, p2.dataLabels = w(p2.dataLabels), (h2 = y(n2, r2, p2, c2)).pointRange = k(p2.pointRange, c2.pointRange, l.plotOptions[h2.type || "line"].pointRange);
              let u2 = c2.data || p2.data;
              e3.hasNavigatorData = e3.hasNavigatorData || !!u2, h2.data = u2 || n2.data && n2.data.slice(0), g2 && g2.options ? g2.update(h2, i3) : (t4.navigatorSeries = s2.initSeries(h2), s2.setSortedData(), t4.navigatorSeries.baseSeries = t4, o2.push(t4.navigatorSeries));
            }), (d2.data && !(a2 && a2.length) || A(d2)) && (e3.hasNavigatorData = false, (d2 = w(d2)).forEach((t4, i4) => {
              r2.name = "Navigator " + (o2.length + 1), (h2 = y(l.navigator.series, { color: s2.series[i4] && !s2.series[i4].options.isInternal && s2.series[i4].color || s2.options.colors[i4] || s2.options.colors[0] }, r2, t4)).data = t4.data, h2.data && (e3.hasNavigatorData = true, o2.push(s2.initSeries(h2)));
            })), t3 && this.addBaseSeriesEvents();
          }
          addBaseSeriesEvents() {
            let t3 = this, i3 = t3.baseSeries || [];
            i3[0] && i3[0].xAxis && i3[0].eventsToUnbind.push(g(i3[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), i3.forEach((e3) => {
              e3.eventsToUnbind.push(g(e3, "show", function() {
                this.navigatorSeries && this.navigatorSeries.setVisible(true, false);
              })), e3.eventsToUnbind.push(g(e3, "hide", function() {
                this.navigatorSeries && this.navigatorSeries.setVisible(false, false);
              })), false !== this.navigatorOptions.adaptToUpdatedData && e3.xAxis && e3.eventsToUnbind.push(g(e3, "updatedData", this.updatedDataHandler)), e3.eventsToUnbind.push(g(e3, "remove", function() {
                i3 && v(i3, e3), this.navigatorSeries && (v(t3.series, this.navigatorSeries), x(this.navigatorSeries.options) && this.navigatorSeries.remove(false), delete this.navigatorSeries);
              }));
            });
          }
          getBaseSeriesMin(t3) {
            return this.baseSeries.reduce(function(t4, i3) {
              return Math.min(t4, i3.xData && i3.xData.length ? i3.xData[0] : t4);
            }, t3);
          }
          modifyNavigatorAxisExtremes() {
            let t3 = this.xAxis;
            if (void 0 !== t3.getExtremes) {
              let i3 = this.getUnionExtremes(true);
              i3 && (i3.dataMin !== t3.min || i3.dataMax !== t3.max) && (t3.min = i3.dataMin, t3.max = i3.dataMax);
            }
          }
          modifyBaseAxisExtremes() {
            var _a;
            let t3, i3;
            let e3 = this.chart.navigator, s2 = this.getExtremes(), a2 = s2.min, r2 = s2.max, o2 = s2.dataMin, n2 = s2.dataMax, h2 = r2 - a2, l2 = e3.stickToMin, d2 = e3.stickToMax, c2 = k((_a = this.ordinal) == null ? void 0 : _a.convertOverscroll(this.options.overscroll), 0), g2 = e3.series && e3.series[0], p2 = !!this.setExtremes;
            !(this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger) && (l2 && (t3 = (i3 = o2) + h2), d2 && (t3 = n2 + c2, l2 || (i3 = Math.max(o2, t3 - h2, e3.getBaseSeriesMin(g2 && g2.xData ? g2.xData[0] : -Number.MAX_VALUE)))), p2 && (l2 || d2) && S(i3) && (this.min = this.userMin = i3, this.max = this.userMax = t3)), e3.stickToMin = e3.stickToMax = null;
          }
          updatedDataHandler() {
            let t3 = this.chart.navigator, i3 = this.navigatorSeries, e3 = t3.reversedExtremes ? 0 === Math.round(t3.zoomedMin) : Math.round(t3.zoomedMax) >= Math.round(t3.size);
            t3.stickToMax = k(this.chart.options.navigator && this.chart.options.navigator.stickToMax, e3), t3.stickToMin = t3.shouldStickToMin(this, t3), i3 && !t3.hasNavigatorData && (i3.options.pointStart = this.xData[0], i3.setData(this.options.data, false, null, false));
          }
          shouldStickToMin(t3, i3) {
            let e3 = i3.getBaseSeriesMin(t3.xData[0]), s2 = t3.xAxis, a2 = s2.max, r2 = s2.min, o2 = s2.options.range;
            return !!(S(a2) && S(r2)) && (o2 && a2 - e3 > 0 ? a2 - e3 < o2 : r2 <= e3);
          }
          addChartEvents() {
            this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(g(this.chart, "redraw", function() {
              let t3 = this.navigator, i3 = t3 && (t3.baseSeries && t3.baseSeries[0] && t3.baseSeries[0].xAxis || this.xAxis[0]);
              i3 && t3.render(i3.min, i3.max);
            }), g(this.chart, "getMargins", function() {
              let t3 = this.navigator, i3 = t3.opposite ? "plotTop" : "marginBottom";
              this.inverted && (i3 = t3.opposite ? "marginRight" : "plotLeft"), this[i3] = (this[i3] || 0) + (t3.navigatorEnabled || !this.inverted ? t3.height + t3.scrollbarHeight : 0) + t3.navigatorOptions.margin;
            }), g(O, "setRange", function(t3) {
              this.chart.xAxis[0].setExtremes(t3.min, t3.max, t3.redraw, t3.animation, t3.eventArguments);
            }));
          }
          destroy() {
            this.removeEvents(), this.xAxis && (v(this.chart.xAxis, this.xAxis), v(this.chart.axes, this.xAxis)), this.yAxis && (v(this.chart.yAxis, this.yAxis), v(this.chart.axes, this.yAxis)), (this.series || []).forEach((t3) => {
              t3.destroy && t3.destroy();
            }), ["series", "xAxis", "yAxis", "shades", "outline", "scrollbarTrack", "scrollbarRifles", "scrollbarGroup", "scrollbar", "navigatorGroup", "rendered"].forEach((t3) => {
              this[t3] && this[t3].destroy && this[t3].destroy(), this[t3] = null;
            }), [this.handles].forEach((t3) => {
              m(t3);
            }), this.navigatorEnabled = false;
          }
        }
        return O;
      }), e(i, "Stock/Navigator/StandaloneNavigatorDefaults.js", [], function() {
        return { chart: { height: 70, margin: [0, 5, 0, 5] }, exporting: { enabled: false }, legend: { enabled: false }, navigator: { enabled: false }, plotOptions: { series: { states: { hover: { enabled: false } }, marker: { enabled: false } } }, scrollbar: { enabled: false }, title: { text: "" }, tooltip: { enabled: false }, xAxis: { visible: false }, yAxis: { height: 0, visible: false } };
      }), e(i, "Stock/Navigator/StandaloneNavigator.js", [i["Core/Chart/Chart.js"], i["Stock/Navigator/Navigator.js"], i["Core/Globals.js"], i["Core/Utilities.js"], i["Core/Axis/Axis.js"], i["Stock/Navigator/StandaloneNavigatorDefaults.js"]], function(t2, i2, e2, s, a, r) {
        let { merge: o, addEvent: n, fireEvent: h, pick: l } = s;
        class d {
          static navigator(t3, i3) {
            let s2 = new d(t3, i3);
            return e2.navigators ? e2.navigators.push(s2) : e2.navigators = [s2], s2;
          }
          constructor(s2, a2) {
            this.boundAxes = [], this.userOptions = a2, this.chartOptions = o(e2.getOptions(), r, { navigator: a2 });
            let n2 = new t2(s2, this.chartOptions);
            n2.options = o(n2.options, { navigator: { enabled: true }, scrollbar: { enabled: true } }), this.chartOptions.navigator && this.chartOptions.scrollbar && (this.chartOptions.navigator.enabled = true, this.chartOptions.scrollbar.enabled = true), this.navigator = new i2(n2), n2.navigator = this.navigator, this.initNavigator();
          }
          bind(i3, e3 = true) {
            let s2 = this, r2 = i3 instanceof t2 ? i3.xAxis[0] : i3;
            if (!(r2 instanceof a)) return;
            let { min: o2, max: h2 } = this.navigator.xAxis, l2 = [];
            if (e3) {
              let t3 = n(r2, "setExtremes", (t4) => {
                ("pan" === t4.trigger || "zoom" === t4.trigger || "mouseWheelZoom" === t4.trigger) && s2.setRange(t4.min, t4.max, true, "pan" !== t4.trigger, { trigger: r2 });
              });
              l2.push(t3);
            }
            let d2 = n(this.navigator, "setRange", (t3) => {
              r2.setExtremes(t3.min, t3.max, t3.redraw, t3.animation);
            });
            l2.push(d2);
            let c = this.boundAxes.filter(function(t3) {
              return t3.axis === r2;
            })[0];
            c || (c = { axis: r2, callbacks: [] }, this.boundAxes.push(c)), c.callbacks = l2, r2.series.forEach((t3) => {
              t3.options.showInNavigator && s2.addSeries(t3.options);
            }), r2.setExtremes(o2, h2), n(r2, "destroy", (t3) => {
              t3.keepEvents || this.unbind(r2);
            });
          }
          unbind(t3) {
            if (!t3) {
              this.boundAxes.forEach(({ callbacks: t4 }) => {
                t4.forEach((t5) => t5());
              }), this.boundAxes.length = 0;
              return;
            }
            let i3 = t3 instanceof a ? t3 : t3.xAxis[0];
            for (let t4 = this.boundAxes.length - 1; t4 >= 0; t4--) this.boundAxes[t4].axis === i3 && (this.boundAxes[t4].callbacks.forEach((t5) => t5()), this.boundAxes.splice(t4, 1));
          }
          destroy() {
            this.boundAxes.forEach(({ callbacks: t3 }) => {
              t3.forEach((t4) => t4());
            }), this.boundAxes.length = 0, this.navigator.destroy(), this.navigator.chart.destroy();
          }
          update(t3, i3) {
            this.chartOptions = o(this.chartOptions, { navigator: t3 }), this.navigator.chart.update(this.chartOptions, i3);
          }
          redraw() {
            this.navigator.chart.redraw();
          }
          addSeries(t3) {
            this.navigator.chart.addSeries(o(t3, { showInNavigator: l(t3.showInNavigator, true) })), this.navigator.setBaseSeries();
          }
          initNavigator() {
            var _a;
            let t3 = this.navigator;
            t3.top = 1, t3.xAxis.setScale(), t3.yAxis.setScale(), t3.xAxis.render(), t3.yAxis.render(), (_a = t3.series) == null ? void 0 : _a.forEach((t4) => {
              t4.translate(), t4.render(), t4.redraw();
            });
            let { min: i3, max: e3 } = this.getInitialExtremes();
            t3.chart.xAxis[0].userMin = i3, t3.chart.xAxis[0].userMax = e3, t3.render(i3, e3);
          }
          getRange() {
            let { min: t3, max: i3 } = this.navigator.chart.xAxis[0].getExtremes(), { userMin: e3, userMax: s2, min: a2, max: r2 } = this.navigator.xAxis.getExtremes();
            return { min: l(t3, a2), max: l(i3, r2), dataMin: a2, dataMax: r2, userMin: e3, userMax: s2 };
          }
          setRange(t3, i3, e3, s2, a2) {
            h(this.navigator, "setRange", { min: t3, max: i3, redraw: e3, animation: s2, eventArguments: o(a2, { trigger: "navigator" }) });
          }
          getInitialExtremes() {
            let { min: t3, max: i3 } = this.navigator.xAxis.getExtremes();
            return { min: t3, max: i3 };
          }
        }
        return d;
      }), e(i, "masters/modules/navigator.src.js", [i["Core/Globals.js"], i["Stock/Navigator/StandaloneNavigator.js"], i["Stock/Navigator/NavigatorComposition.js"]], function(t2, i2, e2) {
        return t2.StandaloneNavigator = t2.StandaloneNavigator || i2, t2.navigator = t2.StandaloneNavigator.navigator, e2.compose(t2.Chart, t2.Axis, t2.Series), t2;
      });
    });
  }
});
export default require_navigator();
//# sourceMappingURL=highcharts_modules_navigator__js.js.map
