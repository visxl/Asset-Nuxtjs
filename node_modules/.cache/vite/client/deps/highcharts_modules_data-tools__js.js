import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/data-tools.js
var require_data_tools = __commonJS({
  "node_modules/highcharts/modules/data-tools.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Highcharts
    *
    * (c) 2010-2024 Highsoft AS
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/data-tools", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function r(t2, r2, s, o) {
        t2.hasOwnProperty(r2) || (t2[r2] = o.apply(null, s), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: r2, module: t2[r2] } })));
      }
      r(t, "Data/Modifiers/DataModifier.js", [t["Core/Utilities.js"]], function(e2) {
        var t2;
        let { addEvent: r2, fireEvent: s, merge: o } = e2;
        class n {
          benchmark(e3, t3) {
            let r3 = [], s2 = this, n2 = () => {
              s2.modifyTable(e3), s2.emit({ type: "afterBenchmarkIteration" });
            }, { iterations: i } = o({ iterations: 1 }, t3);
            s2.on("afterBenchmarkIteration", () => {
              if (r3.length === i) {
                s2.emit({ type: "afterBenchmark", results: r3 });
                return;
              }
              n2();
            });
            let l = { startTime: 0, endTime: 0 };
            return s2.on("modify", () => {
              l.startTime = window.performance.now();
            }), s2.on("afterModify", () => {
              l.endTime = window.performance.now(), r3.push(l.endTime - l.startTime);
            }), n2(), r3;
          }
          emit(e3) {
            s(this, e3.type, e3);
          }
          modify(e3, t3) {
            let r3 = this;
            return new Promise((s2, o2) => {
              e3.modified === e3 && (e3.modified = e3.clone(false, t3));
              try {
                s2(r3.modifyTable(e3, t3));
              } catch (s3) {
                r3.emit({ type: "error", detail: t3, table: e3 }), o2(s3);
              }
            });
          }
          modifyCell(e3, t3, r3, s2, o2) {
            return this.modifyTable(e3);
          }
          modifyColumns(e3, t3, r3, s2) {
            return this.modifyTable(e3);
          }
          modifyRows(e3, t3, r3, s2) {
            return this.modifyTable(e3);
          }
          on(e3, t3) {
            return r2(this, e3, t3);
          }
        }
        return (t2 = n || (n = {})).types = {}, t2.registerType = function(e3, r3) {
          return !!e3 && !t2.types[e3] && !!(t2.types[e3] = r3);
        }, n;
      }), r(t, "Data/DataTable.js", [t["Core/Utilities.js"]], function(e2) {
        let { addEvent: t2, defined: r2, fireEvent: s, uniqueKey: o } = e2;
        class n {
          static isNull(e3) {
            if (e3 === n.NULL) return true;
            if (e3 instanceof Array) {
              if (!e3.length) return false;
              for (let t3 = 0, r3 = e3.length; t3 < r3; ++t3) if (null !== e3[t3]) return false;
            } else {
              let t3 = Object.keys(e3);
              if (!t3.length) return false;
              for (let r3 = 0, s2 = t3.length; r3 < s2; ++r3) if (null !== e3[t3[r3]]) return false;
            }
            return true;
          }
          constructor(e3 = {}) {
            this.autoId = !e3.id, this.columns = {}, this.id = e3.id || o(), this.modified = this, this.rowCount = 0, this.versionTag = o();
            let t3 = e3.columns || {}, r3 = Object.keys(t3), s2 = this.columns, n2 = 0;
            for (let e4 = 0, o2 = r3.length, i, l; e4 < o2; ++e4) i = t3[l = r3[e4]].slice(), s2[l] = i, n2 = Math.max(n2, i.length);
            for (let e4 = 0, t4 = r3.length; e4 < t4; ++e4) s2[r3[e4]].length = n2;
            this.rowCount = n2;
          }
          clone(e3, t3) {
            let r3 = {};
            this.emit({ type: "cloneTable", detail: t3 }), e3 || (r3.columns = this.columns), this.autoId || (r3.id = this.id);
            let s2 = new n(r3);
            return e3 || (s2.versionTag = this.versionTag, s2.originalRowIndexes = this.originalRowIndexes, s2.localRowIndexes = this.localRowIndexes), this.emit({ type: "afterCloneTable", detail: t3, tableClone: s2 }), s2;
          }
          deleteColumns(e3, t3) {
            let r3 = this.columns, s2 = {}, o2 = {}, n2 = this.modifier, i = this.rowCount;
            if ((e3 = e3 || Object.keys(r3)).length) {
              this.emit({ type: "deleteColumns", columnNames: e3, detail: t3 });
              for (let t4 = 0, n3 = e3.length, l, a; t4 < n3; ++t4) (l = r3[a = e3[t4]]) && (s2[a] = l, o2[a] = Array(i)), delete r3[a];
              return Object.keys(r3).length || (this.rowCount = 0, this.deleteRowIndexReferences()), n2 && n2.modifyColumns(this, o2, 0, t3), this.emit({ type: "afterDeleteColumns", columns: s2, columnNames: e3, detail: t3 }), s2;
            }
          }
          deleteRowIndexReferences() {
            delete this.originalRowIndexes, delete this.localRowIndexes;
          }
          deleteRows(e3, t3 = 1, r3) {
            let s2 = [], o2 = [], n2 = this.modifier;
            if (this.emit({ type: "deleteRows", detail: r3, rowCount: t3, rowIndex: e3 || 0 }), void 0 === e3 && (e3 = 0, t3 = this.rowCount), t3 > 0 && e3 < this.rowCount) {
              let r4 = this.columns, n3 = Object.keys(r4);
              for (let i = 0, l = n3.length, a, u; i < l; ++i) {
                u = (a = r4[n3[i]]).splice(e3, t3), i || (this.rowCount = a.length);
                for (let e4 = 0, t4 = u.length; e4 < t4; ++e4) s2[e4] = s2[e4] || [], s2[e4][i] = u[e4];
                o2.push(Array(l));
              }
            }
            return n2 && n2.modifyRows(this, o2, e3 || 0, r3), this.emit({ type: "afterDeleteRows", detail: r3, rowCount: t3, rowIndex: e3 || 0, rows: s2 }), s2;
          }
          emit(e3) {
            switch (e3.type) {
              case "afterDeleteColumns":
              case "afterDeleteRows":
              case "afterSetCell":
              case "afterSetColumns":
              case "afterSetRows":
                this.versionTag = o();
            }
            s(this, e3.type, e3);
          }
          getCell(e3, t3) {
            let r3 = this.columns[e3];
            if (r3) return r3[t3];
          }
          getCellAsBoolean(e3, t3) {
            let r3 = this.columns[e3];
            return !!(r3 && r3[t3]);
          }
          getCellAsNumber(e3, t3, r3) {
            let s2 = this.columns[e3], o2 = s2 && s2[t3];
            switch (typeof o2) {
              case "boolean":
                return o2 ? 1 : 0;
              case "number":
                return isNaN(o2) && !r3 ? null : o2;
            }
            return isNaN(o2 = parseFloat(`${o2 ?? ""}`)) && !r3 ? null : o2;
          }
          getCellAsString(e3, t3) {
            let r3 = this.columns[e3];
            return `${r3 && r3[t3]}`;
          }
          getColumn(e3, t3) {
            return this.getColumns([e3], t3)[e3];
          }
          getColumnAsNumbers(e3, t3) {
            let r3 = this.columns[e3], s2 = [];
            if (r3) {
              let o2 = r3.length;
              if (t3) for (let t4 = 0; t4 < o2; ++t4) s2.push(this.getCellAsNumber(e3, t4, true));
              else {
                for (let e4 = 0, t4; e4 < o2; ++e4) {
                  if ("number" == typeof (t4 = r3[e4])) return r3.slice();
                  if (null != t4) break;
                }
                for (let t4 = 0; t4 < o2; ++t4) s2.push(this.getCellAsNumber(e3, t4));
              }
            }
            return s2;
          }
          getColumnNames() {
            return Object.keys(this.columns);
          }
          getColumns(e3, t3) {
            let r3 = this.columns, s2 = {};
            e3 = e3 || Object.keys(r3);
            for (let o2 = 0, n2 = e3.length, i, l; o2 < n2; ++o2) (i = r3[l = e3[o2]]) && (s2[l] = t3 ? i : i.slice());
            return s2;
          }
          getLocalRowIndex(e3) {
            let { localRowIndexes: t3 } = this;
            return t3 ? t3[e3] : e3;
          }
          getModifier() {
            return this.modifier;
          }
          getOriginalRowIndex(e3) {
            let { originalRowIndexes: t3 } = this;
            return t3 ? t3[e3] : e3;
          }
          getRow(e3, t3) {
            return this.getRows(e3, 1, t3)[0];
          }
          getRowCount() {
            return this.rowCount;
          }
          getRowIndexBy(e3, t3, r3) {
            let s2 = this.columns[e3];
            if (s2) {
              let e4 = s2.indexOf(t3, r3);
              if (-1 !== e4) return e4;
            }
          }
          getRowObject(e3, t3) {
            return this.getRowObjects(e3, 1, t3)[0];
          }
          getRowObjects(e3 = 0, t3 = this.rowCount - e3, r3) {
            let s2 = this.columns, o2 = Array(t3);
            r3 = r3 || Object.keys(s2);
            for (let n2 = e3, i = 0, l = Math.min(this.rowCount, e3 + t3), a, u; n2 < l; ++n2, ++i) for (let e4 of (u = o2[i] = {}, r3)) a = s2[e4], u[e4] = a ? a[n2] : void 0;
            return o2;
          }
          getRows(e3 = 0, t3 = this.rowCount - e3, r3) {
            let s2 = this.columns, o2 = Array(t3);
            r3 = r3 || Object.keys(s2);
            for (let n2 = e3, i = 0, l = Math.min(this.rowCount, e3 + t3), a, u; n2 < l; ++n2, ++i) for (let e4 of (u = o2[i] = [], r3)) a = s2[e4], u.push(a ? a[n2] : void 0);
            return o2;
          }
          getVersionTag() {
            return this.versionTag;
          }
          hasColumns(e3) {
            let t3 = this.columns;
            for (let r3 = 0, s2 = e3.length; r3 < s2; ++r3) if (!t3[e3[r3]]) return false;
            return true;
          }
          hasRowWith(e3, t3) {
            let r3 = this.columns[e3];
            return !!r3 && -1 !== r3.indexOf(t3);
          }
          on(e3, r3) {
            return t2(this, e3, r3);
          }
          renameColumn(e3, t3) {
            let r3 = this.columns;
            return !!r3[e3] && (e3 !== t3 && (r3[t3] = r3[e3], delete r3[e3]), true);
          }
          setCell(e3, t3, r3, s2) {
            let o2 = this.columns, n2 = this.modifier, i = o2[e3];
            i && i[t3] === r3 || (this.emit({ type: "setCell", cellValue: r3, columnName: e3, detail: s2, rowIndex: t3 }), i || (i = o2[e3] = Array(this.rowCount)), t3 >= this.rowCount && (this.rowCount = t3 + 1), i[t3] = r3, n2 && n2.modifyCell(this, e3, t3, r3), this.emit({ type: "afterSetCell", cellValue: r3, columnName: e3, detail: s2, rowIndex: t3 }));
          }
          setColumn(e3, t3 = [], r3 = 0, s2) {
            this.setColumns({ [e3]: t3 }, r3, s2);
          }
          setColumns(e3, t3, r3) {
            let s2 = this.columns, o2 = this.modifier, n2 = void 0 === t3, i = Object.keys(e3);
            this.emit({ type: "setColumns", columns: e3, columnNames: i, detail: r3, rowIndex: t3 });
            for (let r4 = 0, o3 = i.length, l2, a; r4 < o3; ++r4) if (l2 = e3[a = i[r4]], n2) s2[a] = l2.slice(), this.rowCount = l2.length;
            else {
              let e4 = s2[a] ? s2[a] : s2[a] = Array(this.rowCount);
              for (let r5 = t3 || 0, s3 = l2.length; r5 < s3; ++r5) e4[r5] = l2[r5];
              this.rowCount = Math.max(this.rowCount, e4.length);
            }
            let l = Object.keys(s2);
            for (let e4 = 0, t4 = l.length; e4 < t4; ++e4) s2[l[e4]].length = this.rowCount;
            o2 && o2.modifyColumns(this, e3, t3 || 0), this.emit({ type: "afterSetColumns", columns: e3, columnNames: i, detail: r3, rowIndex: t3 });
          }
          setModifier(e3, t3) {
            let r3 = this;
            return r3.emit({ type: "setModifier", detail: t3, modifier: e3, modified: r3.modified }), r3.modified = r3, r3.modifier = e3, (e3 ? e3.modify(r3) : Promise.resolve(r3)).then((r4) => (r4.emit({ type: "afterSetModifier", detail: t3, modifier: e3, modified: r4.modified }), r4)).catch((t4) => {
              throw r3.emit({ type: "setModifierError", error: t4, modifier: e3, modified: r3.modified }), t4;
            });
          }
          setOriginalRowIndexes(e3, t3 = false) {
            if (this.originalRowIndexes = e3, t3) return;
            let s2 = this.localRowIndexes = [];
            for (let t4 = 0, o2 = e3.length, n2; t4 < o2; ++t4) r2(n2 = e3[t4]) && (s2[n2] = t4);
          }
          setRow(e3, t3, r3) {
            this.setRows([e3], t3, r3);
          }
          setRows(e3, t3 = this.rowCount, r3) {
            let s2 = this.columns, o2 = Object.keys(s2), i = this.modifier, l = e3.length;
            this.emit({ type: "setRows", detail: r3, rowCount: l, rowIndex: t3, rows: e3 });
            for (let r4 = 0, i2 = t3, a2; r4 < l; ++r4, ++i2) if ((a2 = e3[r4]) === n.NULL) for (let e4 = 0, t4 = o2.length; e4 < t4; ++e4) s2[o2[e4]][i2] = null;
            else if (a2 instanceof Array) for (let e4 = 0, t4 = o2.length; e4 < t4; ++e4) s2[o2[e4]][i2] = a2[e4];
            else {
              let e4 = Object.keys(a2);
              for (let t4 = 0, r5 = e4.length, o3; t4 < r5; ++t4) s2[o3 = e4[t4]] || (s2[o3] = Array(i2 + 1)), s2[o3][i2] = a2[o3];
            }
            let a = t3 + l;
            if (a > this.rowCount) {
              this.rowCount = a;
              for (let e4 = 0, t4 = o2.length; e4 < t4; ++e4) s2[o2[e4]].length = a;
            }
            i && i.modifyRows(this, e3, t3), this.emit({ type: "afterSetRows", detail: r3, rowCount: l, rowIndex: t3, rows: e3 });
          }
        }
        return n.NULL = {}, n.version = "1.0.0", n;
      }), r(t, "Data/Connectors/DataConnector.js", [t["Data/Modifiers/DataModifier.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2, r2) {
        var s;
        let { addEvent: o, fireEvent: n, merge: i, pick: l } = r2;
        class a {
          constructor(e3 = {}) {
            this.table = new t2(e3.dataTable), this.metadata = e3.metadata || { columns: {} };
          }
          get polling() {
            return !!this.polling;
          }
          describeColumn(e3, t3) {
            let r3 = this.metadata.columns;
            r3[e3] = i(r3[e3] || {}, t3);
          }
          describeColumns(e3) {
            let t3;
            let r3 = Object.keys(e3);
            for (; "string" == typeof (t3 = r3.pop()); ) this.describeColumn(t3, e3[t3]);
          }
          emit(e3) {
            n(this, e3.type, e3);
          }
          getColumnOrder(e3) {
            let t3 = this.metadata.columns, r3 = Object.keys(t3 || {});
            if (r3.length) return r3.sort((e4, r4) => l(t3[e4].index, 0) - l(t3[r4].index, 0));
          }
          getSortedColumns(e3) {
            return this.table.getColumns(this.getColumnOrder(e3));
          }
          load() {
            return n(this, "afterLoad", { table: this.table }), Promise.resolve(this);
          }
          on(e3, t3) {
            return o(this, e3, t3);
          }
          save() {
            return n(this, "saveError", { table: this.table }), Promise.reject(Error("Not implemented"));
          }
          setColumnOrder(e3) {
            for (let t3 = 0, r3 = e3.length; t3 < r3; ++t3) this.describeColumn(e3[t3], { index: t3 });
          }
          setModifierOptions(t3) {
            let r3 = t3 && e2.types[t3.type];
            return this.table.setModifier(r3 ? new r3(t3) : void 0).then(() => this);
          }
          startPolling(e3 = 1e3) {
            let t3 = this;
            window.clearTimeout(t3._polling), t3._polling = window.setTimeout(() => t3.load().catch((e4) => t3.emit({ type: "loadError", error: e4, table: t3.table })).then(() => {
              t3._polling && t3.startPolling(e3);
            }), e3);
          }
          stopPolling() {
            window.clearTimeout(this._polling), delete this._polling;
          }
          whatIs(e3) {
            return this.metadata.columns[e3];
          }
        }
        return (s = a || (a = {})).types = {}, s.registerType = function(e3, t3) {
          return !!e3 && !s.types[e3] && !!(s.types[e3] = t3);
        }, a;
      }), r(t, "Data/Converters/DataConverter.js", [t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { addEvent: r2, fireEvent: s, isNumber: o, merge: n } = t2;
        class i {
          constructor(e3) {
            this.dateFormats = { "YYYY/mm/dd": { regex: /^(\d{4})([\-\.\/])(\d{1,2})\2(\d{1,2})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[1], e4[3] - 1, +e4[4]) : NaN;
            } }, "dd/mm/YYYY": { regex: /^(\d{1,2})([\-\.\/])(\d{1,2})\2(\d{4})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4], e4[3] - 1, +e4[1]) : NaN;
            }, alternative: "mm/dd/YYYY" }, "mm/dd/YYYY": { regex: /^(\d{1,2})([\-\.\/])(\d{1,2})\2(\d{4})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4], e4[1] - 1, +e4[3]) : NaN;
            } }, "dd/mm/YY": { regex: /^(\d{1,2})([\-\.\/])(\d{1,2})\2(\d{2})$/, parser: function(e4) {
              let t4 = /* @__PURE__ */ new Date();
              if (!e4) return NaN;
              let r4 = +e4[4];
              return r4 > t4.getFullYear() - 2e3 ? r4 += 1900 : r4 += 2e3, Date.UTC(r4, e4[3] - 1, +e4[1]);
            }, alternative: "mm/dd/YY" }, "mm/dd/YY": { regex: /^(\d{1,2})([\-\.\/])(\d{1,2})\2(\d{2})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4] + 2e3, e4[1] - 1, +e4[3]) : NaN;
            } } };
            let t3 = n(i.defaultOptions, e3), r3 = t3.decimalPoint;
            ("." === r3 || "," === r3) && (r3 = "." === r3 ? "\\." : ",", this.decimalRegExp = RegExp("^(-?[0-9]+)" + r3 + "([0-9]+)$")), this.options = t3;
          }
          asBoolean(e3) {
            return "boolean" == typeof e3 ? e3 : "string" == typeof e3 ? "" !== e3 && "0" !== e3 && "false" !== e3 : !!this.asNumber(e3);
          }
          asDate(e3) {
            let t3;
            if ("string" == typeof e3) t3 = this.parseDate(e3);
            else if ("number" == typeof e3) t3 = e3;
            else {
              if (e3 instanceof Date) return e3;
              t3 = this.parseDate(this.asString(e3));
            }
            return new Date(t3);
          }
          asGuessedType(e3) {
            return { number: this.asNumber, Date: this.asDate, string: this.asString }[this.guessType(e3)].call(this, e3);
          }
          asNumber(e3) {
            if ("number" == typeof e3) return e3;
            if ("boolean" == typeof e3) return e3 ? 1 : 0;
            if ("string" == typeof e3) {
              let t3 = this.decimalRegExp;
              if (e3.indexOf(" ") > -1 && (e3 = e3.replace(/\s+/g, "")), t3) {
                if (!t3.test(e3)) return NaN;
                e3 = e3.replace(t3, "$1.$2");
              }
              return parseFloat(e3);
            }
            return e3 instanceof Date ? e3.getDate() : e3 ? e3.getRowCount() : NaN;
          }
          asString(e3) {
            return "" + e3;
          }
          deduceDateFormat(e3, t3, r3) {
            let s2 = [], o2 = [], n2 = "YYYY/mm/dd", i2, l = [], a = 0, u = false, h, c;
            for ((!t3 || t3 > e3.length) && (t3 = e3.length); a < t3; a++) if (void 0 !== e3[a] && e3[a] && e3[a].length) for (c = 0, i2 = e3[a].trim().replace(/[\-\.\/]/g, " ").split(" "), l = ["", "", ""]; c < i2.length; c++) c < l.length && (h = parseInt(i2[c], 10)) && (o2[c] = !o2[c] || o2[c] < h ? h : o2[c], void 0 !== s2[c] ? s2[c] !== h && (s2[c] = false) : s2[c] = h, h > 31 ? h < 100 ? l[c] = "YY" : l[c] = "YYYY" : h > 12 && h <= 31 ? (l[c] = "dd", u = true) : l[c].length || (l[c] = "mm"));
            if (u) {
              for (c = 0; c < s2.length; c++) false !== s2[c] ? o2[c] > 12 && "YY" !== l[c] && "YYYY" !== l[c] && (l[c] = "YY") : o2[c] > 12 && "mm" === l[c] && (l[c] = "dd");
              3 === l.length && "dd" === l[1] && "dd" === l[2] && (l[2] = "YY"), n2 = l.join("/");
            }
            return r3 && (this.options.dateFormat = n2), n2;
          }
          emit(e3) {
            s(this, e3.type, e3);
          }
          export(e3, t3) {
            throw this.emit({ type: "exportError", columns: [], headers: [] }), Error("Not implemented");
          }
          getTable() {
            throw Error("Not implemented");
          }
          guessType(e3) {
            let t3 = "string";
            if ("string" == typeof e3) {
              let r3 = this.trim(`${e3}`), s2 = this.decimalRegExp, n2 = this.trim(r3, true);
              s2 && (n2 = s2.test(n2) ? n2.replace(s2, "$1.$2") : "");
              let i2 = parseFloat(n2);
              +n2 === i2 ? e3 = i2 : t3 = o(this.parseDate(e3)) ? "Date" : "string";
            }
            return "number" == typeof e3 && (t3 = e3 > 31536e6 ? "Date" : "number"), t3;
          }
          on(e3, t3) {
            return r2(this, e3, t3);
          }
          parse(e3) {
            throw this.emit({ type: "parseError", columns: [], headers: [] }), Error("Not implemented");
          }
          parseDate(e3, t3) {
            let r3 = this.options, s2 = t3 || r3.dateFormat, n2 = NaN, i2, l, a;
            if (r3.parseDate) n2 = r3.parseDate(e3);
            else {
              if (s2) (l = this.dateFormats[s2]) || (l = this.dateFormats["YYYY/mm/dd"]), (a = e3.match(l.regex)) && (n2 = l.parser(a));
              else for (i2 in this.dateFormats) if (l = this.dateFormats[i2], a = e3.match(l.regex)) {
                s2 = i2, n2 = l.parser(a);
                break;
              }
              !a && ("object" == typeof (a = Date.parse(e3)) && null !== a && a.getTime ? n2 = a.getTime() - 6e4 * a.getTimezoneOffset() : o(a) && (n2 = a - 6e4 * new Date(a).getTimezoneOffset(), -1 === e3.indexOf("2001") && 2001 === new Date(n2).getFullYear() && (n2 = NaN)));
            }
            return n2;
          }
          trim(e3, t3) {
            return "string" == typeof e3 && (e3 = e3.replace(/^\s+|\s+$/g, ""), t3 && /^[\d\s]+$/.test(e3) && (e3 = e3.replace(/\s/g, ""))), e3;
          }
        }
        return i.defaultOptions = { dateFormat: "", alternativeFormat: "", startColumn: 0, endColumn: Number.MAX_VALUE, startRow: 0, endRow: Number.MAX_VALUE, firstRowAsNames: true, switchRowsAndColumns: false }, (i || (i = {})).getTableFromColumns = function(t3 = [], r3 = []) {
          let s2 = new e2();
          for (let e3 = 0, o2 = Math.max(r3.length, t3.length); e3 < o2; ++e3) s2.setColumn(r3[e3] || `${e3}`, t3[e3]);
          return s2;
        }, i;
      }), r(t, "Data/DataCursor.js", [], function() {
        class e2 {
          constructor(e3 = {}) {
            this.emittingRegister = [], this.listenerMap = {}, this.stateMap = e3;
          }
          addListener(e3, t2, r2) {
            let s = this.listenerMap[e3] = this.listenerMap[e3] || {};
            return (s[t2] = s[t2] || []).push(r2), this;
          }
          buildEmittingTag(e3) {
            return ("position" === e3.cursor.type ? [e3.table.id, e3.cursor.column, e3.cursor.row, e3.cursor.state, e3.cursor.type] : [e3.table.id, e3.cursor.columns, e3.cursor.firstRow, e3.cursor.lastRow, e3.cursor.state, e3.cursor.type]).join("\0");
          }
          emitCursor(t2, r2, s, o) {
            let n = t2.id, i = r2.state, l = this.listenerMap[n] && this.listenerMap[n][i];
            if (l) {
              let i2 = this.stateMap[n] = this.stateMap[n] ?? {}, a = i2[r2.state] || [];
              o && (a.length || (i2[r2.state] = a), -1 === e2.getIndex(r2, a) && a.push(r2));
              let u = { cursor: r2, cursors: a, table: t2 };
              s && (u.event = s);
              let h = this.emittingRegister, c = this.buildEmittingTag(u);
              if (h.indexOf(c) >= 0) return this;
              try {
                this.emittingRegister.push(c);
                for (let e3 = 0, t3 = l.length; e3 < t3; ++e3) l[e3].call(this, u);
              } finally {
                let e3 = this.emittingRegister.indexOf(c);
                e3 >= 0 && this.emittingRegister.splice(e3, 1);
              }
            }
            return this;
          }
          remitCursor(t2, r2) {
            let s = this.stateMap[t2] && this.stateMap[t2][r2.state];
            if (s) {
              let t3 = e2.getIndex(r2, s);
              t3 >= 0 && s.splice(t3, 1);
            }
            return this;
          }
          removeListener(e3, t2, r2) {
            let s = this.listenerMap[e3] && this.listenerMap[e3][t2];
            if (s) {
              let e4 = s.indexOf(r2);
              e4 >= 0 && s.splice(e4, 1);
            }
            return this;
          }
        }
        return e2.version = "1.0.0", function(e3) {
          function t2(e4, t3) {
            if ("range" === e4.type) return e4;
            let r2 = { type: "range", firstRow: e4.row ?? (t3 && t3.firstRow) ?? 0, lastRow: e4.row ?? (t3 && t3.lastRow) ?? Number.MAX_VALUE, state: e4.state };
            return void 0 !== e4.column && (r2.columns = [e4.column]), r2;
          }
          e3.getIndex = function(e4, t3) {
            if ("position" === e4.type) {
              for (let r2, s = 0, o = t3.length; s < o; ++s) if ("position" === (r2 = t3[s]).type && r2.state === e4.state && r2.column === e4.column && r2.row === e4.row) return s;
            } else {
              let r2 = JSON.stringify(e4.columns);
              for (let s, o = 0, n = t3.length; o < n; ++o) if ("range" === (s = t3[o]).type && s.state === e4.state && s.firstRow === e4.firstRow && s.lastRow === e4.lastRow && JSON.stringify(s.columns) === r2) return o;
            }
            return -1;
          }, e3.isEqual = function(e4, t3) {
            return "position" === e4.type && "position" === t3.type ? e4.column === t3.column && e4.row === t3.row && e4.state === t3.state : "range" === e4.type && "range" === t3.type && e4.firstRow === t3.firstRow && e4.lastRow === t3.lastRow && JSON.stringify(e4.columns) === JSON.stringify(t3.columns);
          }, e3.isInRange = function(e4, r2) {
            "position" === r2.type && (r2 = t2(r2)), "position" === e4.type && (e4 = t2(e4, r2));
            let s = e4.columns, o = r2.columns;
            return e4.firstRow >= r2.firstRow && e4.lastRow <= r2.lastRow && (!s || !o || s.every((e5) => o.indexOf(e5) >= 0));
          }, e3.toPositions = function(e4) {
            if ("position" === e4.type) return [e4];
            let t3 = e4.columns || [], r2 = [], s = e4.state;
            for (let o = e4.firstRow, n = e4.lastRow; o < n; ++o) {
              if (!t3.length) {
                r2.push({ type: "position", row: o, state: s });
                continue;
              }
              for (let e5 = 0, n2 = t3.length; e5 < n2; ++e5) r2.push({ type: "position", column: t3[e5], row: o, state: s });
            }
            return r2;
          }, e3.toRange = t2;
        }(e2 || (e2 = {})), e2;
      }), r(t, "Data/DataPoolDefaults.js", [], function() {
        return { connectors: [] };
      }), r(t, "Data/DataPool.js", [t["Data/Connectors/DataConnector.js"], t["Data/DataPoolDefaults.js"], t["Core/Utilities.js"]], function(e2, t2, r2) {
        class s {
          constructor(e3 = t2) {
            e3.connectors = e3.connectors || [], this.connectors = {}, this.options = e3, this.waiting = {};
          }
          emit(e3) {
            r2.fireEvent(this, e3.type, e3);
          }
          getConnector(e3) {
            let t3 = this.connectors[e3];
            if (t3) return Promise.resolve(t3);
            let r3 = this.waiting[e3];
            if (!r3) {
              r3 = this.waiting[e3] = [];
              let t4 = this.getConnectorOptions(e3);
              if (!t4) throw Error(`Connector '${e3}' not found.`);
              this.loadConnector(t4).then((t5) => {
                delete this.waiting[e3];
                for (let e4 = 0, s2 = r3.length; e4 < s2; ++e4) r3[e4][0](t5);
              }).catch((t5) => {
                delete this.waiting[e3];
                for (let e4 = 0, s2 = r3.length; e4 < s2; ++e4) r3[e4][1](t5);
              });
            }
            return new Promise((e4, t4) => {
              r3.push([e4, t4]);
            });
          }
          getConnectorIds() {
            let e3 = this.options.connectors, t3 = [];
            for (let r3 = 0, s2 = e3.length; r3 < s2; ++r3) t3.push(e3[r3].id);
            return t3;
          }
          getConnectorOptions(e3) {
            let t3 = this.options.connectors;
            for (let r3 = 0, s2 = t3.length; r3 < s2; ++r3) if (t3[r3].id === e3) return t3[r3];
          }
          getConnectorTable(e3) {
            return this.getConnector(e3).then((e4) => e4.table);
          }
          isNewConnector(e3) {
            return !this.connectors[e3];
          }
          loadConnector(t3) {
            return new Promise((r3, s2) => {
              this.emit({ type: "load", options: t3 });
              let o = e2.types[t3.type];
              if (!o) throw Error(`Connector type not found. (${t3.type})`);
              new o(t3.options).load().then((e3) => {
                this.connectors[t3.id] = e3, this.emit({ type: "afterLoad", options: t3 }), r3(e3);
              }).catch(s2);
            });
          }
          on(e3, t3) {
            return r2.addEvent(this, e3, t3);
          }
          setConnectorOptions(e3) {
            let t3 = this.options.connectors, r3 = this.connectors;
            this.emit({ type: "setConnectorOptions", options: e3 });
            for (let r4 = 0, s2 = t3.length; r4 < s2; ++r4) if (t3[r4].id === e3.id) {
              t3.splice(r4, 1);
              break;
            }
            r3[e3.id] && (r3[e3.id].stopPolling(), delete r3[e3.id]), t3.push(e3), this.emit({ type: "afterSetConnectorOptions", options: e3 });
          }
        }
        return s.version = "1.0.0", s;
      }), r(t, "Data/Formula/FormulaParser.js", [], function() {
        let e2 = /^(?:FALSE|TRUE)/, t2 = /^[+\-]?\d+(?:\.\d+)?(?:e[+\-]\d+)?/, r2 = /^[+\-]?\d+(?:,\d+)?(?:e[+\-]\d+)?/, s = /^([A-Z][A-Z\d\.]*)\(/, o = /^(?:[+\-*\/^<=>]|<=|=>)/, n = /^(\$?[A-Z]+)(\$?\d+)\:(\$?[A-Z]+)(\$?\d+)/, i = /^R(\d*|\[\d+\])C(\d*|\[\d+\])\:R(\d*|\[\d+\])C(\d*|\[\d+\])/, l = /^(\$?[A-Z]+)(\$?\d+)(?![\:C])/, a = /^R(\d*|\[\d+\])C(\d*|\[\d+\])(?!\:)/;
        function u(e3) {
          let t3 = 0;
          for (let r3 = 0, s2 = e3.length, o2, n2 = 1; r3 < s2; ++r3) {
            if ("(" === (o2 = e3[r3])) {
              t3 || (n2 = r3 + 1), ++t3;
              continue;
            }
            if (")" === o2 && !--t3) return e3.substring(n2, r3);
          }
          if (t3 > 0) {
            let e4 = Error("Incomplete parantheses.");
            throw e4.name = "FormulaParseError", e4;
          }
          return "";
        }
        function h(e3) {
          let t3 = -1;
          for (let r4 = 0, s2 = e3.length, o2, n2 = false; r4 < s2; ++r4) {
            if ("\\" === (o2 = e3[r4])) {
              n2 = !n2;
              continue;
            }
            if (n2) {
              n2 = false;
              continue;
            }
            if ('"' === o2) {
              if (!(t3 < 0)) return e3.substring(t3 + 1, r4);
              t3 = r4;
            }
          }
          let r3 = Error("Incomplete string.");
          throw r3.name = "FormulaParseError", r3;
        }
        function c(e3, t3) {
          let r3;
          if (r3 = e3.match(i)) {
            let e4 = "" === r3[2] || "[" === r3[2][0], t4 = "" === r3[1] || "[" === r3[1][0], s3 = "" === r3[4] || "[" === r3[4][0], o2 = "" === r3[3] || "[" === r3[3][0], n2 = { type: "range", beginColumn: e4 ? parseInt(r3[2].substring(1, -1) || "0", 10) : parseInt(r3[2], 10) - 1, beginRow: t4 ? parseInt(r3[1].substring(1, -1) || "0", 10) : parseInt(r3[1], 10) - 1, endColumn: s3 ? parseInt(r3[4].substring(1, -1) || "0", 10) : parseInt(r3[4], 10) - 1, endRow: o2 ? parseInt(r3[3].substring(1, -1) || "0", 10) : parseInt(r3[3], 10) - 1 };
            return e4 && (n2.beginColumnRelative = true), t4 && (n2.beginRowRelative = true), s3 && (n2.endColumnRelative = true), o2 && (n2.endRowRelative = true), n2;
          }
          if (r3 = e3.match(n)) {
            let e4 = "$" !== r3[1][0], t4 = "$" !== r3[2][0], s3 = "$" !== r3[3][0], o2 = "$" !== r3[4][0], n2 = { type: "range", beginColumn: f(e4 ? r3[1] : r3[1].substring(1)) - 1, beginRow: parseInt(t4 ? r3[2] : r3[2].substring(1), 10) - 1, endColumn: f(s3 ? r3[3] : r3[3].substring(1)) - 1, endRow: parseInt(o2 ? r3[4] : r3[4].substring(1), 10) - 1 };
            return e4 && (n2.beginColumnRelative = true), t4 && (n2.beginRowRelative = true), s3 && (n2.endColumnRelative = true), o2 && (n2.endRowRelative = true), n2;
          }
          let s2 = m(e3, t3);
          return 1 === s2.length && "string" != typeof s2[0] ? s2[0] : s2;
        }
        function m(n2, i2) {
          let d = i2 ? r2 : t2, p = [], g, y = ("=" === n2[0] ? n2.substring(1) : n2).trim();
          for (; y; ) {
            if (g = y.match(a)) {
              let e3 = "" === g[2] || "[" === g[2][0], t4 = "" === g[1] || "[" === g[1][0], r4 = { type: "reference", column: e3 ? parseInt(g[2].substring(1, -1) || "0", 10) : parseInt(g[2], 10) - 1, row: t4 ? parseInt(g[1].substring(1, -1) || "0", 10) : parseInt(g[1], 10) - 1 };
              e3 && (r4.columnRelative = true), t4 && (r4.rowRelative = true), p.push(r4), y = y.substring(g[0].length).trim();
              continue;
            }
            if (g = y.match(l)) {
              let e3 = "$" !== g[1][0], t4 = "$" !== g[2][0], r4 = { type: "reference", column: f(e3 ? g[1] : g[1].substring(1)) - 1, row: parseInt(t4 ? g[2] : g[2].substring(1), 10) - 1 };
              e3 && (r4.columnRelative = true), t4 && (r4.rowRelative = true), p.push(r4), y = y.substring(g[0].length).trim();
              continue;
            }
            if (g = y.match(o)) {
              p.push(g[0]), y = y.substring(g[0].length).trim();
              continue;
            }
            if (g = y.match(e2)) {
              p.push("TRUE" === g[0]), y = y.substring(g[0].length).trim();
              continue;
            }
            if (g = y.match(d)) {
              p.push(parseFloat(g[0])), y = y.substring(g[0].length).trim();
              continue;
            }
            if ('"' === y[0]) {
              let e3 = h(y);
              p.push(e3.substring(1, -1)), y = y.substring(e3.length + 2).trim();
              continue;
            }
            if (g = y.match(s)) {
              let e3 = u(y = y.substring(g[1].length).trim());
              p.push({ type: "function", name: g[1], args: function(e4, t4) {
                let r4 = [], s2 = t4 ? ";" : ",", o2 = 0, n3 = "";
                for (let i3 = 0, l2 = e4.length, a2; i3 < l2; ++i3) if ((a2 = e4[i3]) === s2 && !o2 && n3) r4.push(c(n3, t4)), n3 = "";
                else if ('"' !== a2 || o2 || n3) " " !== a2 && (n3 += a2, "(" === a2 ? ++o2 : ")" === a2 && --o2);
                else {
                  let t5 = h(e4.substring(i3));
                  r4.push(t5), i3 += t5.length + 1;
                }
                return !o2 && n3 && r4.push(c(n3, t4)), r4;
              }(e3, i2) }), y = y.substring(e3.length + 2).trim();
              continue;
            }
            if ("(" === y[0]) {
              let e3 = u(y);
              if (e3) {
                p.push(m(e3, i2)), y = y.substring(e3.length + 2).trim();
                continue;
              }
            }
            let t3 = n2.length - y.length, r3 = Error("Unexpected character `" + n2.substring(t3, t3 + 1) + "` at position " + (t3 + 1) + ". (`..." + n2.substring(t3 - 5, t3 + 6) + "...`)");
            throw r3.name = "FormulaParseError", r3;
          }
          return p;
        }
        function f(e3) {
          let t3 = 0;
          for (let r3 = 0, s2 = e3.length, o2, n2 = e3.length - 1; r3 < s2; ++r3) (o2 = e3.charCodeAt(r3)) >= 65 && o2 <= 90 && (t3 += (o2 - 64) * Math.pow(26, n2)), --n2;
          return t3;
        }
        return { parseFormula: m };
      }), r(t, "Data/Formula/FormulaTypes.js", [], function() {
        let e2 = ["+", "-", "*", "/", "^", "=", "<", "<=", ">", ">="];
        return { isFormula: function(e3) {
          return e3 instanceof Array;
        }, isFunction: function(e3) {
          return "object" == typeof e3 && !(e3 instanceof Array) && "function" === e3.type;
        }, isOperator: function(t2) {
          return "string" == typeof t2 && e2.indexOf(t2) >= 0;
        }, isRange: function(e3) {
          return "object" == typeof e3 && !(e3 instanceof Array) && "range" === e3.type;
        }, isReference: function(e3) {
          return "object" == typeof e3 && !(e3 instanceof Array) && "reference" === e3.type;
        }, isValue: function(e3) {
          return "boolean" == typeof e3 || "number" == typeof e3 || "string" == typeof e3;
        } };
      }), r(t, "Data/Formula/FormulaProcessor.js", [t["Data/Formula/FormulaTypes.js"]], function(e2) {
        let { isFormula: t2, isFunction: r2, isOperator: s, isRange: o, isReference: n, isValue: i } = e2, l = / */, a = Number.MAX_VALUE / 1.000000000001, u = Number.MAX_VALUE / 1.000000000002, h = Number.MAX_VALUE, c = { "^": 3, "*": 2, "/": 2, "+": 1, "-": 1, "=": 0, "<": 0, "<=": 0, ">": 0, ">=": 0 }, m = {}, f = /^[A-Z][A-Z\.]*$/;
        function d(e3) {
          switch (typeof e3) {
            case "boolean":
              return e3 ? h : a;
            case "string":
              return u;
            case "number":
              return e3;
            default:
              return NaN;
          }
        }
        function p(e3) {
          return "string" == typeof e3 ? e3.toLowerCase().replace(l, "\0") : e3;
        }
        function g(e3) {
          switch (typeof e3) {
            case "boolean":
              return e3 ? 1 : 0;
            case "string":
              return parseFloat(e3.replace(",", "."));
            case "number":
              return e3;
            default:
              return NaN;
          }
        }
        function y(e3, t3, r3) {
          let s2;
          switch (e3) {
            case "=":
              return p(t3) === p(r3);
            case "<":
              if (typeof t3 == typeof r3) return p(t3) < p(r3);
              return d(t3) < d(r3);
            case "<=":
              if (typeof t3 == typeof r3) return p(t3) <= p(r3);
              return d(t3) <= d(r3);
            case ">":
              if (typeof t3 == typeof r3) return p(t3) > p(r3);
              return d(t3) > d(r3);
            case ">=":
              if (typeof t3 == typeof r3) return p(t3) >= p(r3);
              return d(t3) >= d(r3);
          }
          switch (t3 = g(t3), r3 = g(r3), e3) {
            case "+":
              s2 = t3 + r3;
              break;
            case "-":
              s2 = t3 - r3;
              break;
            case "*":
              s2 = t3 * r3;
              break;
            case "/":
              s2 = t3 / r3;
              break;
            case "^":
              s2 = Math.pow(t3, r3);
              break;
            default:
              return NaN;
          }
          return s2 % 1 ? Math.round(1e9 * s2) / 1e9 : s2;
        }
        function b(e3, s2) {
          return i(e3) ? e3 : o(e3) ? s2 && C(e3, s2) || [] : r2(e3) ? R(e3, s2) : D(t2(e3) ? e3 : [e3], s2);
        }
        function C(e3, t3) {
          let r3 = t3.getColumnNames().slice(e3.beginColumn, e3.endColumn + 1), s2 = [];
          for (let o2 = 0, n2 = r3.length, l2; o2 < n2; ++o2) {
            let n3 = t3.getColumn(r3[o2], true) || [];
            for (let a2 = e3.beginRow, u2 = e3.endRow + 1; a2 < u2; ++a2) "string" == typeof (l2 = n3[a2]) && "=" === l2[0] && t3 !== t3.modified && (l2 = t3.modified.getCell(r3[o2], a2)), s2.push(i(l2) ? l2 : NaN);
          }
          return s2;
        }
        function w(e3, t3) {
          let r3 = t3.getColumnNames()[e3.column];
          if (r3) {
            let s2 = t3.getCell(r3, e3.row);
            if ("string" == typeof s2 && "=" === s2[0] && t3 !== t3.modified) {
              let s3 = t3.modified.getCell(r3, e3.row);
              return i(s3) ? s3 : NaN;
            }
            return i(s2) ? s2 : NaN;
          }
          return NaN;
        }
        function D(e3, o2) {
          let l2;
          for (let a2 = 0, u2 = e3.length, h2, m2, f2, d2; a2 < u2; ++a2) {
            if (s(h2 = e3[a2])) {
              m2 = h2;
              continue;
            }
            if (i(h2) ? d2 = h2 : t2(h2) ? d2 = D(e3, o2) : r2(h2) ? d2 = i(f2 = R(h2, o2)) ? f2 : NaN : n(h2) && (d2 = o2 && w(h2, o2)), void 0 !== d2) {
              if (void 0 === l2) l2 = m2 ? y(m2, 0, d2) : d2;
              else {
                if (!m2) return NaN;
                let t3 = e3[a2 + 1];
                s(t3) && c[t3] > c[m2] && (d2 = y(t3, d2, D(e3.slice(a2 + 2))), a2 = u2), l2 = y(m2, l2, d2);
              }
              m2 = void 0, d2 = void 0;
            }
          }
          return i(l2) ? l2 : NaN;
        }
        function R(e3, t3, r3) {
          let s2 = m[e3.name];
          if (s2) try {
            return s2(e3.args, t3);
          } catch {
            return NaN;
          }
          let o2 = Error(`Function "${e3.name}" not found.`);
          throw o2.name = "FormulaProcessError", o2;
        }
        return { asNumber: g, getArgumentValue: b, getArgumentsValues: function(e3, t3) {
          let r3 = [];
          for (let s2 = 0, o2 = e3.length; s2 < o2; ++s2) r3.push(b(e3[s2], t3));
          return r3;
        }, getRangeValues: C, getReferenceValue: w, processFormula: D, processorFunctions: m, registerProcessorFunction: function(e3, t3) {
          return f.test(e3) && !m[e3] && !!(m[e3] = t3);
        }, translateReferences: function e3(t3, s2 = 0, i2 = 0) {
          for (let l2 = 0, a2 = t3.length, u2; l2 < a2; ++l2) (u2 = t3[l2]) instanceof Array ? e3(u2, s2, i2) : r2(u2) ? e3(u2.args, s2, i2) : o(u2) ? (u2.beginColumnRelative && (u2.beginColumn += s2), u2.beginRowRelative && (u2.beginRow += i2), u2.endColumnRelative && (u2.endColumn += s2), u2.endRowRelative && (u2.endRow += i2)) : n(u2) && (u2.columnRelative && (u2.column += s2), u2.rowRelative && (u2.row += i2));
          return t3;
        } };
      }), r(t, "Data/Formula/Functions/ABS.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, r3) {
          let s = t2(e3[0], r3);
          switch (typeof s) {
            case "number":
              return Math.abs(s);
            case "object": {
              let e4 = [];
              for (let t3 = 0, r4 = s.length, o; t3 < r4; ++t3) {
                if ("number" != typeof (o = s[t3])) return NaN;
                e4.push(Math.abs(o));
              }
              return e4;
            }
            default:
              return NaN;
          }
        }
        return e2.registerProcessorFunction("ABS", r2), r2;
      }), r(t, "Data/Formula/Functions/AND.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, s) {
          for (let o = 0, n = e3.length, i; o < n; ++o) if (!(i = t2(e3[o], s)) || "object" == typeof i && !r2(i, s)) return false;
          return true;
        }
        return e2.registerProcessorFunction("AND", r2), r2;
      }), r(t, "Data/Formula/Functions/AVERAGE.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentsValues: t2 } = e2;
        function r2(e3, r3) {
          let s = t2(e3, r3), o = 0, n = 0;
          for (let e4 = 0, t3 = s.length, r4; e4 < t3; ++e4) switch (typeof (r4 = s[e4])) {
            case "number":
              isNaN(r4) || (++o, n += r4);
              break;
            case "object":
              for (let e5 = 0, t4 = r4.length, s2; e5 < t4; ++e5) "number" != typeof (s2 = r4[e5]) || isNaN(s2) || (++o, n += s2);
          }
          return o ? n / o : 0;
        }
        return e2.registerProcessorFunction("AVERAGE", r2), r2;
      }), r(t, "Data/Formula/Functions/AVERAGEA.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, r3) {
          let s = 0, o = 0;
          for (let n = 0, i = e3.length, l; n < i; ++n) switch (typeof (l = t2(e3[n], r3))) {
            case "boolean":
              ++s, o += l ? 1 : 0;
              continue;
            case "number":
              isNaN(l) || (++s, o += l);
              continue;
            case "string":
              ++s;
              continue;
            default:
              for (let e4 = 0, t3 = l.length, r4; e4 < t3; ++e4) switch (typeof (r4 = l[e4])) {
                case "boolean":
                  ++s, o += r4 ? 1 : 0;
                  continue;
                case "number":
                  isNaN(r4) || (++s, o += r4);
                  continue;
                case "string":
                  ++s;
                  continue;
              }
              continue;
          }
          return s ? o / s : 0;
        }
        return e2.registerProcessorFunction("AVERAGEA", r2), r2;
      }), r(t, "Data/Formula/Functions/COUNT.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(r2, s) {
          let o = e2.getArgumentsValues(r2, s), n = 0;
          for (let e3 = 0, r3 = o.length, i; e3 < r3; ++e3) switch (typeof (i = o[e3])) {
            case "number":
              !isNaN(i) && ++n;
              break;
            case "object":
              n += t2(i, s);
          }
          return n;
        }
        return e2.registerProcessorFunction("COUNT", t2), t2;
      }), r(t, "Data/Formula/Functions/COUNTA.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(r2, s) {
          let o = e2.getArgumentsValues(r2, s), n = 0;
          for (let e3 = 0, r3 = o.length, i; e3 < r3; ++e3) {
            switch (typeof (i = o[e3])) {
              case "number":
                if (isNaN(i)) continue;
                break;
              case "object":
                n += t2(i, s);
                continue;
              case "string":
                if (!i) continue;
            }
            ++n;
          }
          return n;
        }
        return e2.registerProcessorFunction("COUNTA", t2), t2;
      }), r(t, "Data/Formula/Functions/IF.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, r3) {
          return t2(e3[0], r3) ? t2(e3[1], r3) : t2(e3[2], r3);
        }
        return e2.registerProcessorFunction("IF", r2), r2;
      }), r(t, "Data/Formula/Functions/ISNA.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, r3) {
          let s = t2(e3[0], r3);
          return "number" != typeof s || isNaN(s);
        }
        return e2.registerProcessorFunction("ISNA", r2), r2;
      }), r(t, "Data/Formula/Functions/MAX.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentsValues: t2 } = e2;
        function r2(e3, s) {
          let o = t2(e3, s), n = Number.NEGATIVE_INFINITY;
          for (let e4 = 0, t3 = o.length, s2; e4 < t3; ++e4) switch (typeof (s2 = o[e4])) {
            case "number":
              s2 > n && (n = s2);
              break;
            case "object":
              (s2 = r2(s2)) > n && (n = s2);
          }
          return isFinite(n) ? n : 0;
        }
        return e2.registerProcessorFunction("MAX", r2), r2;
      }), r(t, "Data/Formula/Functions/MEDIAN.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(t3, r2) {
          let s = [], o = e2.getArgumentsValues(t3, r2);
          for (let e3 = 0, t4 = o.length, r3; e3 < t4; ++e3) switch (typeof (r3 = o[e3])) {
            case "number":
              isNaN(r3) || s.push(r3);
              break;
            case "object":
              for (let e4 = 0, t5 = r3.length, o2; e4 < t5; ++e4) "number" != typeof (o2 = r3[e4]) || isNaN(o2) || s.push(o2);
          }
          let n = s.length;
          if (!n) return NaN;
          let i = Math.floor(n / 2);
          return n % 2 ? s[i] : (s[i - 1] + s[i]) / 2;
        }
        return e2.registerProcessorFunction("MEDIAN", t2), t2;
      }), r(t, "Data/Formula/Functions/MIN.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentsValues: t2 } = e2;
        function r2(e3, s) {
          let o = t2(e3, s), n = Number.POSITIVE_INFINITY;
          for (let e4 = 0, t3 = o.length, s2; e4 < t3; ++e4) switch (typeof (s2 = o[e4])) {
            case "number":
              s2 < n && (n = s2);
              break;
            case "object":
              (s2 = r2(s2)) < n && (n = s2);
          }
          return isFinite(n) ? n : 0;
        }
        return e2.registerProcessorFunction("MIN", r2), r2;
      }), r(t, "Data/Formula/Functions/MOD.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, r3) {
          let s = t2(e3[0], r3), o = t2(e3[1], r3);
          return ("object" == typeof s && (s = s[0]), "object" == typeof o && (o = o[0]), "number" != typeof s || "number" != typeof o || 0 === o) ? NaN : s % o;
        }
        return e2.registerProcessorFunction("MOD", r2), r2;
      }), r(t, "Data/Formula/Functions/MODE.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(t3, r3) {
          let s2 = {}, o = e2.getArgumentsValues(t3, r3);
          for (let e3 = 0, t4 = o.length, r4; e3 < t4; ++e3) switch (typeof (r4 = o[e3])) {
            case "number":
              isNaN(r4) || (s2[r4] = (s2[r4] || 0) + 1);
              break;
            case "object":
              for (let e4 = 0, t5 = r4.length, o2; e4 < t5; ++e4) "number" != typeof (o2 = r4[e4]) || isNaN(o2) || (s2[o2] = (s2[o2] || 0) + 1);
          }
          return s2;
        }
        function r2(e3, r3) {
          let s2 = t2(e3, r3), o = Object.keys(s2);
          if (!o.length) return NaN;
          let n = [parseFloat(o[0])], i = s2[o[0]];
          for (let e4 = 1, t3 = o.length, r4, l; e4 < t3; ++e4) i < (l = s2[r4 = o[e4]]) ? (n = [parseFloat(r4)], i = l) : i === l && n.push(parseFloat(r4));
          return i > 1 ? n : NaN;
        }
        function s(e3, r3) {
          let s2 = t2(e3, r3), o = Object.keys(s2);
          if (!o.length) return NaN;
          let n = parseFloat(o[0]), i = s2[o[0]];
          for (let e4 = 1, t3 = o.length, r4, l, a; e4 < t3; ++e4) i < (a = s2[r4 = o[e4]]) ? (n = parseFloat(r4), i = a) : i === a && n > (l = parseFloat(r4)) && (n = l, i = a);
          return i > 1 ? n : NaN;
        }
        return e2.registerProcessorFunction("MODE", s), e2.registerProcessorFunction("MODE.MULT", r2), e2.registerProcessorFunction("MODE.SNGL", s), { MULT: r2, SNGL: s };
      }), r(t, "Data/Formula/Functions/NOT.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, r3) {
          let s = t2(e3[0], r3);
          switch ("object" == typeof s && (s = s[0]), typeof s) {
            case "boolean":
            case "number":
              return !s;
          }
          return NaN;
        }
        return e2.registerProcessorFunction("NOT", r2), r2;
      }), r(t, "Data/Formula/Functions/OR.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, s) {
          for (let o = 0, n = e3.length, i; o < n; ++o) if ("object" == typeof (i = t2(e3[o], s))) {
            if (r2(i, s)) return true;
          } else if (i) return true;
          return false;
        }
        return e2.registerProcessorFunction("OR", r2), r2;
      }), r(t, "Data/Formula/Functions/PRODUCT.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentsValues: t2 } = e2;
        function r2(e3, s) {
          let o = t2(e3, s), n = 1, i = false;
          for (let e4 = 0, t3 = o.length, l; e4 < t3; ++e4) switch (typeof (l = o[e4])) {
            case "number":
              isNaN(l) || (i = true, n *= l);
              break;
            case "object":
              i = true, n *= r2(l, s);
          }
          return i ? n : 0;
        }
        return e2.registerProcessorFunction("PRODUCT", r2), r2;
      }), r(t, "Data/Formula/Functions/SUM.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        function t2(r2, s) {
          let o = e2.getArgumentsValues(r2, s), n = 0;
          for (let e3 = 0, r3 = o.length, i; e3 < r3; ++e3) switch (typeof (i = o[e3])) {
            case "number":
              isNaN(i) || (n += i);
              break;
            case "object":
              n += t2(i, s);
          }
          return n;
        }
        return e2.registerProcessorFunction("SUM", t2), t2;
      }), r(t, "Data/Formula/Functions/XOR.js", [t["Data/Formula/FormulaProcessor.js"]], function(e2) {
        let { getArgumentValue: t2 } = e2;
        function r2(e3, r3) {
          for (let s = 0, o = e3.length, n, i; s < o; ++s) switch (typeof (i = t2(e3[s], r3))) {
            case "boolean":
            case "number":
              if (void 0 === n) n = !!i;
              else if (!!i !== n) return true;
              break;
            case "object":
              for (let e4 = 0, t3 = i.length, r4; e4 < t3; ++e4) switch (typeof (r4 = i[e4])) {
                case "boolean":
                case "number":
                  if (void 0 === n) n = !!r4;
                  else if (!!r4 !== n) return true;
              }
          }
          return false;
        }
        return e2.registerProcessorFunction("XOR", r2), r2;
      }), r(t, "Data/Formula/Formula.js", [t["Data/Formula/FormulaParser.js"], t["Data/Formula/FormulaProcessor.js"], t["Data/Formula/FormulaTypes.js"]], function(e2, t2, r2) {
        return { ...e2, ...t2, ...r2 };
      }), r(t, "Data/Converters/CSVConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: r2 } = t2;
        class s extends e2 {
          constructor(e3) {
            let t3 = r2(s.defaultOptions, e3);
            super(t3), this.columns = [], this.headers = [], this.dataTypes = [], this.options = t3;
          }
          export(e3, t3 = this.options) {
            let { useLocalDecimalPoint: r3, lineDelimiter: s2 } = t3, o = false !== this.options.firstRowAsNames, { decimalPoint: n, itemDelimiter: i } = t3;
            n || (n = "," !== i && r3 ? 1.1.toLocaleString()[1] : "."), i || (i = "," === n ? ";" : ",");
            let l = e3.getSortedColumns(t3.usePresentationOrder), a = Object.keys(l), u = [], h = a.length, c = [];
            o && u.push(a.map((e4) => `"${e4}"`).join(i));
            for (let t4 = 0; t4 < h; t4++) {
              let r4;
              let s3 = a[t4], o2 = l[s3], m = o2.length, f = e3.whatIs(s3);
              f && (r4 = f.dataType);
              for (let e4 = 0; e4 < m; e4++) {
                let s4 = o2[e4];
                if (c[e4] || (c[e4] = []), "string" === r4 ? s4 = '"' + s4 + '"' : "number" == typeof s4 ? s4 = String(s4).replace(".", n) : "string" == typeof s4 && (s4 = `"${s4}"`), c[e4][t4] = s4, t4 === h - 1) {
                  let r5 = t4;
                  for (; c[e4].length > 2 && void 0 === c[e4][r5]; ) c[e4].pop(), r5--;
                  u.push(c[e4].join(i));
                }
              }
            }
            return u.join(s2);
          }
          parse(e3, t3) {
            let s2 = this.dataTypes, o = r2(this.options, e3), { beforeParse: n, lineDelimiter: i, firstRowAsNames: l, itemDelimiter: a } = o, u, h = 0, { csv: c, startRow: m, endRow: f } = o, d;
            if (this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers }), c && n && (c = n(c)), c) {
              if (u = c.replace(/\r\n|\r/g, "\n").split(i || "\n"), (!m || m < 0) && (m = 0), (!f || f >= u.length) && (f = u.length - 1), a || (this.guessedItemDelimiter = this.guessDelimiter(u)), l) {
                let e5 = u[0].split(a || this.guessedItemDelimiter || ",");
                for (let t4 = 0; t4 < e5.length; t4++) e5[t4] = e5[t4].trim().replace(/^["']|["']$/g, "");
                this.headers = e5, m++;
              }
              let e4 = 0;
              for (h = m; h <= f; h++) "#" === u[h][0] ? e4++ : this.parseCSVRow(u[h], h - m - e4);
              s2.length && s2[0].length && "date" === s2[0][1] && !this.options.dateFormat && this.deduceDateFormat(this.columns[0], null, true);
              for (let e5 = 0, t4 = this.columns.length; e5 < t4; ++e5) {
                d = this.columns[e5];
                for (let t5 = 0, r3 = d.length; t5 < r3; ++t5) if (d[t5] && "string" == typeof d[t5]) {
                  let r4 = this.asGuessedType(d[t5]);
                  r4 instanceof Date && (r4 = r4.getTime()), this.columns[e5][t5] = r4;
                }
              }
            }
            this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.headers });
          }
          parseCSVRow(e3, t3) {
            let r3 = this, s2 = r3.columns || [], o = r3.dataTypes, { startColumn: n, endColumn: i } = r3.options, l = r3.options.itemDelimiter || r3.guessedItemDelimiter, { decimalPoint: a } = r3.options;
            a && a !== l || (a = r3.guessedDecimalPoint || ".");
            let u = 0, h = "", c = "", m = 0, f = 0, d = (t4) => {
              h = e3[t4];
            }, p = (e4) => {
              o.length < f + 1 && o.push([e4]), o[f][o[f].length - 1] !== e4 && o[f].push(e4);
            }, g = () => {
              if (n > m || m > i) {
                ++m, c = "";
                return;
              }
              if ("string" == typeof c ? !isNaN(parseFloat(c)) && isFinite(c) ? (c = parseFloat(c), p("number")) : isNaN(Date.parse(c)) ? p("string") : (c = c.replace(/\//g, "-"), p("date")) : p("number"), s2.length < f + 1 && s2.push([]), "number" != typeof c && "number" !== r3.guessType(c) && a) {
                let e4 = c;
                c = c.replace(a, "."), "number" !== r3.guessType(c) && (c = e4);
              }
              s2[f][t3] = c, c = "", ++f, ++m;
            };
            if (e3.trim().length && "#" !== e3.trim()[0]) {
              for (; u < e3.length; u++) {
                if (d(u), "#" === h && !/^#[A-F\d]{3,3}|[A-F\d]{6,6}/i.test(e3.substring(u))) {
                  g();
                  return;
                }
                if ('"' === h) for (d(++u); u < e3.length && '"' !== h; ) c += h, d(++u);
                else h === l ? g() : c += h;
              }
              g();
            }
          }
          guessDelimiter(e3) {
            let t3 = 0, r3 = 0, s2, o = { ",": 0, ";": 0, "	": 0 }, n = e3.length;
            for (let s3 = 0; s3 < n; s3++) {
              let n2 = false, i, l, a, u = "";
              if (s3 > 13) break;
              let h = e3[s3];
              for (let e4 = 0; e4 < h.length && (i = h[e4], l = h[e4 + 1], a = h[e4 - 1], "#" !== i); e4++) {
                if ('"' === i) {
                  if (n2) {
                    if ('"' !== a && '"' !== l) {
                      for (; " " === l && e4 < h.length; ) l = h[++e4];
                      void 0 !== o[l] && o[l]++, n2 = false;
                    }
                  } else n2 = true;
                } else void 0 !== o[i] ? (isNaN(Date.parse(u = u.trim())) ? (isNaN(Number(u)) || !isFinite(Number(u))) && o[i]++ : o[i]++, u = "") : u += i;
                "," === i && r3++, "." === i && t3++;
              }
            }
            return o[";"] > o[","] ? s2 = ";" : (o[","], o[";"], s2 = ","), t3 > r3 ? this.guessedDecimalPoint = "." : this.guessedDecimalPoint = ",", s2;
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.headers);
          }
        }
        return s.defaultOptions = { ...e2.defaultOptions, lineDelimiter: "\n" }, s;
      }), r(t, "Data/Connectors/CSVConnector.js", [t["Data/Converters/CSVConverter.js"], t["Data/Connectors/DataConnector.js"], t["Core/Utilities.js"]], function(e2, t2, r2) {
        let { merge: s } = r2;
        class o extends t2 {
          constructor(t3) {
            let r3 = s(o.defaultOptions, t3);
            super(r3), this.converter = new e2(r3), this.options = r3, r3.enablePolling && this.startPolling(1e3 * Math.max(r3.dataRefreshRate || 0, 1));
          }
          load(e3) {
            let t3 = this, r3 = t3.converter, s2 = t3.table, { csv: o2, csvURL: n, dataModifier: i } = t3.options;
            return t3.emit({ type: "load", csv: o2, detail: e3, table: s2 }), Promise.resolve(n ? fetch(n).then((e4) => e4.text()) : o2 || "").then((e4) => (e4 && (s2.deleteColumns(), r3.parse({ csv: e4 }), s2.setColumns(r3.getTable().getColumns())), t3.setModifierOptions(i).then(() => e4))).then((r4) => (t3.emit({ type: "afterLoad", csv: r4, detail: e3, table: s2 }), t3)).catch((r4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: r4, table: s2 }), r4;
            });
          }
        }
        return o.defaultOptions = { csv: "", csvURL: "", enablePolling: false, dataRefreshRate: 1, firstRowAsNames: true }, t2.registerType("CSV", o), o;
      }), r(t, "Data/Converters/JSONConverter.js", [t["Data/Converters/DataConverter.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2, r2) {
        let { error: s, isArray: o, merge: n, objectEach: i } = r2;
        class l extends e2 {
          constructor(e3) {
            let r3 = n(l.defaultOptions, e3);
            super(r3), this.columns = [], this.headers = [], this.options = r3, this.table = new t2();
          }
          parse(e3, t3) {
            let { beforeParse: r3, orientation: l2, firstRowAsNames: a, columnNames: u } = e3 = n(this.options, e3), h = e3.data;
            if (h) {
              if (this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers }), r3 && (h = r3(h)), h = h.slice(), "columns" === l2) for (let e4 = 0, t4 = h.length; e4 < t4; e4++) {
                let t5 = h[e4];
                if (!(t5 instanceof Array)) return;
                this.headers instanceof Array ? (a ? this.headers.push(`${t5.shift()}`) : u && u instanceof Array && this.headers.push(u[e4]), this.table.setColumn(this.headers[e4] || e4.toString(), t5)) : s("JSONConverter: Invalid `columnNames` option.", false);
              }
              else if ("rows" === l2) {
                a ? this.headers = h.shift() : u && (this.headers = u);
                for (let e4 = 0, t4 = h.length; e4 < t4; e4++) {
                  let t5 = h[e4];
                  if (o(t5)) for (let e5 = 0, r4 = t5.length; e5 < r4; e5++) this.columns.length < e5 + 1 && this.columns.push([]), this.columns[e5].push(t5[e5]), this.headers instanceof Array ? this.table.setColumn(this.headers[e5] || e5.toString(), this.columns[e5]) : s("JSONConverter: Invalid `columnNames` option.", false);
                  else {
                    let r4 = this.headers;
                    if (r4 && !(r4 instanceof Array)) {
                      let e5 = {};
                      i(r4, (r5, s2) => {
                        e5[s2] = r5.reduce((e6, t6) => e6[t6], t5);
                      }), t5 = e5;
                    }
                    this.table.setRows([t5], e4);
                  }
                }
              }
              this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.headers });
            }
          }
          getTable() {
            return this.table;
          }
        }
        return l.defaultOptions = { ...e2.defaultOptions, data: [], orientation: "rows" }, l;
      }), r(t, "Data/Connectors/JSONConnector.js", [t["Data/Connectors/DataConnector.js"], t["Core/Utilities.js"], t["Data/Converters/JSONConverter.js"]], function(e2, t2, r2) {
        let { merge: s } = t2;
        class o extends e2 {
          constructor(e3) {
            let t3 = s(o.defaultOptions, e3);
            super(t3), this.converter = new r2(t3), this.options = t3, t3.enablePolling && this.startPolling(1e3 * Math.max(t3.dataRefreshRate || 0, 1));
          }
          load(e3) {
            let t3 = this, r3 = t3.converter, s2 = t3.table, { data: o2, dataUrl: n, dataModifier: i } = t3.options;
            return t3.emit({ type: "load", data: o2, detail: e3, table: s2 }), Promise.resolve(n ? fetch(n).then((e4) => e4.json()) : o2 || []).then((e4) => (e4 && (s2.deleteColumns(), r3.parse({ data: e4 }), s2.setColumns(r3.getTable().getColumns())), t3.setModifierOptions(i).then(() => e4))).then((r4) => (t3.emit({ type: "afterLoad", data: r4, detail: e3, table: s2 }), t3)).catch((r4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: r4, table: s2 }), r4;
            });
          }
        }
        return o.defaultOptions = { data: [], enablePolling: false, dataRefreshRate: 0, firstRowAsNames: true, orientation: "rows" }, e2.registerType("JSON", o), o;
      }), r(t, "Data/Converters/GoogleSheetsConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: r2, uniqueKey: s } = t2;
        class o extends e2 {
          constructor(e3) {
            let t3 = r2(o.defaultOptions, e3);
            super(t3), this.columns = [], this.header = [], this.options = t3;
          }
          parse(e3, t3) {
            var _a;
            let o2;
            let n = r2(this.options, e3), i = (((_a = n.json) == null ? void 0 : _a.values) || []).map((e4) => e4.slice());
            if (0 === i.length) return false;
            this.header = [], this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.header });
            let { beforeParse: l, json: a } = n;
            l && a && (i = l(a.values)), this.columns = i;
            for (let e4 = 0, t4 = i.length; e4 < t4; e4++) {
              o2 = i[e4], this.header[e4] = n.firstRowAsNames ? `${o2.shift()}` : s();
              for (let t5 = 0, r3 = o2.length; t5 < r3; ++t5) if (o2[t5] && "string" == typeof o2[t5]) {
                let r4 = this.asGuessedType(o2[t5]);
                r4 instanceof Date && (r4 = r4.getTime()), this.columns[e4][t5] = r4;
              }
            }
            this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.header });
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.header);
          }
        }
        return o.defaultOptions = { ...e2.defaultOptions }, o;
      }), r(t, "Data/Connectors/GoogleSheetsConnector.js", [t["Data/Connectors/DataConnector.js"], t["Data/Converters/GoogleSheetsConverter.js"], t["Core/Utilities.js"]], function(e2, t2, r2) {
        let { merge: s, pick: o } = r2;
        class n extends e2 {
          constructor(e3) {
            let r3 = s(n.defaultOptions, e3);
            super(r3), this.converter = new t2(r3), this.options = r3;
          }
          load(e3) {
            let t3 = this, r3 = t3.converter, s2 = t3.table, { dataModifier: o2, dataRefreshRate: i, enablePolling: l, firstRowAsNames: a, googleAPIKey: u, googleSpreadsheetKey: h } = t3.options, c = n.buildFetchURL(u, h, t3.options);
            if (t3.emit({ type: "load", detail: e3, table: s2, url: c }), !URL.canParse(c)) throw Error("Invalid URL: " + c);
            return fetch(c).then((e4) => e4.json()).then((e4) => {
              if ("object" == typeof e4 && e4 && "object" == typeof e4.error && e4.error && "number" == typeof e4.error.code && "string" == typeof e4.error.message && "string" == typeof e4.error.status) throw Error(e4.error.message);
              return r3.parse({ firstRowAsNames: a, json: e4 }), s2.deleteColumns(), s2.setColumns(r3.getTable().getColumns()), t3.setModifierOptions(o2);
            }).then(() => (t3.emit({ type: "afterLoad", detail: e3, table: s2, url: c }), l && setTimeout(() => t3.load(), 1e3 * Math.max(i || 0, 1)), t3)).catch((r4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: r4, table: s2 }), r4;
            });
          }
        }
        return n.defaultOptions = { googleAPIKey: "", googleSpreadsheetKey: "", enablePolling: false, dataRefreshRate: 2, firstRowAsNames: true }, function(e3) {
          let t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
          function r3(e4 = {}) {
            let { endColumn: s2, endRow: n2, googleSpreadsheetRange: i, startColumn: l, startRow: a } = e4;
            return i || (t3[l || 0] || "A") + (Math.max(a || 0, 0) + 1) + ":" + (t3[o(s2, 25)] || "Z") + (n2 ? Math.max(n2, 0) : "Z");
          }
          e3.buildFetchURL = function(e4, t4, s2 = {}) {
            let o2 = new URL(`https://sheets.googleapis.com/v4/spreadsheets/${t4}/values/`), n2 = s2.onlyColumnNames ? "A1:Z1" : r3(s2);
            o2.pathname += n2;
            let i = o2.searchParams;
            return i.set("alt", "json"), s2.onlyColumnNames || (i.set("dateTimeRenderOption", "FORMATTED_STRING"), i.set("majorDimension", "COLUMNS"), i.set("valueRenderOption", "UNFORMATTED_VALUE")), i.set("prettyPrint", "false"), i.set("key", e4), o2.href;
          }, e3.buildQueryRange = r3;
        }(n || (n = {})), e2.registerType("GoogleSheets", n), n;
      }), r(t, "Data/Converters/HTMLTableConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: r2 } = t2;
        class s extends e2 {
          constructor(e3) {
            let t3 = r2(s.defaultOptions, e3);
            super(t3), this.columns = [], this.headers = [], this.options = t3, t3.tableElement && (this.tableElement = t3.tableElement, this.tableElementID = t3.tableElement.id);
          }
          export(e3, t3 = this.options) {
            let r3 = false !== t3.firstRowAsNames, s2 = t3.useMultiLevelHeaders, o = e3.getSortedColumns(t3.usePresentationOrder), n = Object.keys(o), i = [], l = n.length, a = [], u = "";
            if (r3) {
              let e4 = [];
              if (s2) {
                for (let t4 of n) {
                  let r4 = (o[t4].shift() || "").toString();
                  e4.push(r4);
                }
                u = this.getTableHeaderHTML(n, e4, t3);
              } else u = this.getTableHeaderHTML(void 0, n, t3);
            }
            for (let e4 = 0; e4 < l; e4++) {
              let t4 = o[n[e4]], r4 = t4.length;
              for (let s3 = 0; s3 < r4; s3++) {
                let r5 = t4[s3];
                a[s3] || (a[s3] = []), "string" == typeof r5 || "number" == typeof r5 || void 0 === r5 || (r5 = (r5 || "").toString()), a[s3][e4] = this.getCellHTMLFromValue(e4 ? "td" : "th", null, e4 ? "" : 'scope="row"', r5), e4 === l - 1 && i.push("<tr>" + a[s3].join("") + "</tr>");
              }
            }
            let h = "";
            return t3.tableCaption && (h = '<caption class="highcharts-table-caption">' + t3.tableCaption + "</caption>"), "<table>" + h + u + "<tbody>" + i.join("") + "</tbody></table>";
          }
          getCellHTMLFromValue(e3, t3, r3, s2, o) {
            let n = s2, i = "text" + (t3 ? " " + t3 : "");
            return "number" == typeof n ? (n = n.toString(), "," === o && (n = n.replace(".", o)), i = "number") : s2 || (n = "", i = "empty"), "<" + e3 + (r3 ? " " + r3 : "") + ' class="' + i + '">' + n + "</" + e3 + ">";
          }
          getTableHeaderHTML(e3 = [], t3 = [], r3 = this.options) {
            let { useMultiLevelHeaders: s2, useRowspanHeaders: o } = r3, n = "<thead>", i = 0, l = t3 && t3.length, a, u = 0, h;
            if (s2 && e3 && t3 && !function(e4, t4) {
              let r4 = e4.length;
              if (t4.length !== r4) return false;
              for (; --r4; ) if (e4[r4] !== t4[r4]) return false;
              return true;
            }(e3, t3)) {
              for (n += "<tr>"; i < l; ++i) (a = e3[i]) === e3[i + 1] ? ++u : u ? (n += this.getCellHTMLFromValue("th", "highcharts-table-topheading", 'scope="col" colspan="' + (u + 1) + '"', a), u = 0) : (a === t3[i] ? o ? (h = 2, delete t3[i]) : (h = 1, t3[i] = "") : h = 1, n += this.getCellHTMLFromValue("th", "highcharts-table-topheading", 'scope="col"' + (h > 1 ? ' valign="top" rowspan="' + h + '"' : ""), a));
              n += "</tr>";
            }
            if (t3) {
              for (n += "<tr>", i = 0, l = t3.length; i < l; ++i) void 0 !== t3[i] && (n += this.getCellHTMLFromValue("th", null, 'scope="col"', t3[i]));
              n += "</tr>";
            }
            return n + "</thead>";
          }
          parse(e3, t3) {
            let s2 = [], o = [], n = r2(this.options, e3), { endRow: i, startColumn: l, endColumn: a, firstRowAsNames: u } = n, h = n.tableElement || this.tableElement;
            if (!(h instanceof HTMLElement)) {
              this.emit({ type: "parseError", columns: s2, detail: t3, headers: o, error: "Not a valid HTML Table" });
              return;
            }
            this.tableElement = h, this.tableElementID = h.id, this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers });
            let c = h.getElementsByTagName("tr"), m = c.length, f = 0, d, { startRow: p } = n;
            if (u && m) {
              let e4 = c[0].children, t4 = e4.length;
              for (let r3 = l; r3 < t4 && !(r3 > a); r3++) ("TD" === (d = e4[r3]).tagName || "TH" === d.tagName) && o.push(d.innerHTML);
              p++;
            }
            for (; f < m; ) {
              if (f >= p && f <= i) {
                let e4 = c[f].children, t4 = e4.length, r3 = 0;
                for (; r3 < t4; ) {
                  let t5 = r3 - l, o2 = s2[t5];
                  if (("TD" === (d = e4[r3]).tagName || "TH" === d.tagName) && r3 >= l && r3 <= a) {
                    s2[t5] || (s2[t5] = []);
                    let e5 = this.asGuessedType(d.innerHTML);
                    e5 instanceof Date && (e5 = e5.getTime()), s2[t5][f - p] = e5;
                    let r4 = 1;
                    for (; f - p >= r4 && void 0 === o2[f - p - r4]; ) o2[f - p - r4] = null, r4++;
                  }
                  r3++;
                }
              }
              f++;
            }
            this.columns = s2, this.headers = o, this.emit({ type: "afterParse", columns: s2, detail: t3, headers: o });
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.headers);
          }
        }
        return s.defaultOptions = { ...e2.defaultOptions, useRowspanHeaders: true, useMultiLevelHeaders: true }, s;
      }), r(t, "Data/Connectors/HTMLTableConnector.js", [t["Data/Connectors/DataConnector.js"], t["Core/Globals.js"], t["Data/Converters/HTMLTableConverter.js"], t["Core/Utilities.js"]], function(e2, t2, r2, s) {
        let { win: o } = t2, { merge: n } = s;
        class i extends e2 {
          constructor(e3) {
            let t3 = n(i.defaultOptions, e3);
            super(t3), this.converter = new r2(t3), this.options = t3;
          }
          load(e3) {
            let t3;
            let r3 = this, s2 = r3.converter, i2 = r3.table, { dataModifier: l, table: a } = r3.options;
            if (r3.emit({ type: "load", detail: e3, table: i2, tableElement: r3.tableElement }), "string" == typeof a ? (r3.tableID = a, t3 = o.document.getElementById(a)) : (t3 = a, r3.tableID = t3.id), r3.tableElement = t3 || void 0, !r3.tableElement) {
              let t4 = "HTML table not provided, or element with ID not found";
              return r3.emit({ type: "loadError", detail: e3, error: t4, table: i2 }), Promise.reject(Error(t4));
            }
            return s2.parse(n({ tableElement: r3.tableElement }, r3.options), e3), i2.deleteColumns(), i2.setColumns(s2.getTable().getColumns()), r3.setModifierOptions(l).then(() => (r3.emit({ type: "afterLoad", detail: e3, table: i2, tableElement: r3.tableElement }), r3));
          }
        }
        return i.defaultOptions = { table: "" }, e2.registerType("HTMLTable", i), i;
      }), r(t, "Data/Modifiers/ChainModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: r2 } = t2;
        class s extends e2 {
          constructor(t3, ...o) {
            super(), this.chain = o, this.options = r2(s.defaultOptions, t3);
            let n = this.options.chain || [];
            for (let t4 = 0, r3 = n.length, s2, i; t4 < r3; ++t4) (s2 = n[t4]).type && (i = e2.types[s2.type]) && o.push(new i(s2));
          }
          add(e3, t3) {
            this.emit({ type: "addModifier", detail: t3, modifier: e3 }), this.chain.push(e3), this.emit({ type: "addModifier", detail: t3, modifier: e3 });
          }
          clear(e3) {
            this.emit({ type: "clearChain", detail: e3 }), this.chain.length = 0, this.emit({ type: "afterClearChain", detail: e3 });
          }
          async modify(e3, t3) {
            let r3 = this.options.reverse ? this.chain.slice().reverse() : this.chain.slice();
            e3.modified === e3 && (e3.modified = e3.clone(false, t3));
            let s2 = e3;
            for (let o = 0, n = r3.length; o < n; ++o) {
              try {
                await r3[o].modify(s2, t3);
              } catch (r4) {
                throw this.emit({ type: "error", detail: t3, table: e3 }), r4;
              }
              s2 = s2.modified;
            }
            return e3.modified = s2, e3;
          }
          modifyCell(e3, t3, r3, s2, o) {
            let n = this.options.reverse ? this.chain.reverse() : this.chain;
            if (n.length) {
              let i = e3.clone();
              for (let e4 = 0, l = n.length; e4 < l; ++e4) n[e4].modifyCell(i, t3, r3, s2, o), i = i.modified;
              e3.modified = i;
            }
            return e3;
          }
          modifyColumns(e3, t3, r3, s2) {
            let o = this.options.reverse ? this.chain.reverse() : this.chain.slice();
            if (o.length) {
              let n = e3.clone();
              for (let e4 = 0, i = o.length; e4 < i; ++e4) o[e4].modifyColumns(n, t3, r3, s2), n = n.modified;
              e3.modified = n;
            }
            return e3;
          }
          modifyRows(e3, t3, r3, s2) {
            let o = this.options.reverse ? this.chain.reverse() : this.chain.slice();
            if (o.length) {
              let n = e3.clone();
              for (let e4 = 0, i = o.length; e4 < i; ++e4) o[e4].modifyRows(n, t3, r3, s2), n = n.modified;
              e3.modified = n;
            }
            return e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let r3 = this.options.reverse ? this.chain.reverse() : this.chain.slice(), s2 = e3.modified;
            for (let e4 = 0, o = r3.length; e4 < o; ++e4) s2 = r3[e4].modifyTable(s2, t3).modified;
            return e3.modified = s2, this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
          remove(e3, t3) {
            let r3 = this.chain;
            this.emit({ type: "removeModifier", detail: t3, modifier: e3 }), r3.splice(r3.indexOf(e3), 1), this.emit({ type: "afterRemoveModifier", detail: t3, modifier: e3 });
          }
        }
        return s.defaultOptions = { type: "Chain" }, e2.registerType("Chain", s), s;
      }), r(t, "Data/Modifiers/InvertModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: r2 } = t2;
        class s extends e2 {
          constructor(e3) {
            super(), this.options = r2(s.defaultOptions, e3);
          }
          modifyCell(e3, t3, r3, s2, o) {
            let n = e3.modified, i = n.getRowIndexBy("columnNames", t3);
            return void 0 === i ? n.setColumns(this.modifyTable(e3.clone()).getColumns(), void 0, o) : n.setCell(`${r3}`, i, s2, o), e3;
          }
          modifyColumns(e3, t3, r3, s2) {
            let o = e3.modified, n = o.getColumn("columnNames") || [], i = e3.getColumnNames(), l = e3.getRowCount() !== n.length;
            if (!l) {
              for (let e4 = 0, t4 = i.length; e4 < t4; ++e4) if (i[e4] !== n[e4]) {
                l = true;
                break;
              }
            }
            if (l) return this.modifyTable(e3, s2);
            i = Object.keys(t3);
            for (let e4 = 0, n2 = i.length, l2, a, u; e4 < n2; ++e4) {
              l2 = t3[a = i[e4]], u = o.getRowIndexBy("columnNames", a) || o.getRowCount();
              for (let e5 = 0, t4 = r3, n3 = l2.length; e5 < n3; ++e5, ++t4) o.setCell(`${t4}`, u, l2[e5], s2);
            }
            return e3;
          }
          modifyRows(e3, t3, r3, s2) {
            let o = e3.getColumnNames(), n = e3.modified, i = n.getColumn("columnNames") || [], l = e3.getRowCount() !== i.length;
            if (!l) {
              for (let e4 = 0, t4 = o.length; e4 < t4; ++e4) if (o[e4] !== i[e4]) {
                l = true;
                break;
              }
            }
            if (l) return this.modifyTable(e3, s2);
            for (let e4 = 0, i2 = r3, l2 = t3.length, a; e4 < l2; ++e4, ++i2) if ((a = t3[e4]) instanceof Array) n.setColumn(`${i2}`, a);
            else for (let e5 = 0, t4 = o.length; e5 < t4; ++e5) n.setCell(`${i2}`, e5, a[o[e5]], s2);
            return e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let r3 = e3.modified;
            if (e3.hasColumns(["columnNames"])) {
              let t4 = ((e3.deleteColumns(["columnNames"]) || {}).columnNames || []).map((e4) => `${e4}`), s2 = {};
              for (let r4 = 0, o = e3.getRowCount(), n; r4 < o; ++r4) (n = e3.getRow(r4)) && (s2[t4[r4]] = n);
              r3.deleteColumns(), r3.setColumns(s2);
            } else {
              let t4 = {};
              for (let r4 = 0, s2 = e3.getRowCount(), o; r4 < s2; ++r4) (o = e3.getRow(r4)) && (t4[`${r4}`] = o);
              t4.columnNames = e3.getColumnNames(), r3.deleteColumns(), r3.setColumns(t4);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return s.defaultOptions = { type: "Invert" }, e2.registerType("Invert", s), s;
      }), r(t, "Data/Modifiers/MathModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Data/Formula/FormulaParser.js"], t["Data/Formula/FormulaProcessor.js"]], function(e2, t2, r2) {
        class s extends e2 {
          constructor(e3) {
            super(), this.options = { ...s.defaultOptions, ...e3 };
          }
          modifyTable(e3, r3) {
            this.emit({ type: "modify", detail: r3, table: e3 });
            let s2 = this.options.alternativeSeparators, o = this.options.formulaColumns || e3.getColumnNames(), n = e3.modified;
            for (let t3 = 0, r4 = o.length, s3; t3 < r4; ++t3) s3 = o[t3], o.indexOf(s3) >= 0 && n.setColumn(s3, this.processColumn(e3, s3));
            let i = this.options.columnFormulas || [];
            for (let r4 = 0, o2 = i.length, l, a; r4 < o2; ++r4) l = i[r4], a = t2.parseFormula(l.formula, s2), n.setColumn(l.column, this.processColumnFormula(a, e3, l.rowStart, l.rowEnd));
            return this.emit({ type: "afterModify", detail: r3, table: e3 }), e3;
          }
          processColumn(e3, s2, o = 0) {
            let n = this.options.alternativeSeparators, i = (e3.getColumn(s2, true) || []).slice(o > 0 ? o : 0);
            for (let s3 = 0, o2 = i.length, l = [], a; s3 < o2; ++s3) if ("string" == typeof (a = i[s3]) && "=" === a[0]) try {
              l = "" === a ? l : t2.parseFormula(a.substring(1), n), i[s3] = r2.processFormula(l, e3);
            } catch {
              i[s3] = NaN;
            }
            return i;
          }
          processColumnFormula(e3, t3, s2 = 0, o = t3.getRowCount()) {
            s2 = s2 >= 0 ? s2 : 0, o = o >= 0 ? o : t3.getRowCount() + o;
            let n = [], i = t3.modified;
            for (let t4 = 0, l = o - s2; t4 < l; ++t4) try {
              n[t4] = r2.processFormula(e3, i);
            } catch {
              n[t4] = NaN;
            } finally {
              e3 = r2.translateReferences(e3, 0, 1);
            }
            return n;
          }
        }
        return s.defaultOptions = { type: "Math", alternativeSeparators: false }, e2.registerType("Math", s), s;
      }), r(t, "Data/Modifiers/RangeModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: r2 } = t2;
        class s extends e2 {
          constructor(e3) {
            super(), this.options = r2(s.defaultOptions, e3);
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let r3 = [], { additive: s2, ranges: o, strict: n } = this.options;
            if (o.length) {
              let t4 = e3.modified, i = e3.getColumns(), l = [];
              for (let a = 0, u = o.length, h, c; a < u; ++a) if (h = o[a], !n || typeof h.minValue == typeof h.maxValue) {
                a > 0 && !s2 && (t4.deleteRows(), t4.setRows(l), t4.setOriginalRowIndexes(r3, true), i = t4.getColumns(), l = [], r3 = []), c = i[h.column] || [];
                for (let o2 = 0, i2 = c.length, a2, u2, m; o2 < i2; ++o2) {
                  switch (typeof (a2 = c[o2])) {
                    default:
                      continue;
                    case "boolean":
                    case "number":
                    case "string":
                  }
                  (!n || typeof a2 == typeof h.minValue) && a2 >= h.minValue && a2 <= h.maxValue && (s2 ? (u2 = e3.getRow(o2), m = e3.getOriginalRowIndex(o2)) : (u2 = t4.getRow(o2), m = t4.getOriginalRowIndex(o2)), u2 && (l.push(u2), r3.push(m)));
                }
              }
              t4.deleteRows(), t4.setRows(l), t4.setOriginalRowIndexes(r3);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return s.defaultOptions = { type: "Range", ranges: [] }, e2.registerType("Range", s), s;
      }), r(t, "Data/Modifiers/SortModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2, r2) {
        let { merge: s } = r2;
        class o extends e2 {
          static ascending(e3, t3) {
            return (e3 || 0) < (t3 || 0) ? -1 : (e3 || 0) > (t3 || 0) ? 1 : 0;
          }
          static descending(e3, t3) {
            return (t3 || 0) < (e3 || 0) ? -1 : (t3 || 0) > (e3 || 0) ? 1 : 0;
          }
          constructor(e3) {
            super(), this.options = s(o.defaultOptions, e3);
          }
          getRowReferences(e3) {
            let t3 = e3.getRows(), r3 = [];
            for (let e4 = 0, s2 = t3.length; e4 < s2; ++e4) r3.push({ index: e4, row: t3[e4] });
            return r3;
          }
          modifyCell(e3, r3, s2, o2, n) {
            let { orderByColumn: i, orderInColumn: l } = this.options;
            return r3 === i && (l ? (e3.modified.setCell(r3, s2, o2), e3.modified.setColumn(l, this.modifyTable(new t2({ columns: e3.getColumns([i, l]) })).modified.getColumn(l))) : this.modifyTable(e3, n)), e3;
          }
          modifyColumns(e3, r3, s2, o2) {
            let { orderByColumn: n, orderInColumn: i } = this.options, l = Object.keys(r3);
            return l.indexOf(n) > -1 && (i && r3[l[0]].length ? (e3.modified.setColumns(r3, s2), e3.modified.setColumn(i, this.modifyTable(new t2({ columns: e3.getColumns([n, i]) })).modified.getColumn(i))) : this.modifyTable(e3, o2)), e3;
          }
          modifyRows(e3, r3, s2, o2) {
            let { orderByColumn: n, orderInColumn: i } = this.options;
            return i && r3.length ? (e3.modified.setRows(r3, s2), e3.modified.setColumn(i, this.modifyTable(new t2({ columns: e3.getColumns([n, i]) })).modified.getColumn(i))) : this.modifyTable(e3, o2), e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let r3 = e3.getColumnNames(), s2 = e3.getRowCount(), n = this.getRowReferences(e3), { direction: i, orderByColumn: l, orderInColumn: a } = this.options, u = "asc" === i ? o.ascending : o.descending, h = r3.indexOf(l), c = e3.modified;
            if (-1 !== h && n.sort((e4, t4) => u(e4.row[h], t4.row[h])), a) {
              let e4 = [];
              for (let t4 = 0; t4 < s2; ++t4) e4[n[t4].index] = t4;
              c.setColumns({ [a]: e4 });
            } else {
              let e4;
              let t4 = [], r4 = [];
              for (let o2 = 0; o2 < s2; ++o2) e4 = n[o2], t4.push(c.getOriginalRowIndex(e4.index)), r4.push(e4.row);
              c.setRows(r4, 0), c.setOriginalRowIndexes(t4);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return o.defaultOptions = { type: "Sort", direction: "desc", orderByColumn: "y" }, e2.registerType("Sort", o), o;
      }), r(t, "masters/modules/data-tools.src.js", [t["Core/Globals.js"], t["Data/Connectors/DataConnector.js"], t["Data/Converters/DataConverter.js"], t["Data/DataCursor.js"], t["Data/Modifiers/DataModifier.js"], t["Data/DataPool.js"], t["Data/DataTable.js"], t["Data/Formula/Formula.js"]], function(e2, t2, r2, s, o, n, i, l) {
        return e2.DataConnector = e2.DataConnector || t2, e2.DataConverter = e2.DataConverter || r2, e2.DataCursor = e2.DataCursor || s, e2.DataModifier = e2.DataModifier || o, e2.DataPool = e2.DataPool || n, e2.DataTable = e2.DataTable || i, e2.Formula = e2.Formula || l, e2;
      });
    });
  }
});
export default require_data_tools();
//# sourceMappingURL=highcharts_modules_data-tools__js.js.map
