import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/tiledwebmap.js
var require_tiledwebmap = __commonJS({
  "node_modules/highcharts/modules/tiledwebmap.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2009-2024
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/tiledwebmap", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function o(t2, o2, i, r) {
        t2.hasOwnProperty(o2) || (t2[o2] = r.apply(null, i), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: o2, module: t2[o2] } })));
      }
      o(t, "Maps/TilesProviders/OpenStreetMap.js", [], function() {
        return class {
          constructor() {
            this.defaultCredits = 'Map data &copy2023 <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>', this.initialProjectionName = "WebMercator", this.subdomains = ["a", "b", "c"], this.themes = { Standard: { url: "https://tile.openstreetmap.org/{zoom}/{x}/{y}.png", minZoom: 0, maxZoom: 19 }, Hot: { url: "https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png", minZoom: 0, maxZoom: 19 }, OpenTopoMap: { url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", minZoom: 0, maxZoom: 17, credits: `Map data: &copy; <a href="https://www.openstreetmap.org/copyright">
                        OpenStreetMap</a> contributors, <a href="https://viewfinderpanoramas.org">SRTM</a> 
                        | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> 
                        (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)` } };
          }
        };
      }), o(t, "Maps/TilesProviders/Stamen.js", [], function() {
        return class {
          constructor() {
            this.defaultCredits = '&copy; Map tiles by <a href="https://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://www.openstreetmap.org/copyright">ODbL</a>', this.initialProjectionName = "WebMercator", this.subdomains = ["a", "b", "c", "d"], this.themes = { Toner: { url: "https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png", minZoom: 0, maxZoom: 20 }, TonerBackground: { url: "https://stamen-tiles-{s}.a.ssl.fastly.net/toner-background/{z}/{x}/{y}.png", minZoom: 0, maxZoom: 20 }, TonerLite: { url: "https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png", minZoom: 0, maxZoom: 20 }, Terrain: { url: "https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png", minZoom: 0, maxZoom: 18 }, TerrainBackground: { url: "https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}.png", minZoom: 0, maxZoom: 18 }, Watercolor: { url: "https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.png", minZoom: 1, maxZoom: 16, credits: '&copy Map tiles by <a href="https://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>' } };
          }
        };
      }), o(t, "Maps/TilesProviders/LimaLabs.js", [], function() {
        return class {
          constructor() {
            this.defaultCredits = 'Map data &copy;2023 <a href="https://maps.lima-labs.com/">LimaLabs</a>', this.initialProjectionName = "WebMercator", this.requiresApiKey = true, this.themes = { Standard: { url: "https://cdn.lima-labs.com/{zoom}/{x}/{y}.png?api={apikey}", minZoom: 0, maxZoom: 20 } };
          }
        };
      }), o(t, "Maps/TilesProviders/Thunderforest.js", [], function() {
        return class {
          constructor() {
            this.defaultCredits = 'Maps &copy <a href="https://www.thunderforest.com">Thunderforest</a>, Data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>', this.initialProjectionName = "WebMercator", this.requiresApiKey = true, this.subdomains = ["a", "b", "c"], this.themes = { OpenCycleMap: { url: "https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 }, Transport: { url: "https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 }, TransportDark: { url: "https://{s}.tile.thunderforest.com/transport-dark/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 }, SpinalMap: { url: "https://{s}.tile.thunderforest.com/spinal-map/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 }, Landscape: { url: "https://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 }, Outdoors: { url: "https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 }, Pioneer: { url: "https://{s}.tile.thunderforest.com/pioneer/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 }, MobileAtlas: { url: "https://{s}.tile.thunderforest.com/mobile-atlas/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 }, Neighbourhood: { url: "https://{s}.tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png?apikey={apikey}", minZoom: 0, maxZoom: 22 } };
          }
        };
      }), o(t, "Maps/TilesProviders/Esri.js", [], function() {
        return class {
          constructor() {
            this.defaultCredits = "Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS,  Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012", this.initialProjectionName = "WebMercator", this.themes = { WorldStreetMap: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 20 }, DeLorme: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/Specialty/DeLorme_World_Base_Map/MapServer/tile/{z}/{y}/{x}", minZoom: 1, maxZoom: 11, credits: "Tiles &copy; Esri &mdash; Copyright: &copy;2012 DeLorme" }, WorldTopoMap: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 20, credits: "Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community" }, WorldImagery: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 20, credits: "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community" }, WorldTerrain: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 13, credits: "Tiles &copy; Esri &mdash; Source: USGS, Esri, TANA, DeLorme, and NPS" }, WorldShadedRelief: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 13, credits: "Tiles &copy; Esri &mdash; Source: Esri" }, WorldPhysical: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 8, credits: "Tiles &copy; Esri &mdash; Source: US National Park Service" }, NatGeoWorldMap: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 16, credits: "Tiles &copy; Esri &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC" }, WorldGrayCanvas: { url: "https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 16, credits: "Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ" } };
          }
        };
      }), o(t, "Maps/TilesProviders/USGS.js", [], function() {
        return class {
          constructor() {
            this.defaultCredits = 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. GeologicalSurvey</a>', this.initialProjectionName = "WebMercator", this.themes = { USTopo: { url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 20 }, USImagery: { url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 20 }, USImageryTopo: { url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}", minZoom: 0, maxZoom: 20 } };
          }
        };
      }), o(t, "Maps/TilesProviders/TilesProviderRegistry.js", [t["Maps/TilesProviders/OpenStreetMap.js"], t["Maps/TilesProviders/Stamen.js"], t["Maps/TilesProviders/LimaLabs.js"], t["Maps/TilesProviders/Thunderforest.js"], t["Maps/TilesProviders/Esri.js"], t["Maps/TilesProviders/USGS.js"]], function(e2, t2, o2, i, r, s) {
        return { Esri: r, LimaLabs: o2, OpenStreetMap: e2, Stamen: t2, Thunderforest: i, USGS: s };
      }), o(t, "Series/TiledWebMap/TiledWebMapSeriesDefaults.js", [], function() {
        return { states: { inactive: { enabled: false } } };
      }), o(t, "Series/TiledWebMap/TiledWebMapSeries.js", [t["Core/Globals.js"], t["Core/Series/SeriesRegistry.js"], t["Maps/TilesProviders/TilesProviderRegistry.js"], t["Series/TiledWebMap/TiledWebMapSeriesDefaults.js"], t["Core/Utilities.js"]], function(e2, t2, o2, i, r) {
        let { composed: s } = e2, { map: a } = t2.seriesTypes, { addEvent: n, defined: l, error: p, merge: m, pick: c, pushUnique: h } = r;
        function d(e3) {
          let { geoBounds: t3, chart: i2 } = e3, r2 = (i2.options.series || []).filter((e4) => "tiledwebmap" === e4.type)[0];
          if (r2 && r2.provider && r2.provider.type && !r2.provider.url) {
            let e4 = o2[r2.provider.type];
            if (l(e4)) {
              let { initialProjectionName: o3 } = new e4();
              if (t3) {
                let { x1: e5, y1: i3, x2: r3, y2: s2 } = t3;
                this.recommendedMapView = { projection: { name: o3, parallels: [i3, s2], rotation: [-(e5 + r3) / 2] } };
              } else this.recommendedMapView = { projection: { name: o3 }, minZoom: 0 };
              return false;
            }
            p("Highcharts warning: Tiles Provider not defined in the Provider Registry.", false);
          }
          return true;
        }
        class u extends a {
          constructor() {
            super(...arguments), this.redrawTiles = false, this.isAnimating = false;
          }
          static compose(e3) {
            h(s, "TiledWebMapSeries") && n(e3, "onRecommendMapView", d);
          }
          lonLatToTile(e3, t3) {
            let { lon: o3, lat: i2 } = e3;
            return { x: Math.floor((o3 + 180) / 360 * Math.pow(2, t3)), y: Math.floor((1 - Math.log(Math.tan(i2 * Math.PI / 180) + 1 / Math.cos(i2 * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, t3)) };
          }
          tileToLonLat(e3, t3, o3) {
            let i2 = e3 / Math.pow(2, o3) * 360 - 180, r2 = Math.PI - 2 * Math.PI * t3 / Math.pow(2, o3);
            return { lon: i2, lat: 180 / Math.PI * Math.atan(0.5 * (Math.exp(r2) - Math.exp(-r2))) };
          }
          drawPoints() {
            var _a;
            let e3 = this.chart, t3 = e3.mapView;
            if (!t3) return;
            let i2 = this.tiles = this.tiles || {}, r2 = this.transformGroups = this.transformGroups || [], s2 = this, a2 = this.options.provider, { zoom: n2 } = t3, m2 = c(t3.projection.options.rotation && t3.projection.options.rotation[0], 0), h2 = e3.renderer.forExport ? 0 : 200, d2 = (e4) => {
              for (let o3 of Object.keys(i2)) parseFloat(o3) === (t3.zoom < 0 ? 0 : Math.floor(t3.zoom)) || s2.minZoom && (t3.zoom < 0 ? 0 : Math.floor(t3.zoom)) < s2.minZoom && parseFloat(o3) === s2.minZoom || s2.maxZoom && (t3.zoom < 0 ? 0 : Math.floor(t3.zoom)) > s2.maxZoom && parseFloat(o3) === s2.maxZoom ? Object.keys(i2[o3].tiles).forEach((t4, r3) => {
                i2[o3].tiles[t4].animate({ opacity: 1 }, { duration: e4 }, () => {
                  r3 === Object.keys(i2[o3].tiles).length - 1 && (i2[o3].isActive = true);
                });
              }) : Object.keys(i2[o3].tiles).forEach((t4, r3) => {
                i2[o3].tiles[t4].animate({ opacity: 0 }, { duration: e4, defer: e4 / 2 }, () => {
                  i2[o3].tiles[t4].destroy(), delete i2[o3].tiles[t4], r3 === Object.keys(i2[o3].tiles).length - 1 && (i2[o3].isActive = false, i2[o3].loaded = false);
                });
              });
            }, u2 = n2 < 0 ? 0 : Math.floor(n2), y = Math.pow(2, u2), f = 0.638436911716859 * Math.pow(2, n2) / (0.638436911716859 * Math.pow(2, u2)), g = 256 * f;
            if (a2 && (a2.type || a2.url)) {
              if (a2.type && !a2.url) {
                let i3 = o2[a2.type];
                if (!l(i3)) {
                  p("Highcharts warning: Tiles Provider '" + a2.type + "' not defined in the ProviderRegistry.", false);
                  return;
                }
                let r3 = new i3(), s3 = r3.initialProjectionName, n3, m3 = "";
                if (a2.theme && l(r3.themes[a2.theme])) n3 = r3.themes[a2.theme];
                else {
                  let e4 = Object.keys(r3.themes)[0];
                  n3 = r3.themes[e4], p("Highcharts warning: The Tiles Provider's Theme '" + a2.theme + "' is not defined in the Provider definition - falling back to '" + e4 + "'.", false);
                }
                a2.subdomain && r3.subdomains && -1 !== r3.subdomains.indexOf(a2.subdomain) ? m3 = a2.subdomain : l(r3.subdomains) && -1 !== n3.url.indexOf("{s}") && (m3 = c(r3.subdomains && r3.subdomains[0], ""), p("Highcharts warning: The Tiles Provider's Subdomain '" + a2.subdomain + "' is not defined in the Provider definition - falling back to '" + m3 + "'.", false)), r3.requiresApiKey && (a2.apiKey ? n3.url = n3.url.replace("{apikey}", a2.apiKey) : (p("Highcharts warning: The Tiles Provider requires API Key to use tiles, use provider.apiKey to provide a token.", false), n3.url = n3.url.replace("?apikey={apikey}", ""))), a2.url = n3.url.replace("{s}", m3), this.minZoom = n3.minZoom, this.maxZoom = n3.maxZoom;
                let h3 = c(e3.userOptions.credits && e3.userOptions.credits.text, "Highcharts.com " + c(n3.credits, r3.defaultCredits));
                e3.credits ? e3.credits.update({ text: h3 }) : e3.addCredits({ text: h3, style: c((_a = e3.options.credits) == null ? void 0 : _a.style, {}) }), t3.projection.options.name !== s3 && p("Highcharts warning: The set projection is different than supported by Tiles Provider.", false);
              } else t3.projection.options.name || p("Highcharts warning: The set projection is different than supported by Tiles Provider.", false);
              if (l(this.minZoom) && u2 < this.minZoom ? (y = Math.pow(2, u2 = this.minZoom), g = 256 * (f = 0.638436911716859 * Math.pow(2, n2) / (0.638436911716859 * Math.pow(2, u2)))) : l(this.maxZoom) && u2 > this.maxZoom && (y = Math.pow(2, u2 = this.maxZoom), g = 256 * (f = 0.638436911716859 * Math.pow(2, n2) / (0.638436911716859 * Math.pow(2, u2)))), t3.projection && t3.projection.def) {
                t3.projection.hasCoordinates = true, r2[u2] || (r2[u2] = e3.renderer.g().add(this.group));
                let o3 = (e4, t4, o4, i3) => e4.replace("{x}", t4.toString()).replace("{y}", o4.toString()).replace("{zoom}", i3.toString()).replace("{z}", i3.toString()), n3 = (n4, l3, p3, m3, c3) => {
                  let u3 = n4 % y, f3 = l3 % y, M2 = u3 < 0 ? u3 + y : u3, T2 = f3 < 0 ? f3 + y : f3;
                  if (!i2[`${p3}`].tiles[`${n4},${l3}`] && a2.url) {
                    let u4 = o3(a2.url, M2, T2, p3);
                    i2[p3].loaded = false, i2[`${p3}`].tiles[`${n4},${l3}`] = e3.renderer.image(u4, n4 * g - m3, l3 * g - c3, g, g).attr({ zIndex: 2, opacity: 0 }).on("load", function() {
                      a2.onload && a2.onload.apply(this), (p3 === (t3.zoom < 0 ? 0 : Math.floor(t3.zoom)) || p3 === s2.minZoom) && (i2[`${p3}`].actualTilesCount++, i2[`${p3}`].howManyTiles === i2[`${p3}`].actualTilesCount && (i2[p3].loaded = true, s2.isAnimating ? s2.redrawTiles = true : (s2.redrawTiles = false, d2(h2)), i2[`${p3}`].actualTilesCount = 0));
                    }).add(r2[p3]), i2[`${p3}`].tiles[`${n4},${l3}`].posX = n4, i2[`${p3}`].tiles[`${n4},${l3}`].posY = l3, i2[`${p3}`].tiles[`${n4},${l3}`].originalURL = u4;
                  }
                }, l2 = t3.pixelsToProjectedUnits({ x: 0, y: 0 }), p2 = t3.projection.def.inverse([l2.x, l2.y]), c2 = { lon: p2[0] - m2, lat: p2[1] }, f2 = t3.pixelsToProjectedUnits({ x: e3.plotWidth, y: e3.plotHeight }), M = t3.projection.def.inverse([f2.x, f2.y]), T = { lon: M[0] - m2, lat: M[1] };
                (c2.lat > t3.projection.maxLatitude || T.lat < -1 * t3.projection.maxLatitude) && (c2.lat = t3.projection.maxLatitude, T.lat = -1 * t3.projection.maxLatitude);
                let x = this.lonLatToTile(c2, u2), S = this.lonLatToTile(T, u2), v = this.tileToLonLat(x.x, x.y, u2), b = t3.projection.def.forward([v.lon + m2, v.lat]), Z = t3.projectedUnitsToPixels({ x: b[0], y: b[1] }), w = x.x * g - Z.x, j = x.y * g - Z.y;
                i2[`${u2}`] || (i2[`${u2}`] = { tiles: {}, isActive: false, howManyTiles: 0, actualTilesCount: 0, loaded: false }), i2[`${u2}`].howManyTiles = (S.x - x.x + 1) * (S.y - x.y + 1), i2[`${u2}`].actualTilesCount = 0;
                for (let e4 = x.x; e4 <= S.x; e4++) for (let t4 = x.y; t4 <= S.y; t4++) n3(e4, t4, u2, w, j);
              }
              for (let o3 of Object.keys(i2)) for (let r3 of Object.keys(i2[o3].tiles)) if (t3.projection && t3.projection.def) {
                let a3 = 256 * (0.638436911716859 * Math.pow(2, n2) / (0.638436911716859 * Math.pow(2, parseFloat(o3)))), p2 = i2[o3].tiles[Object.keys(i2[o3].tiles)[0]], { posX: c2, posY: y2 } = i2[o3].tiles[r3];
                if (l(c2) && l(y2) && l(p2.posX) && l(p2.posY)) {
                  let n3 = this.tileToLonLat(p2.posX, p2.posY, parseFloat(o3)), l2 = t3.projection.def.forward([n3.lon + m2, n3.lat]), f2 = t3.projectedUnitsToPixels({ x: l2[0], y: l2[1] }), g2 = p2.posX * a3 - f2.x, M = p2.posY * a3 - f2.y;
                  if (e3.renderer.globalAnimation && e3.hasRendered) {
                    let e4 = Number(i2[o3].tiles[r3].attr("x")), t4 = Number(i2[o3].tiles[r3].attr("y")), n4 = Number(i2[o3].tiles[r3].attr("width")), l3 = Number(i2[o3].tiles[r3].attr("height")), p3 = (s3, p4) => {
                      i2[o3].tiles[r3].attr({ x: e4 + (c2 * a3 - g2 - e4) * p4.pos, y: t4 + (y2 * a3 - M - t4) * p4.pos, width: n4 + (Math.ceil(a3) + 1 - n4) * p4.pos, height: l3 + (Math.ceil(a3) + 1 - l3) * p4.pos });
                    };
                    s2.isAnimating = true, i2[o3].tiles[r3].attr({ animator: 0 }).animate({ animator: 1 }, { step: p3 }, function() {
                      s2.isAnimating = false, s2.redrawTiles && (s2.redrawTiles = false, d2(h2));
                    });
                  } else (s2.redrawTiles || parseFloat(o3) !== u2 || (i2[o3].isActive || parseFloat(o3) === u2) && Object.keys(i2[o3].tiles).map((e4) => i2[o3].tiles[e4]).some((e4) => 0 === e4.opacity)) && (s2.redrawTiles = false, d2(h2)), i2[o3].tiles[r3].attr({ x: c2 * a3 - g2, y: y2 * a3 - M, width: Math.ceil(a3) + 1, height: Math.ceil(a3) + 1 });
                }
              }
            } else p("Highcharts warning: Tiles Provider not defined in the Provider Registry.", false);
          }
          update() {
            var _a;
            let { transformGroups: e3 } = this, t3 = this.chart, i2 = t3.mapView, r2 = arguments[0], { provider: s2 } = r2;
            if (e3 && (e3.forEach((e4) => {
              0 !== Object.keys(e4).length && e4.destroy();
            }), this.transformGroups = []), i2 && !l((_a = t3.userOptions.mapView) == null ? void 0 : _a.projection) && s2 && s2.type) {
              let e4 = o2[s2.type];
              if (e4) {
                let { initialProjectionName: t4 } = new e4();
                i2.update({ projection: { name: t4 } });
              }
            }
            super.update.apply(this, arguments);
          }
        }
        return u.defaultOptions = m(a.defaultOptions, i), t2.registerSeriesType("tiledwebmap", u), u;
      }), o(t, "masters/modules/tiledwebmap.src.js", [t["Core/Globals.js"], t["Maps/TilesProviders/TilesProviderRegistry.js"], t["Series/TiledWebMap/TiledWebMapSeries.js"]], function(e2, t2, o2) {
        return e2.TilesProviderRegistry = e2.TilesProviderRegistry || t2, o2.compose(e2.MapView), e2;
      });
    });
  }
});
export default require_tiledwebmap();
//# sourceMappingURL=highcharts_modules_tiledwebmap__js.js.map
