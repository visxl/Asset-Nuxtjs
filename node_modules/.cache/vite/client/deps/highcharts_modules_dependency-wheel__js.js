import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/dependency-wheel.js
var require_dependency_wheel = __commonJS({
  "node_modules/highcharts/modules/dependency-wheel.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Dependency wheel module
    *
    * (c) 2010-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/dependency-wheel", ["highcharts", "highcharts/modules/sankey"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function s(t2, s2, n, a) {
        t2.hasOwnProperty(s2) || (t2[s2] = a.apply(null, n), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: t2[s2] } })));
      }
      s(t, "Series/DependencyWheel/DependencyWheelPoint.js", [t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { sankey: { prototype: { pointClass: s2 } } } = e2.seriesTypes, { pInt: n, wrap: a } = t2;
        return class extends s2 {
          getDataLabelPath(e3) {
            var _a;
            let t3 = this, s3 = t3.series.chart.renderer, r = t3.shapeArgs, i = t3.angle < 0 || t3.angle > Math.PI, o = r.start || 0, l = r.end || 0;
            return t3.dataLabelPath ? (t3.dataLabelPath = t3.dataLabelPath.destroy(), delete t3.dataLabelPath) : a(e3, "destroy", function(e4) {
              return t3.dataLabelPath && (t3.dataLabelPath = t3.dataLabelPath.destroy()), e4.call(this);
            }), t3.dataLabelPath = s3.arc({ open: true, longArc: Math.abs(Math.abs(o) - Math.abs(l)) < Math.PI ? 0 : 1 }).attr({ x: r.x, y: r.y, r: (r.r || 0) + n(((_a = e3.options) == null ? void 0 : _a.distance) || 0), start: i ? o : l, end: i ? l : o, clockwise: +i }).add(s3.defs), t3.dataLabelPath;
          }
          isValid() {
            return true;
          }
        };
      }), s(t, "Series/DependencyWheel/DependencyWheelSeriesDefaults.js", [], function() {
        return { center: [null, null], curveFactor: 0.6, startAngle: 0, dataLabels: { textPath: { enabled: false, attributes: { dy: 5 } } } };
      }), s(t, "Series/DependencyWheel/DependencyWheelSeries.js", [t["Core/Animation/AnimationUtilities.js"], t["Series/DependencyWheel/DependencyWheelPoint.js"], t["Series/DependencyWheel/DependencyWheelSeriesDefaults.js"], t["Core/Globals.js"], t["Series/Sankey/SankeyColumnComposition.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"], t["Core/Renderer/SVG/SVGElement.js"], t["Extensions/TextPath.js"]], function(e2, t2, s2, n, a, r, i, o, l) {
        let { animObject: d } = e2, { deg2rad: h } = n, { pie: c, sankey: p } = r.seriesTypes, { extend: u, merge: y, relativeLength: f } = i;
        l.compose(o);
        class g extends p {
          animate(e3) {
            if (!e3) {
              let e4 = d(this.options.animation).duration / 2 / this.nodes.length, t3 = 0;
              for (let s3 of this.nodes) {
                let n2 = s3.graphic;
                n2 && (n2.attr({ opacity: 0 }), setTimeout(() => {
                  s3.graphic && s3.graphic.animate({ opacity: 1 }, { duration: e4 });
                }, e4 * t3++));
              }
              for (let e5 of this.points) {
                let t4 = e5.graphic;
                !e5.isNode && t4 && t4.attr({ opacity: 0 }).animate({ opacity: 1 }, this.options.animation);
              }
            }
          }
          createNode(e3) {
            let t3 = super.createNode(e3);
            return t3.getSum = () => t3.linksFrom.concat(t3.linksTo).reduce((e4, t4) => e4 + t4.weight, 0), t3.offset = (e4) => {
              let s3 = (e5) => e5.fromNode === t3 ? e5.toNode : e5.fromNode, n2 = 0, a2 = t3.linksFrom.concat(t3.linksTo), r2;
              a2.sort((e5, t4) => s3(e5).index - s3(t4).index);
              for (let e5 = 0; e5 < a2.length; e5++) if (s3(a2[e5]).index > t3.index) {
                a2 = a2.slice(0, e5).reverse().concat(a2.slice(e5).reverse()), r2 = true;
                break;
              }
              r2 || a2.reverse();
              for (let t4 = 0; t4 < a2.length; t4++) {
                if (a2[t4] === e4) return n2;
                n2 += a2[t4].weight;
              }
            }, t3;
          }
          createNodeColumns() {
            let e3 = [a.compose([], this)];
            for (let t3 of this.nodes) t3.column = 0, e3[0].push(t3);
            return e3;
          }
          getNodePadding() {
            return this.options.nodePadding / Math.PI;
          }
          translate() {
            let e3 = this.options, t3 = 2 * Math.PI / (this.chart.plotHeight + this.getNodePadding()), s3 = this.getCenter(), n2 = (e3.startAngle - 90) * h, a2 = e3.borderRadius, r2 = "object" == typeof a2 ? a2.radius : a2;
            for (let a3 of (super.translate(), this.nodeColumns[0])) if (a3.sum) {
              let i2 = a3.shapeArgs, o2 = s3[0], l2 = s3[1], d2 = s3[2] / 2, h2 = d2 - f(("auto" === e3.nodeWidth ? 20 : e3.nodeWidth) || 0, d2), c2 = n2 + t3 * (i2.y || 0), p2 = n2 + t3 * ((i2.y || 0) + (i2.height || 0));
              for (let s4 of (a3.angle = c2 + (p2 - c2) / 2, a3.shapeType = "arc", a3.shapeArgs = { x: o2, y: l2, r: d2, innerR: h2, start: c2, end: p2, borderRadius: r2 }, a3.dlBox = { x: o2 + Math.cos((c2 + p2) / 2) * (d2 + h2) / 2, y: l2 + Math.sin((c2 + p2) / 2) * (d2 + h2) / 2, width: 1, height: 1 }, a3.linksFrom)) if (s4.linkBase) {
                let a4, r3;
                let i3 = s4.linkBase.map((i4, d3) => {
                  let c3 = t3 * i4, p3 = Math.cos(n2 + c3) * (h2 + 1), u2 = Math.sin(n2 + c3) * (h2 + 1);
                  return a4 = e3.curveFactor || 0, (r3 = Math.abs(s4.linkBase[3 - d3] * t3 - c3)) > Math.PI && (r3 = 2 * Math.PI - r3), (r3 *= h2) < h2 && (a4 *= r3 / h2), { x: o2 + p3, y: l2 + u2, cpX: o2 + (1 - a4) * p3, cpY: l2 + (1 - a4) * u2 };
                });
                s4.shapeArgs = { d: [["M", i3[0].x, i3[0].y], ["A", h2, h2, 0, 0, 1, i3[1].x, i3[1].y], ["C", i3[1].cpX, i3[1].cpY, i3[2].cpX, i3[2].cpY, i3[2].x, i3[2].y], ["A", h2, h2, 0, 0, 1, i3[3].x, i3[3].y], ["C", i3[3].cpX, i3[3].cpY, i3[0].cpX, i3[0].cpY, i3[0].x, i3[0].y]] };
              }
            }
          }
        }
        return g.defaultOptions = y(p.defaultOptions, s2), u(g.prototype, { orderNodes: false, getCenter: c.prototype.getCenter }), g.prototype.pointClass = t2, r.registerSeriesType("dependencywheel", g), g;
      }), s(t, "masters/modules/dependency-wheel.src.js", [t["Core/Globals.js"]], function(e2) {
        return e2;
      });
    });
  }
});
export default require_dependency_wheel();
//# sourceMappingURL=highcharts_modules_dependency-wheel__js.js.map
