import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/item-series.js
var require_item_series = __commonJS({
  "node_modules/highcharts/modules/item-series.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Item series type for Highcharts
    *
    * (c) 2019 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/item-series", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function s(e2, s2, i, o) {
        e2.hasOwnProperty(s2) || (e2[s2] = o.apply(null, i), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: e2[s2] } })));
      }
      s(e, "Series/Item/ItemPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { series: { prototype: { pointClass: s2 } }, seriesTypes: { pie: { prototype: { pointClass: i } } } } = t2, { extend: o } = e2;
        class r extends i {
        }
        return o(r.prototype, { haloPath: s2.prototype.haloPath }), r;
      }), s(e, "Series/Item/ItemSeriesDefaults.js", [e["Core/Series/SeriesDefaults.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { merge: s2 } = e2;
        return { endAngle: void 0, innerSize: "40%", itemPadding: 0.1, layout: "vertical", marker: s2(t2.marker, { radius: null }), rows: void 0, crisp: false, showInLegend: true, startAngle: void 0 };
      }), s(e, "Series/Item/ItemSeries.js", [e["Series/Item/ItemPoint.js"], e["Series/Item/ItemSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i) {
        let { pie: o } = s2.seriesTypes, { defined: r, extend: a, fireEvent: l, isNumber: n, merge: h, pick: d } = i;
        class p extends o {
          animate(t3) {
            let e3 = this.group;
            e3 && (t3 ? e3.attr({ opacity: 0 }) : e3.animate({ opacity: 1 }, this.options.animation));
          }
          drawDataLabels() {
            if (this.center && this.slots) super.drawDataLabels();
            else for (let t3 of this.points) t3.destroyElements({ dataLabel: 1 });
          }
          drawPoints() {
            let t3 = this.options, e3 = this.chart.renderer, s3 = t3.marker, i2 = this.borderWidth % 2 ? 0.5 : 1, o2 = this.getRows(), l2 = Math.ceil(this.total / o2), n2 = this.chart.plotWidth / l2, h2 = this.chart.plotHeight / o2, p2 = this.itemSize || Math.min(n2, h2), u = 0;
            for (let c of this.points) {
              let f, g, m, y, S, w;
              let M = c.marker || {}, v = M.symbol || s3.symbol, C = d(M.radius, s3.radius), A = r(C) ? 2 * C : p2, b = A * t3.itemPadding;
              if (c.graphics = g = c.graphics || [], this.chart.styledMode || (m = this.pointAttribs(c, c.selected && "select")), !c.isNull && c.visible) {
                c.graphic || (c.graphic = e3.g("point").add(this.group));
                for (let s4 = 0; s4 < (c.y || 0); ++s4) {
                  if (this.center && this.slots) {
                    let t4 = this.slots.shift();
                    y = t4.x - p2 / 2, S = t4.y - p2 / 2;
                  } else "horizontal" === t3.layout ? (y = u % l2 * n2, S = h2 * Math.floor(u / l2)) : (y = n2 * Math.floor(u / o2), S = u % o2 * h2);
                  y += b, S += b, w = Math.round(A - 2 * b), this.options.crisp && (y = Math.round(y) - i2, S = Math.round(S) + i2), f = { x: y, y: S, width: w, height: w }, void 0 !== C && (f.r = C), m && a(f, m);
                  let r2 = g[s4];
                  r2 ? r2.animate(f) : r2 = e3.symbol(v, void 0, void 0, void 0, void 0, { backgroundSize: "within" }).attr(f).add(c.graphic), r2.isActive = true, g[s4] = r2, ++u;
                }
              }
              for (let t4 = 0; t4 < g.length; t4++) {
                let e4 = g[t4];
                if (!e4) return;
                e4.isActive ? e4.isActive = false : (e4.destroy(), g.splice(t4, 1), t4--);
              }
            }
          }
          getRows() {
            let t3 = this.chart, e3 = this.total || 0, s3 = this.options.rows, i2;
            if (!s3) {
              if (i2 = t3.plotWidth / t3.plotHeight, s3 = Math.sqrt(e3), i2 > 1) for (s3 = Math.ceil(s3); s3 > 0 && !(e3 / s3 / s3 > i2); ) s3--;
              else for (s3 = Math.floor(s3); s3 < e3 && !(e3 / s3 / s3 < i2); ) s3++;
            }
            return s3;
          }
          getSlots() {
            let t3 = this.center, e3 = t3[2], s3 = this.slots = this.slots || [], i2 = this.endAngleRad - this.startAngleRad, o2 = this.options.rows, r2 = i2 % (2 * Math.PI) == 0, a2 = this.total || 0, l2 = t3[3], n2, h2, d2, p2, u, c, f, g, m = 0, y, S = Number.MAX_VALUE, w, M, v, C = (e3 - l2) / e3;
            for (; S > a2 + (M && r2 ? M.length : 0); ) {
              w = S, s3.length = 0, S = 0, M = v, v = [], y = e3 / ++m / 2, o2 ? (l2 = (y - o2) / y * e3) >= 0 ? y = o2 : (l2 = 0, C = 1) : y = Math.floor(y * C);
              for (let t4 = y; t4 > 0; t4--) u = Math.ceil((p2 = i2 * (d2 = (l2 + t4 / y * (e3 - l2 - m)) / 2)) / m), v.push({ rowRadius: d2, rowLength: p2, colCount: u }), S += u + 1;
            }
            if (!M) return;
            let A = w - this.total - (r2 ? M.length : 0), b = (t4) => {
              A > 0 && (t4.row.colCount--, A--);
            };
            for (; A > 0; ) M.map((t4) => ({ angle: t4.colCount / t4.rowLength, row: t4 })).sort((t4, e4) => e4.angle - t4.angle).slice(0, Math.min(A, Math.ceil(M.length / 2))).forEach(b);
            for (let e4 of M) {
              let o3 = e4.rowRadius, r3 = e4.colCount;
              for (g = 0, c = r3 ? i2 / r3 : 0; g <= r3; g += 1) f = this.startAngleRad + g * c, n2 = t3[0] + Math.cos(f) * o3, h2 = t3[1] + Math.sin(f) * o3, s3.push({ x: n2, y: h2, angle: f });
            }
            return s3.sort((t4, e4) => t4.angle - e4.angle), this.itemSize = m, s3;
          }
          translate(t3) {
            0 === this.total && n(this.options.startAngle) && n(this.options.endAngle) && (this.center = this.getCenter()), this.slots || (this.slots = []), n(this.options.startAngle) && n(this.options.endAngle) ? (super.translate(t3), this.slots = this.getSlots()) : (this.generatePoints(), l(this, "afterTranslate"));
          }
        }
        return p.defaultOptions = h(o.defaultOptions, e2), a(p.prototype, { markerAttribs: void 0, pointClass: t2 }), s2.registerSeriesType("item", p), p;
      }), s(e, "masters/modules/item-series.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_item_series();
//# sourceMappingURL=highcharts_modules_item-series__js.js.map
