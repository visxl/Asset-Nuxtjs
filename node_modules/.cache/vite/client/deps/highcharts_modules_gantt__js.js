import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/gantt.js
var require_gantt = __commonJS({
  "node_modules/highcharts/modules/gantt.js"(exports, module) {
    !/**
    * Highcharts Gantt JS v11.4.7 (2024-08-14)
    *
    * Gantt series
    *
    * (c) 2016-2024 Lars A. V. Cabrera
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/gantt", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, s, o) {
        e2.hasOwnProperty(i2) || (e2[i2] = o.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Extensions/ArrowSymbols.js", [], function() {
        function t2(t3, e3, i3, s2) {
          return [["M", t3, e3 + s2 / 2], ["L", t3 + i3, e3], ["L", t3, e3 + s2 / 2], ["L", t3 + i3, e3 + s2]];
        }
        function e2(e3, i3, s2, o) {
          return t2(e3, i3, s2 / 2, o);
        }
        function i2(t3, e3, i3, s2) {
          return [["M", t3 + i3, e3], ["L", t3, e3 + s2 / 2], ["L", t3 + i3, e3 + s2], ["Z"]];
        }
        function s(t3, e3, s2, o) {
          return i2(t3, e3, s2 / 2, o);
        }
        return { compose: function(o) {
          let r = o.prototype.symbols;
          r.arrow = t2, r["arrow-filled"] = i2, r["arrow-filled-half"] = s, r["arrow-half"] = e2, r["triangle-left"] = i2, r["triangle-left-half"] = s;
        } };
      }), i(e, "Gantt/Connection.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { defined: i2, error: s, merge: o, objectEach: r } = e2, n = t2.deg2rad, a = Math.max, l = Math.min;
        return class {
          constructor(t3, e3, i3) {
            this.init(t3, e3, i3);
          }
          init(t3, e3, i3) {
            this.fromPoint = t3, this.toPoint = e3, this.options = i3, this.chart = t3.series.chart, this.pathfinder = this.chart.pathfinder;
          }
          renderPath(t3, e3) {
            let i3 = this.chart, s2 = i3.styledMode, o2 = this.pathfinder, r2 = {}, n2 = this.graphics && this.graphics.path;
            o2.group || (o2.group = i3.renderer.g().addClass("highcharts-pathfinder-group").attr({ zIndex: -1 }).add(i3.seriesGroup)), o2.group.translate(i3.plotLeft, i3.plotTop), n2 && n2.renderer || (n2 = i3.renderer.path().add(o2.group), s2 || n2.attr({ opacity: 0 })), n2.attr(e3), r2.d = t3, s2 || (r2.opacity = 1), n2.animate(r2), this.graphics = this.graphics || {}, this.graphics.path = n2;
          }
          addMarker(t3, e3, i3) {
            let s2, o2, r2, a2, l2, h, d, c;
            let p = this.fromPoint.series.chart, u = p.pathfinder, g = p.renderer, x = "start" === t3 ? this.fromPoint : this.toPoint, f = x.getPathfinderAnchorPoint(e3);
            e3.enabled && ((c = "start" === t3 ? i3[1] : i3[i3.length - 2]) && "M" === c[0] || "L" === c[0]) && (d = { x: c[1], y: c[2] }, o2 = x.getRadiansToVector(d, f), s2 = x.getMarkerVector(o2, e3.radius, f), r2 = -o2 / n, e3.width && e3.height ? (l2 = e3.width, h = e3.height) : l2 = h = 2 * e3.radius, this.graphics = this.graphics || {}, a2 = { x: s2.x - l2 / 2, y: s2.y - h / 2, width: l2, height: h, rotation: r2, rotationOriginX: s2.x, rotationOriginY: s2.y }, this.graphics[t3] ? this.graphics[t3].animate(a2) : (this.graphics[t3] = g.symbol(e3.symbol).addClass("highcharts-point-connecting-path-" + t3 + "-marker highcharts-color-" + this.fromPoint.colorIndex).attr(a2).add(u.group), g.styledMode || this.graphics[t3].attr({ fill: e3.color || this.fromPoint.color, stroke: e3.lineColor, "stroke-width": e3.lineWidth, opacity: 0 }).animate({ opacity: 1 }, x.series.options.animation)));
          }
          getPath(t3) {
            let e3 = this.pathfinder, i3 = this.chart, r2 = e3.algorithms[t3.type], n2 = e3.chartObstacles;
            return "function" != typeof r2 ? (s('"' + t3.type + '" is not a Pathfinder algorithm.'), { path: [], obstacles: [] }) : (r2.requiresObstacles && !n2 && (n2 = e3.chartObstacles = e3.getChartObstacles(t3), i3.options.connectors.algorithmMargin = t3.algorithmMargin, e3.chartObstacleMetrics = e3.getObstacleMetrics(n2)), r2(this.fromPoint.getPathfinderAnchorPoint(t3.startMarker), this.toPoint.getPathfinderAnchorPoint(t3.endMarker), o({ chartObstacles: n2, lineObstacles: e3.lineObstacles || [], obstacleMetrics: e3.chartObstacleMetrics, hardBounds: { xMin: 0, xMax: i3.plotWidth, yMin: 0, yMax: i3.plotHeight }, obstacleOptions: { margin: t3.algorithmMargin }, startDirectionX: e3.getAlgorithmStartDirection(t3.startMarker) }, t3)));
          }
          render() {
            let t3 = this.fromPoint, e3 = t3.series, s2 = e3.chart, r2 = s2.pathfinder, n2 = {}, h = o(s2.options.connectors, e3.options.connectors, t3.options.connectors, this.options);
            !s2.styledMode && (n2.stroke = h.lineColor || t3.color, n2["stroke-width"] = h.lineWidth, h.dashStyle && (n2.dashstyle = h.dashStyle)), n2.class = "highcharts-point-connecting-path highcharts-color-" + t3.colorIndex, i2((h = o(n2, h)).marker.radius) || (h.marker.radius = l(a(Math.ceil((h.algorithmMargin || 8) / 2) - 1, 1), 5));
            let d = this.getPath(h), c = d.path;
            d.obstacles && (r2.lineObstacles = r2.lineObstacles || [], r2.lineObstacles = r2.lineObstacles.concat(d.obstacles)), this.renderPath(c, n2), this.addMarker("start", o(h.marker, h.startMarker), c), this.addMarker("end", o(h.marker, h.endMarker), c);
          }
          destroy() {
            this.graphics && (r(this.graphics, function(t3) {
              t3.destroy();
            }), delete this.graphics);
          }
        };
      }), i(e, "Extensions/CurrentDateIndication.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { composed: i2 } = t2, { addEvent: s, merge: o, pushUnique: r, wrap: n } = e2, a = { color: "#ccd3ff", width: 2, label: { format: "%a, %b %d %Y, %H:%M", formatter: function(t3, e3) {
          return this.axis.chart.time.dateFormat(e3 || "", t3);
        }, rotation: 0, style: { fontSize: "0.7em" } } };
        function l() {
          let t3 = this.options, e3 = t3.currentDateIndicator;
          if (e3) {
            let i3 = "object" == typeof e3 ? o(a, e3) : o(a);
            i3.value = Date.now(), i3.className = "highcharts-current-date-indicator", t3.plotLines || (t3.plotLines = []), t3.plotLines.push(i3);
          }
        }
        function h() {
          this.label && this.label.attr({ text: this.getLabelText(this.options.label) });
        }
        function d(t3, e3) {
          let i3 = this.options;
          return i3 && i3.className && -1 !== i3.className.indexOf("highcharts-current-date-indicator") && i3.label && "function" == typeof i3.label.formatter ? (i3.value = Date.now(), i3.label.formatter.call(this, i3.value, i3.label.format)) : t3.call(this, e3);
        }
        return { compose: function(t3, e3) {
          r(i2, "CurrentDateIndication") && (s(t3, "afterSetOptions", l), s(e3, "render", h), n(e3.prototype, "getLabelText", d));
        } };
      }), i(e, "Core/Chart/GanttChart.js", [e["Core/Chart/Chart.js"], e["Core/Defaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        var s;
        let { defaultOptions: o } = e2, { isArray: r, merge: n, splat: a } = i2;
        class l extends t2 {
          init(t3, e3) {
            let i3;
            let s2 = t3.xAxis, l2 = t3.yAxis;
            t3.xAxis = t3.yAxis = void 0;
            let h = n(true, { chart: { type: "gantt" }, title: { text: "" }, legend: { enabled: false }, navigator: { series: { type: "gantt" }, yAxis: { type: "category" } } }, t3, { isGantt: true });
            t3.xAxis = s2, t3.yAxis = l2, h.xAxis = (r(t3.xAxis) ? t3.xAxis : [t3.xAxis || {}, {}]).map((t4, e4) => {
              var _a;
              return 1 === e4 && (i3 = 0), n({ grid: { borderColor: "#cccccc", enabled: true }, opposite: ((_a = o.xAxis) == null ? void 0 : _a.opposite) ?? t4.opposite ?? true, linkedTo: i3 }, t4, { type: "datetime" });
            }), h.yAxis = a(t3.yAxis || {}).map((t4) => n({ grid: { borderColor: "#cccccc", enabled: true }, staticScale: 50, reversed: true, type: t4.categories ? t4.type : "treegrid" }, t4)), super.init(h, e3);
          }
        }
        return (s = l || (l = {})).ganttChart = function(t3, e3, i3) {
          return new s(t3, e3, i3);
        }, l;
      }), i(e, "Stock/Navigator/ChartNavigatorComposition.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let i2;
        let { isTouchDevice: s } = t2, { addEvent: o, merge: r, pick: n } = e2, a = [];
        function l() {
          this.navigator && this.navigator.setBaseSeries(null, false);
        }
        function h() {
          var _a;
          let t3, e3, i3;
          let s2 = this.legend, o2 = this.navigator;
          if (o2) {
            t3 = s2 && s2.options, e3 = o2.xAxis, i3 = o2.yAxis;
            let { scrollbarHeight: r2, scrollButtonSize: a2 } = o2;
            this.inverted ? (o2.left = o2.opposite ? this.chartWidth - r2 - o2.height : this.spacing[3] + r2, o2.top = this.plotTop + a2) : (o2.left = n(e3.left, this.plotLeft + a2), o2.top = o2.navigatorOptions.top || this.chartHeight - o2.height - r2 - (((_a = this.scrollbar) == null ? void 0 : _a.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t3 && "bottom" === t3.verticalAlign && "proximate" !== t3.layout && t3.enabled && !t3.floating ? s2.legendHeight + n(t3.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e3 && i3 && (this.inverted ? e3.options.left = i3.options.left = o2.left : e3.options.top = i3.options.top = o2.top, e3.setAxisSize(), i3.setAxisSize());
          }
        }
        function d(t3) {
          !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new i2(this), n(t3.redraw, true) && this.redraw(t3.animation));
        }
        function c() {
          let t3 = this.options;
          (t3.navigator.enabled || t3.scrollbar.enabled) && (this.scroller = this.navigator = new i2(this));
        }
        function p() {
          let t3 = this.options, e3 = t3.navigator, i3 = t3.rangeSelector;
          if ((e3 && e3.enabled || i3 && i3.enabled) && (!s && "x" === this.zooming.type || s && "x" === this.zooming.pinchType)) return false;
        }
        function u(t3) {
          let e3 = t3.navigator;
          if (e3 && t3.xAxis[0]) {
            let i3 = t3.xAxis[0].getExtremes();
            e3.render(i3.min, i3.max);
          }
        }
        function g(t3) {
          let e3 = t3.options.navigator || {}, i3 = t3.options.scrollbar || {};
          !this.navigator && !this.scroller && (e3.enabled || i3.enabled) && (r(true, this.options.navigator, e3), r(true, this.options.scrollbar, i3), delete t3.options.navigator, delete t3.options.scrollbar);
        }
        return { compose: function(t3, s2) {
          if (e2.pushUnique(a, t3)) {
            let e3 = t3.prototype;
            i2 = s2, e3.callbacks.push(u), o(t3, "afterAddSeries", l), o(t3, "afterSetChartSize", h), o(t3, "afterUpdate", d), o(t3, "beforeRender", c), o(t3, "beforeShowResetZoom", p), o(t3, "update", g);
          }
        } };
      }), i(e, "Core/Axis/NavigatorAxisComposition.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { isTouchDevice: i2 } = t2, { addEvent: s, correctFloat: o, defined: r, isNumber: n, pick: a } = e2;
        function l() {
          this.navigatorAxis || (this.navigatorAxis = new d(this));
        }
        function h(t3) {
          let e3;
          let s2 = this.chart, o2 = s2.options, n2 = o2.navigator, a2 = this.navigatorAxis, l2 = s2.zooming.pinchType, h2 = o2.rangeSelector, d2 = s2.zooming.type;
          if (this.isXAxis && ((n2 == null ? void 0 : n2.enabled) || (h2 == null ? void 0 : h2.enabled))) {
            if ("y" === d2 && "zoom" === t3.trigger) e3 = false;
            else if (("zoom" === t3.trigger && "xy" === d2 || i2 && "xy" === l2) && this.options.range) {
              let e4 = a2.previousZoom;
              r(t3.min) ? a2.previousZoom = [this.min, this.max] : e4 && (t3.min = e4[0], t3.max = e4[1], a2.previousZoom = void 0);
            }
          }
          void 0 !== e3 && t3.preventDefault();
        }
        class d {
          static compose(t3) {
            t3.keepProps.includes("navigatorAxis") || (t3.keepProps.push("navigatorAxis"), s(t3, "init", l), s(t3, "setExtremes", h));
          }
          constructor(t3) {
            this.axis = t3;
          }
          destroy() {
            this.axis = void 0;
          }
          toFixedRange(t3, e3, i3, s2) {
            let l2 = this.axis, h2 = (l2.pointRange || 0) / 2, d2 = a(i3, l2.translate(t3, true, !l2.horiz)), c = a(s2, l2.translate(e3, true, !l2.horiz));
            return r(i3) || (d2 = o(d2 + h2)), r(s2) || (c = o(c - h2)), n(d2) && n(c) || (d2 = c = void 0), { min: d2, max: c };
          }
        }
        return d;
      }), i(e, "Stock/Navigator/NavigatorDefaults.js", [e["Core/Color/Color.js"], e["Core/Series/SeriesRegistry.js"]], function(t2, e2) {
        let { parse: i2 } = t2, { seriesTypes: s } = e2;
        return { height: 40, margin: 25, maskInside: true, handles: { width: 7, borderRadius: 0, height: 15, symbols: ["navigator-handle", "navigator-handle"], enabled: true, lineWidth: 1, backgroundColor: "#f2f2f2", borderColor: "#999999" }, maskFill: i2("#667aff").setOpacity(0.3).get(), outlineColor: "#999999", outlineWidth: 1, series: { type: void 0 === s.areaspline ? "line" : "areaspline", fillOpacity: 0.05, lineWidth: 1, compare: null, sonification: { enabled: false }, dataGrouping: { approximation: "average", enabled: true, groupPixelWidth: 2, firstAnchor: "firstPoint", anchor: "middle", lastAnchor: "lastPoint", units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2, 3, 4]], ["week", [1, 2, 3]], ["month", [1, 3, 6]], ["year", null]] }, dataLabels: { enabled: false, zIndex: 2 }, id: "highcharts-navigator-series", className: "highcharts-navigator-series", lineColor: null, marker: { enabled: false }, threshold: null }, xAxis: { className: "highcharts-navigator-xaxis", tickLength: 0, lineWidth: 0, gridLineColor: "#e6e6e6", id: "navigator-x-axis", gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", style: { color: "#000000", fontSize: "0.7em", opacity: 0.6, textOutline: "2px contrast" }, x: 3, y: -4 }, crosshair: false }, yAxis: { className: "highcharts-navigator-yaxis", gridLineWidth: 0, startOnTick: false, endOnTick: false, minPadding: 0.1, id: "navigator-y-axis", maxPadding: 0.1, labels: { enabled: false }, crosshair: false, title: { text: null }, tickLength: 0, tickWidth: 0 } };
      }), i(e, "Stock/Navigator/NavigatorSymbols.js", [e["Core/Renderer/SVG/Symbols.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { relativeLength: i2 } = e2;
        return { "navigator-handle": function(e3, s, o, r, n = {}) {
          let a = n.width ? n.width / 2 : o, l = i2(n.borderRadius || 0, Math.min(2 * a, r));
          return [["M", -1.5, (r = n.height || r) / 2 - 3.5], ["L", -1.5, r / 2 + 4.5], ["M", 0.5, r / 2 - 3.5], ["L", 0.5, r / 2 + 4.5], ...t2.rect(-a - 1, 0.5, 2 * a + 1, r, { r: l })];
        } };
      }), i(e, "Stock/Utilities/StockUtilities.js", [e["Core/Utilities.js"]], function(t2) {
        let { defined: e2 } = t2;
        return { setFixedRange: function(t3) {
          let i2 = this.xAxis[0];
          e2(i2.dataMax) && e2(i2.dataMin) && t3 ? this.fixedRange = Math.min(t3, i2.dataMax - i2.dataMin) : this.fixedRange = t3;
        } };
      }), i(e, "Stock/Navigator/NavigatorComposition.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/NavigatorAxisComposition.js"], e["Stock/Navigator/NavigatorDefaults.js"], e["Stock/Navigator/NavigatorSymbols.js"], e["Core/Renderer/RendererRegistry.js"], e["Stock/Utilities/StockUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, o, r, n, a) {
        let { setOptions: l } = t2, { composed: h } = e2, { getRendererType: d } = r, { setFixedRange: c } = n, { addEvent: p, extend: u, pushUnique: g } = a;
        function x() {
          this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, false);
        }
        return { compose: function(t3, e3, r2) {
          i2.compose(e3), g(h, "Navigator") && (t3.prototype.setFixedRange = c, u(d().prototype.symbols, o), p(r2, "afterUpdate", x), l({ navigator: s }));
        } };
      }), i(e, "Core/Axis/ScrollbarAxis.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var i2;
        let { composed: s } = t2, { addEvent: o, defined: r, pick: n, pushUnique: a } = e2;
        return function(t3) {
          let e3;
          function i3(t4) {
            let e4 = n(t4.options && t4.options.min, t4.min), i4 = n(t4.options && t4.options.max, t4.max);
            return { axisMin: e4, axisMax: i4, scrollMin: r(t4.dataMin) ? Math.min(e4, t4.min, t4.dataMin, n(t4.threshold, 1 / 0)) : e4, scrollMax: r(t4.dataMax) ? Math.max(i4, t4.max, t4.dataMax, n(t4.threshold, -1 / 0)) : i4 };
          }
          function l() {
            let t4 = this.scrollbar, e4 = t4 && !t4.options.opposite, i4 = this.horiz ? 2 : e4 ? 3 : 1;
            t4 && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[i4] += t4.size + (t4.options.margin || 0));
          }
          function h() {
            let t4 = this;
            t4.options && t4.options.scrollbar && t4.options.scrollbar.enabled && (t4.options.scrollbar.vertical = !t4.horiz, t4.options.startOnTick = t4.options.endOnTick = false, t4.scrollbar = new e3(t4.chart.renderer, t4.options.scrollbar, t4.chart), o(t4.scrollbar, "changed", function(e4) {
              let s2, o2;
              let { axisMin: n2, axisMax: a2, scrollMin: l2, scrollMax: h2 } = i3(t4), d2 = h2 - l2;
              if (r(n2) && r(a2)) {
                if (t4.horiz && !t4.reversed || !t4.horiz && t4.reversed ? (s2 = l2 + d2 * this.to, o2 = l2 + d2 * this.from) : (s2 = l2 + d2 * (1 - this.from), o2 = l2 + d2 * (1 - this.to)), this.shouldUpdateExtremes(e4.DOMType)) {
                  let i4 = "mousemove" !== e4.DOMType && "touchmove" !== e4.DOMType && void 0;
                  t4.setExtremes(o2, s2, true, i4, e4);
                } else this.setRange(this.from, this.to);
              }
            }));
          }
          function d() {
            let t4, e4, s2;
            let { scrollMin: o2, scrollMax: n2 } = i3(this), a2 = this.scrollbar, l2 = this.axisTitleMargin + (this.titleOffset || 0), h2 = this.chart.scrollbarsOffsets, d2 = this.options.margin || 0;
            if (a2 && h2) {
              if (this.horiz) this.opposite || (h2[1] += l2), a2.position(this.left, this.top + this.height + 2 + h2[1] - (this.opposite ? d2 : 0), this.width, this.height), this.opposite || (h2[1] += d2), t4 = 1;
              else {
                let e5;
                this.opposite && (h2[0] += l2), e5 = a2.options.opposite ? this.left + this.width + 2 + h2[0] - (this.opposite ? 0 : d2) : this.opposite ? 0 : d2, a2.position(e5, this.top, this.width, this.height), this.opposite && (h2[0] += d2), t4 = 0;
              }
              h2[t4] += a2.size + (a2.options.margin || 0), isNaN(o2) || isNaN(n2) || !r(this.min) || !r(this.max) || this.min === this.max ? a2.setRange(0, 1) : (e4 = (this.min - o2) / (n2 - o2), s2 = (this.max - o2) / (n2 - o2), this.horiz && !this.reversed || !this.horiz && this.reversed ? a2.setRange(e4, s2) : a2.setRange(1 - s2, 1 - e4));
            }
          }
          t3.compose = function(t4, i4) {
            a(s, "Axis.Scrollbar") && (e3 = i4, o(t4, "afterGetOffset", l), o(t4, "afterInit", h), o(t4, "afterRender", d));
          };
        }(i2 || (i2 = {})), i2;
      }), i(e, "Stock/Scrollbar/ScrollbarDefaults.js", [], function() {
        return { height: 10, barBorderRadius: 5, buttonBorderRadius: 0, buttonsEnabled: false, liveRedraw: void 0, margin: void 0, minWidth: 6, opposite: true, step: 0.2, zIndex: 3, barBackgroundColor: "#cccccc", barBorderWidth: 0, barBorderColor: "#cccccc", buttonArrowColor: "#333333", buttonBackgroundColor: "#e6e6e6", buttonBorderColor: "#cccccc", buttonBorderWidth: 1, rifleColor: "none", trackBackgroundColor: "rgba(255, 255, 255, 0.001)", trackBorderColor: "#cccccc", trackBorderRadius: 5, trackBorderWidth: 1 };
      }), i(e, "Stock/Scrollbar/Scrollbar.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/ScrollbarAxis.js"], e["Stock/Scrollbar/ScrollbarDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, o) {
        let { defaultOptions: r } = t2, { addEvent: n, correctFloat: a, crisp: l, defined: h, destroyObjectProperties: d, fireEvent: c, merge: p, pick: u, removeEvent: g } = o;
        class x {
          static compose(t3) {
            i2.compose(t3, x);
          }
          static swapXY(t3, e3) {
            return e3 && t3.forEach((t4) => {
              let e4;
              let i3 = t4.length;
              for (let s2 = 0; s2 < i3; s2 += 2) "number" == typeof (e4 = t4[s2 + 1]) && (t4[s2 + 1] = t4[s2 + 2], t4[s2 + 2] = e4);
            }), t3;
          }
          constructor(t3, e3, i3) {
            this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t3, e3, i3);
          }
          addEvents() {
            let t3 = this.options.inverted ? [1, 0] : [0, 1], e3 = this.scrollbarButtons, i3 = this.scrollbarGroup.element, s2 = this.track.element, o2 = this.mouseDownHandler.bind(this), r2 = this.mouseMoveHandler.bind(this), a2 = this.mouseUpHandler.bind(this), l2 = [[e3[t3[0]].element, "click", this.buttonToMinClick.bind(this)], [e3[t3[1]].element, "click", this.buttonToMaxClick.bind(this)], [s2, "click", this.trackClick.bind(this)], [i3, "mousedown", o2], [i3.ownerDocument, "mousemove", r2], [i3.ownerDocument, "mouseup", a2], [i3, "touchstart", o2], [i3.ownerDocument, "touchmove", r2], [i3.ownerDocument, "touchend", a2]];
            l2.forEach(function(t4) {
              n.apply(null, t4);
            }), this._events = l2;
          }
          buttonToMaxClick(t3) {
            let e3 = (this.to - this.from) * u(this.options.step, 0.2);
            this.updatePosition(this.from + e3, this.to + e3), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          buttonToMinClick(t3) {
            let e3 = a(this.to - this.from) * u(this.options.step, 0.2);
            this.updatePosition(a(this.from - e3), a(this.to - e3)), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          cursorToScrollbarPosition(t3) {
            let e3 = this.options, i3 = e3.minWidth > this.calculatedWidth ? e3.minWidth : 0;
            return { chartX: (t3.chartX - this.x - this.xOffset) / (this.barWidth - i3), chartY: (t3.chartY - this.y - this.yOffset) / (this.barWidth - i3) };
          }
          destroy() {
            let t3 = this, e3 = t3.chart.scroller;
            t3.removeEvents(), ["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"].forEach(function(e4) {
              t3[e4] && t3[e4].destroy && (t3[e4] = t3[e4].destroy());
            }), e3 && t3 === e3.scrollbar && (e3.scrollbar = null, d(e3.scrollbarButtons));
          }
          drawScrollbarButton(t3) {
            let e3 = this.renderer, i3 = this.scrollbarButtons, s2 = this.options, o2 = this.size, r2 = e3.g().add(this.group);
            if (i3.push(r2), s2.buttonsEnabled) {
              let n2 = e3.rect().addClass("highcharts-scrollbar-button").add(r2);
              this.chart.styledMode || n2.attr({ stroke: s2.buttonBorderColor, "stroke-width": s2.buttonBorderWidth, fill: s2.buttonBackgroundColor }), n2.attr(n2.crisp({ x: -0.5, y: -0.5, width: o2, height: o2, r: s2.buttonBorderRadius }, n2.strokeWidth()));
              let a2 = e3.path(x.swapXY([["M", o2 / 2 + (t3 ? -1 : 1), o2 / 2 - 3], ["L", o2 / 2 + (t3 ? -1 : 1), o2 / 2 + 3], ["L", o2 / 2 + (t3 ? 2 : -2), o2 / 2]], s2.vertical)).addClass("highcharts-scrollbar-arrow").add(i3[t3]);
              this.chart.styledMode || a2.attr({ fill: s2.buttonArrowColor });
            }
          }
          init(t3, e3, i3) {
            this.scrollbarButtons = [], this.renderer = t3, this.userOptions = e3, this.options = p(s, r.scrollbar, e3), this.options.margin = u(this.options.margin, 10), this.chart = i3, this.size = u(this.options.size, this.options.height), e3.enabled && (this.render(), this.addEvents());
          }
          mouseDownHandler(t3) {
            var _a;
            let e3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3, i3 = this.cursorToScrollbarPosition(e3);
            this.chartX = i3.chartX, this.chartY = i3.chartY, this.initPositions = [this.from, this.to], this.grabbedCenter = true;
          }
          mouseMoveHandler(t3) {
            var _a;
            let e3;
            let i3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3, s2 = this.options.vertical ? "chartY" : "chartX", o2 = this.initPositions || [];
            this.grabbedCenter && (!t3.touches || 0 !== t3.touches[0][s2]) && (e3 = this.cursorToScrollbarPosition(i3)[s2] - this[s2], this.hasDragged = true, this.updatePosition(o2[0] + e3, o2[1] + e3), this.hasDragged && c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t3.type, DOMEvent: t3 }));
          }
          mouseUpHandler(t3) {
            this.hasDragged && c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMType: t3.type, DOMEvent: t3 }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
          }
          position(t3, e3, i3, s2) {
            let { buttonsEnabled: o2, margin: r2 = 0, vertical: n2 } = this.options, a2 = this.rendered ? "animate" : "attr", l2 = s2, h2 = 0;
            this.group.show(), this.x = t3, this.y = e3 + this.trackBorderWidth, this.width = i3, this.height = s2, this.xOffset = l2, this.yOffset = h2, n2 ? (this.width = this.yOffset = i3 = h2 = this.size, this.xOffset = l2 = 0, this.yOffset = h2 = o2 ? this.size : 0, this.barWidth = s2 - (o2 ? 2 * i3 : 0), this.x = t3 += r2) : (this.height = s2 = this.size, this.xOffset = l2 = o2 ? this.size : 0, this.barWidth = i3 - (o2 ? 2 * s2 : 0), this.y = this.y + r2), this.group[a2]({ translateX: t3, translateY: this.y }), this.track[a2]({ width: i3, height: s2 }), this.scrollbarButtons[1][a2]({ translateX: n2 ? 0 : i3 - l2, translateY: n2 ? s2 - h2 : 0 });
          }
          removeEvents() {
            this._events.forEach(function(t3) {
              g.apply(null, t3);
            }), this._events.length = 0;
          }
          render() {
            let t3 = this.renderer, e3 = this.options, i3 = this.size, s2 = this.chart.styledMode, o2 = t3.g("scrollbar").attr({ zIndex: e3.zIndex }).hide().add();
            this.group = o2, this.track = t3.rect().addClass("highcharts-scrollbar-track").attr({ r: e3.trackBorderRadius || 0, height: i3, width: i3 }).add(o2), s2 || this.track.attr({ fill: e3.trackBackgroundColor, stroke: e3.trackBorderColor, "stroke-width": e3.trackBorderWidth });
            let r2 = this.trackBorderWidth = this.track.strokeWidth();
            this.track.attr({ x: -l(0, r2), y: -l(0, r2) }), this.scrollbarGroup = t3.g().add(o2), this.scrollbar = t3.rect().addClass("highcharts-scrollbar-thumb").attr({ height: i3 - r2, width: i3 - r2, r: e3.barBorderRadius || 0 }).add(this.scrollbarGroup), this.scrollbarRifles = t3.path(x.swapXY([["M", -3, i3 / 4], ["L", -3, 2 * i3 / 3], ["M", 0, i3 / 4], ["L", 0, 2 * i3 / 3], ["M", 3, i3 / 4], ["L", 3, 2 * i3 / 3]], e3.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s2 || (this.scrollbar.attr({ fill: e3.barBackgroundColor, stroke: e3.barBorderColor, "stroke-width": e3.barBorderWidth }), this.scrollbarRifles.attr({ stroke: e3.rifleColor, "stroke-width": 1 })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-l(0, this.scrollbarStrokeWidth), -l(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);
          }
          setRange(t3, e3) {
            let i3, s2;
            let o2 = this.options, r2 = o2.vertical, n2 = o2.minWidth, l2 = this.barWidth, d2 = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
            if (!h(l2)) return;
            let c2 = l2 * Math.min(e3, 1);
            i3 = Math.ceil(l2 * (t3 = Math.max(t3, 0))), this.calculatedWidth = s2 = a(c2 - i3), s2 < n2 && (i3 = (l2 - n2 + s2) * t3, s2 = n2);
            let p2 = Math.floor(i3 + this.xOffset + this.yOffset), u2 = s2 / 2 - 0.5;
            this.from = t3, this.to = e3, r2 ? (this.scrollbarGroup[d2]({ translateY: p2 }), this.scrollbar[d2]({ height: s2 }), this.scrollbarRifles[d2]({ translateY: u2 }), this.scrollbarTop = p2, this.scrollbarLeft = 0) : (this.scrollbarGroup[d2]({ translateX: p2 }), this.scrollbar[d2]({ width: s2 }), this.scrollbarRifles[d2]({ translateX: u2 }), this.scrollbarLeft = p2, this.scrollbarTop = 0), s2 <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), false === o2.showFull && (t3 <= 0 && e3 >= 1 ? this.group.hide() : this.group.show()), this.rendered = true;
          }
          shouldUpdateExtremes(t3) {
            return u(this.options.liveRedraw, e2.svg && !e2.isTouchDevice && !this.chart.boosted) || "mouseup" === t3 || "touchend" === t3 || !h(t3);
          }
          trackClick(t3) {
            var _a;
            let e3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3, i3 = this.to - this.from, s2 = this.y + this.scrollbarTop, o2 = this.x + this.scrollbarLeft;
            this.options.vertical && e3.chartY > s2 || !this.options.vertical && e3.chartX > o2 ? this.updatePosition(this.from + i3, this.to + i3) : this.updatePosition(this.from - i3, this.to - i3), c(this, "changed", { from: this.from, to: this.to, trigger: "scrollbar", DOMEvent: t3 });
          }
          update(t3) {
            this.destroy(), this.init(this.chart.renderer, p(true, this.options, t3), this.chart);
          }
          updatePosition(t3, e3) {
            e3 > 1 && (t3 = a(1 - a(e3 - t3)), e3 = 1), t3 < 0 && (e3 = a(e3 - t3), t3 = 0), this.from = t3, this.to = e3;
          }
        }
        return x.defaultOptions = s, r.scrollbar = p(true, x.defaultOptions, r.scrollbar), x;
      }), i(e, "Stock/Navigator/Navigator.js", [e["Core/Axis/Axis.js"], e["Stock/Navigator/ChartNavigatorComposition.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Axis/NavigatorAxisComposition.js"], e["Stock/Navigator/NavigatorComposition.js"], e["Stock/Scrollbar/Scrollbar.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, o, r, n, a, l) {
        let { defaultOptions: h } = i2, { isTouchDevice: d } = s, { prototype: { symbols: c } } = a, { addEvent: p, clamp: u, correctFloat: g, defined: x, destroyObjectProperties: f, erase: m, extend: b, find: y, fireEvent: v, isArray: M, isNumber: k, merge: A, pick: S, removeEvent: C, splat: w } = l;
        function P(t3, ...e3) {
          let i3 = [].filter.call(e3, k);
          if (i3.length) return Math[t3].apply(0, i3);
        }
        class O {
          static compose(t3, i3, s2) {
            e2.compose(t3, O), r.compose(t3, i3, s2);
          }
          constructor(t3) {
            this.isDirty = false, this.scrollbarHeight = 0, this.init(t3);
          }
          drawHandle(t3, e3, i3, s2) {
            let o2 = this.navigatorOptions.handles.height;
            this.handles[e3][s2](i3 ? { translateX: Math.round(this.left + this.height / 2), translateY: Math.round(this.top + parseInt(t3, 10) + 0.5 - o2) } : { translateX: Math.round(this.left + parseInt(t3, 10)), translateY: Math.round(this.top + this.height / 2 - o2 / 2 - 1) });
          }
          drawOutline(t3, e3, i3, s2) {
            let o2 = this.navigatorOptions.maskInside, r2 = this.outline.strokeWidth(), n2 = r2 / 2, a2 = r2 % 2 / 2, l2 = this.scrollButtonSize, h2 = this.size, d2 = this.top, c2 = this.height, p2 = d2 - n2, u2 = d2 + c2, g2 = this.left, x2, f2;
            i3 ? (x2 = d2 + e3 + a2, e3 = d2 + t3 + a2, f2 = [["M", g2 + c2, d2 - l2 - a2], ["L", g2 + c2, x2], ["L", g2, x2], ["M", g2, e3], ["L", g2 + c2, e3], ["L", g2 + c2, d2 + h2 + l2]], o2 && f2.push(["M", g2 + c2, x2 - n2], ["L", g2 + c2, e3 + n2])) : (g2 -= l2, t3 += g2 + l2 - a2, e3 += g2 + l2 - a2, f2 = [["M", g2, p2], ["L", t3, p2], ["L", t3, u2], ["M", e3, u2], ["L", e3, p2], ["L", g2 + h2 + 2 * l2, p2]], o2 && f2.push(["M", t3 - n2, p2], ["L", e3 + n2, p2])), this.outline[s2]({ d: f2 });
          }
          drawMasks(t3, e3, i3, s2) {
            let o2, r2, n2, a2;
            let l2 = this.left, h2 = this.top, d2 = this.height;
            i3 ? (n2 = [l2, l2, l2], a2 = [h2, h2 + t3, h2 + e3], r2 = [d2, d2, d2], o2 = [t3, e3 - t3, this.size - e3]) : (n2 = [l2, l2 + t3, l2 + e3], a2 = [h2, h2, h2], r2 = [t3, e3 - t3, this.size - e3], o2 = [d2, d2, d2]), this.shades.forEach((t4, e4) => {
              t4[s2]({ x: n2[e4], y: a2[e4], width: r2[e4], height: o2[e4] });
            });
          }
          renderElements() {
            var _a;
            let t3 = this, e3 = t3.navigatorOptions, i3 = e3.maskInside, s2 = t3.chart, o2 = s2.inverted, r2 = s2.renderer, n2 = { cursor: o2 ? "ns-resize" : "ew-resize" }, a2 = t3.navigatorGroup ?? (t3.navigatorGroup = r2.g("navigator").attr({ zIndex: 8, visibility: "hidden" }).add());
            if ([!i3, i3, !i3].forEach((i4, o3) => {
              let l2 = t3.shades[o3] ?? (t3.shades[o3] = r2.rect().addClass("highcharts-navigator-mask" + (1 === o3 ? "-inside" : "-outside")).add(a2));
              s2.styledMode || (l2.attr({ fill: i4 ? e3.maskFill : "rgba(0,0,0,0)" }), 1 === o3 && l2.css(n2));
            }), t3.outline || (t3.outline = r2.path().addClass("highcharts-navigator-outline").add(a2)), s2.styledMode || t3.outline.attr({ "stroke-width": e3.outlineWidth, stroke: e3.outlineColor }), (_a = e3.handles) == null ? void 0 : _a.enabled) {
              let i4 = e3.handles, { height: o3, width: l2 } = i4;
              [0, 1].forEach((e4) => {
                let h2 = i4.symbols[e4];
                if (t3.handles[e4]) {
                  if (h2 !== t3.handles[e4].symbolName) {
                    let i5 = c[h2].call(c, -l2 / 2 - 1, 0, l2, o3);
                    t3.handles[e4].attr({ d: i5 }), t3.handles[e4].symbolName = h2;
                  }
                } else t3.handles[e4] = r2.symbol(h2, -l2 / 2 - 1, 0, l2, o3, i4), t3.handles[e4].attr({ zIndex: 7 - e4 }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][e4]).add(a2);
                s2.inverted && t3.handles[e4].attr({ rotation: 90, rotationOriginX: Math.floor(-l2 / 2), rotationOriginY: (o3 + l2) / 2 }), s2.styledMode || t3.handles[e4].attr({ fill: i4.backgroundColor, stroke: i4.borderColor, "stroke-width": i4.lineWidth, width: i4.width, height: i4.height, x: -l2 / 2 - 1, y: 0 }).css(n2);
              });
            }
          }
          update(t3, e3 = false) {
            var _a;
            let i3 = this.chart, s2 = i3.options.chart.inverted !== ((_a = i3.scrollbar) == null ? void 0 : _a.options.vertical);
            if (A(true, i3.options.navigator, t3), this.navigatorOptions = i3.options.navigator || {}, this.setOpposite(), x(t3.enabled) || s2) return this.destroy(), this.navigatorEnabled = t3.enabled || this.navigatorEnabled, this.init(i3);
            if (this.navigatorEnabled && (this.isDirty = true, false === t3.adaptToUpdatedData && this.baseSeries.forEach((t4) => {
              C(t4, "updatedData", this.updatedDataHandler);
            }, this), t3.adaptToUpdatedData && this.baseSeries.forEach((t4) => {
              t4.eventsToUnbind.push(p(t4, "updatedData", this.updatedDataHandler));
            }, this), (t3.series || t3.baseSeries) && this.setBaseSeries(void 0, false), t3.height || t3.xAxis || t3.yAxis)) {
              this.height = t3.height ?? this.height;
              let e4 = this.getXAxisOffsets();
              this.xAxis.update({ ...t3.xAxis, offsets: e4, [i3.inverted ? "width" : "height"]: this.height, [i3.inverted ? "height" : "width"]: void 0 }, false), this.yAxis.update({ ...t3.yAxis, [i3.inverted ? "width" : "height"]: this.height }, false);
            }
            e3 && i3.redraw();
          }
          render(t3, e3, i3, s2) {
            let o2 = this.chart, r2 = this.xAxis, n2 = r2.pointRange || 0, a2 = r2.navigatorAxis.fake ? o2.xAxis[0] : r2, l2 = this.navigatorEnabled, h2 = this.rendered, d2 = o2.inverted, c2 = o2.xAxis[0].minRange, p2 = o2.xAxis[0].options.maxRange, f2 = this.scrollButtonSize, m2, b2, y2, M2 = this.scrollbarHeight, A2, C2;
            if (this.hasDragged && !x(i3)) return;
            if (this.isDirty && this.renderElements(), t3 = g(t3 - n2 / 2), e3 = g(e3 + n2 / 2), !k(t3) || !k(e3)) {
              if (!h2) return;
              i3 = 0, s2 = S(r2.width, a2.width);
            }
            this.left = S(r2.left, o2.plotLeft + f2 + (d2 ? o2.plotWidth : 0));
            let w2 = this.size = A2 = S(r2.len, (d2 ? o2.plotHeight : o2.plotWidth) - 2 * f2);
            m2 = d2 ? M2 : A2 + 2 * f2, i3 = S(i3, r2.toPixels(t3, true)), s2 = S(s2, r2.toPixels(e3, true)), k(i3) && Math.abs(i3) !== 1 / 0 || (i3 = 0, s2 = m2);
            let P2 = r2.toValue(i3, true), O2 = r2.toValue(s2, true), B = Math.abs(g(O2 - P2));
            B < c2 ? this.grabbedLeft ? i3 = r2.toPixels(O2 - c2 - n2, true) : this.grabbedRight && (s2 = r2.toPixels(P2 + c2 + n2, true)) : x(p2) && g(B - n2) > p2 && (this.grabbedLeft ? i3 = r2.toPixels(O2 - p2 - n2, true) : this.grabbedRight && (s2 = r2.toPixels(P2 + p2 + n2, true))), this.zoomedMax = u(Math.max(i3, s2), 0, w2), this.zoomedMin = u(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i3, s2), 0, w2), this.range = this.zoomedMax - this.zoomedMin, w2 = Math.round(this.zoomedMax);
            let E = Math.round(this.zoomedMin);
            l2 && (this.navigatorGroup.attr({ visibility: "inherit" }), C2 = h2 && !this.hasDragged ? "animate" : "attr", this.drawMasks(E, w2, d2, C2), this.drawOutline(E, w2, d2, C2), this.navigatorOptions.handles.enabled && (this.drawHandle(E, 0, d2, C2), this.drawHandle(w2, 1, d2, C2))), this.scrollbar && (d2 ? (y2 = this.top - f2, b2 = this.left - M2 + (l2 || !a2.opposite ? 0 : (a2.titleOffset || 0) + a2.axisTitleMargin), M2 = A2 + 2 * f2) : (y2 = this.top + (l2 ? this.height : -M2), b2 = this.left - f2), this.scrollbar.position(b2, y2, m2, M2), this.scrollbar.setRange(this.zoomedMin / (A2 || 1), this.zoomedMax / (A2 || 1))), this.rendered = true, this.isDirty = false, v(this, "afterRender");
          }
          addMouseEvents() {
            let t3 = this, e3 = t3.chart, i3 = e3.container, s2 = [], o2, r2;
            t3.mouseMoveHandler = o2 = function(e4) {
              t3.onMouseMove(e4);
            }, t3.mouseUpHandler = r2 = function(e4) {
              t3.onMouseUp(e4);
            }, (s2 = t3.getPartsEvents("mousedown")).push(p(e3.renderTo, "mousemove", o2), p(i3.ownerDocument, "mouseup", r2), p(e3.renderTo, "touchmove", o2), p(i3.ownerDocument, "touchend", r2)), s2.concat(t3.getPartsEvents("touchstart")), t3.eventsToUnbind = s2, t3.series && t3.series[0] && s2.push(p(t3.series[0].xAxis, "foundExtremes", function() {
              e3.navigator.modifyNavigatorAxisExtremes();
            }));
          }
          getPartsEvents(t3) {
            let e3 = this, i3 = [];
            return ["shades", "handles"].forEach(function(s2) {
              e3[s2].forEach(function(o2, r2) {
                i3.push(p(o2.element, t3, function(t4) {
                  e3[s2 + "Mousedown"](t4, r2);
                }));
              });
            }), i3;
          }
          shadesMousedown(t3, e3) {
            var _a;
            t3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3;
            let i3 = this.chart, s2 = this.xAxis, o2 = this.zoomedMin, r2 = this.size, n2 = this.range, a2 = this.left, l2 = t3.chartX, h2, d2, c2, p2;
            i3.inverted && (l2 = t3.chartY, a2 = this.top), 1 === e3 ? (this.grabbedCenter = l2, this.fixedWidth = n2, this.dragOffset = l2 - o2) : (p2 = l2 - a2 - n2 / 2, 0 === e3 ? p2 = Math.max(0, p2) : 2 === e3 && p2 + n2 >= r2 && (p2 = r2 - n2, this.reversedExtremes ? (p2 -= n2, d2 = this.getUnionExtremes().dataMin) : h2 = this.getUnionExtremes().dataMax), p2 !== o2 && (this.fixedWidth = n2, x((c2 = s2.navigatorAxis.toFixedRange(p2, p2 + n2, d2, h2)).min) && v(this, "setRange", { min: Math.min(c2.min, c2.max), max: Math.max(c2.min, c2.max), redraw: true, eventArguments: { trigger: "navigator" } })));
          }
          handlesMousedown(t3, e3) {
            var _a;
            t3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(t3)) || t3;
            let i3 = this.chart, s2 = i3.xAxis[0], o2 = this.reversedExtremes;
            0 === e3 ? (this.grabbedLeft = true, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o2 ? s2.min : s2.max) : (this.grabbedRight = true, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o2 ? s2.max : s2.min), i3.setFixedRange(void 0);
          }
          onMouseMove(t3) {
            var _a;
            let e3 = this, i3 = e3.chart, s2 = e3.navigatorSize, o2 = e3.range, r2 = e3.dragOffset, n2 = i3.inverted, a2 = e3.left, l2;
            (!t3.touches || 0 !== t3.touches[0].pageX) && (l2 = (t3 = ((_a = i3.pointer) == null ? void 0 : _a.normalize(t3)) || t3).chartX, n2 && (a2 = e3.top, l2 = t3.chartY), e3.grabbedLeft ? (e3.hasDragged = true, e3.render(0, 0, l2 - a2, e3.otherHandlePos)) : e3.grabbedRight ? (e3.hasDragged = true, e3.render(0, 0, e3.otherHandlePos, l2 - a2)) : e3.grabbedCenter && (e3.hasDragged = true, l2 < r2 ? l2 = r2 : l2 > s2 + r2 - o2 && (l2 = s2 + r2 - o2), e3.render(0, 0, l2 - r2, l2 - r2 + o2)), e3.hasDragged && e3.scrollbar && S(e3.scrollbar.options.liveRedraw, !d && !this.chart.boosted) && (t3.DOMType = t3.type, setTimeout(function() {
              e3.onMouseUp(t3);
            }, 0)));
          }
          onMouseUp(t3) {
            let e3, i3, s2, o2, r2, n2;
            let a2 = this.chart, l2 = this.xAxis, h2 = this.scrollbar, d2 = t3.DOMEvent || t3, c2 = a2.inverted, p2 = this.rendered && !this.hasDragged ? "animate" : "attr";
            (this.hasDragged && (!h2 || !h2.hasDragged) || "scrollbar" === t3.trigger) && (s2 = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o2 = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r2 = this.fixedExtreme), this.zoomedMax === this.size && (r2 = this.reversedExtremes ? s2.dataMin : s2.dataMax), 0 === this.zoomedMin && (o2 = this.reversedExtremes ? s2.dataMax : s2.dataMin), x((n2 = l2.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o2, r2)).min) && v(this, "setRange", { min: Math.min(n2.min, n2.max), max: Math.max(n2.min, n2.max), redraw: true, animation: !this.hasDragged && null, eventArguments: { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: d2 } })), "mousemove" !== t3.DOMType && "touchmove" !== t3.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && k(this.zoomedMin) && k(this.zoomedMax) && (i3 = Math.round(this.zoomedMin), e3 = Math.round(this.zoomedMax), this.shades && this.drawMasks(i3, e3, c2, p2), this.outline && this.drawOutline(i3, e3, c2, p2), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i3, 0, c2, p2), this.drawHandle(e3, 1, c2, p2)));
          }
          removeEvents() {
            this.eventsToUnbind && (this.eventsToUnbind.forEach(function(t3) {
              t3();
            }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();
          }
          removeBaseSeriesEvents() {
            let t3 = this.baseSeries || [];
            this.navigatorEnabled && t3[0] && (false !== this.navigatorOptions.adaptToUpdatedData && t3.forEach(function(t4) {
              C(t4, "updatedData", this.updatedDataHandler);
            }, this), t3[0].xAxis && C(t3[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
          }
          getXAxisOffsets() {
            return this.chart.inverted ? [this.scrollButtonSize, 0, -this.scrollButtonSize, 0] : [0, -this.scrollButtonSize, 0, this.scrollButtonSize];
          }
          init(e3) {
            var _a;
            let i3 = e3.options, s2 = i3.navigator || {}, r2 = s2.enabled, a2 = i3.scrollbar || {}, l2 = a2.enabled, h2 = r2 && s2.height || 0, d2 = l2 && a2.height || 0, c2 = a2.buttonsEnabled && d2 || 0;
            this.handles = [], this.shades = [], this.chart = e3, this.setBaseSeries(), this.height = h2, this.scrollbarHeight = d2, this.scrollButtonSize = c2, this.scrollbarEnabled = l2, this.navigatorEnabled = r2, this.navigatorOptions = s2, this.scrollbarOptions = a2, this.setOpposite();
            let u2 = this, g2 = u2.baseSeries, x2 = e3.xAxis.length, f2 = e3.yAxis.length, m2 = g2 && g2[0] && g2[0].xAxis || e3.xAxis[0] || { options: {} };
            if (e3.isDirtyBox = true, u2.navigatorEnabled) {
              let i4 = this.getXAxisOffsets();
              u2.xAxis = new t2(e3, A({ breaks: m2.options.breaks, ordinal: m2.options.ordinal, overscroll: m2.options.overscroll }, s2.xAxis, { type: "datetime", yAxis: (_a = s2.yAxis) == null ? void 0 : _a.id, index: x2, isInternal: true, offset: 0, keepOrdinalPadding: true, startOnTick: false, endOnTick: false, minPadding: m2.options.ordinal ? 0 : m2.options.minPadding, maxPadding: m2.options.ordinal ? 0 : m2.options.maxPadding, zoomEnabled: false }, e3.inverted ? { offsets: i4, width: h2 } : { offsets: i4, height: h2 }), "xAxis"), u2.yAxis = new t2(e3, A(s2.yAxis, { alignTicks: false, offset: 0, index: f2, isInternal: true, reversed: S(s2.yAxis && s2.yAxis.reversed, e3.yAxis[0] && e3.yAxis[0].reversed, false), zoomEnabled: false }, e3.inverted ? { width: h2 } : { height: h2 }), "yAxis"), g2 || s2.series.data ? u2.updateNavigatorSeries(false) : 0 === e3.series.length && (u2.unbindRedraw = p(e3, "beforeRedraw", function() {
                e3.series.length > 0 && !u2.series && (u2.setBaseSeries(), u2.unbindRedraw());
              })), u2.reversedExtremes = e3.inverted && !u2.xAxis.reversed || !e3.inverted && u2.xAxis.reversed, u2.renderElements(), u2.addMouseEvents();
            } else u2.xAxis = { chart: e3, navigatorAxis: { fake: true }, translate: function(t3, i4) {
              let s3 = e3.xAxis[0], o2 = s3.getExtremes(), r3 = s3.len - 2 * c2, n2 = P("min", s3.options.min, o2.dataMin), a3 = P("max", s3.options.max, o2.dataMax) - n2;
              return i4 ? t3 * a3 / r3 + n2 : r3 * (t3 - n2) / a3;
            }, toPixels: function(t3) {
              return this.translate(t3);
            }, toValue: function(t3) {
              return this.translate(t3, true);
            } }, u2.xAxis.navigatorAxis.axis = u2.xAxis, u2.xAxis.navigatorAxis.toFixedRange = o.prototype.toFixedRange.bind(u2.xAxis.navigatorAxis);
            if (e3.options.scrollbar.enabled) {
              let t3 = A(e3.options.scrollbar, { vertical: e3.inverted });
              !k(t3.margin) && u2.navigatorEnabled && (t3.margin = e3.inverted ? -3 : 3), e3.scrollbar = u2.scrollbar = new n(e3.renderer, t3, e3), p(u2.scrollbar, "changed", function(t4) {
                let e4 = u2.size, i4 = e4 * this.to, s3 = e4 * this.from;
                u2.hasDragged = u2.scrollbar.hasDragged, u2.render(0, 0, s3, i4), this.shouldUpdateExtremes(t4.DOMType) && setTimeout(function() {
                  u2.onMouseUp(t4);
                });
              });
            }
            u2.addBaseSeriesEvents(), u2.addChartEvents();
          }
          setOpposite() {
            let t3 = this.navigatorOptions, e3 = this.navigatorEnabled, i3 = this.chart;
            this.opposite = S(t3.opposite, !!(!e3 && i3.inverted));
          }
          getUnionExtremes(t3) {
            let e3;
            let i3 = this.chart.xAxis[0], s2 = this.xAxis, o2 = s2.options, r2 = i3.options;
            return t3 && null === i3.dataMin || (e3 = { dataMin: S(o2 && o2.min, P("min", r2.min, i3.dataMin, s2.dataMin, s2.min)), dataMax: S(o2 && o2.max, P("max", r2.max, i3.dataMax, s2.dataMax, s2.max)) }), e3;
          }
          setBaseSeries(t3, e3) {
            let i3 = this.chart, s2 = this.baseSeries = [];
            t3 = t3 || i3.options && i3.options.navigator.baseSeries || (i3.series.length ? y(i3.series, (t4) => !t4.options.isInternal).index : 0), (i3.series || []).forEach((e4, i4) => {
              !e4.options.isInternal && (e4.options.showInNavigator || (i4 === t3 || e4.options.id === t3) && false !== e4.options.showInNavigator) && s2.push(e4);
            }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(true, e3);
          }
          updateNavigatorSeries(t3, e3) {
            var _a, _b;
            let i3 = this, s2 = i3.chart, o2 = i3.baseSeries, r2 = { enableMouseTracking: false, index: null, linkedTo: null, group: "nav", padXAxis: false, xAxis: (_a = this.navigatorOptions.xAxis) == null ? void 0 : _a.id, yAxis: (_b = this.navigatorOptions.yAxis) == null ? void 0 : _b.id, showInLegend: false, stacking: void 0, isInternal: true, states: { inactive: { opacity: 1 } } }, n2 = i3.series = (i3.series || []).filter((t4) => {
              let e4 = t4.baseSeries;
              return !(0 > o2.indexOf(e4)) || (e4 && (C(e4, "updatedData", i3.updatedDataHandler), delete e4.navigatorSeries), t4.chart && t4.destroy(), false);
            }), a2, l2, d2 = i3.navigatorOptions.series, c2;
            o2 && o2.length && o2.forEach((t4) => {
              let p2 = t4.navigatorSeries, u2 = b({ color: t4.color, visible: t4.visible }, M(d2) ? h.navigator.series : d2);
              if (p2 && false === i3.navigatorOptions.adaptToUpdatedData) return;
              r2.name = "Navigator " + o2.length, c2 = (a2 = t4.options || {}).navigatorOptions || {}, u2.dataLabels = w(u2.dataLabels), (l2 = A(a2, r2, u2, c2)).pointRange = S(u2.pointRange, c2.pointRange, h.plotOptions[l2.type || "line"].pointRange);
              let g2 = c2.data || u2.data;
              i3.hasNavigatorData = i3.hasNavigatorData || !!g2, l2.data = g2 || a2.data && a2.data.slice(0), p2 && p2.options ? p2.update(l2, e3) : (t4.navigatorSeries = s2.initSeries(l2), s2.setSortedData(), t4.navigatorSeries.baseSeries = t4, n2.push(t4.navigatorSeries));
            }), (d2.data && !(o2 && o2.length) || M(d2)) && (i3.hasNavigatorData = false, (d2 = w(d2)).forEach((t4, e4) => {
              r2.name = "Navigator " + (n2.length + 1), (l2 = A(h.navigator.series, { color: s2.series[e4] && !s2.series[e4].options.isInternal && s2.series[e4].color || s2.options.colors[e4] || s2.options.colors[0] }, r2, t4)).data = t4.data, l2.data && (i3.hasNavigatorData = true, n2.push(s2.initSeries(l2)));
            })), t3 && this.addBaseSeriesEvents();
          }
          addBaseSeriesEvents() {
            let t3 = this, e3 = t3.baseSeries || [];
            e3[0] && e3[0].xAxis && e3[0].eventsToUnbind.push(p(e3[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), e3.forEach((i3) => {
              i3.eventsToUnbind.push(p(i3, "show", function() {
                this.navigatorSeries && this.navigatorSeries.setVisible(true, false);
              })), i3.eventsToUnbind.push(p(i3, "hide", function() {
                this.navigatorSeries && this.navigatorSeries.setVisible(false, false);
              })), false !== this.navigatorOptions.adaptToUpdatedData && i3.xAxis && i3.eventsToUnbind.push(p(i3, "updatedData", this.updatedDataHandler)), i3.eventsToUnbind.push(p(i3, "remove", function() {
                e3 && m(e3, i3), this.navigatorSeries && (m(t3.series, this.navigatorSeries), x(this.navigatorSeries.options) && this.navigatorSeries.remove(false), delete this.navigatorSeries);
              }));
            });
          }
          getBaseSeriesMin(t3) {
            return this.baseSeries.reduce(function(t4, e3) {
              return Math.min(t4, e3.xData && e3.xData.length ? e3.xData[0] : t4);
            }, t3);
          }
          modifyNavigatorAxisExtremes() {
            let t3 = this.xAxis;
            if (void 0 !== t3.getExtremes) {
              let e3 = this.getUnionExtremes(true);
              e3 && (e3.dataMin !== t3.min || e3.dataMax !== t3.max) && (t3.min = e3.dataMin, t3.max = e3.dataMax);
            }
          }
          modifyBaseAxisExtremes() {
            var _a;
            let t3, e3;
            let i3 = this.chart.navigator, s2 = this.getExtremes(), o2 = s2.min, r2 = s2.max, n2 = s2.dataMin, a2 = s2.dataMax, l2 = r2 - o2, h2 = i3.stickToMin, d2 = i3.stickToMax, c2 = S((_a = this.ordinal) == null ? void 0 : _a.convertOverscroll(this.options.overscroll), 0), p2 = i3.series && i3.series[0], u2 = !!this.setExtremes;
            !(this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger) && (h2 && (t3 = (e3 = n2) + l2), d2 && (t3 = a2 + c2, h2 || (e3 = Math.max(n2, t3 - l2, i3.getBaseSeriesMin(p2 && p2.xData ? p2.xData[0] : -Number.MAX_VALUE)))), u2 && (h2 || d2) && k(e3) && (this.min = this.userMin = e3, this.max = this.userMax = t3)), i3.stickToMin = i3.stickToMax = null;
          }
          updatedDataHandler() {
            let t3 = this.chart.navigator, e3 = this.navigatorSeries, i3 = t3.reversedExtremes ? 0 === Math.round(t3.zoomedMin) : Math.round(t3.zoomedMax) >= Math.round(t3.size);
            t3.stickToMax = S(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i3), t3.stickToMin = t3.shouldStickToMin(this, t3), e3 && !t3.hasNavigatorData && (e3.options.pointStart = this.xData[0], e3.setData(this.options.data, false, null, false));
          }
          shouldStickToMin(t3, e3) {
            let i3 = e3.getBaseSeriesMin(t3.xData[0]), s2 = t3.xAxis, o2 = s2.max, r2 = s2.min, n2 = s2.options.range;
            return !!(k(o2) && k(r2)) && (n2 && o2 - i3 > 0 ? o2 - i3 < n2 : r2 <= i3);
          }
          addChartEvents() {
            this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(p(this.chart, "redraw", function() {
              let t3 = this.navigator, e3 = t3 && (t3.baseSeries && t3.baseSeries[0] && t3.baseSeries[0].xAxis || this.xAxis[0]);
              e3 && t3.render(e3.min, e3.max);
            }), p(this.chart, "getMargins", function() {
              let t3 = this.navigator, e3 = t3.opposite ? "plotTop" : "marginBottom";
              this.inverted && (e3 = t3.opposite ? "marginRight" : "plotLeft"), this[e3] = (this[e3] || 0) + (t3.navigatorEnabled || !this.inverted ? t3.height + t3.scrollbarHeight : 0) + t3.navigatorOptions.margin;
            }), p(O, "setRange", function(t3) {
              this.chart.xAxis[0].setExtremes(t3.min, t3.max, t3.redraw, t3.animation, t3.eventArguments);
            }));
          }
          destroy() {
            this.removeEvents(), this.xAxis && (m(this.chart.xAxis, this.xAxis), m(this.chart.axes, this.xAxis)), this.yAxis && (m(this.chart.yAxis, this.yAxis), m(this.chart.axes, this.yAxis)), (this.series || []).forEach((t3) => {
              t3.destroy && t3.destroy();
            }), ["series", "xAxis", "yAxis", "shades", "outline", "scrollbarTrack", "scrollbarRifles", "scrollbarGroup", "scrollbar", "navigatorGroup", "rendered"].forEach((t3) => {
              this[t3] && this[t3].destroy && this[t3].destroy(), this[t3] = null;
            }), [this.handles].forEach((t3) => {
              f(t3);
            }), this.navigatorEnabled = false;
          }
        }
        return O;
      }), i(e, "Stock/RangeSelector/RangeSelectorDefaults.js", [], function() {
        return { lang: { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "", rangeSelectorTo: "" }, rangeSelector: { allButtonsEnabled: false, buttons: void 0, buttonSpacing: 5, dropdown: "responsive", enabled: void 0, verticalAlign: "top", buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 }, floating: false, x: 0, y: 0, height: void 0, inputBoxBorderColor: "none", inputBoxHeight: 17, inputBoxWidth: void 0, inputDateFormat: "%e %b %Y", inputDateParser: void 0, inputEditDateFormat: "%Y-%m-%d", inputEnabled: true, inputPosition: { align: "right", x: 0, y: 0 }, inputSpacing: 5, selected: void 0, buttonPosition: { align: "left", x: 0, y: 0 }, inputStyle: { color: "#334eff", cursor: "pointer", fontSize: "0.8em" }, labelStyle: { color: "#666666", fontSize: "0.8em" } } };
      }), i(e, "Stock/RangeSelector/RangeSelectorComposition.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Stock/RangeSelector/RangeSelectorDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s) {
        let o;
        let { defaultOptions: r } = t2, { composed: n } = e2, { addEvent: a, defined: l, extend: h, isNumber: d, merge: c, pick: p, pushUnique: u } = s, g = [];
        function x() {
          let t3, e3;
          let i3 = this.range, s2 = i3.type, o2 = this.max, r2 = this.chart.time, n2 = function(t4, e4) {
            let i4 = "year" === s2 ? "FullYear" : "Month", o3 = new r2.Date(t4), n3 = r2.get(i4, o3);
            return r2.set(i4, o3, n3 + e4), n3 === r2.get(i4, o3) && r2.set("Date", o3, 0), o3.getTime() - t4;
          };
          d(i3) ? (t3 = o2 - i3, e3 = i3) : i3 && (t3 = o2 + n2(o2, -(i3.count || 1)), this.chart && this.chart.setFixedRange(o2 - t3));
          let a2 = p(this.dataMin, Number.MIN_VALUE);
          return d(t3) || (t3 = a2), t3 <= a2 && (t3 = a2, void 0 === e3 && (e3 = n2(t3, i3.count)), this.newMax = Math.min(t3 + e3, p(this.dataMax, Number.MAX_VALUE))), d(o2) ? !d(i3) && i3 && i3._offsetMin && (t3 += i3._offsetMin) : t3 = void 0, t3;
        }
        function f() {
          this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new o(this));
        }
        function m() {
          let t3 = this.rangeSelector;
          if (t3) {
            d(t3.deferredYTDClick) && (t3.clickButton(t3.deferredYTDClick), delete t3.deferredYTDClick);
            let e3 = t3.options.verticalAlign;
            t3.options.floating || ("bottom" === e3 ? this.extraBottomMargin = true : "middle" === e3 || (this.extraTopMargin = true));
          }
        }
        function b() {
          let t3;
          let e3 = this.rangeSelector;
          if (!e3) return;
          let i3 = this.xAxis[0].getExtremes(), s2 = this.legend, o2 = e3 && e3.options.verticalAlign;
          d(i3.min) && e3.render(i3.min, i3.max), s2.display && "top" === o2 && o2 === s2.options.verticalAlign && (t3 = c(this.spacingBox), "vertical" === s2.options.layout ? t3.y = this.plotTop : t3.y += e3.getHeight(), s2.group.placed = false, s2.align(t3));
        }
        function y() {
          for (let t3 = 0, e3 = g.length; t3 < e3; ++t3) {
            let e4 = g[t3];
            if (e4[0] === this) {
              e4[1].forEach((t4) => t4()), g.splice(t3, 1);
              return;
            }
          }
        }
        function v() {
          let t3 = this.rangeSelector;
          if (t3) {
            let e3 = t3.getHeight();
            this.extraTopMargin && (this.plotTop += e3), this.extraBottomMargin && (this.marginBottom += e3);
          }
        }
        function M(t3) {
          let e3 = t3.options.rangeSelector, i3 = this.extraBottomMargin, s2 = this.extraTopMargin, r2 = this.rangeSelector;
          if (e3 && e3.enabled && !l(r2) && this.options.rangeSelector && (this.options.rangeSelector.enabled = true, this.rangeSelector = r2 = new o(this)), this.extraBottomMargin = false, this.extraTopMargin = false, r2) {
            let t4 = e3 && e3.verticalAlign || r2.options && r2.options.verticalAlign;
            r2.options.floating || ("bottom" === t4 ? this.extraBottomMargin = true : "middle" === t4 || (this.extraTopMargin = true)), (this.extraBottomMargin !== i3 || this.extraTopMargin !== s2) && (this.isDirtyBox = true);
          }
        }
        return { compose: function(t3, e3, s2) {
          if (o = s2, u(n, "RangeSelector")) {
            let s3 = e3.prototype;
            t3.prototype.minFromRange = x, a(e3, "afterGetContainer", f), a(e3, "beforeRender", m), a(e3, "destroy", y), a(e3, "getMargins", v), a(e3, "redraw", b), a(e3, "update", M), s3.callbacks.push(b), h(r, { rangeSelector: i2.rangeSelector }), h(r.lang, i2.lang);
          }
        } };
      }), i(e, "Core/Axis/OrdinalAxis.js", [e["Core/Axis/Axis.js"], e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s) {
        var o;
        let { addEvent: r, correctFloat: n, css: a, defined: l, error: h, isNumber: d, pick: c, timeUnits: p, isString: u } = s;
        return function(t3) {
          function s2(t4, e3, i3, o3, r2 = [], n2 = 0, a2) {
            let d2 = {}, c2 = this.options.tickPixelInterval, u2 = this.chart.time, g2 = [], x2, f2, m2, b2, y2, v2 = 0, M2 = [], k2 = -Number.MAX_VALUE;
            if (!this.options.ordinal && !this.options.breaks || !r2 || r2.length < 3 || void 0 === e3) return u2.getTimeTicks.apply(u2, arguments);
            let A2 = r2.length;
            for (x2 = 0; x2 < A2; x2++) {
              if (y2 = x2 && r2[x2 - 1] > i3, r2[x2] < e3 && (v2 = x2), x2 === A2 - 1 || r2[x2 + 1] - r2[x2] > 5 * n2 || y2) {
                if (r2[x2] > k2) {
                  for (f2 = u2.getTimeTicks(t4, r2[v2], r2[x2], o3); f2.length && f2[0] <= k2; ) f2.shift();
                  f2.length && (k2 = f2[f2.length - 1]), g2.push(M2.length), M2 = M2.concat(f2);
                }
                v2 = x2 + 1;
              }
              if (y2) break;
            }
            if (f2) {
              if (b2 = f2.info, a2 && b2.unitRange <= p.hour) {
                for (v2 = 1, x2 = M2.length - 1; v2 < x2; v2++) u2.dateFormat("%d", M2[v2]) !== u2.dateFormat("%d", M2[v2 - 1]) && (d2[M2[v2]] = "day", m2 = true);
                m2 && (d2[M2[0]] = "day"), b2.higherRanks = d2;
              }
              b2.segmentStarts = g2, M2.info = b2;
            } else h(12, false, this.chart);
            if (a2 && l(c2)) {
              let t5 = M2.length, e4 = [], s3 = [], o4, r3, n3, a3, l2, h2 = t5;
              for (; h2--; ) r3 = this.translate(M2[h2]), n3 && (s3[h2] = n3 - r3), e4[h2] = n3 = r3;
              for (s3.sort((t6, e5) => t6 - e5), (a3 = s3[Math.floor(s3.length / 2)]) < 0.6 * c2 && (a3 = null), h2 = M2[t5 - 1] > i3 ? t5 - 1 : t5, n3 = void 0; h2--; ) l2 = Math.abs(n3 - (r3 = e4[h2])), n3 && l2 < 0.8 * c2 && (null === a3 || l2 < 0.8 * a3) ? (d2[M2[h2]] && !d2[M2[h2 + 1]] ? (o4 = h2 + 1, n3 = r3) : o4 = h2, M2.splice(o4, 1)) : n3 = r3;
            }
            return M2;
          }
          function o2(t4) {
            let e3 = this.ordinal.positions;
            if (!e3) return t4;
            let i3 = e3.length - 1, s3;
            return (t4 < 0 ? t4 = e3[0] : t4 > i3 ? t4 = e3[i3] : (i3 = Math.floor(t4), s3 = t4 - i3), void 0 !== s3 && void 0 !== e3[i3]) ? e3[i3] + (s3 ? s3 * (e3[i3 + 1] - e3[i3]) : 0) : t4;
          }
          function g(t4) {
            let e3 = this.ordinal, i3 = this.old ? this.old.min : this.min, s3 = this.old ? this.old.transA : this.transA, o3 = e3.getExtendedPositions();
            if (o3 && o3.length) {
              let r2 = n((t4 - i3) * s3 + this.minPixelPadding), a2 = n(e3.getIndexOfPoint(r2, o3)), l2 = n(a2 % 1);
              if (a2 >= 0 && a2 <= o3.length - 1) {
                let t5 = o3[Math.floor(a2)], e4 = o3[Math.ceil(a2)];
                return o3[Math.floor(a2)] + l2 * (e4 - t5);
              }
            }
            return t4;
          }
          function x(e3, i3) {
            let s3 = t3.Additions.findIndexOf(e3, i3, true);
            if (e3[s3] === i3) return s3;
            let o3 = (i3 - e3[s3]) / (e3[s3 + 1] - e3[s3]);
            return s3 + o3;
          }
          function f() {
            this.ordinal || (this.ordinal = new t3.Additions(this));
          }
          function m() {
            let { eventArgs: t4, options: e3 } = this;
            if (this.isXAxis && l(e3.overscroll) && 0 !== e3.overscroll && d(this.max) && d(this.min) && (this.options.ordinal && !this.ordinal.originalOrdinalRange && this.ordinal.getExtendedPositions(false), this.max === this.dataMax && ((t4 == null ? void 0 : t4.trigger) !== "pan" || this.isInternal) && (t4 == null ? void 0 : t4.trigger) !== "navigator")) {
              let i3 = this.ordinal.convertOverscroll(e3.overscroll);
              this.max += i3, !this.isInternal && l(this.userMin) && (t4 == null ? void 0 : t4.trigger) !== "mousewheel" && (this.min += i3);
            }
          }
          function b() {
            this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
          }
          function y() {
            this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
          }
          function v(t4) {
            let e3 = this.xAxis[0], i3 = e3.ordinal.convertOverscroll(e3.options.overscroll), s3 = t4.originalEvent.chartX, o3 = this.options.chart.panning, r2 = false;
            if (o3 && "y" !== o3.type && e3.options.ordinal && e3.series.length && (!t4.touches || t4.touches.length <= 1)) {
              let t5, o4;
              let n2 = this.mouseDownX, l2 = e3.getExtremes(), h2 = l2.dataMin, d2 = l2.dataMax, c2 = l2.min, p2 = l2.max, u2 = this.hoverPoints, g2 = e3.closestPointRange || e3.ordinal && e3.ordinal.overscrollPointsRange, x2 = Math.round((n2 - s3) / (e3.translationSlope * (e3.ordinal.slope || g2))), f2 = e3.ordinal.getExtendedPositions(), m2 = { ordinal: { positions: f2, extendedOrdinalPositions: f2 } }, b2 = e3.index2val, y2 = e3.val2lin;
              if (c2 <= h2 && x2 < 0 || p2 + i3 >= d2 && x2 > 0) return;
              m2.ordinal.positions ? Math.abs(x2) > 1 && (u2 && u2.forEach(function(t6) {
                t6.setState();
              }), d2 > (o4 = m2.ordinal.positions)[o4.length - 1] && o4.push(d2), this.setFixedRange(p2 - c2), (t5 = e3.navigatorAxis.toFixedRange(void 0, void 0, b2.apply(m2, [y2.apply(m2, [c2, true]) + x2]), b2.apply(m2, [y2.apply(m2, [p2, true]) + x2]))).min >= Math.min(l2.dataMin, c2) && t5.max <= Math.max(d2, p2) + i3 && e3.setExtremes(t5.min, t5.max, true, false, { trigger: "pan" }), this.mouseDownX = s3, a(this.container, { cursor: "move" })) : r2 = true;
            } else r2 = true;
            r2 || o3 && /y/.test(o3.type) ? i3 && (e3.max = e3.dataMax + i3) : t4.preventDefault();
          }
          function M() {
            let t4 = this.xAxis;
            t4 && t4.options.ordinal && (delete t4.ordinal.index, delete t4.ordinal.originalOrdinalRange);
          }
          function k(t4, e3) {
            let i3;
            let s3 = this.ordinal, o3 = s3.positions, r2 = s3.slope, n2;
            if (!o3) return t4;
            let a2 = o3.length;
            if (o3[0] <= t4 && o3[a2 - 1] >= t4) i3 = x(o3, t4);
            else {
              if (!((n2 = s3.getExtendedPositions && s3.getExtendedPositions()) && n2.length)) return t4;
              let a3 = n2.length;
              r2 || (r2 = (n2[a3 - 1] - n2[0]) / a3);
              let l2 = x(n2, o3[0]);
              if (t4 >= n2[0] && t4 <= n2[a3 - 1]) i3 = x(n2, t4) - l2;
              else {
                if (!e3) return t4;
                i3 = t4 < n2[0] ? -l2 - (n2[0] - t4) / r2 : (t4 - n2[a3 - 1]) / r2 + a3 - l2;
              }
            }
            return e3 ? i3 : r2 * (i3 || 0) + s3.offset;
          }
          t3.compose = function(t4, e3, i3) {
            let n2 = t4.prototype;
            return n2.ordinal2lin || (n2.getTimeTicks = s2, n2.index2val = o2, n2.lin2val = g, n2.val2lin = k, n2.ordinal2lin = n2.val2lin, r(t4, "afterInit", f), r(t4, "foundExtremes", m), r(t4, "afterSetScale", b), r(t4, "initialAxisTranslation", y), r(i3, "pan", v), r(i3, "touchpan", v), r(e3, "updatedData", M)), t4;
          };
          class A {
            constructor(t4) {
              this.index = {}, this.axis = t4;
            }
            beforeSetTickPositions() {
              var _a;
              let t4 = this.axis, e3 = t4.ordinal, i3 = t4.getExtremes(), s3 = i3.min, o3 = i3.max, r2 = (_a = t4.brokenAxis) == null ? void 0 : _a.hasBreaks, n2 = t4.options.ordinal, a2, l2, h2, d2, p2, u2, g2, x2 = [], f2 = Number.MAX_VALUE, m2 = false, b2 = false, y2 = false;
              if (n2 || r2) {
                let i4 = 0;
                if (t4.series.forEach(function(t5, e4) {
                  if (l2 = [], e4 > 0 && "highcharts-navigator-series" !== t5.options.id && t5.processedXData.length > 1 && (b2 = i4 !== t5.processedXData[1] - t5.processedXData[0]), i4 = t5.processedXData[1] - t5.processedXData[0], t5.boosted && (y2 = t5.boosted), t5.reserveSpace() && (false !== t5.takeOrdinalPosition || r2) && (a2 = (x2 = x2.concat(t5.processedXData)).length, x2.sort(function(t6, e5) {
                    return t6 - e5;
                  }), f2 = Math.min(f2, c(t5.closestPointRange, f2)), a2)) {
                    for (e4 = 0; e4 < a2 - 1; ) x2[e4] !== x2[e4 + 1] && l2.push(x2[e4 + 1]), e4++;
                    l2[0] !== x2[0] && l2.unshift(x2[0]), x2 = l2;
                  }
                }), t4.ordinal.originalOrdinalRange || (t4.ordinal.originalOrdinalRange = (x2.length - 1) * f2), b2 && y2 && (x2.pop(), x2.shift()), (a2 = x2.length) > 2) {
                  for (h2 = x2[1] - x2[0], g2 = a2 - 1; g2-- && !m2; ) x2[g2 + 1] - x2[g2] !== h2 && (m2 = true);
                  !t4.options.keepOrdinalPadding && (x2[0] - s3 > h2 || o3 - x2[x2.length - 1] > h2) && (m2 = true);
                } else t4.options.overscroll && (2 === a2 ? f2 = x2[1] - x2[0] : 1 === a2 ? (f2 = t4.ordinal.convertOverscroll(t4.options.overscroll), x2 = [x2[0], x2[0] + f2]) : f2 = e3.overscrollPointsRange);
                m2 || t4.forceOrdinal ? (t4.options.overscroll && (e3.overscrollPointsRange = f2, x2 = x2.concat(e3.getOverscrollPositions())), e3.positions = x2, d2 = t4.ordinal2lin(Math.max(s3, x2[0]), true), p2 = Math.max(t4.ordinal2lin(Math.min(o3, x2[x2.length - 1]), true), 1), e3.slope = u2 = (o3 - s3) / (p2 - d2), e3.offset = s3 - d2 * u2) : (e3.overscrollPointsRange = c(t4.closestPointRange, e3.overscrollPointsRange), e3.positions = t4.ordinal.slope = e3.offset = void 0);
              }
              t4.isOrdinal = n2 && m2, e3.groupIntervalFactor = null;
            }
            static findIndexOf(t4, e3, i3) {
              let s3 = 0, o3 = t4.length - 1, r2;
              for (; s3 < o3; ) t4[r2 = Math.ceil((s3 + o3) / 2)] <= e3 ? s3 = r2 : o3 = r2 - 1;
              return t4[s3] === e3 ? s3 : i3 ? s3 : -1;
            }
            getExtendedPositions(t4 = true) {
              var _a;
              let s3 = this, o3 = s3.axis, r2 = o3.constructor.prototype, n2 = o3.chart, a2 = (_a = o3.series[0]) == null ? void 0 : _a.currentDataGrouping, l2 = a2 ? a2.count + a2.unitName : "raw", h2 = t4 ? o3.ordinal.convertOverscroll(o3.options.overscroll) : 0, d2 = o3.getExtremes(), c2, p2, u2 = s3.index;
              return u2 || (u2 = s3.index = {}), u2[l2] || ((c2 = { series: [], chart: n2, forceOrdinal: false, getExtremes: function() {
                return { min: d2.dataMin, max: d2.dataMax + h2 };
              }, applyGrouping: r2.applyGrouping, getGroupPixelWidth: r2.getGroupPixelWidth, getTimeTicks: r2.getTimeTicks, options: { ordinal: true }, ordinal: { getGroupIntervalFactor: this.getGroupIntervalFactor }, ordinal2lin: r2.ordinal2lin, getIndexOfPoint: r2.getIndexOfPoint, val2lin: r2.val2lin }).ordinal.axis = c2, o3.series.forEach(function(o4) {
                var _a2, _b, _c;
                p2 = { xAxis: c2, xData: o4.xData.slice(), chart: n2, groupPixelWidth: o4.groupPixelWidth, destroyGroupedData: e2.noop, getProcessedData: i2.prototype.getProcessedData, applyGrouping: i2.prototype.applyGrouping, reserveSpace: i2.prototype.reserveSpace, visible: o4.visible }, t4 && (p2.xData = p2.xData.concat(s3.getOverscrollPositions())), p2.options = { dataGrouping: a2 ? { firstAnchor: (_a2 = o4.options.dataGrouping) == null ? void 0 : _a2.firstAnchor, anchor: (_b = o4.options.dataGrouping) == null ? void 0 : _b.anchor, lastAnchor: (_c = o4.options.dataGrouping) == null ? void 0 : _c.firstAnchor, enabled: true, forced: true, approximation: "open", units: [[a2.unitName, [a2.count]]] } : { enabled: false } }, c2.series.push(p2), o4.processData.apply(p2);
              }), c2.applyGrouping({ hasExtremesChanged: true }), (p2 == null ? void 0 : p2.closestPointRange) !== (p2 == null ? void 0 : p2.basePointRange) && p2.currentDataGrouping && (c2.forceOrdinal = true), o3.ordinal.beforeSetTickPositions.apply({ axis: c2 }), !o3.ordinal.originalOrdinalRange && c2.ordinal.originalOrdinalRange && (o3.ordinal.originalOrdinalRange = c2.ordinal.originalOrdinalRange), u2[l2] = c2.ordinal.positions), u2[l2];
            }
            getGroupIntervalFactor(t4, e3, i3) {
              let s3 = i3.processedXData, o3 = s3.length, r2 = [], n2, a2, l2 = this.groupIntervalFactor;
              if (!l2) {
                for (a2 = 0; a2 < o3 - 1; a2++) r2[a2] = s3[a2 + 1] - s3[a2];
                r2.sort(function(t5, e4) {
                  return t5 - e4;
                }), n2 = r2[Math.floor(o3 / 2)], t4 = Math.max(t4, s3[0]), e3 = Math.min(e3, s3[o3 - 1]), this.groupIntervalFactor = l2 = o3 * n2 / (e3 - t4);
              }
              return l2;
            }
            getIndexOfPoint(t4, e3) {
              let i3;
              let s3 = this.axis, o3 = 0, r2 = function(t5) {
                let { min: e4, max: i4 } = s3;
                return !!(l(e4) && l(i4)) && t5.points.some((t6) => t6.x >= e4 && t6.x <= i4);
              };
              s3.series.forEach((t5) => {
                var _a;
                let e4 = (_a = t5.points) == null ? void 0 : _a[0];
                l(e4 == null ? void 0 : e4.plotX) && (e4.plotX < i3 || !l(i3)) && r2(t5) && (i3 = e4.plotX, o3 = e4.x);
              }), i3 ?? (i3 = s3.minPixelPadding);
              let a2 = s3.translationSlope * (this.slope || s3.closestPointRange || this.overscrollPointsRange), h2 = n((t4 - i3) / a2);
              return A.findIndexOf(e3, o3, true) + h2;
            }
            getOverscrollPositions() {
              let t4 = this.axis, e3 = this.convertOverscroll(t4.options.overscroll), i3 = this.overscrollPointsRange, s3 = [], o3 = t4.dataMax;
              if (l(i3)) for (; o3 <= t4.dataMax + e3; ) s3.push(o3 += i3);
              return s3;
            }
            postProcessTickInterval(t4) {
              let e3 = this.axis, i3 = this.slope;
              return i3 ? e3.options.breaks ? e3.closestPointRange || t4 : t4 / (i3 / e3.closestPointRange) : t4;
            }
            convertOverscroll(t4 = 0) {
              let e3 = this, i3 = e3.axis, s3 = function(t5) {
                return c(e3.originalOrdinalRange, l(i3.dataMax) && l(i3.dataMin) ? i3.dataMax - i3.dataMin : 0) * t5;
              };
              if (u(t4)) {
                let e4 = parseInt(t4, 10);
                if (/%$/.test(t4)) return s3(e4 / 100);
                if (/px/.test(t4)) {
                  let t5 = Math.min(e4, 0.9 * i3.len) / i3.len;
                  return s3(t5 / (1 - t5));
                }
                return 0;
              }
              return t4;
            }
          }
          t3.Additions = A;
        }(o || (o = {})), o;
      }), i(e, "Stock/RangeSelector/RangeSelector.js", [e["Core/Axis/Axis.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Stock/RangeSelector/RangeSelectorComposition.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"], e["Core/Axis/OrdinalAxis.js"]], function(t2, e2, i2, s, o, r, n) {
        let { defaultOptions: a } = e2, { addEvent: l, createElement: h, css: d, defined: c, destroyObjectProperties: p, discardElement: u, extend: g, fireEvent: x, isNumber: f, merge: m, objectEach: b, pad: y, pick: v, pInt: M, splat: k } = r;
        class A {
          static compose(t3, e3) {
            s.compose(t3, e3, A);
          }
          constructor(t3) {
            this.buttonOptions = A.prototype.defaultButtons, this.initialButtonGroupWidth = 0, this.init(t3);
          }
          clickButton(e3, i3) {
            let s2 = this.chart, o2 = this.buttonOptions[e3], r2 = s2.xAxis[0], n2 = s2.scroller && s2.scroller.getUnionExtremes() || r2 || {}, a2 = o2.type, h2 = o2.dataGrouping, d2 = n2.dataMin, p2 = n2.dataMax, u2, g2 = r2 && Math.round(Math.min(r2.max, v(p2, r2.max))), m2, b2 = o2._range, y2, M2, A2, S = true;
            if (null !== d2 && null !== p2) {
              if (this.setSelected(e3), h2 && (this.forcedDataGrouping = true, t2.prototype.setDataGrouping.call(r2 || { chart: this.chart }, h2, false), this.frozenStates = o2.preserveDataGrouping), "month" === a2 || "year" === a2) r2 ? (M2 = { range: o2, max: g2, chart: s2, dataMin: d2, dataMax: p2 }, u2 = r2.minFromRange.call(M2), f(M2.newMax) && (g2 = M2.newMax), S = false) : b2 = o2;
              else if (b2) g2 = Math.min((u2 = Math.max(g2 - b2, d2)) + b2, p2), S = false;
              else if ("ytd" === a2) {
                if (r2) (void 0 === p2 || void 0 === d2) && (d2 = Number.MAX_VALUE, p2 = Number.MIN_VALUE, s2.series.forEach((t3) => {
                  let e4 = t3.xData;
                  e4 && (d2 = Math.min(e4[0], d2), p2 = Math.max(e4[e4.length - 1], p2));
                }), i3 = false), u2 = y2 = (A2 = this.getYTDExtremes(p2, d2, s2.time.useUTC)).min, g2 = A2.max;
                else {
                  this.deferredYTDClick = e3;
                  return;
                }
              } else "all" === a2 && r2 && (s2.navigator && s2.navigator.baseSeries[0] && (s2.navigator.baseSeries[0].xAxis.options.range = void 0), u2 = d2, g2 = p2);
              if (S && o2._offsetMin && c(u2) && (u2 += o2._offsetMin), o2._offsetMax && c(g2) && (g2 += o2._offsetMax), this.dropdown && (this.dropdown.selectedIndex = e3 + 1), r2) r2.setExtremes(u2, g2, v(i3, true), void 0, { trigger: "rangeSelectorButton", rangeSelectorButton: o2 }), s2.setFixedRange(o2._range);
              else {
                m2 = k(s2.options.xAxis)[0];
                let t3 = l(s2, "afterGetAxes", function() {
                  let t4 = s2.xAxis[0];
                  t4.range = t4.options.range = b2, t4.min = t4.options.min = y2;
                });
                l(s2, "load", function() {
                  let e4 = s2.xAxis[0];
                  s2.setFixedRange(o2._range), e4.options.range = m2.range, e4.options.min = m2.min, t3();
                });
              }
              x(this, "afterBtnClick");
            }
          }
          setSelected(t3) {
            this.selected = this.options.selected = t3;
          }
          init(t3) {
            let e3 = this, i3 = t3.options.rangeSelector, s2 = i3.buttons || e3.defaultButtons.slice(), o2 = i3.selected, r2 = function() {
              let t4 = e3.minInput, i4 = e3.maxInput;
              t4 && t4.blur && x(t4, "blur"), i4 && i4.blur && x(i4, "blur");
            };
            e3.chart = t3, e3.options = i3, e3.buttons = [], e3.buttonOptions = s2, this.eventsToUnbind = [], this.eventsToUnbind.push(l(t3.container, "mousedown", r2)), this.eventsToUnbind.push(l(t3, "resize", r2)), s2.forEach(e3.computeButtonRange), void 0 !== o2 && s2[o2] && this.clickButton(o2, false), this.eventsToUnbind.push(l(t3, "load", function() {
              t3.xAxis && t3.xAxis[0] && l(t3.xAxis[0], "setExtremes", function(i4) {
                f(this.max) && f(this.min) && this.max - this.min !== t3.fixedRange && "rangeSelectorButton" !== i4.trigger && "updatedData" !== i4.trigger && e3.forcedDataGrouping && !e3.frozenStates && this.setDataGrouping(false, false);
              });
            })), this.createElements();
          }
          updateButtonStates() {
            let t3 = this, e3 = this.chart, i3 = this.dropdown, s2 = this.dropdownLabel, o2 = e3.xAxis[0], r2 = Math.round(o2.max - o2.min), l2 = !o2.hasVisibleSeries, h2 = 24 * 36e5, c2 = e3.scroller && e3.scroller.getUnionExtremes() || o2, p2 = c2.dataMin, u2 = c2.dataMax, g2 = t3.getYTDExtremes(u2, p2, e3.time.useUTC), x2 = g2.min, m2 = g2.max, b2 = t3.selected, y2 = t3.options.allButtonsEnabled, v2 = Array(t3.buttonOptions.length).fill(0), M2 = f(b2), k2 = t3.buttons, A2 = false, S = null;
            t3.buttonOptions.forEach((e4, i4) => {
              var _a;
              let s3 = e4._range, a2 = e4.type, d2 = e4.count || 1, c3 = e4._offsetMax - e4._offsetMin, g3 = i4 === b2, f2 = s3 > u2 - p2, k3 = s3 < o2.minRange, C = false, w = s3 === r2;
              if (g3 && f2 && (A2 = true), o2.isOrdinal && ((_a = o2.ordinal) == null ? void 0 : _a.positions) && s3 && r2 < s3) {
                let t4 = o2.ordinal.positions, e5 = n.Additions.findIndexOf(t4, o2.min, true), i5 = Math.min(n.Additions.findIndexOf(t4, o2.max, true) + 1, t4.length - 1);
                t4[i5] - t4[e5] > s3 && (w = true);
              } else ("month" === a2 || "year" === a2) && r2 + 36e5 >= { month: 28, year: 365 }[a2] * h2 * d2 - c3 && r2 - 36e5 <= { month: 31, year: 366 }[a2] * h2 * d2 + c3 ? w = true : "ytd" === a2 ? (w = m2 - x2 + c3 === r2, C = !g3) : "all" === a2 && (w = o2.max - o2.min >= u2 - p2);
              let P = !y2 && !(A2 && "all" === a2) && (f2 || k3 || l2), O = A2 && "all" === a2 || !C && w || g3 && t3.frozenStates;
              P ? v2[i4] = 3 : O && (!M2 || i4 === b2) && (S = i4);
            }), null !== S ? (v2[S] = 2, t3.setSelected(S)) : (t3.setSelected(), s2 && (s2.setState(0), s2.attr({ text: (a.lang.rangeSelectorZoom || "") + " " })));
            for (let e4 = 0; e4 < v2.length; e4++) {
              let o3 = v2[e4], r3 = k2[e4];
              if (r3.state !== o3 && (r3.setState(o3), i3)) {
                i3.options[e4 + 1].disabled = 3 === o3, 2 === o3 && (s2 && (s2.setState(2), s2.attr({ text: t3.buttonOptions[e4].text + " " })), i3.selectedIndex = e4 + 1);
                let r4 = s2.getBBox();
                d(i3, { width: `${r4.width}px`, height: `${r4.height}px` });
              }
            }
          }
          computeButtonRange(t3) {
            let e3 = t3.type, i3 = t3.count || 1, s2 = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5 };
            s2[e3] ? t3._range = s2[e3] * i3 : ("month" === e3 || "year" === e3) && (t3._range = 24 * { month: 30, year: 365 }[e3] * 36e5 * i3), t3._offsetMin = v(t3.offsetMin, 0), t3._offsetMax = v(t3.offsetMax, 0), t3._range += t3._offsetMax - t3._offsetMin;
          }
          getInputValue(t3) {
            let e3 = "min" === t3 ? this.minInput : this.maxInput, i3 = this.chart.options.rangeSelector, s2 = this.chart.time;
            return e3 ? ("text" === e3.type && i3.inputDateParser || this.defaultInputDateParser)(e3.value, s2.useUTC, s2) : 0;
          }
          setInputValue(t3, e3) {
            let i3 = this.options, s2 = this.chart.time, o2 = "min" === t3 ? this.minInput : this.maxInput, r2 = "min" === t3 ? this.minDateBox : this.maxDateBox;
            if (o2) {
              let t4 = o2.getAttribute("data-hc-time"), n2 = c(t4) ? Number(t4) : void 0;
              if (c(e3)) {
                let t5 = n2;
                c(t5) && o2.setAttribute("data-hc-time-previous", t5), o2.setAttribute("data-hc-time", e3), n2 = e3;
              }
              o2.value = s2.dateFormat(this.inputTypeFormats[o2.type] || i3.inputEditDateFormat, n2), r2 && r2.attr({ text: s2.dateFormat(i3.inputDateFormat, n2) });
            }
          }
          setInputExtremes(t3, e3, i3) {
            let s2 = "min" === t3 ? this.minInput : this.maxInput;
            if (s2) {
              let t4 = this.inputTypeFormats[s2.type], o2 = this.chart.time;
              if (t4) {
                let r2 = o2.dateFormat(t4, e3);
                s2.min !== r2 && (s2.min = r2);
                let n2 = o2.dateFormat(t4, i3);
                s2.max !== n2 && (s2.max = n2);
              }
            }
          }
          showInput(t3) {
            let e3 = "min" === t3 ? this.minDateBox : this.maxDateBox, i3 = "min" === t3 ? this.minInput : this.maxInput;
            if (i3 && e3 && this.inputGroup) {
              let t4 = "text" === i3.type, { translateX: s2 = 0, translateY: o2 = 0 } = this.inputGroup, { x: r2 = 0, width: n2 = 0, height: a2 = 0 } = e3, { inputBoxWidth: l2 } = this.options;
              d(i3, { width: t4 ? n2 + (l2 ? -2 : 20) + "px" : "auto", height: a2 - 2 + "px", border: "2px solid silver" }), t4 && l2 ? d(i3, { left: s2 + r2 + "px", top: o2 + "px" }) : d(i3, { left: Math.min(Math.round(r2 + s2 - (i3.offsetWidth - n2) / 2), this.chart.chartWidth - i3.offsetWidth) + "px", top: o2 - (i3.offsetHeight - a2) / 2 + "px" });
            }
          }
          hideInput(t3) {
            let e3 = "min" === t3 ? this.minInput : this.maxInput;
            e3 && d(e3, { top: "-9999em", border: 0, width: "1px", height: "1px" });
          }
          defaultInputDateParser(t3, e3, s2) {
            let o2 = t3.split("/").join("-").split(" ").join("T");
            if (-1 === o2.indexOf("T") && (o2 += "T00:00"), e3) o2 += "Z";
            else {
              let t4;
              if (i2.isSafari && !((t4 = o2).length > 6 && (t4.lastIndexOf("-") === t4.length - 6 || t4.lastIndexOf("+") === t4.length - 6))) {
                let t5 = new Date(o2).getTimezoneOffset() / 60;
                o2 += t5 <= 0 ? `+${y(-t5)}:00` : `-${y(t5)}:00`;
              }
            }
            let r2 = Date.parse(o2);
            if (!f(r2)) {
              let e4 = t3.split("-");
              r2 = Date.UTC(M(e4[0]), M(e4[1]) - 1, M(e4[2]));
            }
            return s2 && e3 && f(r2) && (r2 += s2.getTimezoneOffset(r2)), r2;
          }
          drawInput(t3) {
            let { chart: e3, div: s2, inputGroup: o2 } = this, r2 = this, n2 = e3.renderer.style || {}, l2 = e3.renderer, c2 = e3.options.rangeSelector, p2 = a.lang, u2 = "min" === t3;
            function x2(t4) {
              var _a;
              let { maxInput: i3, minInput: s3 } = r2, o3 = e3.xAxis[0], n3 = ((_a = e3.scroller) == null ? void 0 : _a.getUnionExtremes()) || o3, a2 = n3.dataMin, l3 = n3.dataMax, h2 = e3.xAxis[0].getExtremes()[t4], d2 = r2.getInputValue(t4);
              f(d2) && d2 !== h2 && (u2 && i3 && f(a2) ? d2 > Number(i3.getAttribute("data-hc-time")) ? d2 = void 0 : d2 < a2 && (d2 = a2) : s3 && f(l3) && (d2 < Number(s3.getAttribute("data-hc-time")) ? d2 = void 0 : d2 > l3 && (d2 = l3)), void 0 !== d2 && o3.setExtremes(u2 ? d2 : o3.min, u2 ? o3.max : d2, void 0, void 0, { trigger: "rangeSelectorInput" }));
            }
            let b2 = p2[u2 ? "rangeSelectorFrom" : "rangeSelectorTo"] || "", y2 = l2.label(b2, 0).addClass("highcharts-range-label").attr({ padding: b2 ? 2 : 0, height: b2 ? c2.inputBoxHeight : 0 }).add(o2), v2 = l2.label("", 0).addClass("highcharts-range-input").attr({ padding: 2, width: c2.inputBoxWidth, height: c2.inputBoxHeight, "text-align": "center" }).on("click", function() {
              r2.showInput(t3), r2[t3 + "Input"].focus();
            });
            e3.styledMode || v2.attr({ stroke: c2.inputBoxBorderColor, "stroke-width": 1 }), v2.add(o2);
            let M2 = h("input", { name: t3, className: "highcharts-range-selector" }, void 0, s2);
            M2.setAttribute("type", function(t4) {
              if (-1 !== t4.indexOf("%L")) return "text";
              let e4 = ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some((e5) => -1 !== t4.indexOf("%" + e5)), i3 = ["H", "k", "I", "l", "M", "S"].some((e5) => -1 !== t4.indexOf("%" + e5));
              return e4 && i3 ? "datetime-local" : e4 ? "date" : i3 ? "time" : "text";
            }(c2.inputDateFormat || "%e %b %Y")), e3.styledMode || (y2.css(m(n2, c2.labelStyle)), v2.css(m({ color: "#333333" }, n2, c2.inputStyle)), d(M2, g({ position: "absolute", border: 0, boxShadow: "0 0 15px rgba(0,0,0,0.3)", width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: n2.fontSize, fontFamily: n2.fontFamily, top: "-9999em" }, c2.inputStyle))), M2.onfocus = () => {
              r2.showInput(t3);
            }, M2.onblur = () => {
              M2 === i2.doc.activeElement && x2(t3), r2.hideInput(t3), r2.setInputValue(t3), M2.blur();
            };
            let k2 = false;
            return M2.onchange = () => {
              k2 || (x2(t3), r2.hideInput(t3), M2.blur());
            }, M2.onkeypress = (e4) => {
              13 === e4.keyCode && x2(t3);
            }, M2.onkeydown = (e4) => {
              k2 = true, ("ArrowUp" === e4.key || "ArrowDown" === e4.key || "Tab" === e4.key) && x2(t3);
            }, M2.onkeyup = () => {
              k2 = false;
            }, { dateBox: v2, input: M2, label: y2 };
          }
          getPosition() {
            let t3 = this.chart, e3 = t3.options.rangeSelector, i3 = "top" === e3.verticalAlign ? t3.plotTop - t3.axisOffset[0] : 0;
            return { buttonTop: i3 + e3.buttonPosition.y, inputTop: i3 + e3.inputPosition.y - 10 };
          }
          getYTDExtremes(t3, e3, i3) {
            let s2 = this.chart.time, o2 = new s2.Date(t3), r2 = s2.get("FullYear", o2), n2 = Math.max(e3, i3 ? s2.Date.UTC(r2, 0, 1) : +new s2.Date(r2, 0, 1)), a2 = o2.getTime();
            return { max: Math.min(t3 || a2, a2), min: n2 };
          }
          createElements() {
            var _a;
            let t3 = this.chart, e3 = t3.renderer, i3 = t3.container, s2 = t3.options, o2 = s2.rangeSelector, r2 = o2.inputEnabled, n2 = v((_a = s2.chart.style) == null ? void 0 : _a.zIndex, 0) + 1;
            if (false !== o2.enabled && (this.group = e3.g("range-selector-group").attr({ zIndex: 7 }).add(), this.div = h("div", void 0, { position: "relative", height: 0, zIndex: n2 }), this.buttonOptions.length && this.renderButtons(), i3.parentNode && i3.parentNode.insertBefore(this.div, i3), r2)) {
              this.inputGroup = e3.g("input-group").add(this.group);
              let t4 = this.drawInput("min");
              this.minDateBox = t4.dateBox, this.minLabel = t4.label, this.minInput = t4.input;
              let i4 = this.drawInput("max");
              this.maxDateBox = i4.dateBox, this.maxLabel = i4.label, this.maxInput = i4.input;
            }
          }
          render(t3, e3) {
            let i3 = this.chart, s2 = i3.options.rangeSelector, o2 = s2.inputEnabled;
            if (false !== s2.enabled) {
              if (o2) {
                this.setInputValue("min", t3), this.setInputValue("max", e3);
                let o3 = i3.scroller && i3.scroller.getUnionExtremes() || i3.xAxis[0] || {};
                if (c(o3.dataMin) && c(o3.dataMax)) {
                  let t4 = i3.xAxis[0].minRange || 0;
                  this.setInputExtremes("min", o3.dataMin, Math.min(o3.dataMax, this.getInputValue("max")) - t4), this.setInputExtremes("max", Math.max(o3.dataMin, this.getInputValue("min")) + t4, o3.dataMax);
                }
                if (this.inputGroup) {
                  let t4 = 0;
                  [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach((e4) => {
                    if (e4) {
                      let { width: i4 } = e4.getBBox();
                      i4 && (e4.attr({ x: t4 }), t4 += i4 + s2.inputSpacing);
                    }
                  });
                }
              }
              this.alignElements(), this.updateButtonStates();
            }
          }
          renderButtons() {
            var _a;
            let { buttons: t3, chart: e3, options: s2 } = this, o2 = a.lang, r2 = e3.renderer, n2 = m(s2.buttonTheme), d2 = n2 && n2.states, c2 = n2.width || 28;
            delete n2.width, delete n2.states, this.buttonGroup = r2.g("range-selector-buttons").add(this.group);
            let p2 = this.dropdown = h("select", void 0, { position: "absolute", padding: 0, border: 0, cursor: "pointer", opacity: 1e-4 }, this.div), u2 = (_a = e3.userOptions.rangeSelector) == null ? void 0 : _a.buttonTheme;
            this.dropdownLabel = r2.button("", 0, 0, () => {
            }, m(n2, { "stroke-width": v(n2["stroke-width"], 0), width: "auto", paddingLeft: v(s2.buttonTheme.paddingLeft, u2 == null ? void 0 : u2.padding, 8), paddingRight: v(s2.buttonTheme.paddingRight, u2 == null ? void 0 : u2.padding, 8) }), d2 && d2.hover, d2 && d2.select, d2 && d2.disabled).hide().add(this.group), l(p2, "touchstart", () => {
              p2.style.fontSize = "16px";
            });
            let g2 = i2.isMS ? "mouseover" : "mouseenter", f2 = i2.isMS ? "mouseout" : "mouseleave";
            l(p2, g2, () => {
              x(this.dropdownLabel.element, g2);
            }), l(p2, f2, () => {
              x(this.dropdownLabel.element, f2);
            }), l(p2, "change", () => {
              x(this.buttons[p2.selectedIndex - 1].element, "click");
            }), this.zoomText = r2.label(o2.rangeSelectorZoom || "", 0).attr({ padding: s2.buttonTheme.padding, height: s2.buttonTheme.height, paddingLeft: 0, paddingRight: 0 }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(s2.labelStyle), n2["stroke-width"] = v(n2["stroke-width"], 0)), h("option", { textContent: this.zoomText.textStr, disabled: true }, void 0, p2), this.buttonOptions.forEach((e4, i3) => {
              h("option", { textContent: e4.title || e4.text }, void 0, p2), t3[i3] = r2.button(e4.text, 0, 0, (t4) => {
                let s3;
                let o3 = e4.events && e4.events.click;
                o3 && (s3 = o3.call(e4, t4)), false !== s3 && this.clickButton(i3), this.isActive = true;
              }, n2, d2 && d2.hover, d2 && d2.select, d2 && d2.disabled).attr({ "text-align": "center", width: c2 }).add(this.buttonGroup), e4.title && t3[i3].attr("title", e4.title);
            });
          }
          alignElements() {
            var _a;
            let { buttonGroup: t3, buttons: e3, chart: i3, group: s2, inputGroup: o2, options: r2, zoomText: n2 } = this, a2 = i3.options, l2 = a2.exporting && false !== a2.exporting.enabled && a2.navigation && a2.navigation.buttonOptions, { buttonPosition: h2, inputPosition: d2, verticalAlign: c2 } = r2, p2 = (t4, e4) => l2 && this.titleCollision(i3) && "top" === c2 && "right" === e4.align && e4.y - t4.getBBox().height - 12 < (l2.y || 0) + (l2.height || 0) + i3.spacing[0] ? -40 : 0, u2 = i3.plotLeft;
            if (s2 && h2 && d2) {
              let a3 = h2.x - i3.spacing[3];
              if (t3) {
                if (this.positionButtons(), !this.initialButtonGroupWidth) {
                  let t4 = 0;
                  n2 && (t4 += n2.getBBox().width + 5), e3.forEach((i4, s3) => {
                    t4 += i4.width || 0, s3 !== e3.length - 1 && (t4 += r2.buttonSpacing);
                  }), this.initialButtonGroupWidth = t4;
                }
                u2 -= i3.spacing[3];
                let o3 = p2(t3, h2);
                this.alignButtonGroup(o3), ((_a = this.buttonGroup) == null ? void 0 : _a.translateY) && this.dropdownLabel.attr({ y: this.buttonGroup.translateY }), s2.placed = t3.placed = i3.hasLoaded;
              }
              let l3 = 0;
              o2 && (l3 = p2(o2, d2), "left" === d2.align ? a3 = u2 : "right" === d2.align && (a3 = -Math.max(i3.axisOffset[1], -l3)), o2.align({ y: d2.y, width: o2.getBBox().width, align: d2.align, x: d2.x + a3 - 2 }, true, i3.spacingBox), o2.placed = i3.hasLoaded), this.handleCollision(l3), s2.align({ verticalAlign: c2 }, true, i3.spacingBox);
              let g2 = s2.alignAttr.translateY, x2 = s2.getBBox().height + 20, f2 = 0;
              if ("bottom" === c2) {
                let t4 = i3.legend && i3.legend.options;
                f2 = g2 - (x2 = x2 + (t4 && "bottom" === t4.verticalAlign && t4.enabled && !t4.floating ? i3.legend.legendHeight + v(t4.margin, 10) : 0) - 20) - (r2.floating ? 0 : r2.y) - (i3.titleOffset ? i3.titleOffset[2] : 0) - 10;
              }
              "top" === c2 ? (r2.floating && (f2 = 0), i3.titleOffset && i3.titleOffset[0] && (f2 = i3.titleOffset[0]), f2 += i3.margin[0] - i3.spacing[0] || 0) : "middle" === c2 && (d2.y === h2.y ? f2 = g2 : (d2.y || h2.y) && (d2.y < 0 || h2.y < 0 ? f2 -= Math.min(d2.y, h2.y) : f2 = g2 - x2)), s2.translate(r2.x, r2.y + Math.floor(f2));
              let { minInput: m2, maxInput: b2, dropdown: y2 } = this;
              r2.inputEnabled && m2 && b2 && (m2.style.marginTop = s2.translateY + "px", b2.style.marginTop = s2.translateY + "px"), y2 && (y2.style.marginTop = s2.translateY + "px");
            }
          }
          alignButtonGroup(t3, e3) {
            let { chart: i3, options: s2, buttonGroup: o2 } = this, { buttonPosition: r2 } = s2, n2 = i3.plotLeft - i3.spacing[3], a2 = r2.x - i3.spacing[3];
            "right" === r2.align ? a2 += t3 - n2 : "center" === r2.align && (a2 -= n2 / 2), o2 && o2.align({ y: r2.y, width: v(e3, this.initialButtonGroupWidth), align: r2.align, x: a2 }, true, i3.spacingBox);
          }
          positionButtons() {
            let { buttons: t3, chart: e3, options: i3, zoomText: s2 } = this, o2 = e3.hasLoaded ? "animate" : "attr", { buttonPosition: r2 } = i3, n2 = e3.plotLeft, a2 = n2;
            s2 && "hidden" !== s2.visibility && (s2[o2]({ x: v(n2 + r2.x, n2) }), a2 += r2.x + s2.getBBox().width + 5);
            for (let e4 = 0, s3 = this.buttonOptions.length; e4 < s3; ++e4) "hidden" !== t3[e4].visibility ? (t3[e4][o2]({ x: a2 }), a2 += (t3[e4].width || 0) + i3.buttonSpacing) : t3[e4][o2]({ x: n2 });
          }
          handleCollision(t3) {
            let { chart: e3, buttonGroup: i3, inputGroup: s2 } = this, { buttonPosition: o2, dropdown: r2, inputPosition: n2 } = this.options, a2 = () => {
              let t4 = 0;
              return this.buttons.forEach((e4) => {
                let i4 = e4.getBBox();
                i4.width > t4 && (t4 = i4.width);
              }), t4;
            }, l2 = (e4) => {
              if ((s2 == null ? void 0 : s2.alignOptions) && i3) {
                let r3 = s2.alignAttr.translateX + s2.alignOptions.x - t3 + s2.getBBox().x + 2, a3 = s2.alignOptions.width || 0, l3 = i3.alignAttr.translateX + i3.getBBox().x;
                return l3 + e4 > r3 && r3 + a3 > l3 && o2.y < n2.y + s2.getBBox().height;
              }
              return false;
            }, h2 = () => {
              s2 && i3 && s2.attr({ translateX: s2.alignAttr.translateX + (e3.axisOffset[1] >= -t3 ? 0 : -t3), translateY: s2.alignAttr.translateY + i3.getBBox().height + 10 });
            };
            if (i3) {
              if ("always" === r2) {
                this.collapseButtons(), l2(a2()) && h2();
                return;
              }
              "never" === r2 && this.expandButtons();
            }
            s2 && i3 ? n2.align === o2.align || l2(this.initialButtonGroupWidth + 20) ? "responsive" === r2 ? (this.collapseButtons(), l2(a2()) && h2()) : h2() : "responsive" === r2 && this.expandButtons() : i3 && "responsive" === r2 && (this.initialButtonGroupWidth > e3.plotWidth ? this.collapseButtons() : this.expandButtons());
          }
          collapseButtons() {
            let { buttons: t3, zoomText: e3 } = this;
            true !== this.isCollapsed && (this.isCollapsed = true, e3.hide(), t3.forEach((t4) => void t4.hide()), this.showDropdown());
          }
          expandButtons() {
            let { buttons: t3, zoomText: e3 } = this;
            false !== this.isCollapsed && (this.isCollapsed = false, this.hideDropdown(), e3.show(), t3.forEach((t4) => void t4.show()), this.positionButtons());
          }
          showDropdown() {
            let { buttonGroup: t3, chart: e3, dropdownLabel: i3, dropdown: s2 } = this;
            if (t3 && s2) {
              let { translateX: o2 = 0, translateY: r2 = 0 } = t3, n2 = e3.plotLeft + o2;
              i3.attr({ x: n2, y: r2 }).show(), d(s2, { left: n2 + "px", top: r2 + "px", visibility: "inherit" }), this.hasVisibleDropdown = true;
            }
          }
          hideDropdown() {
            let { dropdown: t3 } = this;
            t3 && (this.dropdownLabel.hide(), d(t3, { visibility: "hidden", width: "1px", height: "1px" }), this.hasVisibleDropdown = false);
          }
          getHeight() {
            let t3 = this.options, e3 = this.group, i3 = t3.inputPosition, s2 = t3.buttonPosition, o2 = t3.y, r2 = s2.y, n2 = i3.y, a2 = 0;
            if (t3.height) return t3.height;
            this.alignElements(), a2 = e3 ? e3.getBBox(true).height + 13 + o2 : 0;
            let l2 = Math.min(n2, r2);
            return (n2 < 0 && r2 < 0 || n2 > 0 && r2 > 0) && (a2 += Math.abs(l2)), a2;
          }
          titleCollision(t3) {
            return !(t3.options.title.text || t3.options.subtitle.text);
          }
          update(t3, e3 = true) {
            let i3 = this.chart;
            m(true, i3.options.rangeSelector, t3), this.destroy(), this.init(i3), e3 && this.render();
          }
          destroy() {
            let t3 = this, e3 = t3.minInput, i3 = t3.maxInput;
            t3.eventsToUnbind && (t3.eventsToUnbind.forEach((t4) => t4()), t3.eventsToUnbind = void 0), p(t3.buttons), e3 && (e3.onfocus = e3.onblur = e3.onchange = null), i3 && (i3.onfocus = i3.onblur = i3.onchange = null), b(t3, function(e4, i4) {
              e4 && "chart" !== i4 && (e4 instanceof o ? e4.destroy() : e4 instanceof window.HTMLElement && u(e4)), e4 !== A.prototype[i4] && (t3[i4] = null);
            }, this);
          }
        }
        return g(A.prototype, { defaultButtons: [{ type: "month", count: 1, text: "1m", title: "View 1 month" }, { type: "month", count: 3, text: "3m", title: "View 3 months" }, { type: "month", count: 6, text: "6m", title: "View 6 months" }, { type: "ytd", text: "YTD", title: "View year to date" }, { type: "year", count: 1, text: "1y", title: "View 1 year" }, { type: "all", text: "All", title: "View all" }], inputTypeFormats: { "datetime-local": "%Y-%m-%dT%H:%M:%S", date: "%Y-%m-%d", time: "%H:%M:%S" } }), A;
      }), i(e, "Series/PathUtilities.js", [], function() {
        function t2(t3, e2) {
          let i2 = [];
          for (let s = 0; s < t3.length; s++) {
            let o = t3[s][1], r = t3[s][2];
            if ("number" == typeof o && "number" == typeof r) {
              if (0 === s) i2.push(["M", o, r]);
              else if (s === t3.length - 1) i2.push(["L", o, r]);
              else if (e2) {
                let n = t3[s - 1], a = t3[s + 1];
                if (n && a) {
                  let t4 = n[1], s2 = n[2], l = a[1], h = a[2];
                  if ("number" == typeof t4 && "number" == typeof l && "number" == typeof s2 && "number" == typeof h && t4 !== l && s2 !== h) {
                    let n2 = t4 < l ? 1 : -1, a2 = s2 < h ? 1 : -1;
                    i2.push(["L", o - n2 * Math.min(Math.abs(o - t4), e2), r - a2 * Math.min(Math.abs(r - s2), e2)], ["C", o, r, o, r, o + n2 * Math.min(Math.abs(o - l), e2), r + a2 * Math.min(Math.abs(r - h), e2)]);
                  }
                }
              } else i2.push(["L", o, r]);
            }
          }
          return i2;
        }
        return { applyRadius: t2, getLinkPath: { default: function(e2) {
          let { x1: i2, y1: s, x2: o, y2: r, width: n = 0, inverted: a = false, radius: l, parentVisible: h } = e2, d = [["M", i2, s], ["L", i2, s], ["C", i2, s, i2, r, i2, r], ["L", i2, r], ["C", i2, s, i2, r, i2, r], ["L", i2, r]];
          return h ? t2([["M", i2, s], ["L", i2 + n * (a ? -0.5 : 0.5), s], ["L", i2 + n * (a ? -0.5 : 0.5), r], ["L", o, r]], l) : d;
        }, straight: function(t3) {
          let { x1: e2, y1: i2, x2: s, y2: o, width: r = 0, inverted: n = false, parentVisible: a } = t3;
          return a ? [["M", e2, i2], ["L", e2 + r * (n ? -1 : 1), o], ["L", s, o]] : [["M", e2, i2], ["L", e2, o], ["L", e2, o]];
        }, curved: function(t3) {
          let { x1: e2, y1: i2, x2: s, y2: o, offset: r = 0, width: n = 0, inverted: a = false, parentVisible: l } = t3;
          return l ? [["M", e2, i2], ["C", e2 + r, i2, e2 - r + n * (a ? -1 : 1), o, e2 + n * (a ? -1 : 1), o], ["L", s, o]] : [["M", e2, i2], ["C", e2, i2, e2, o, e2, o], ["L", s, o]];
        } } };
      }), i(e, "Gantt/PathfinderAlgorithms.js", [e["Series/PathUtilities.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { pick: i2 } = e2, { min: s, max: o, abs: r } = Math;
        function n(t3, e3, i3) {
          let s2 = e3 - 1e-7, o2 = i3 || 0, r2 = t3.length - 1, n2, a2;
          for (; o2 <= r2; ) if ((a2 = s2 - t3[n2 = r2 + o2 >> 1].xMin) > 0) o2 = n2 + 1;
          else {
            if (!(a2 < 0)) return n2;
            r2 = n2 - 1;
          }
          return o2 > 0 ? o2 - 1 : 0;
        }
        function a(t3, e3) {
          let i3 = n(t3, e3.x + 1) + 1;
          for (; i3--; ) {
            var s2;
            if (t3[i3].xMax >= e3.x && (s2 = t3[i3], e3.x <= s2.xMax && e3.x >= s2.xMin && e3.y <= s2.yMax && e3.y >= s2.yMin)) return i3;
          }
          return -1;
        }
        function l(t3) {
          let e3 = [];
          if (t3.length) {
            e3.push(["M", t3[0].start.x, t3[0].start.y]);
            for (let i3 = 0; i3 < t3.length; ++i3) e3.push(["L", t3[i3].end.x, t3[i3].end.y]);
          }
          return e3;
        }
        function h(t3, e3) {
          t3.yMin = o(t3.yMin, e3.yMin), t3.yMax = s(t3.yMax, e3.yMax), t3.xMin = o(t3.xMin, e3.xMin), t3.xMax = s(t3.xMax, e3.xMax);
        }
        let d = function(e3, s2, o2) {
          let n2 = [], h2 = o2.chartObstacles, d2 = a(h2, e3), c2 = a(h2, s2), p, u = i2(o2.startDirectionX, r(s2.x - e3.x) > r(s2.y - e3.y)) ? "x" : "y", g, x, f, m;
          function b(t3, e4, i3, s3, o3) {
            let r2 = { x: t3.x, y: t3.y };
            return r2[e4] = i3[s3 || e4] + (o3 || 0), r2;
          }
          function y(t3, e4, i3) {
            let s3 = r(e4[i3] - t3[i3 + "Min"]) > r(e4[i3] - t3[i3 + "Max"]);
            return b(e4, i3, t3, i3 + (s3 ? "Max" : "Min"), s3 ? 1 : -1);
          }
          c2 > -1 ? (p = { start: x = y(h2[c2], s2, u), end: s2 }, m = x) : m = s2, d2 > -1 && (x = y(g = h2[d2], e3, u), n2.push({ start: e3, end: x }), x[u] >= e3[u] == x[u] >= m[u] && (f = e3[u = "y" === u ? "x" : "y"] < s2[u], n2.push({ start: x, end: b(x, u, g, u + (f ? "Max" : "Min"), f ? 1 : -1) }), u = "y" === u ? "x" : "y"));
          let v = n2.length ? n2[n2.length - 1].end : e3;
          x = b(v, u, m), n2.push({ start: v, end: x });
          let M = b(x, u = "y" === u ? "x" : "y", m);
          return n2.push({ start: x, end: M }), n2.push(p), { path: t2.applyRadius(l(n2), o2.radius), obstacles: n2 };
        };
        function c(t3, e3, d2) {
          let c2 = i2(d2.startDirectionX, r(e3.x - t3.x) > r(e3.y - t3.y)), p = c2 ? "x" : "y", u = [], g = d2.obstacleMetrics, x = s(t3.x, e3.x) - g.maxWidth - 10, f = o(t3.x, e3.x) + g.maxWidth + 10, m = s(t3.y, e3.y) - g.maxHeight - 10, b = o(t3.y, e3.y) + g.maxHeight + 10, y, v, M, k = false, A = d2.chartObstacles, S = n(A, f), C = n(A, x);
          function w(t4, e4, i3) {
            let o2, r2, a2, l2;
            let h2 = t4.x < e4.x ? 1 : -1;
            t4.x < e4.x ? (o2 = t4, r2 = e4) : (o2 = e4, r2 = t4), t4.y < e4.y ? (l2 = t4, a2 = e4) : (l2 = e4, a2 = t4);
            let d3 = h2 < 0 ? s(n(A, r2.x), A.length - 1) : 0;
            for (; A[d3] && (h2 > 0 && A[d3].xMin <= r2.x || h2 < 0 && A[d3].xMax >= o2.x); ) {
              if (A[d3].xMin <= r2.x && A[d3].xMax >= o2.x && A[d3].yMin <= a2.y && A[d3].yMax >= l2.y) {
                if (i3) return { y: t4.y, x: t4.x < e4.x ? A[d3].xMin - 1 : A[d3].xMax + 1, obstacle: A[d3] };
                return { x: t4.x, y: t4.y < e4.y ? A[d3].yMin - 1 : A[d3].yMax + 1, obstacle: A[d3] };
              }
              d3 += h2;
            }
            return e4;
          }
          function P(t4, e4, i3, s2, o2) {
            let n2 = o2.soft, a2 = o2.hard, l2 = s2 ? "x" : "y", h2 = { x: e4.x, y: e4.y }, d3 = { x: e4.x, y: e4.y }, c3 = t4[l2 + "Max"] >= n2[l2 + "Max"], p2 = t4[l2 + "Min"] <= n2[l2 + "Min"], u2 = t4[l2 + "Max"] >= a2[l2 + "Max"], g2 = t4[l2 + "Min"] <= a2[l2 + "Min"], x2 = r(t4[l2 + "Min"] - e4[l2]), f2 = r(t4[l2 + "Max"] - e4[l2]), m2 = 10 > r(x2 - f2) ? e4[l2] < i3[l2] : f2 < x2;
            d3[l2] = t4[l2 + "Min"], h2[l2] = t4[l2 + "Max"];
            let b2 = w(e4, d3, s2)[l2] !== d3[l2], y2 = w(e4, h2, s2)[l2] !== h2[l2];
            return m2 = b2 ? !y2 || m2 : !y2 && m2, m2 = p2 ? !c3 || m2 : !c3 && m2, m2 = g2 ? !u2 || m2 : !u2 && m2;
          }
          for ((S = a(A = A.slice(C, S + 1), e3)) > -1 && (M = function(t4, e4, i3) {
            let o2 = s(t4.xMax - e4.x, e4.x - t4.xMin) < s(t4.yMax - e4.y, e4.y - t4.yMin), r2 = P(t4, e4, i3, o2, { soft: d2.hardBounds, hard: d2.hardBounds });
            return o2 ? { y: e4.y, x: t4[r2 ? "xMax" : "xMin"] + (r2 ? 1 : -1) } : { x: e4.x, y: t4[r2 ? "yMax" : "yMin"] + (r2 ? 1 : -1) };
          }(A[S], e3, t3), u.push({ end: e3, start: M }), e3 = M); (S = a(A, e3)) > -1; ) v = e3[p] - t3[p] < 0, (M = { x: e3.x, y: e3.y })[p] = A[S][v ? p + "Max" : p + "Min"] + (v ? 1 : -1), u.push({ end: e3, start: M }), e3 = M;
          return { path: l(y = (y = function t4(e4, i3, r2) {
            let n2, l2, c3, p2, u2, g2, y2;
            if (e4.x === i3.x && e4.y === i3.y) return [];
            let v2 = r2 ? "x" : "y", M2 = d2.obstacleOptions.margin, S2 = { soft: { xMin: x, xMax: f, yMin: m, yMax: b }, hard: d2.hardBounds };
            return (u2 = a(A, e4)) > -1 ? (p2 = P(u2 = A[u2], e4, i3, r2, S2), h(u2, d2.hardBounds), y2 = r2 ? { y: e4.y, x: u2[p2 ? "xMax" : "xMin"] + (p2 ? 1 : -1) } : { x: e4.x, y: u2[p2 ? "yMax" : "yMin"] + (p2 ? 1 : -1) }, (g2 = a(A, y2)) > -1 && (h(g2 = A[g2], d2.hardBounds), y2[v2] = p2 ? o(u2[v2 + "Max"] - M2 + 1, (g2[v2 + "Min"] + u2[v2 + "Max"]) / 2) : s(u2[v2 + "Min"] + M2 - 1, (g2[v2 + "Max"] + u2[v2 + "Min"]) / 2), e4.x === y2.x && e4.y === y2.y ? (k && (y2[v2] = p2 ? o(u2[v2 + "Max"], g2[v2 + "Max"]) + 1 : s(u2[v2 + "Min"], g2[v2 + "Min"]) - 1), k = !k) : k = false), l2 = [{ start: e4, end: y2 }]) : (n2 = w(e4, { x: r2 ? i3.x : e4.x, y: r2 ? e4.y : i3.y }, r2), l2 = [{ start: e4, end: { x: n2.x, y: n2.y } }], n2[r2 ? "x" : "y"] !== i3[r2 ? "x" : "y"] && (p2 = P(n2.obstacle, n2, i3, !r2, S2), h(n2.obstacle, d2.hardBounds), c3 = { x: r2 ? n2.x : n2.obstacle[p2 ? "xMax" : "xMin"] + (p2 ? 1 : -1), y: r2 ? n2.obstacle[p2 ? "yMax" : "yMin"] + (p2 ? 1 : -1) : n2.y }, r2 = !r2, l2 = l2.concat(t4({ x: n2.x, y: n2.y }, c3, r2)))), l2 = l2.concat(t4(l2[l2.length - 1].end, i3, !r2));
          }(t3, e3, c2)).concat(u.reverse())), obstacles: y };
        }
        return d.requiresObstacles = true, c.requiresObstacles = true, { fastAvoid: c, straight: function(t3, e3) {
          return { path: [["M", t3.x, t3.y], ["L", e3.x, e3.y]], obstacles: [{ start: t3, end: e3 }] };
        }, simpleConnect: d };
      }), i(e, "Gantt/ConnectorsDefaults.js", [], function() {
        return { connectors: { type: "straight", radius: 0, lineWidth: 1, marker: { enabled: false, align: "center", verticalAlign: "middle", inside: false, lineWidth: 1 }, startMarker: { symbol: "diamond" }, endMarker: { symbol: "arrow-filled" } } };
      }), i(e, "Gantt/PathfinderComposition.js", [e["Gantt/ConnectorsDefaults.js"], e["Core/Defaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        var s;
        let { setOptions: o } = e2, { defined: r, error: n, merge: a } = i2;
        function l(t3) {
          let e3 = t3.shapeArgs;
          if (e3) return { xMin: e3.x || 0, xMax: (e3.x || 0) + (e3.width || 0), yMin: e3.y || 0, yMax: (e3.y || 0) + (e3.height || 0) };
          let i3 = t3.graphic && t3.graphic.getBBox();
          return i3 ? { xMin: t3.plotX - i3.width / 2, xMax: t3.plotX + i3.width / 2, yMin: t3.plotY - i3.height / 2, yMax: t3.plotY + i3.height / 2 } : null;
        }
        return function(e3) {
          function i3(t3) {
            let e4, i4;
            let s3 = l(this);
            switch (t3.align) {
              case "right":
                e4 = "xMax";
                break;
              case "left":
                e4 = "xMin";
            }
            switch (t3.verticalAlign) {
              case "top":
                i4 = "yMin";
                break;
              case "bottom":
                i4 = "yMax";
            }
            return { x: e4 ? s3[e4] : (s3.xMin + s3.xMax) / 2, y: i4 ? s3[i4] : (s3.yMin + s3.yMax) / 2 };
          }
          function s2(t3, e4) {
            let i4;
            return !r(e4) && (i4 = l(this)) && (e4 = { x: (i4.xMin + i4.xMax) / 2, y: (i4.yMin + i4.yMax) / 2 }), Math.atan2(e4.y - t3.y, t3.x - e4.x);
          }
          function h(t3, e4, i4) {
            let s3 = 2 * Math.PI, o2 = l(this), r2 = o2.xMax - o2.xMin, n2 = o2.yMax - o2.yMin, a2 = Math.atan2(n2, r2), h2 = r2 / 2, d = n2 / 2, c = o2.xMin + h2, p = o2.yMin + d, u = { x: c, y: p }, g = t3, x = 1, f = false, m = 1, b = 1;
            for (; g < -Math.PI; ) g += s3;
            for (; g > Math.PI; ) g -= s3;
            return x = Math.tan(g), g > -a2 && g <= a2 ? (b = -1, f = true) : g > a2 && g <= Math.PI - a2 ? b = -1 : g > Math.PI - a2 || g <= -(Math.PI - a2) ? (m = -1, f = true) : m = -1, f ? (u.x += m * h2, u.y += b * h2 * x) : (u.x += n2 / (2 * x) * m, u.y += b * d), i4.x !== c && (u.x = i4.x), i4.y !== p && (u.y = i4.y), { x: u.x + e4 * Math.cos(g), y: u.y - e4 * Math.sin(g) };
          }
          e3.compose = function(e4, r2, l2) {
            let d = l2.prototype;
            d.getPathfinderAnchorPoint || (e4.prototype.callbacks.push(function(t3) {
              false !== t3.options.connectors.enabled && ((t3.options.pathfinder || t3.series.reduce(function(t4, e5) {
                return e5.options && a(true, e5.options.connectors = e5.options.connectors || {}, e5.options.pathfinder), t4 || e5.options && e5.options.pathfinder;
              }, false)) && (a(true, t3.options.connectors = t3.options.connectors || {}, t3.options.pathfinder), n('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.')), this.pathfinder = new r2(this), this.pathfinder.update(true));
            }), d.getMarkerVector = h, d.getPathfinderAnchorPoint = i3, d.getRadiansToVector = s2, o(t2));
          };
        }(s || (s = {})), s;
      }), i(e, "Gantt/Pathfinder.js", [e["Gantt/Connection.js"], e["Gantt/PathfinderAlgorithms.js"], e["Gantt/PathfinderComposition.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, o) {
        let { addEvent: r, defined: n, pick: a, splat: l } = o, h = Math.max, d = Math.min;
        class c {
          static compose(t3, e3) {
            i2.compose(t3, c, e3);
          }
          constructor(t3) {
            this.init(t3);
          }
          init(t3) {
            this.chart = t3, this.connections = [], r(t3, "redraw", function() {
              this.pathfinder.update();
            });
          }
          update(e3) {
            let i3 = this.chart, o2 = this, r2 = o2.connections;
            o2.connections = [], i3.series.forEach(function(e4) {
              e4.visible && !e4.options.isInternal && e4.points.forEach(function(e5) {
                var _a;
                let r3;
                let n2 = e5.options;
                n2 && n2.dependency && (n2.connect = n2.dependency);
                let a2 = ((_a = e5.options) == null ? void 0 : _a.connect) && l(e5.options.connect);
                e5.visible && false !== e5.isInside && a2 && a2.forEach(function(n3) {
                  (r3 = i3.get("string" == typeof n3 ? n3 : n3.to)) instanceof s && r3.series.visible && r3.visible && false !== r3.isInside && o2.connections.push(new t2(e5, r3, "string" == typeof n3 ? {} : n3));
                });
              });
            });
            for (let t3 = 0, e4, i4, s2 = r2.length, n2 = o2.connections.length; t3 < s2; ++t3) {
              i4 = false;
              let s3 = r2[t3];
              for (e4 = 0; e4 < n2; ++e4) {
                let t4 = o2.connections[e4];
                if ((s3.options && s3.options.type) === (t4.options && t4.options.type) && s3.fromPoint === t4.fromPoint && s3.toPoint === t4.toPoint) {
                  t4.graphics = s3.graphics, i4 = true;
                  break;
                }
              }
              i4 || s3.destroy();
            }
            delete this.chartObstacles, delete this.lineObstacles, o2.renderConnections(e3);
          }
          renderConnections(t3) {
            t3 ? this.chart.series.forEach(function(t4) {
              let e3 = function() {
                let e4 = t4.chart.pathfinder;
                (e4 && e4.connections || []).forEach(function(e5) {
                  e5.fromPoint && e5.fromPoint.series === t4 && e5.render();
                }), t4.pathfinderRemoveRenderEvent && (t4.pathfinderRemoveRenderEvent(), delete t4.pathfinderRemoveRenderEvent);
              };
              false === t4.options.animation ? e3() : t4.pathfinderRemoveRenderEvent = r(t4, "afterAnimate", e3);
            }) : this.connections.forEach(function(t4) {
              t4.render();
            });
          }
          getChartObstacles(t3) {
            let e3 = this.chart.series, i3 = a(t3.algorithmMargin, 0), s2 = [], o2;
            for (let t4 = 0, o3 = e3.length; t4 < o3; ++t4) if (e3[t4].visible && !e3[t4].options.isInternal) for (let o4 = 0, r2 = e3[t4].points.length, n2, a2; o4 < r2; ++o4) (a2 = e3[t4].points[o4]).visible && (n2 = function(t5) {
              let e4 = t5.shapeArgs;
              if (e4) return { xMin: e4.x || 0, xMax: (e4.x || 0) + (e4.width || 0), yMin: e4.y || 0, yMax: (e4.y || 0) + (e4.height || 0) };
              let i4 = t5.graphic && t5.graphic.getBBox();
              return i4 ? { xMin: t5.plotX - i4.width / 2, xMax: t5.plotX + i4.width / 2, yMin: t5.plotY - i4.height / 2, yMax: t5.plotY + i4.height / 2 } : null;
            }(a2)) && s2.push({ xMin: n2.xMin - i3, xMax: n2.xMax + i3, yMin: n2.yMin - i3, yMax: n2.yMax + i3 });
            return s2 = s2.sort(function(t4, e4) {
              return t4.xMin - e4.xMin;
            }), n(t3.algorithmMargin) || (o2 = t3.algorithmMargin = function(t4) {
              let e4;
              let i4 = t4.length, s3 = [];
              for (let o3 = 0; o3 < i4; ++o3) for (let r2 = o3 + 1; r2 < i4; ++r2) (e4 = function t5(e5, i5, s4) {
                let o4 = a(s4, 10), r3 = e5.yMax + o4 > i5.yMin - o4 && e5.yMin - o4 < i5.yMax + o4, n2 = e5.xMax + o4 > i5.xMin - o4 && e5.xMin - o4 < i5.xMax + o4, l2 = r3 ? e5.xMin > i5.xMax ? e5.xMin - i5.xMax : i5.xMin - e5.xMax : 1 / 0, h2 = n2 ? e5.yMin > i5.yMax ? e5.yMin - i5.yMax : i5.yMin - e5.yMax : 1 / 0;
                return n2 && r3 ? o4 ? t5(e5, i5, Math.floor(o4 / 2)) : 1 / 0 : d(l2, h2);
              }(t4[o3], t4[r2])) < 80 && s3.push(e4);
              return s3.push(80), h(Math.floor(s3.sort(function(t5, e5) {
                return t5 - e5;
              })[Math.floor(s3.length / 10)] / 2 - 1), 1);
            }(s2), s2.forEach(function(t4) {
              t4.xMin -= o2, t4.xMax += o2, t4.yMin -= o2, t4.yMax += o2;
            })), s2;
          }
          getObstacleMetrics(t3) {
            let e3 = 0, i3 = 0, s2, o2, r2 = t3.length;
            for (; r2--; ) s2 = t3[r2].xMax - t3[r2].xMin, o2 = t3[r2].yMax - t3[r2].yMin, e3 < s2 && (e3 = s2), i3 < o2 && (i3 = o2);
            return { maxHeight: i3, maxWidth: e3 };
          }
          getAlgorithmStartDirection(t3) {
            let e3 = "left" !== t3.align && "right" !== t3.align, i3 = "top" !== t3.verticalAlign && "bottom" !== t3.verticalAlign;
            return e3 ? !!i3 && void 0 : !!i3 || void 0;
          }
        }
        return c.prototype.algorithms = e2, c;
      }), i(e, "masters/modules/pathfinder.src.js", [e["Core/Globals.js"], e["Gantt/Pathfinder.js"], e["Extensions/ArrowSymbols.js"]], function(t2, e2, i2) {
        return t2.Pathfinder = t2.Pathfinder || e2, i2.compose(t2.SVGRenderer), t2.Pathfinder.compose(t2.Chart, t2.Point), t2;
      }), i(e, "Extensions/StaticScale.js", [e["Core/Utilities.js"]], function(t2) {
        let { addEvent: e2, defined: i2, isNumber: s, pick: o } = t2;
        function r() {
          let t3 = this.chart.options.chart;
          !this.horiz && s(this.options.staticScale) && (!t3.height || t3.scrollablePlotArea && t3.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);
        }
        function n() {
          if ("adjustHeight" !== this.redrawTrigger) {
            for (let t3 of this.axes || []) {
              let e3 = t3.chart, s2 = !!e3.initiatedScale && e3.options.animation, r2 = t3.options.staticScale;
              if (t3.staticScale && i2(t3.min)) {
                let i3 = o(t3.brokenAxis && t3.brokenAxis.unitLength, t3.max + t3.tickInterval - t3.min) * r2, n2 = (i3 = Math.max(i3, r2)) - e3.plotHeight;
                !e3.scrollablePixelsY && Math.abs(n2) >= 1 && (e3.plotHeight = i3, e3.redrawTrigger = "adjustHeight", e3.setSize(void 0, e3.chartHeight + n2, s2)), t3.series.forEach(function(t4) {
                  let i4 = t4.sharedClipKey && e3.sharedClips[t4.sharedClipKey];
                  i4 && i4.attr(e3.inverted ? { width: e3.plotHeight } : { height: e3.plotHeight });
                });
              }
            }
            this.initiatedScale = true;
          }
          this.redrawTrigger = null;
        }
        return { compose: function(t3, i3) {
          let s2 = i3.prototype;
          s2.adjustHeight || (e2(t3, "afterSetOptions", r), s2.adjustHeight = n, e2(i3, "render", s2.adjustHeight));
        } };
      }), i(e, "masters/modules/static-scale.src.js", [e["Core/Globals.js"], e["Extensions/StaticScale.js"]], function(t2, e2) {
        return e2.compose(t2.Axis, t2.Chart), t2;
      }), i(e, "Series/XRange/XRangeSeriesDefaults.js", [e["Core/Utilities.js"]], function(t2) {
        let { correctFloat: e2, isNumber: i2, isObject: s } = t2;
        return { colorByPoint: true, dataLabels: { formatter: function() {
          let t3 = this.point.partialFill;
          if (s(t3) && (t3 = t3.amount), i2(t3) && t3 > 0) return e2(100 * t3) + "%";
        }, inside: true, verticalAlign: "middle", style: { whiteSpace: "nowrap" } }, tooltip: { headerFormat: '<span style="font-size: 0.8em">{point.x} - {point.x2}</span><br/>', pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.yCategory}</b><br/>' }, borderRadius: 3, pointRange: 0 };
      }), i(e, "Series/XRange/XRangePoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { column: { prototype: { pointClass: i2 } } } = t2.seriesTypes, { extend: s } = e2;
        class o extends i2 {
          static getColorByCategory(t3, e3) {
            let i3 = t3.options.colors || t3.chart.options.colors, s2 = i3 ? i3.length : t3.chart.options.chart.colorCount, o2 = e3.y % s2, r = i3 && i3[o2];
            return { colorIndex: o2, color: r };
          }
          resolveColor() {
            let t3 = this.series;
            if (t3.options.colorByPoint && !this.options.color) {
              let e3 = o.getColorByCategory(t3, this);
              t3.chart.styledMode || (this.color = e3.color), this.options.colorIndex || (this.colorIndex = e3.colorIndex);
            } else this.color = this.options.color || t3.color;
          }
          constructor(t3, e3) {
            super(t3, e3), this.y || (this.y = 0);
          }
          setState() {
            super.setState.apply(this, arguments), this.series.drawPoint(this, this.series.getAnimationVerb());
          }
          getLabelConfig() {
            let t3 = super.getLabelConfig.call(this), e3 = this.series.yAxis.categories;
            return t3.x2 = this.x2, t3.yCategory = this.yCategory = e3 && e3[this.y], t3.key = this.category || this.name, t3;
          }
          isValid() {
            return "number" == typeof this.x && "number" == typeof this.x2;
          }
        }
        return s(o.prototype, { ttBelow: false, tooltipDateKeys: ["x", "x2"] }), o;
      }), i(e, "Series/XRange/XRangeSeries.js", [e["Core/Globals.js"], e["Core/Color/Color.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"], e["Series/XRange/XRangeSeriesDefaults.js"], e["Series/XRange/XRangePoint.js"]], function(t2, e2, i2, s, o, r) {
        let { composed: n, noop: a } = t2, { parse: l } = e2, { column: h } = i2.seriesTypes, { addEvent: d, clamp: c, crisp: p, defined: u, extend: g, find: x, isNumber: f, isObject: m, merge: b, pick: y, pushUnique: v, relativeLength: M } = s;
        function k() {
          let t3, e3;
          if (this.isXAxis) {
            for (let i3 of (t3 = y(this.dataMax, -Number.MAX_VALUE), this.series)) if (i3.x2Data) for (let s2 of i3.x2Data) s2 && s2 > t3 && (t3 = s2, e3 = true);
            e3 && (this.dataMax = t3);
          }
        }
        class A extends h {
          static compose(t3) {
            v(n, "Series.XRange") && d(t3, "afterGetSeriesExtremes", k);
          }
          init() {
            super.init.apply(this, arguments), this.options.stacking = void 0;
          }
          getColumnMetrics() {
            let t3 = () => {
              for (let t4 of this.chart.series) {
                let e4 = t4.xAxis;
                t4.xAxis = t4.yAxis, t4.yAxis = e4;
              }
            };
            t3();
            let e3 = super.getColumnMetrics();
            return t3(), e3;
          }
          cropData(t3, e3, i3, s2) {
            let o2 = super.cropData(this.x2Data, e3, i3, s2);
            return o2.xData = t3.slice(o2.start, o2.end), o2;
          }
          findPointIndex(t3) {
            let e3;
            let { cropStart: i3, points: s2 } = this, { id: o2 } = t3;
            if (o2) {
              let t4 = x(s2, (t5) => t5.id === o2);
              e3 = t4 ? t4.index : void 0;
            }
            if (void 0 === e3) {
              let i4 = x(s2, (e4) => e4.x === t3.x && e4.x2 === t3.x2 && !e4.touched);
              e3 = i4 ? i4.index : void 0;
            }
            return this.cropped && f(e3) && f(i3) && e3 >= i3 && (e3 -= i3), e3;
          }
          alignDataLabel(t3) {
            var _a;
            let e3 = t3.plotX;
            t3.plotX = y(t3.dlBox && t3.dlBox.centerX, t3.plotX), t3.dataLabel && ((_a = t3.shapeArgs) == null ? void 0 : _a.width) && t3.dataLabel.css({ width: `${t3.shapeArgs.width}px` }), super.alignDataLabel.apply(this, arguments), t3.plotX = e3;
          }
          translatePoint(t3) {
            let e3 = this.xAxis, i3 = this.yAxis, s2 = this.columnMetrics, o2 = this.options, r2 = o2.minPointLength || 0, n2 = (t3.shapeArgs && t3.shapeArgs.width || 0) / 2, a2 = this.pointXOffset = s2.offset, l2 = y(t3.x2, t3.x + (t3.len || 0)), h2 = o2.borderRadius, d2 = this.chart.plotTop, g2 = this.chart.plotLeft, x2 = t3.plotX, v2 = e3.translate(l2, 0, 0, 0, 1), k2 = Math.abs(v2 - x2), A2 = this.chart.inverted, S = y(o2.borderWidth, 1), C, w, P = s2.offset, O = Math.round(s2.width), B, E, T, D;
            r2 && ((C = r2 - k2) < 0 && (C = 0), x2 -= C / 2, v2 += C / 2), x2 = Math.max(x2, -10), v2 = c(v2, -10, e3.len + 10), u(t3.options.pointWidth) && (P -= (Math.ceil(t3.options.pointWidth) - O) / 2, O = Math.ceil(t3.options.pointWidth)), o2.pointPlacement && f(t3.plotY) && i3.categories && (t3.plotY = i3.translate(t3.y, 0, 1, 0, 1, o2.pointPlacement));
            let G = p(Math.min(x2, v2), S), R = p(Math.max(x2, v2), S) - G, I = Math.min(M("object" == typeof h2 ? h2.radius : h2 || 0, O), Math.min(R, O) / 2), j = { x: G, y: p((t3.plotY || 0) + P, S), width: R, height: O, r: I };
            t3.shapeArgs = j, A2 ? t3.tooltipPos[1] += a2 + n2 : t3.tooltipPos[0] -= n2 + a2 - j.width / 2, E = (B = j.x) + j.width, B < 0 || E > e3.len ? (B = c(B, 0, e3.len), T = (E = c(E, 0, e3.len)) - B, t3.dlBox = b(j, { x: B, width: E - B, centerX: T ? T / 2 : null })) : t3.dlBox = null;
            let L = t3.tooltipPos, z = A2 ? 1 : 0, N = A2 ? 0 : 1, U = this.columnMetrics ? this.columnMetrics.offset : -s2.width / 2;
            A2 ? L[z] += j.width / 2 : L[z] = c(L[z] + (e3.reversed ? -1 : 0) * j.width, e3.left - g2, e3.left + e3.len - g2 - 1), L[N] = c(L[N] + (A2 ? -1 : 1) * U, i3.top - d2, i3.top + i3.len - d2 - 1), (w = t3.partialFill) && (m(w) && (w = w.amount), f(w) || (w = 0), t3.partShapeArgs = b(j), D = Math.max(Math.round(k2 * w + t3.plotX - x2), 0), t3.clipRectArgs = { x: e3.reversed ? j.x + k2 - D : j.x, y: j.y, width: D, height: j.height });
          }
          translate() {
            for (let t3 of (super.translate.apply(this, arguments), this.points)) this.translatePoint(t3);
          }
          drawPoint(t3, e3) {
            let i3 = this.options, s2 = this.chart.renderer, o2 = t3.shapeType, r2 = t3.shapeArgs, n2 = t3.partShapeArgs, a2 = t3.clipRectArgs, h2 = t3.state, d2 = i3.states[h2 || "normal"] || {}, c2 = void 0 === h2 ? "attr" : e3, p2 = this.pointAttribs(t3, h2), u2 = y(this.chart.options.chart.animation, d2.animation), g2 = t3.graphic, x2 = t3.partialFill;
            if (t3.isNull || false === t3.visible) g2 && (t3.graphic = g2.destroy());
            else if (g2 ? g2.rect[e3](r2) : (t3.graphic = g2 = s2.g("point").addClass(t3.getClassName()).add(t3.group || this.group), g2.rect = s2[o2](b(r2)).addClass(t3.getClassName()).addClass("highcharts-partfill-original").add(g2)), n2 && (g2.partRect ? (g2.partRect[e3](b(n2)), g2.partialClipRect[e3](b(a2))) : (g2.partialClipRect = s2.clipRect(a2.x, a2.y, a2.width, a2.height), g2.partRect = s2[o2](n2).addClass("highcharts-partfill-overlay").add(g2).clip(g2.partialClipRect))), !this.chart.styledMode && (g2.rect[e3](p2, u2).shadow(i3.shadow), n2)) {
              m(x2) || (x2 = {}), m(i3.partialFill) && (x2 = b(i3.partialFill, x2));
              let e4 = x2.fill || l(p2.fill).brighten(-0.3).get() || l(t3.color || this.color).brighten(-0.3).get();
              p2.fill = e4, g2.partRect[c2](p2, u2).shadow(i3.shadow);
            }
          }
          drawPoints() {
            let t3 = this.getAnimationVerb();
            for (let e3 of this.points) this.drawPoint(e3, t3);
          }
          getAnimationVerb() {
            return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
          }
          isPointInside(t3) {
            let e3 = t3.shapeArgs, i3 = t3.plotX, s2 = t3.plotY;
            return e3 ? void 0 !== i3 && void 0 !== s2 && s2 >= 0 && s2 <= this.yAxis.len && (e3.x || 0) + (e3.width || 0) >= 0 && i3 <= this.xAxis.len : super.isPointInside.apply(this, arguments);
          }
        }
        return A.defaultOptions = b(h.defaultOptions, o), g(A.prototype, { pointClass: r, pointArrayMap: ["x2", "y"], getExtremesFromAll: true, parallelArrays: ["x", "x2", "y"], requireSorting: false, type: "xrange", animate: i2.series.prototype.animate, autoIncrement: a, buildKDTree: a }), i2.registerSeriesType("xrange", A), A;
      }), i(e, "masters/modules/xrange.src.js", [e["Core/Globals.js"], e["Series/XRange/XRangeSeries.js"]], function(t2, e2) {
        return e2.compose(t2.Axis), t2;
      }), i(e, "Series/Gantt/GanttPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { xrange: { prototype: { pointClass: i2 } } } = t2.seriesTypes, { pick: s } = e2;
        class o extends i2 {
          static setGanttPointAliases(t3) {
            function e3(e4, i3) {
              void 0 !== i3 && (t3[e4] = i3);
            }
            e3("x", s(t3.start, t3.x)), e3("x2", s(t3.end, t3.x2)), e3("partialFill", s(t3.completed, t3.partialFill));
          }
          applyOptions(t3, e3) {
            let i3 = super.applyOptions(t3, e3);
            return o.setGanttPointAliases(i3), i3;
          }
          isValid() {
            return ("number" == typeof this.start || "number" == typeof this.x) && ("number" == typeof this.end || "number" == typeof this.x2 || this.milestone);
          }
        }
        return o;
      }), i(e, "Series/Gantt/GanttSeriesDefaults.js", [e["Core/Utilities.js"]], function(t2) {
        let { isNumber: e2 } = t2;
        return { grouping: false, dataLabels: { enabled: true }, tooltip: { headerFormat: '<span style="font-size: 0.8em">{series.name}</span><br/>', pointFormat: null, pointFormatter: function() {
          let t3 = this.series, i2 = t3.xAxis, s = t3.tooltipOptions.dateTimeLabelFormats, o = i2.options.startOfWeek, r = t3.tooltipOptions, n = this.options.milestone, a = r.xDateFormat, l = "<b>" + (this.name || this.yCategory) + "</b>";
          if (r.pointFormat) return this.tooltipFormatter(r.pointFormat);
          !a && e2(this.start) && (a = t3.chart.time.getDateFormat(i2.closestPointRange, this.start, o, s || {}));
          let h = t3.chart.time.dateFormat(a, this.start), d = t3.chart.time.dateFormat(a, this.end);
          return l += "<br/>", n ? l += h + "<br/>" : l += "Start: " + h + "<br/>End: " + d + "<br/>", l;
        } }, connectors: { type: "simpleConnect", animation: { reversed: true }, radius: 0, startMarker: { enabled: true, symbol: "arrow-filled", radius: 4, fill: "#fa0", align: "left" }, endMarker: { enabled: false, align: "right" } } };
      }), i(e, "Core/Axis/BrokenAxis.js", [e["Core/Axis/Stacking/StackItem.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var i2;
        let { addEvent: s, find: o, fireEvent: r, isArray: n, isNumber: a, pick: l } = e2;
        return function(e3) {
          function i3() {
            void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, false);
          }
          function h() {
            var _a;
            ((_a = this.brokenAxis) == null ? void 0 : _a.hasBreaks) && (this.options.ordinal = false);
          }
          function d() {
            let t3 = this.brokenAxis;
            if (t3 == null ? void 0 : t3.hasBreaks) {
              let e4 = this.tickPositions, i4 = this.tickPositions.info, s2 = [];
              for (let i5 = 0; i5 < e4.length; i5++) t3.isInAnyBreak(e4[i5]) || s2.push(e4[i5]);
              this.tickPositions = s2, this.tickPositions.info = i4;
            }
          }
          function c() {
            this.brokenAxis || (this.brokenAxis = new f(this));
          }
          function p() {
            var _a, _b;
            let { isDirty: t3, options: { connectNulls: e4 }, points: i4, xAxis: s2, yAxis: o2 } = this;
            if (t3) {
              let t4 = i4.length;
              for (; t4--; ) {
                let r2 = i4[t4], n2 = !(null === r2.y && false === e4) && (((_a = s2 == null ? void 0 : s2.brokenAxis) == null ? void 0 : _a.isInAnyBreak(r2.x, true)) || ((_b = o2 == null ? void 0 : o2.brokenAxis) == null ? void 0 : _b.isInAnyBreak(r2.y, true)));
                r2.visible = !n2 && false !== r2.options.visible;
              }
            }
          }
          function u() {
            this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, l(this.pointArrayMap, ["y"]));
          }
          function g(t3, e4) {
            var _a;
            let i4, s2, o2;
            let n2 = this, h2 = n2.points;
            if ((_a = t3 == null ? void 0 : t3.brokenAxis) == null ? void 0 : _a.hasBreaks) {
              let d2 = t3.brokenAxis;
              e4.forEach(function(e5) {
                var _a2, _b;
                i4 = (d2 == null ? void 0 : d2.breakArray) || [], s2 = t3.isXAxis ? t3.min : l(n2.options.threshold, t3.min);
                let c2 = (_b = (_a2 = t3 == null ? void 0 : t3.options) == null ? void 0 : _a2.breaks) == null ? void 0 : _b.filter(function(t4) {
                  let e6 = true;
                  for (let s3 = 0; s3 < i4.length; s3++) {
                    let o3 = i4[s3];
                    if (o3.from === t4.from && o3.to === t4.to) {
                      e6 = false;
                      break;
                    }
                  }
                  return e6;
                });
                h2.forEach(function(n3) {
                  o2 = l(n3["stack" + e5.toUpperCase()], n3[e5]), i4.forEach(function(e6) {
                    if (a(s2) && a(o2)) {
                      let i5 = "";
                      s2 < e6.from && o2 > e6.to || s2 > e6.from && o2 < e6.from ? i5 = "pointBreak" : (s2 < e6.from && o2 > e6.from && o2 < e6.to || s2 > e6.from && o2 > e6.to && o2 < e6.from) && (i5 = "pointInBreak"), i5 && r(t3, i5, { point: n3, brk: e6 });
                    }
                  }), c2 == null ? void 0 : c2.forEach(function(e6) {
                    r(t3, "pointOutsideOfBreak", { point: n3, brk: e6 });
                  });
                });
              });
            }
          }
          function x() {
            let e4 = this.currentDataGrouping, i4 = e4 == null ? void 0 : e4.gapSize, s2 = this.points.slice(), o2 = this.yAxis, r2 = this.options.gapSize, n2 = s2.length - 1;
            if (r2 && n2 > 0) {
              let e5, a2;
              for ("value" !== this.options.gapUnit && (r2 *= this.basePointRange), i4 && i4 > r2 && i4 >= this.basePointRange && (r2 = i4); n2--; ) if (a2 && false !== a2.visible || (a2 = s2[n2 + 1]), e5 = s2[n2], false !== a2.visible && false !== e5.visible) {
                if (a2.x - e5.x > r2) {
                  let i5 = (e5.x + a2.x) / 2;
                  s2.splice(n2 + 1, 0, { isNull: true, x: i5 }), o2.stacking && this.options.stacking && ((o2.stacking.stacks[this.stackKey][i5] = new t2(o2, o2.options.stackLabels, false, i5, this.stack)).total = 0);
                }
                a2 = e5;
              }
            }
            return this.getGraphPath(s2);
          }
          e3.compose = function(t3, e4) {
            if (!t3.keepProps.includes("brokenAxis")) {
              t3.keepProps.push("brokenAxis"), s(t3, "init", c), s(t3, "afterInit", i3), s(t3, "afterSetTickPositions", d), s(t3, "afterSetOptions", h);
              let o2 = e4.prototype;
              o2.drawBreaks = g, o2.gappedPath = x, s(e4, "afterGeneratePoints", p), s(e4, "afterRender", u);
            }
            return t3;
          };
          class f {
            static isInBreak(t3, e4) {
              let i4 = t3.repeat || 1 / 0, s2 = t3.from, o2 = t3.to - t3.from, r2 = e4 >= s2 ? (e4 - s2) % i4 : i4 - (s2 - e4) % i4;
              return t3.inclusive ? r2 <= o2 : r2 < o2 && 0 !== r2;
            }
            static lin2Val(t3) {
              let e4 = this.brokenAxis, i4 = e4 && e4.breakArray;
              if (!i4 || !a(t3)) return t3;
              let s2 = t3, o2, r2;
              for (r2 = 0; r2 < i4.length && !((o2 = i4[r2]).from >= s2); r2++) o2.to < s2 ? s2 += o2.len : f.isInBreak(o2, s2) && (s2 += o2.len);
              return s2;
            }
            static val2Lin(t3) {
              let e4 = this.brokenAxis, i4 = e4 && e4.breakArray;
              if (!i4 || !a(t3)) return t3;
              let s2 = t3, o2, r2;
              for (r2 = 0; r2 < i4.length; r2++) if ((o2 = i4[r2]).to <= t3) s2 -= o2.len;
              else if (o2.from >= t3) break;
              else if (f.isInBreak(o2, t3)) {
                s2 -= t3 - o2.from;
                break;
              }
              return s2;
            }
            constructor(t3) {
              this.hasBreaks = false, this.axis = t3;
            }
            findBreakAt(t3, e4) {
              return o(e4, function(e5) {
                return e5.from < t3 && t3 < e5.to;
              });
            }
            isInAnyBreak(t3, e4) {
              let i4 = this.axis, s2 = i4.options.breaks || [], o2 = s2.length, r2, n2, h2;
              if (o2 && a(t3)) {
                for (; o2--; ) f.isInBreak(s2[o2], t3) && (r2 = true, n2 || (n2 = l(s2[o2].showPoints, !i4.isXAxis)));
                h2 = r2 && e4 ? r2 && !n2 : r2;
              }
              return h2;
            }
            setBreaks(t3, e4) {
              let i4 = this, s2 = i4.axis, o2 = n(t3) && !!t3.length && !!Object.keys(t3[0]).length;
              s2.isDirty = i4.hasBreaks !== o2, i4.hasBreaks = o2, t3 !== s2.options.breaks && (s2.options.breaks = s2.userOptions.breaks = t3), s2.forceRedraw = true, s2.series.forEach(function(t4) {
                t4.isDirty = true;
              }), o2 || s2.val2lin !== f.val2Lin || (delete s2.val2lin, delete s2.lin2val), o2 && (s2.userOptions.ordinal = false, s2.lin2val = f.lin2Val, s2.val2lin = f.val2Lin, s2.setExtremes = function(t4, e5, o3, r2, n2) {
                if (i4.hasBreaks) {
                  let s3;
                  let o4 = this.options.breaks || [];
                  for (; s3 = i4.findBreakAt(t4, o4); ) t4 = s3.to;
                  for (; s3 = i4.findBreakAt(e5, o4); ) e5 = s3.from;
                  e5 < t4 && (e5 = t4);
                }
                s2.constructor.prototype.setExtremes.call(this, t4, e5, o3, r2, n2);
              }, s2.setAxisTranslation = function() {
                if (s2.constructor.prototype.setAxisTranslation.call(this), i4.unitLength = void 0, i4.hasBreaks) {
                  let t4 = s2.options.breaks || [], e5 = [], o3 = [], n2 = l(s2.pointRangePadding, 0), h2 = 0, d2, c2, p2 = s2.userMin || s2.min, u2 = s2.userMax || s2.max, g2, x2;
                  t4.forEach(function(t5) {
                    c2 = t5.repeat || 1 / 0, a(p2) && a(u2) && (f.isInBreak(t5, p2) && (p2 += t5.to % c2 - p2 % c2), f.isInBreak(t5, u2) && (u2 -= u2 % c2 - t5.from % c2));
                  }), t4.forEach(function(t5) {
                    if (g2 = t5.from, c2 = t5.repeat || 1 / 0, a(p2) && a(u2)) {
                      for (; g2 - c2 > p2; ) g2 -= c2;
                      for (; g2 < p2; ) g2 += c2;
                      for (x2 = g2; x2 < u2; x2 += c2) e5.push({ value: x2, move: "in" }), e5.push({ value: x2 + t5.to - t5.from, move: "out", size: t5.breakSize });
                    }
                  }), e5.sort(function(t5, e6) {
                    return t5.value === e6.value ? ("in" === t5.move ? 0 : 1) - ("in" === e6.move ? 0 : 1) : t5.value - e6.value;
                  }), d2 = 0, g2 = p2, e5.forEach(function(t5) {
                    1 === (d2 += "in" === t5.move ? 1 : -1) && "in" === t5.move && (g2 = t5.value), 0 === d2 && a(g2) && (o3.push({ from: g2, to: t5.value, len: t5.value - g2 - (t5.size || 0) }), h2 += t5.value - g2 - (t5.size || 0));
                  }), i4.breakArray = o3, a(p2) && a(u2) && a(s2.min) && (i4.unitLength = u2 - p2 - h2 + n2, r(s2, "afterBreaks"), s2.staticScale ? s2.transA = s2.staticScale : i4.unitLength && (s2.transA *= (u2 - s2.min + n2) / i4.unitLength), n2 && (s2.minPixelPadding = s2.transA * (s2.minPointOffset || 0)), s2.min = p2, s2.max = u2);
                }
              }), l(e4, true) && s2.chart.redraw();
            }
          }
          e3.Additions = f;
        }(i2 || (i2 = {})), i2;
      }), i(e, "Core/Axis/GridAxis.js", [e["Core/Axis/Axis.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        var s, o;
        let { dateFormats: r } = e2, { addEvent: n, defined: a, erase: l, find: h, isArray: d, isNumber: c, merge: p, pick: u, timeUnits: g, wrap: x } = i2;
        function f(t3) {
          return i2.isObject(t3, true);
        }
        function m(t3, e3) {
          let i3 = { width: 0, height: 0 };
          if (e3.forEach(function(e4) {
            let s2 = t3[e4], o2 = 0, r2 = 0, n2;
            f(s2) && (o2 = (n2 = f(s2.label) ? s2.label : {}).getBBox ? n2.getBBox().height : 0, n2.textStr && !c(n2.textPxLength) && (n2.textPxLength = n2.getBBox().width), r2 = c(n2.textPxLength) ? Math.round(n2.textPxLength) : 0, n2.textStr && (r2 = Math.round(n2.getBBox().width)), i3.height = Math.max(o2, i3.height), i3.width = Math.max(r2, i3.width));
          }), "treegrid" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode) {
            let t4 = this.treeGrid.mapOfPosToGridNode[-1].height || 0;
            i3.width += this.options.labels.indentation * (t4 - 1);
          }
          return i3;
        }
        function b(t3) {
          let { grid: e3 } = this, i3 = 3 === this.side;
          if (i3 || t3.apply(this), !(e3 == null ? void 0 : e3.isColumn)) {
            let t4 = (e3 == null ? void 0 : e3.columns) || [];
            i3 && (t4 = t4.slice().reverse()), t4.forEach((t5) => {
              t5.getOffset();
            });
          }
          i3 && t3.apply(this);
        }
        function y(t3) {
          if (true === (this.options.grid || {}).enabled) {
            let { axisTitle: e3, height: i3, horiz: o2, left: r2, offset: n2, opposite: a2, options: l2, top: h2, width: d2 } = this, c2 = this.tickSize(), p2 = e3 && e3.getBBox().width, g2 = l2.title.x, x2 = l2.title.y, f2 = u(l2.title.margin, o2 ? 5 : 10), m2 = e3 ? this.chart.renderer.fontMetrics(e3).f : 0, b2 = (o2 ? h2 + i3 : r2) + (o2 ? 1 : -1) * (a2 ? -1 : 1) * (c2 ? c2[0] / 2 : 0) + (this.side === s.bottom ? m2 : 0);
            t3.titlePosition.x = o2 ? r2 - (p2 || 0) / 2 - f2 + g2 : b2 + (a2 ? d2 : 0) + n2 + g2, t3.titlePosition.y = o2 ? b2 - (a2 ? i3 : 0) + (a2 ? m2 : -m2) / 2 + n2 + x2 : h2 - f2 + x2;
          }
        }
        function v() {
          let { chart: e3, options: { grid: i3 = {} }, userOptions: s2 } = this;
          if (i3.enabled && function(t3) {
            let e4 = t3.options;
            e4.labels.align = u(e4.labels.align, "center"), t3.categories || (e4.showLastLabel = false), t3.labelRotation = 0, e4.labels.rotation = 0, e4.minTickInterval = 1;
          }(this), i3.columns) {
            let o2 = this.grid.columns = [], r2 = this.grid.columnIndex = 0;
            for (; ++r2 < i3.columns.length; ) {
              let n2 = p(s2, i3.columns[r2], { isInternal: true, linkedTo: 0, scrollbar: { enabled: false } }, { grid: { columns: void 0 } }), a2 = new t2(this.chart, n2, "yAxis");
              a2.grid.isColumn = true, a2.grid.columnIndex = r2, l(e3.axes, a2), l(e3[this.coll] || [], a2), o2.push(a2);
            }
          }
        }
        function M() {
          let { axisTitle: t3, grid: e3, options: i3 } = this;
          if (true === (i3.grid || {}).enabled) {
            let o2 = this.min || 0, r2 = this.max || 0, n2 = this.ticks[this.tickPositions[0]];
            if (t3 && !this.chart.styledMode && (n2 == null ? void 0 : n2.slotWidth) && !this.options.title.style.width && t3.css({ width: `${n2.slotWidth}px` }), this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions), this.rightWall && this.rightWall.destroy(), this.grid && this.grid.isOuterAxis() && this.axisLine) {
              let t4 = i3.lineWidth;
              if (t4) {
                let e4 = this.getLinePath(t4), n3 = e4[0], a2 = e4[1], l2 = (this.tickSize("tick") || [1])[0] * (this.side === s.top || this.side === s.left ? -1 : 1);
                if ("M" === n3[0] && "L" === a2[0] && (this.horiz ? (n3[2] += l2, a2[2] += l2) : (n3[1] += l2, a2[1] += l2)), !this.horiz && this.chart.marginRight) {
                  let t5 = ["L", this.left, n3[2] || 0], e5 = [n3, t5], s2 = ["L", this.chart.chartWidth - this.chart.marginRight, this.toPixels(r2 + this.tickmarkOffset)], l3 = [["M", a2[1] || 0, this.toPixels(r2 + this.tickmarkOffset)], s2];
                  this.grid.upperBorder || o2 % 1 == 0 || (this.grid.upperBorder = this.grid.renderBorder(e5)), this.grid.upperBorder && (this.grid.upperBorder.attr({ stroke: i3.lineColor, "stroke-width": i3.lineWidth }), this.grid.upperBorder.animate({ d: e5 })), this.grid.lowerBorder || r2 % 1 == 0 || (this.grid.lowerBorder = this.grid.renderBorder(l3)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({ stroke: i3.lineColor, "stroke-width": i3.lineWidth }), this.grid.lowerBorder.animate({ d: l3 }));
                }
                this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({ stroke: i3.lineColor, "stroke-width": i3.lineWidth }), this.grid.axisLineExtra.animate({ d: e4 })) : this.grid.axisLineExtra = this.grid.renderBorder(e4), this.axisLine[this.showAxis ? "show" : "hide"]();
              }
            }
            if ((e3 && e3.columns || []).forEach((t4) => t4.render()), !this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar) && this.tickPositions.length) {
              let t4, e4;
              let i4 = this.tickmarkOffset, s2 = this.tickPositions[this.tickPositions.length - 1], n3 = this.tickPositions[0];
              for (; (t4 = this.hiddenLabels.pop()) && t4.element; ) t4.show();
              for (; (e4 = this.hiddenMarks.pop()) && e4.element; ) e4.show();
              (t4 = this.ticks[n3].label) && (o2 - n3 > i4 ? this.hiddenLabels.push(t4.hide()) : t4.show()), (t4 = this.ticks[s2].label) && (s2 - r2 > i4 ? this.hiddenLabels.push(t4.hide()) : t4.show());
              let a2 = this.ticks[s2].mark;
              a2 && s2 - r2 < i4 && s2 - r2 > 0 && this.ticks[s2].isLast && this.hiddenMarks.push(a2.hide());
            }
          }
        }
        function k() {
          let t3 = this.tickPositions && this.tickPositions.info, e3 = this.options, i3 = e3.grid || {}, s2 = this.userOptions.labels || {};
          i3.enabled && (this.horiz ? (this.series.forEach((t4) => {
            t4.options.pointRange = 0;
          }), t3 && e3.dateTimeLabelFormats && e3.labels && !a(s2.align) && (false === e3.dateTimeLabelFormats[t3.unitName].range || t3.count > 1) && (e3.labels.align = "left", a(s2.x) || (e3.labels.x = 3))) : "treegrid" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));
        }
        function A(t3) {
          let e3;
          let i3 = this.options, s2 = t3.userOptions, o2 = i3 && f(i3.grid) ? i3.grid : {};
          true === o2.enabled && (e3 = p(true, { className: "highcharts-grid-axis " + (s2.className || ""), dateTimeLabelFormats: { hour: { list: ["%H:%M", "%H"] }, day: { list: ["%A, %e. %B", "%a, %e. %b", "%E"] }, week: { list: ["Week %W", "W%W"] }, month: { list: ["%B", "%b", "%o"] } }, grid: { borderWidth: 1 }, labels: { padding: 2, style: { fontSize: "0.9em" } }, margin: 0, title: { text: null, reserveSpace: false, rotation: 0, style: { textOverflow: "ellipsis" } }, units: [["millisecond", [1, 10, 100]], ["second", [1, 10]], ["minute", [1, 5, 15]], ["hour", [1, 6]], ["day", [1]], ["week", [1]], ["month", [1]], ["year", null]] }, s2), "xAxis" !== this.coll || (a(s2.linkedTo) && !a(s2.tickPixelInterval) && (e3.tickPixelInterval = 350), !(!a(s2.tickPixelInterval) && a(s2.linkedTo)) || a(s2.tickPositioner) || a(s2.tickInterval) || a(s2.units) || (e3.tickPositioner = function(t4, i4) {
            let s3 = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;
            if (s3) {
              let o3 = e3.units || [], r2, n2 = 1, a2 = "year";
              for (let t5 = 0; t5 < o3.length; t5++) {
                let e4 = o3[t5];
                if (e4 && e4[0] === s3.unitName) {
                  r2 = t5;
                  break;
                }
              }
              let l2 = c(r2) && o3[r2 + 1];
              if (l2) {
                a2 = l2[0] || "year";
                let t5 = l2[1];
                n2 = t5 && t5[0] || 1;
              } else "year" === s3.unitName && (n2 = 10 * s3.count);
              let h2 = g[a2];
              return this.tickInterval = h2 * n2, this.chart.time.getTimeTicks({ unitRange: h2, count: n2, unitName: a2 }, t4, i4, this.options.startOfWeek);
            }
          })), p(true, this.options, e3), this.horiz && (i3.minPadding = u(s2.minPadding, 0), i3.maxPadding = u(s2.maxPadding, 0)), c(i3.grid.borderWidth) && (i3.tickWidth = i3.lineWidth = o2.borderWidth));
        }
        function S(t3) {
          let e3 = t3.userOptions, i3 = e3 && e3.grid || {}, s2 = i3.columns;
          i3.enabled && s2 && p(true, this.options, s2[0]);
        }
        function C() {
          (this.grid.columns || []).forEach((t3) => t3.setScale());
        }
        function w(t3) {
          let { horiz: e3, maxLabelDimensions: i3, options: { grid: s2 = {} } } = this;
          if (s2.enabled && i3) {
            let o2 = 2 * this.options.labels.distance, r2 = e3 ? s2.cellHeight || o2 + i3.height : o2 + i3.width;
            d(t3.tickSize) ? t3.tickSize[0] = r2 : t3.tickSize = [r2, 0];
          }
        }
        function P() {
          this.axes.forEach((t3) => {
            (t3.grid && t3.grid.columns || []).forEach((t4) => {
              t4.setAxisSize(), t4.setAxisTranslation();
            });
          });
        }
        function O(t3) {
          let { grid: e3 } = this;
          (e3.columns || []).forEach((e4) => e4.destroy(t3.keepEvents)), e3.columns = void 0;
        }
        function B(t3) {
          let e3 = t3.userOptions || {}, i3 = e3.grid || {};
          i3.enabled && a(i3.borderColor) && (e3.tickColor = e3.lineColor = i3.borderColor), this.grid || (this.grid = new R(this)), this.hiddenLabels = [], this.hiddenMarks = [];
        }
        function E(t3) {
          let e3 = this.label, i3 = this.axis, o2 = i3.reversed, r2 = i3.chart, n2 = i3.options.grid || {}, a2 = i3.options.labels, l2 = a2.align, h2 = s[i3.side], d2 = t3.tickmarkOffset, p2 = i3.tickPositions, u2 = this.pos - d2, g2 = c(p2[t3.index + 1]) ? p2[t3.index + 1] - d2 : (i3.max || 0) + d2, x2 = i3.tickSize("tick"), f2 = x2 ? x2[0] : 0, m2 = x2 ? x2[1] / 2 : 0;
          if (true === n2.enabled) {
            let s2, n3, d3, c2;
            if ("top" === h2 ? n3 = (s2 = i3.top + i3.offset) - f2 : "bottom" === h2 ? s2 = (n3 = r2.chartHeight - i3.bottom + i3.offset) + f2 : (s2 = i3.top + i3.len - (i3.translate(o2 ? g2 : u2) || 0), n3 = i3.top + i3.len - (i3.translate(o2 ? u2 : g2) || 0)), "right" === h2 ? c2 = (d3 = r2.chartWidth - i3.right + i3.offset) + f2 : "left" === h2 ? d3 = (c2 = i3.left + i3.offset) - f2 : (d3 = Math.round(i3.left + (i3.translate(o2 ? g2 : u2) || 0)) - m2, c2 = Math.min(Math.round(i3.left + (i3.translate(o2 ? u2 : g2) || 0)) - m2, i3.left + i3.len)), this.slotWidth = c2 - d3, t3.pos.x = "left" === l2 ? d3 : "right" === l2 ? c2 : d3 + (c2 - d3) / 2, t3.pos.y = n3 + (s2 - n3) / 2, e3) {
              let i4 = r2.renderer.fontMetrics(e3), s3 = e3.getBBox().height;
              if (a2.useHTML) t3.pos.y += i4.b + -(s3 / 2);
              else {
                let e4 = Math.round(s3 / i4.h);
                t3.pos.y += (i4.b - (i4.h - i4.f)) / 2 + -((e4 - 1) * i4.h / 2);
              }
            }
            t3.pos.x += i3.horiz && a2.x || 0;
          }
        }
        function T(t3) {
          let { axis: i3, value: s2 } = t3;
          if (i3.options.grid && i3.options.grid.enabled) {
            let o2;
            let r2 = i3.tickPositions, n2 = (i3.linkedParent || i3).series[0], a2 = s2 === r2[0], l2 = s2 === r2[r2.length - 1], d2 = n2 && h(n2.options.data, function(t4) {
              return t4[i3.isXAxis ? "x" : "y"] === s2;
            });
            d2 && n2.is("gantt") && (o2 = p(d2), e2.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(o2)), t3.isFirst = a2, t3.isLast = l2, t3.point = o2;
          }
        }
        function D() {
          let t3 = this.options, e3 = t3.grid || {}, i3 = this.categories, s2 = this.tickPositions, o2 = s2[0], r2 = s2[1], n2 = s2[s2.length - 1], a2 = s2[s2.length - 2], l2 = this.linkedParent && this.linkedParent.min, h2 = this.linkedParent && this.linkedParent.max, d2 = l2 || this.min, p2 = h2 || this.max, u2 = this.tickInterval, g2 = c(d2) && d2 >= o2 + u2 && d2 < r2, x2 = c(d2) && o2 < d2 && o2 + u2 > d2, f2 = c(p2) && n2 > p2 && n2 - u2 < p2, m2 = c(p2) && p2 <= n2 - u2 && p2 > a2;
          true === e3.enabled && !i3 && (this.isXAxis || this.isLinked) && ((x2 || g2) && !t3.startOnTick && (s2[0] = d2), (f2 || m2) && !t3.endOnTick && (s2[s2.length - 1] = p2));
        }
        function G(t3) {
          var e3;
          let { options: { grid: i3 = {} } } = this;
          return true === i3.enabled && this.categories ? this.tickInterval : t3.apply(this, (e3 = arguments, Array.prototype.slice.call(e3, 1)));
        }
        (o = s || (s = {}))[o.top = 0] = "top", o[o.right = 1] = "right", o[o.bottom = 2] = "bottom", o[o.left = 3] = "left";
        class R {
          constructor(t3) {
            this.axis = t3;
          }
          isOuterAxis() {
            var _a;
            let t3 = this.axis, e3 = t3.chart, i3 = t3.grid.columnIndex, s2 = ((_a = t3.linkedParent) == null ? void 0 : _a.grid.columns) || t3.grid.columns || [], o2 = i3 ? t3.linkedParent : t3, r2 = -1, n2 = 0;
            return 3 === t3.side && !e3.inverted && s2.length ? !t3.linkedParent : ((e3[t3.coll] || []).forEach((e4, i4) => {
              e4.side !== t3.side || e4.options.isInternal || (n2 = i4, e4 !== o2 || (r2 = i4));
            }), n2 === r2 && (!c(i3) || s2.length === i3));
          }
          renderBorder(t3) {
            let e3 = this.axis, i3 = e3.chart.renderer, s2 = e3.options, o2 = i3.path(t3).addClass("highcharts-axis-line").add(e3.axisGroup);
            return i3.styledMode || o2.attr({ stroke: s2.lineColor, "stroke-width": s2.lineWidth, zIndex: 7 }), o2;
          }
        }
        return r.E = function(t3) {
          return this.dateFormat("%a", t3, true).charAt(0);
        }, r.W = function(t3) {
          let e3 = this, i3 = new this.Date(t3);
          ["Hours", "Milliseconds", "Minutes", "Seconds"].forEach(function(t4) {
            e3.set(t4, i3, 0);
          });
          let s2 = (this.get("Day", i3) + 6) % 7, o2 = new this.Date(i3.valueOf());
          this.set("Date", o2, this.get("Date", i3) - s2 + 3);
          let r2 = new this.Date(this.get("FullYear", o2), 0, 1);
          return 4 !== this.get("Day", r2) && (this.set("Month", i3, 0), this.set("Date", i3, 1 + (11 - this.get("Day", r2)) % 7)), (1 + Math.floor((o2.valueOf() - r2.valueOf()) / 6048e5)).toString();
        }, { compose: function(t3, e3, i3) {
          return t3.keepProps.includes("grid") || (t3.keepProps.push("grid"), t3.prototype.getMaxLabelDimensions = m, x(t3.prototype, "unsquish", G), x(t3.prototype, "getOffset", b), n(t3, "init", B), n(t3, "afterGetTitlePosition", y), n(t3, "afterInit", v), n(t3, "afterRender", M), n(t3, "afterSetAxisTranslation", k), n(t3, "afterSetOptions", A), n(t3, "afterSetOptions", S), n(t3, "afterSetScale", C), n(t3, "afterTickSize", w), n(t3, "trimTicks", D), n(t3, "destroy", O), n(e3, "afterSetChartSize", P), n(i3, "afterGetLabelPosition", E), n(i3, "labelFormat", T)), t3;
        } };
      }), i(e, "Gantt/Tree.js", [e["Core/Utilities.js"]], function(t2) {
        let { extend: e2, isNumber: i2, pick: s } = t2;
        function o(t3, r, n, a, l, h) {
          let d = h && h.after, c = h && h.before, p = { data: a, depth: n - 1, id: t3, level: n, parent: r || "" }, u = 0, g = 0, x, f;
          "function" == typeof c && c(p, h);
          let m = (l[t3] || []).map((e3) => {
            let s2 = o(e3.id, t3, n + 1, e3, l, h), r2 = e3.start || NaN, a2 = true === e3.milestone ? r2 : e3.end || NaN;
            return x = !i2(x) || r2 < x ? r2 : x, f = !i2(f) || a2 > f ? a2 : f, u = u + 1 + s2.descendants, g = Math.max(s2.height + 1, g), s2;
          });
          return a && (a.start = s(a.start, x), a.end = s(a.end, f)), e2(p, { children: m, descendants: u, height: g }), "function" == typeof d && d(p, h), p;
        }
        return { getNode: o, getTree: function(t3, e3) {
          return o("", null, 1, null, function(t4) {
            let e4 = [], i3 = t4.reduce((t5, i4) => {
              let { parent: s2 = "", id: o2 } = i4;
              return void 0 === t5[s2] && (t5[s2] = []), t5[s2].push(i4), o2 && e4.push(o2), t5;
            }, {});
            return Object.keys(i3).forEach((t5) => {
              if ("" !== t5 && -1 === e4.indexOf(t5)) {
                let e5 = i3[t5].map(function(t6) {
                  let { ...e6 } = t6;
                  return e6;
                });
                i3[""].push(...e5), delete i3[t5];
              }
            }), i3;
          }(t3), e3);
        } };
      }), i(e, "Core/Axis/TreeGrid/TreeGridTick.js", [e["Core/Utilities.js"]], function(t2) {
        let { addEvent: e2, removeEvent: i2, isObject: s, isNumber: o, pick: r, wrap: n } = t2;
        function a() {
          this.treeGrid || (this.treeGrid = new d(this));
        }
        function l(t3, e3, i3, n2, a2, l2, h2, d2, c) {
          let p, u, g;
          let x = r(this.options && this.options.labels, l2), f = this.pos, m = this.axis, b = "treegrid" === m.options.type, y = t3.apply(this, [e3, i3, n2, a2, x, h2, d2, c]);
          if (b) {
            let { width: t4 = 0, padding: e4 = m.linkedParent ? 0 : 5 } = x && s(x.symbol, true) ? x.symbol : {}, i4 = x && o(x.indentation) ? x.indentation : 0;
            g = (u = (p = m.treeGrid.mapOfPosToGridNode) && p[f]) && u.depth || 1, y.x += t4 + 2 * e4 + (g - 1) * i4;
          }
          return y;
        }
        function h(t3) {
          let n2, a2, l2;
          let { pos: h2, axis: d2, label: c, treeGrid: p, options: u } = this, g = p == null ? void 0 : p.labelIcon, x = c == null ? void 0 : c.element, { treeGrid: f, options: m, chart: b, tickPositions: y } = d2, v = f.mapOfPosToGridNode, M = r(u == null ? void 0 : u.labels, m == null ? void 0 : m.labels), k = M && s(M.symbol, true) ? M.symbol : {}, A = v && v[h2], { descendants: S, depth: C } = A || {}, w = A && S && S > 0, P = "treegrid" === m.type && x, O = y.indexOf(h2) > -1, B = "highcharts-treegrid-node-", E = B + "level-", T = b.styledMode;
          P && A && c.removeClass(RegExp(E + ".*")).addClass(E + C), t3.apply(this, Array.prototype.slice.call(arguments, 1)), P && w ? (n2 = f.isCollapsed(A), function(t4, e3) {
            let i3 = t4.treeGrid, s2 = !i3.labelIcon, n3 = e3.renderer, a3 = e3.xy, l3 = e3.options, h3 = l3.width || 0, d3 = l3.height || 0, c2 = l3.padding ?? t4.axis.linkedParent ? 0 : 5, p2 = { x: a3.x - h3 / 2 - c2, y: a3.y - d3 / 2 }, u2 = e3.collapsed ? 90 : 180, g2 = e3.show && o(p2.y), x2 = i3.labelIcon;
            x2 || (i3.labelIcon = x2 = n3.path(n3.symbols[l3.type](l3.x || 0, l3.y || 0, h3, d3)).addClass("highcharts-label-icon").add(e3.group)), x2[g2 ? "show" : "hide"](), n3.styledMode || x2.attr({ cursor: "pointer", fill: r(e3.color, "#666666"), "stroke-width": 1, stroke: l3.lineColor, strokeWidth: l3.lineWidth || 0 }), x2[s2 ? "attr" : "animate"]({ translateX: p2.x, translateY: p2.y, rotation: u2 });
          }(this, { color: !T && c.styles.color || "", collapsed: n2, group: c.parentGroup, options: k, renderer: c.renderer, show: O, xy: c.xy }), a2 = B + (n2 ? "collapsed" : "expanded"), l2 = B + (n2 ? "expanded" : "collapsed"), c.addClass(a2).removeClass(l2), T || c.css({ cursor: "pointer" }), [c, g].forEach((t4) => {
            t4 && !t4.attachedTreeGridEvents && (e2(t4.element, "mouseover", function() {
              c.addClass("highcharts-treegrid-node-active"), c.renderer.styledMode || c.css({ textDecoration: "underline" });
            }), e2(t4.element, "mouseout", function() {
              !function(t5, e3) {
                let i3 = s(e3.style) ? e3.style : {};
                t5.removeClass("highcharts-treegrid-node-active"), t5.renderer.styledMode || t5.css({ textDecoration: i3.textDecoration || "none" });
              }(c, M);
            }), e2(t4.element, "click", function() {
              p.toggleCollapse();
            }), t4.attachedTreeGridEvents = true);
          })) : g && (i2(x), c == null ? void 0 : c.css({ cursor: "default" }), g.destroy());
        }
        class d {
          static compose(t3) {
            let i3 = t3.prototype;
            i3.toggleCollapse || (e2(t3, "init", a), n(i3, "getLabelPosition", l), n(i3, "renderLabel", h), i3.collapse = function(t4) {
              this.treeGrid.collapse(t4);
            }, i3.expand = function(t4) {
              this.treeGrid.expand(t4);
            }, i3.toggleCollapse = function(t4) {
              this.treeGrid.toggleCollapse(t4);
            });
          }
          constructor(t3) {
            this.tick = t3;
          }
          collapse(t3) {
            let e3 = this.tick, i3 = e3.axis, s2 = i3.brokenAxis;
            if (s2 && i3.treeGrid.mapOfPosToGridNode) {
              let o2 = e3.pos, n2 = i3.treeGrid.mapOfPosToGridNode[o2], a2 = i3.treeGrid.collapse(n2);
              s2.setBreaks(a2, r(t3, true));
            }
          }
          destroy() {
            this.labelIcon && this.labelIcon.destroy();
          }
          expand(t3) {
            let { pos: e3, axis: i3 } = this.tick, { treeGrid: s2, brokenAxis: o2 } = i3, n2 = s2.mapOfPosToGridNode;
            if (o2 && n2) {
              let i4 = n2[e3], a2 = s2.expand(i4);
              o2.setBreaks(a2, r(t3, true));
            }
          }
          toggleCollapse(t3) {
            let e3 = this.tick, i3 = e3.axis, s2 = i3.brokenAxis;
            if (s2 && i3.treeGrid.mapOfPosToGridNode) {
              let o2 = e3.pos, n2 = i3.treeGrid.mapOfPosToGridNode[o2], a2 = i3.treeGrid.toggleCollapse(n2);
              s2.setBreaks(a2, r(t3, true));
            }
          }
        }
        return d;
      }), i(e, "Series/TreeUtilities.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { extend: i2, isArray: s, isNumber: o, isObject: r, merge: n, pick: a, relativeLength: l } = e2;
        return { getColor: function(e3, i3) {
          let s2, o2, r2, n2, l2, h;
          let d = i3.index, c = i3.mapOptionsToLevel, p = i3.parentColor, u = i3.parentColorIndex, g = i3.series, x = i3.colors, f = i3.siblings, m = g.points, b = g.chart.options.chart;
          return e3 && (s2 = m[e3.i], o2 = c[e3.level] || {}, s2 && o2.colorByPoint && (n2 = s2.index % (x ? x.length : b.colorCount), r2 = x && x[n2]), g.chart.styledMode || (l2 = a(s2 && s2.options.color, o2 && o2.color, r2, p && ((e4) => {
            let i4 = o2 && o2.colorVariation;
            return i4 && "brightness" === i4.key && d && f ? t2.parse(e4).brighten(i4.to * (d / f)).get() : e4;
          })(p), g.color)), h = a(s2 && s2.options.colorIndex, o2 && o2.colorIndex, n2, u, i3.colorIndex)), { color: l2, colorIndex: h };
        }, getLevelOptions: function(t3) {
          let e3, i3, l2, h, d, c;
          let p = {};
          if (r(t3)) for (h = o(t3.from) ? t3.from : 1, c = t3.levels, i3 = {}, e3 = r(t3.defaults) ? t3.defaults : {}, s(c) && (i3 = c.reduce((t4, i4) => {
            let s2, l3, d2;
            return r(i4) && o(i4.level) && (l3 = a((d2 = n({}, i4)).levelIsConstant, e3.levelIsConstant), delete d2.levelIsConstant, delete d2.level, r(t4[s2 = i4.level + (l3 ? 0 : h - 1)]) ? n(true, t4[s2], d2) : t4[s2] = d2), t4;
          }, {})), d = o(t3.to) ? t3.to : 1, l2 = 0; l2 <= d; l2++) p[l2] = n({}, e3, r(i3[l2]) ? i3[l2] : {});
          return p;
        }, getNodeWidth: function(t3, e3) {
          let { chart: i3, options: s2 } = t3, { nodeDistance: o2 = 0, nodeWidth: r2 = 0 } = s2, { plotSizeX: n2 = 1 } = i3;
          if ("auto" === r2) {
            if ("string" == typeof o2 && /%$/.test(o2)) return n2 / (e3 + parseFloat(o2) / 100 * (e3 - 1));
            let t4 = Number(o2);
            return (n2 + t4) / (e3 || 1) - t4;
          }
          return l(r2, n2);
        }, setTreeValues: function t3(e3, s2) {
          let o2 = s2.before, r2 = s2.idRoot, n2 = s2.mapIdToNode[r2], l2 = false !== s2.levelIsConstant, h = s2.points[e3.i], d = h && h.options || {}, c = [], p = 0;
          e3.levelDynamic = e3.level - (l2 ? 0 : n2.level), e3.name = a(h && h.name, ""), e3.visible = r2 === e3.id || true === s2.visible, "function" == typeof o2 && (e3 = o2(e3, s2)), e3.children.forEach((o3, r3) => {
            let n3 = i2({}, s2);
            i2(n3, { index: r3, siblings: e3.children.length, visible: e3.visible }), o3 = t3(o3, n3), c.push(o3), o3.visible && (p += o3.val);
          });
          let u = a(d.value, p);
          return e3.visible = u >= 0 && (p > 0 || e3.visible), e3.children = c, e3.childrenTotal = p, e3.isLeaf = e3.visible && !p, e3.val = u, e3;
        }, updateRootId: function(t3) {
          let e3, i3;
          return r(t3) && (i3 = r(t3.options) ? t3.options : {}, e3 = a(t3.rootNode, i3.rootId, ""), r(t3.userOptions) && (t3.userOptions.rootId = e3), t3.rootNode = e3), e3;
        } };
      }), i(e, "Core/Axis/TreeGrid/TreeGridAxis.js", [e["Core/Axis/BrokenAxis.js"], e["Core/Axis/GridAxis.js"], e["Gantt/Tree.js"], e["Core/Axis/TreeGrid/TreeGridTick.js"], e["Series/TreeUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, o, r) {
        let n;
        let { getLevelOptions: a } = o, { addEvent: l, find: h, fireEvent: d, isArray: c, isObject: p, isString: u, merge: g, pick: x, removeEvent: f, wrap: m } = r;
        function b(t3, e3) {
          let i3 = t3.collapseEnd || 0, s2 = t3.collapseStart || 0;
          return i3 >= e3 && (s2 -= 0.5), { from: s2, to: i3, showPoints: false };
        }
        function y(t3, e3, s2) {
          let o2 = [], r2 = [], n2 = {}, a2 = "boolean" == typeof e3 && e3, l2 = {}, d2 = -1, c2 = i2.getTree(t3, { after: function(t4) {
            let e4 = l2[t4.pos], i3 = 0, s3 = 0;
            e4.children.forEach(function(t5) {
              s3 += (t5.descendants || 0) + 1, i3 = Math.max((t5.height || 0) + 1, i3);
            }), e4.descendants = s3, e4.height = i3, e4.collapsed && r2.push(e4);
          }, before: function(t4) {
            let e4, i3;
            let s3 = p(t4.data, true) ? t4.data : {}, r3 = u(s3.name) ? s3.name : "", c3 = n2[t4.parent], g2 = p(c3, true) ? l2[c3.pos] : null;
            a2 && p(g2, true) && (e4 = h(g2.children, function(t5) {
              return t5.name === r3;
            })) ? (i3 = e4.pos, e4.nodes.push(t4)) : i3 = d2++, !l2[i3] && (l2[i3] = e4 = { depth: g2 ? g2.depth + 1 : 0, name: r3, id: s3.id, nodes: [t4], children: [], pos: i3 }, -1 !== i3 && o2.push(r3), p(g2, true) && g2.children.push(e4)), u(t4.id) && (n2[t4.id] = t4), e4 && true === s3.collapsed && (e4.collapsed = true), t4.pos = i3;
          } });
          return { categories: o2, mapOfIdToNode: n2, mapOfPosToGridNode: l2 = function(t4, e4) {
            let i3 = function(t5, s3, o3) {
              let r3 = t5.nodes, n3 = s3 + (-1 === s3 ? 0 : e4 - 1), a3 = (n3 - s3) / 2, l3 = s3 + a3;
              return r3.forEach(function(t6) {
                let e5 = t6.data;
                p(e5, true) && (e5.y = s3 + (e5.seriesIndex || 0), delete e5.seriesIndex), t6.pos = l3;
              }), o3[l3] = t5, t5.pos = l3, t5.tickmarkOffset = a3 + 0.5, t5.collapseStart = n3 + 0.5, t5.children.forEach(function(t6) {
                i3(t6, n3 + 1, o3), n3 = (t6.collapseEnd || 0) - 0.5;
              }), t5.collapseEnd = n3 + 0.5, o3;
            };
            return i3(t4["-1"], -1, {});
          }(l2, s2), collapsedNodes: r2, tree: c2 };
        }
        function v(t3) {
          t3.target.axes.filter(function(t4) {
            return "treegrid" === t4.options.type;
          }).forEach(function(e3) {
            let i3 = e3.options || {}, s2 = i3.labels, o2 = i3.uniqueNames, r2 = i3.max, n2 = !e3.treeGrid.mapOfPosToGridNode || e3.series.some(function(t4) {
              return !t4.hasRendered || t4.isDirtyData || t4.isDirty;
            }), l2 = 0, h2, d2;
            if (n2) {
              if (h2 = e3.series.reduce(function(t4, e4) {
                return e4.visible && ((e4.options.data || []).forEach(function(i4) {
                  e4.options.keys && e4.options.keys.length && (i4 = e4.pointClass.prototype.optionsToObject.call({ series: e4 }, i4), e4.pointClass.setGanttPointAliases(i4)), p(i4, true) && (i4.seriesIndex = l2, t4.push(i4));
                }), true === o2 && l2++), t4;
              }, []), r2 && h2.length < r2) for (let t4 = h2.length; t4 <= r2; t4++) h2.push({ name: t4 + "" });
              d2 = y(h2, o2 || false, true === o2 ? l2 : 1), e3.categories = d2.categories, e3.treeGrid.mapOfPosToGridNode = d2.mapOfPosToGridNode, e3.hasNames = true, e3.treeGrid.tree = d2.tree, e3.series.forEach(function(t4) {
                let e4 = (t4.options.data || []).map(function(e5) {
                  return c(e5) && t4.options.keys && t4.options.keys.length && h2.forEach(function(t5) {
                    e5.indexOf(t5.x) >= 0 && e5.indexOf(t5.x2) >= 0 && (e5 = t5);
                  }), p(e5, true) ? g(e5) : e5;
                });
                t4.visible && t4.setData(e4, false);
              }), e3.treeGrid.mapOptionsToLevel = a({ defaults: s2, from: 1, levels: s2 && s2.levels, to: e3.treeGrid.tree && e3.treeGrid.tree.height }), "beforeRender" === t3.type && (e3.treeGrid.collapsedNodes = d2.collapsedNodes);
            }
          });
        }
        function M(t3, e3) {
          let i3 = this.treeGrid.mapOptionsToLevel || {}, s2 = "treegrid" === this.options.type, o2 = this.ticks, r2 = o2[e3], a2, l2, h2;
          s2 && this.treeGrid.mapOfPosToGridNode ? ((a2 = i3[(h2 = this.treeGrid.mapOfPosToGridNode[e3]).depth]) && (l2 = { labels: a2 }), !r2 && n ? o2[e3] = r2 = new n(this, e3, void 0, void 0, { category: h2.name, tickmarkOffset: h2.tickmarkOffset, options: l2 }) : (r2.parameters.category = h2.name, r2.options = l2, r2.addLabel())) : t3.apply(this, Array.prototype.slice.call(arguments, 1));
        }
        function k(t3, e3, i3, s2) {
          let o2 = this, r2 = "treegrid" === i3.type;
          o2.treeGrid || (o2.treeGrid = new C(o2)), r2 && (l(e3, "beforeRender", v), l(e3, "beforeRedraw", v), l(e3, "addSeries", function(t4) {
            if (t4.options.data) {
              let e4 = y(t4.options.data, i3.uniqueNames || false, 1);
              o2.treeGrid.collapsedNodes = (o2.treeGrid.collapsedNodes || []).concat(e4.collapsedNodes);
            }
          }), l(o2, "foundExtremes", function() {
            o2.treeGrid.collapsedNodes && o2.treeGrid.collapsedNodes.forEach(function(t4) {
              let e4 = o2.treeGrid.collapse(t4);
              o2.brokenAxis && (o2.brokenAxis.setBreaks(e4, false), o2.treeGrid.collapsedNodes && (o2.treeGrid.collapsedNodes = o2.treeGrid.collapsedNodes.filter((e5) => t4.collapseStart !== e5.collapseStart || t4.collapseEnd !== e5.collapseEnd)));
            });
          }), l(o2, "afterBreaks", function() {
            "yAxis" === o2.coll && !o2.staticScale && o2.chart.options.chart.height && (o2.isDirty = true);
          }), i3 = g({ grid: { enabled: true }, labels: { align: "left", levels: [{ level: void 0 }, { level: 1, style: { fontWeight: "bold" } }], symbol: { type: "triangle", x: -5, y: -5, height: 10, width: 10 } }, uniqueNames: false }, i3, { reversed: true })), t3.apply(o2, [e3, i3, s2]), r2 && (o2.hasNames = true, o2.options.showLastLabel = true);
        }
        function A(t3) {
          var _a;
          let e3 = this.options, i3 = "number" == typeof e3.linkedTo ? (_a = this.chart[this.coll]) == null ? void 0 : _a[e3.linkedTo] : void 0;
          if ("treegrid" === e3.type) {
            if (this.min = x(this.userMin, e3.min, this.dataMin), this.max = x(this.userMax, e3.max, this.dataMax), d(this, "foundExtremes"), this.setAxisTranslation(), this.tickInterval = 1, this.tickmarkOffset = 0.5, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : [], i3) {
              let t4 = i3.getExtremes();
              this.min = x(t4.min, t4.dataMin), this.max = x(t4.max, t4.dataMax), this.tickPositions = i3.tickPositions;
            }
            this.linkedParent = i3;
          } else t3.apply(this, Array.prototype.slice.call(arguments, 1));
        }
        function S(t3) {
          let e3 = this;
          "treegrid" === e3.options.type && e3.visible && e3.tickPositions.forEach(function(t4) {
            let i3 = e3.ticks[t4];
            i3.label && i3.label.attachedTreeGridEvents && (f(i3.label.element), i3.label.attachedTreeGridEvents = false);
          }), t3.apply(e3, Array.prototype.slice.call(arguments, 1));
        }
        class C {
          static compose(o2, r2, a2, l2) {
            if (!o2.keepProps.includes("treeGrid")) {
              let t3 = o2.prototype;
              o2.keepProps.push("treeGrid"), m(t3, "generateTick", M), m(t3, "init", k), m(t3, "setTickInterval", A), m(t3, "redraw", S), t3.utils = { getNode: i2.getNode }, n || (n = l2);
            }
            return e2.compose(o2, r2, l2), t2.compose(o2, a2), s.compose(l2), o2;
          }
          constructor(t3) {
            this.axis = t3;
          }
          setCollapsedStatus(t3) {
            let e3 = this.axis, i3 = e3.chart;
            e3.series.forEach(function(e4) {
              let s2 = e4.options.data;
              if (t3.id && s2) {
                let o2 = i3.get(t3.id), r2 = s2[e4.data.indexOf(o2)];
                o2 && r2 && (o2.collapsed = t3.collapsed, r2.collapsed = t3.collapsed);
              }
            });
          }
          collapse(t3) {
            let e3 = this.axis, i3 = e3.options.breaks || [], s2 = b(t3, e3.max);
            return i3.push(s2), t3.collapsed = true, e3.treeGrid.setCollapsedStatus(t3), i3;
          }
          expand(t3) {
            let e3 = this.axis, i3 = e3.options.breaks || [], s2 = b(t3, e3.max);
            return t3.collapsed = false, e3.treeGrid.setCollapsedStatus(t3), i3.reduce(function(t4, e4) {
              return (e4.to !== s2.to || e4.from !== s2.from) && t4.push(e4), t4;
            }, []);
          }
          getTickPositions() {
            let t3 = this.axis, e3 = Math.floor(t3.min / t3.tickInterval) * t3.tickInterval, i3 = Math.ceil(t3.max / t3.tickInterval) * t3.tickInterval;
            return Object.keys(t3.treeGrid.mapOfPosToGridNode || {}).reduce(function(s2, o2) {
              let r2 = +o2;
              return r2 >= e3 && r2 <= i3 && !(t3.brokenAxis && t3.brokenAxis.isInAnyBreak(r2)) && s2.push(r2), s2;
            }, []);
          }
          isCollapsed(t3) {
            let e3 = this.axis, i3 = e3.options.breaks || [], s2 = b(t3, e3.max);
            return i3.some(function(t4) {
              return t4.from === s2.from && t4.to === s2.to;
            });
          }
          toggleCollapse(t3) {
            return this.isCollapsed(t3) ? this.expand(t3) : this.collapse(t3);
          }
        }
        return C;
      }), i(e, "Series/Gantt/GanttSeries.js", [e["Series/Gantt/GanttPoint.js"], e["Series/Gantt/GanttSeriesDefaults.js"], e["Gantt/Pathfinder.js"], e["Core/Series/SeriesRegistry.js"], e["Extensions/StaticScale.js"], e["Core/Axis/TreeGrid/TreeGridAxis.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, o, r, n) {
        let { series: a, seriesTypes: { xrange: l } } = s, { extend: h, isNumber: d, merge: c } = n;
        class p extends l {
          static compose(t3, e3, s2, n2) {
            l.compose(t3), e3 && (o.compose(t3, e3), s2) && (i2.compose(e3, s2.prototype.pointClass), n2 && r.compose(t3, e3, s2, n2));
          }
          drawPoint(t3, e3) {
            let i3 = this.options, s2 = this.chart.renderer, o2 = t3.shapeArgs, r2 = t3.plotY, n2 = t3.selected && "select", a2 = i3.stacking && !i3.borderRadius, l2 = t3.graphic, h2;
            t3.options.milestone ? d(r2) && null !== t3.y && false !== t3.visible ? (h2 = s2.symbols.diamond(o2.x || 0, o2.y || 0, o2.width || 0, o2.height || 0), l2 ? l2[e3]({ d: h2 }) : t3.graphic = l2 = s2.path(h2).addClass(t3.getClassName(), true).add(t3.group || this.group), this.chart.styledMode || t3.graphic.attr(this.pointAttribs(t3, n2)).shadow(i3.shadow, null, a2)) : l2 && (t3.graphic = l2.destroy()) : super.drawPoint(t3, e3);
          }
          translatePoint(t3) {
            let e3, i3;
            super.translatePoint(t3), t3.options.milestone && (i3 = (e3 = t3.shapeArgs).height || 0, t3.shapeArgs = { x: (e3.x || 0) - i3 / 2, y: e3.y, width: i3, height: i3 });
          }
        }
        return p.defaultOptions = c(l.defaultOptions, e2), h(p.prototype, { pointArrayMap: ["start", "end", "y"], pointClass: t2, setData: a.prototype.setData }), s.registerSeriesType("gantt", p), p;
      }), i(e, "masters/modules/gantt.src.js", [e["Core/Globals.js"], e["Extensions/ArrowSymbols.js"], e["Gantt/Connection.js"], e["Extensions/CurrentDateIndication.js"], e["Core/Chart/GanttChart.js"], e["Stock/Navigator/Navigator.js"], e["Stock/RangeSelector/RangeSelector.js"], e["Stock/Scrollbar/Scrollbar.js"], e["Series/Gantt/GanttSeries.js"]], function(t2, e2, i2, s, o, r, n, a, l) {
        return t2.Connection = t2.Connection || i2, t2.GanttChart = t2.GanttChart || o, t2.Navigator = t2.Navigator || r, t2.RangeSelector = t2.RangeSelector || n, t2.Scrollbar = t2.Scrollbar || a, t2.ganttChart = t2.GanttChart.ganttChart, e2.compose(t2.SVGRenderer), s.compose(t2.Axis, t2.PlotLineOrBand), l.compose(t2.Axis, t2.Chart, t2.Series, t2.Tick), t2.Navigator.compose(t2.Chart, t2.Axis, t2.Series), t2.RangeSelector.compose(t2.Axis, t2.Chart), t2.Scrollbar.compose(t2.Axis), t2;
      });
    });
  }
});
export default require_gantt();
//# sourceMappingURL=highcharts_modules_gantt__js.js.map
