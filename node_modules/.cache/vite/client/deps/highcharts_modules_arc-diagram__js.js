import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/arc-diagram.js
var require_arc_diagram = __commonJS({
  "node_modules/highcharts/modules/arc-diagram.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Arc diagram module
    *
    * (c) 2021 Piotr Madej
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("modules/arc-diagram", ["highcharts/modules/sankey"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, s, r) {
        e2.hasOwnProperty(i2) || (e2[i2] = r.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Series/ArcDiagram/ArcDiagramPoint.js", [e["Series/NodesComposition.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { seriesTypes: { sankey: { prototype: { pointClass: s } } } } = e2, { extend: r } = i2;
        class o extends s {
          isValid() {
            return true;
          }
        }
        return r(o.prototype, { setState: t2.setNodeState }), o;
      }), i(e, "Series/ArcDiagram/ArcDiagramSeriesDefaults.js", [], function() {
        return { centeredLinks: false, equalNodes: false, dataLabels: { linkTextPath: { attributes: { startOffset: "25%" } } }, marker: { fillOpacity: 1, lineWidth: 0, states: {}, symbol: "circle" }, offset: "100%", reversed: false };
      }), i(e, "Core/Foundation.js", [e["Core/Utilities.js"]], function(t2) {
        var e2;
        let { addEvent: i2, isFunction: s, objectEach: r, removeEvent: o } = t2;
        return (e2 || (e2 = {})).registerEventOptions = function(t3, e3) {
          t3.eventOptions = t3.eventOptions || {}, r(e3.events, function(e4, r2) {
            t3.eventOptions[r2] !== e4 && (t3.eventOptions[r2] && (o(t3, r2, t3.eventOptions[r2]), delete t3.eventOptions[r2]), s(e4) && (t3.eventOptions[r2] = e4, i2(t3, r2, e4, { order: 0 })));
          });
        }, e2;
      }), i(e, "Core/Legend/LegendSymbol.js", [e["Core/Utilities.js"]], function(t2) {
        var e2;
        let { extend: i2, merge: s, pick: r } = t2;
        return function(t3) {
          function e3(t4, e4, o) {
            var _a;
            let a = this.legendItem = this.legendItem || {}, { chart: n, options: h } = this, { baseline: l = 0, symbolWidth: d, symbolHeight: p } = t4, c = this.symbol || "circle", u = p / 2, g = n.renderer, f = a.group, m = l - Math.round(p * (o ? 0.4 : 0.3)), y = {}, x, b = h.marker, S = 0;
            if (n.styledMode || (y["stroke-width"] = Math.min(h.lineWidth || 0, 24), h.dashStyle ? y.dashstyle = h.dashStyle : "square" === h.linecap || (y["stroke-linecap"] = "round")), a.line = g.path().addClass("highcharts-graph").attr(y).add(f), o && (a.area = g.path().addClass("highcharts-area").add(f)), y["stroke-linecap"] && (S = Math.min(a.line.strokeWidth(), d) / 2), d) {
              let t5 = [["M", S, m], ["L", d - S, m]];
              a.line.attr({ d: t5 }), (_a = a.area) == null ? void 0 : _a.attr({ d: [...t5, ["L", d - S, l], ["L", S, l]] });
            }
            if (b && false !== b.enabled && d) {
              let t5 = Math.min(r(b.radius, u), u);
              0 === c.indexOf("url") && (b = s(b, { width: p, height: p }), t5 = 0), a.symbol = x = g.symbol(c, d / 2 - t5, m - t5, 2 * t5, 2 * t5, i2({ context: "legend" }, b)).addClass("highcharts-point").add(f), x.isMarker = true;
            }
          }
          t3.areaMarker = function(t4, i3) {
            e3.call(this, t4, i3, true);
          }, t3.lineMarker = e3, t3.rectangle = function(t4, e4) {
            let i3 = e4.legendItem || {}, s2 = t4.options, o = t4.symbolHeight, a = s2.squareSymbol, n = a ? o : t4.symbolWidth;
            i3.symbol = this.chart.renderer.rect(a ? (t4.symbolWidth - o) / 2 : 0, t4.baseline - o + 1, n, o, r(t4.options.symbolRadius, o / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(i3.group);
          };
        }(e2 || (e2 = {})), e2;
      }), i(e, "Core/Series/SeriesDefaults.js", [], function() {
        return { lineWidth: 2, allowPointSelect: false, crisp: true, showCheckbox: false, animation: { duration: 1e3 }, enableMouseTracking: true, events: {}, marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, enabled: true, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: true, formatter: function() {
          let { numberFormatter: t2 } = this.series.chart;
          return "number" != typeof this.y ? "" : t2(this.y, -1);
        }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 }, cropThreshold: 300, opacity: 1, pointRange: 0, softThreshold: true, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } }, select: { animation: { duration: 0 } }, inactive: { animation: { duration: 150 }, opacity: 0.2 } }, stickyTracking: true, turboThreshold: 1e3, findNearestPointBy: "x" };
      }), i(e, "Core/Series/Series.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/Point.js"], e["Core/Series/SeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, r, o, a, n, h, l) {
        let { animObject: d, setAnimation: p } = t2, { defaultOptions: c } = e2, { registerEventOptions: u } = i2, { svg: g, win: f } = s, { seriesTypes: m } = n, { arrayMax: y, arrayMin: x, clamp: b, correctFloat: S, crisp: v, defined: C, destroyObjectProperties: k, diffObjects: A, erase: D, error: w, extend: M, find: L, fireEvent: O, getClosestDistance: T, getNestedProperty: P, insertItem: E, isArray: B, isNumber: j, isString: R, merge: I, objectEach: W, pick: G, removeEvent: N, splat: X, syncTimeout: z } = l;
        class V {
          constructor() {
            this.zoneAxis = "y";
          }
          init(t3, e3) {
            let i3;
            O(this, "init", { options: e3 });
            let s2 = this, r2 = t3.series;
            this.eventsToUnbind = [], s2.chart = t3, s2.options = s2.setOptions(e3);
            let o2 = s2.options, a2 = false !== o2.visible;
            s2.linkedSeries = [], s2.bindAxes(), M(s2, { name: o2.name, state: "", visible: a2, selected: true === o2.selected }), u(this, o2);
            let n2 = o2.events;
            (n2 && n2.click || o2.point && o2.point.events && o2.point.events.click || o2.allowPointSelect) && (t3.runTrackerClick = true), s2.getColor(), s2.getSymbol(), s2.parallelArrays.forEach(function(t4) {
              s2[t4 + "Data"] || (s2[t4 + "Data"] = []);
            }), s2.isCartesian && (t3.hasCartesianSeries = true), r2.length && (i3 = r2[r2.length - 1]), s2._i = G(i3 && i3._i, -1) + 1, s2.opacity = s2.options.opacity, t3.orderItems("series", E(this, r2)), o2.dataSorting && o2.dataSorting.enabled ? s2.setDataSortingOptions() : s2.points || s2.data || s2.setData(o2.data, false), O(this, "afterInit");
          }
          is(t3) {
            return m[t3] && this instanceof m[t3];
          }
          bindAxes() {
            let t3;
            let e3 = this, i3 = e3.options, s2 = e3.chart;
            O(this, "bindAxes", null, function() {
              (e3.axisTypes || []).forEach(function(r2) {
                (s2[r2] || []).forEach(function(s3) {
                  t3 = s3.options, (G(i3[r2], 0) === s3.index || void 0 !== i3[r2] && i3[r2] === t3.id) && (E(e3, s3.series), e3[r2] = s3, s3.isDirty = true);
                }), e3[r2] || e3.optionalAxis === r2 || w(18, true, s2);
              });
            }), O(this, "afterBindAxes");
          }
          updateParallelArrays(t3, e3, i3) {
            let s2 = t3.series, r2 = j(e3) ? function(i4) {
              let r3 = "y" === i4 && s2.toYData ? s2.toYData(t3) : t3[i4];
              s2[i4 + "Data"][e3] = r3;
            } : function(t4) {
              Array.prototype[e3].apply(s2[t4 + "Data"], i3);
            };
            s2.parallelArrays.forEach(r2);
          }
          hasData() {
            return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && this.yData.length > 0;
          }
          hasMarkerChanged(t3, e3) {
            let i3 = t3.marker, s2 = e3.marker || {};
            return i3 && (s2.enabled && !i3.enabled || s2.symbol !== i3.symbol || s2.height !== i3.height || s2.width !== i3.width);
          }
          autoIncrement(t3) {
            let e3 = this.options, i3 = e3.pointIntervalUnit, s2 = e3.relativeXValue, r2 = this.chart.time, o2 = this.xIncrement, a2, n2;
            return (o2 = G(o2, e3.pointStart, 0), this.pointInterval = n2 = G(this.pointInterval, e3.pointInterval, 1), s2 && j(t3) && (n2 *= t3), i3 && (a2 = new r2.Date(o2), "day" === i3 ? r2.set("Date", a2, r2.get("Date", a2) + n2) : "month" === i3 ? r2.set("Month", a2, r2.get("Month", a2) + n2) : "year" === i3 && r2.set("FullYear", a2, r2.get("FullYear", a2) + n2), n2 = a2.getTime() - o2), s2 && j(t3)) ? o2 + n2 : (this.xIncrement = o2 + n2, o2);
          }
          setDataSortingOptions() {
            let t3 = this.options;
            M(this, { requireSorting: false, sorted: false, enabledDataSorting: true, allowDG: false }), C(t3.pointRange) || (t3.pointRange = 1);
          }
          setOptions(t3) {
            var _a, _b;
            let e3;
            let i3 = this.chart, s2 = i3.options.plotOptions, r2 = i3.userOptions || {}, o2 = I(t3), a2 = i3.styledMode, n2 = { plotOptions: s2, userOptions: o2 };
            O(this, "setOptions", n2);
            let h2 = n2.plotOptions[this.type], l2 = r2.plotOptions || {}, d2 = l2.series || {}, p2 = c.plotOptions[this.type] || {}, u2 = l2[this.type] || {};
            this.userOptions = n2.userOptions;
            let g2 = I(h2, s2.series, u2, o2);
            this.tooltipOptions = I(c.tooltip, (_a = c.plotOptions.series) == null ? void 0 : _a.tooltip, p2 == null ? void 0 : p2.tooltip, i3.userOptions.tooltip, (_b = l2.series) == null ? void 0 : _b.tooltip, u2.tooltip, o2.tooltip), this.stickyTracking = G(o2.stickyTracking, u2.stickyTracking, d2.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || g2.stickyTracking), null === h2.marker && delete g2.marker, this.zoneAxis = g2.zoneAxis || "y";
            let f2 = this.zones = (g2.zones || []).map((t4) => ({ ...t4 }));
            return (g2.negativeColor || g2.negativeFillColor) && !g2.zones && (e3 = { value: g2[this.zoneAxis + "Threshold"] || g2.threshold || 0, className: "highcharts-negative" }, a2 || (e3.color = g2.negativeColor, e3.fillColor = g2.negativeFillColor), f2.push(e3)), f2.length && C(f2[f2.length - 1].value) && f2.push(a2 ? {} : { color: this.color, fillColor: this.fillColor }), O(this, "afterSetOptions", { options: g2 }), g2;
          }
          getName() {
            return G(this.options.name, "Series " + (this.index + 1));
          }
          getCyclic(t3, e3, i3) {
            let s2, r2;
            let o2 = this.chart, a2 = `${t3}Index`, n2 = `${t3}Counter`, h2 = (i3 == null ? void 0 : i3.length) || o2.options.chart.colorCount;
            !e3 && (C(r2 = G("color" === t3 ? this.options.colorIndex : void 0, this[a2])) ? s2 = r2 : (o2.series.length || (o2[n2] = 0), s2 = o2[n2] % h2, o2[n2] += 1), i3 && (e3 = i3[s2])), void 0 !== s2 && (this[a2] = s2), this[t3] = e3;
          }
          getColor() {
            this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || c.plotOptions[this.type].color, this.chart.options.colors);
          }
          getPointsCollection() {
            return (this.hasGroupedData ? this.points : this.data) || [];
          }
          getSymbol() {
            let t3 = this.options.marker;
            this.getCyclic("symbol", t3.symbol, this.chart.options.symbols);
          }
          findPointIndex(t3, e3) {
            let i3, s2, r2;
            let a2 = t3.id, n2 = t3.x, h2 = this.points, l2 = this.options.dataSorting;
            if (a2) {
              let t4 = this.chart.get(a2);
              t4 instanceof o && (i3 = t4);
            } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
              let e4 = (e5) => !e5.touched && e5.index === t3.index;
              if (l2 && l2.matchByName ? e4 = (e5) => !e5.touched && e5.name === t3.name : this.options.relativeXValue && (e4 = (e5) => !e5.touched && e5.options.x === t3.x), !(i3 = L(h2, e4))) return;
            }
            return i3 && void 0 !== (r2 = i3 && i3.index) && (s2 = true), void 0 === r2 && j(n2) && (r2 = this.xData.indexOf(n2, e3)), -1 !== r2 && void 0 !== r2 && this.cropped && (r2 = r2 >= this.cropStart ? r2 - this.cropStart : r2), !s2 && j(r2) && h2[r2] && h2[r2].touched && (r2 = void 0), r2;
          }
          updateData(t3, e3) {
            let i3 = this.options, s2 = i3.dataSorting, r2 = this.points, o2 = [], a2 = this.requireSorting, n2 = t3.length === r2.length, h2, l2, d2, p2, c2 = true;
            if (this.xIncrement = null, t3.forEach(function(t4, e4) {
              let l3;
              let d3 = C(t4) && this.pointClass.prototype.optionsToObject.call({ series: this }, t4) || {}, c3 = d3.x;
              d3.id || j(c3) ? (-1 === (l3 = this.findPointIndex(d3, p2)) || void 0 === l3 ? o2.push(t4) : r2[l3] && t4 !== i3.data[l3] ? (r2[l3].update(t4, false, null, false), r2[l3].touched = true, a2 && (p2 = l3 + 1)) : r2[l3] && (r2[l3].touched = true), (!n2 || e4 !== l3 || s2 && s2.enabled || this.hasDerivedData) && (h2 = true)) : o2.push(t4);
            }, this), h2) for (l2 = r2.length; l2--; ) (d2 = r2[l2]) && !d2.touched && d2.remove && d2.remove(false, e3);
            else !n2 || s2 && s2.enabled ? c2 = false : (t3.forEach(function(t4, e4) {
              t4 === r2[e4].y || r2[e4].destroyed || r2[e4].update(t4, false, null, false);
            }), o2.length = 0);
            return r2.forEach(function(t4) {
              t4 && (t4.touched = false);
            }), !!c2 && (o2.forEach(function(t4) {
              this.addPoint(t4, false, null, null, false);
            }, this), null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = y(this.xData), this.autoIncrement()), true);
          }
          setData(t3, e3 = true, i3, s2) {
            var _a;
            let r2 = this, o2 = r2.points, a2 = o2 && o2.length || 0, n2 = r2.options, h2 = r2.chart, l2 = n2.dataSorting, d2 = r2.xAxis, p2 = n2.turboThreshold, c2 = this.xData, u2 = this.yData, g2 = r2.pointArrayMap, f2 = g2 && g2.length, m2 = n2.keys, y2, x2, b2, S2 = 0, v2 = 1, C2;
            h2.options.chart.allowMutatingData || (n2.data && delete r2.options.data, r2.userOptions.data && delete r2.userOptions.data, C2 = I(true, t3));
            let k2 = (t3 = C2 || t3 || []).length;
            if (l2 && l2.enabled && (t3 = this.sortData(t3)), h2.options.chart.allowMutatingData && false !== s2 && k2 && a2 && !r2.cropped && !r2.hasGroupedData && r2.visible && !r2.boosted && (b2 = this.updateData(t3, i3)), !b2) {
              r2.xIncrement = null, r2.colorCounter = 0, this.parallelArrays.forEach(function(t4) {
                r2[t4 + "Data"].length = 0;
              });
              let e4 = p2 && k2 > p2;
              if (e4) {
                let i4 = r2.getFirstValidPoint(t3), s3 = r2.getFirstValidPoint(t3, k2 - 1, -1), o3 = (t4) => !!(B(t4) && (m2 || j(t4[0])));
                if (j(i4) && j(s3)) for (y2 = 0; y2 < k2; y2++) c2[y2] = this.autoIncrement(), u2[y2] = t3[y2];
                else if (o3(i4) && o3(s3)) {
                  if (f2) {
                    if (i4.length === f2) for (y2 = 0; y2 < k2; y2++) c2[y2] = this.autoIncrement(), u2[y2] = t3[y2];
                    else for (y2 = 0; y2 < k2; y2++) x2 = t3[y2], c2[y2] = x2[0], u2[y2] = x2.slice(1, f2 + 1);
                  } else if (m2 && (S2 = m2.indexOf("x"), v2 = m2.indexOf("y"), S2 = S2 >= 0 ? S2 : 0, v2 = v2 >= 0 ? v2 : 1), 1 === i4.length && (v2 = 0), S2 === v2) for (y2 = 0; y2 < k2; y2++) c2[y2] = this.autoIncrement(), u2[y2] = t3[y2][v2];
                  else for (y2 = 0; y2 < k2; y2++) x2 = t3[y2], c2[y2] = x2[S2], u2[y2] = x2[v2];
                } else e4 = false;
              }
              if (!e4) for (y2 = 0; y2 < k2; y2++) x2 = { series: r2 }, r2.pointClass.prototype.applyOptions.apply(x2, [t3[y2]]), r2.updateParallelArrays(x2, y2);
              for (u2 && R(u2[0]) && w(14, true, h2), r2.data = [], r2.options.data = r2.userOptions.data = t3, y2 = a2; y2--; ) (_a = o2[y2]) == null ? void 0 : _a.destroy();
              d2 && (d2.minRange = d2.userMinRange), r2.isDirty = h2.isDirtyBox = true, r2.isDirtyData = !!o2, i3 = false;
            }
            "point" === n2.legendType && (this.processData(), this.generatePoints()), e3 && h2.redraw(i3);
          }
          sortData(t3) {
            let e3 = this, i3 = e3.options.dataSorting.sortKey || "y", s2 = function(t4, e4) {
              return C(e4) && t4.pointClass.prototype.optionsToObject.call({ series: t4 }, e4) || {};
            };
            return t3.forEach(function(i4, r2) {
              t3[r2] = s2(e3, i4), t3[r2].index = r2;
            }, this), t3.concat().sort((t4, e4) => {
              let s3 = P(i3, t4), r2 = P(i3, e4);
              return r2 < s3 ? -1 : r2 > s3 ? 1 : 0;
            }).forEach(function(t4, e4) {
              t4.x = e4;
            }, this), e3.linkedSeries && e3.linkedSeries.forEach(function(e4) {
              let i4 = e4.options, r2 = i4.data;
              i4.dataSorting && i4.dataSorting.enabled || !r2 || (r2.forEach(function(i5, o2) {
                r2[o2] = s2(e4, i5), t3[o2] && (r2[o2].x = t3[o2].x, r2[o2].index = o2);
              }), e4.setData(r2, false));
            }), t3;
          }
          getProcessedData(t3) {
            let e3 = this, i3 = e3.xAxis, s2 = e3.options.cropThreshold, r2 = i3 == null ? void 0 : i3.logarithmic, o2 = e3.isCartesian, a2, n2, h2 = 0, l2, d2, p2, c2 = e3.xData, u2 = e3.yData, g2 = false, f2 = c2.length;
            i3 && (d2 = (l2 = i3.getExtremes()).min, p2 = l2.max, g2 = !!(i3.categories && !i3.names.length)), o2 && e3.sorted && !t3 && (!s2 || f2 > s2 || e3.forceCrop) && (c2[f2 - 1] < d2 || c2[0] > p2 ? (c2 = [], u2 = []) : e3.yData && (c2[0] < d2 || c2[f2 - 1] > p2) && (c2 = (a2 = this.cropData(e3.xData, e3.yData, d2, p2)).xData, u2 = a2.yData, h2 = a2.start, n2 = true));
            let m2 = T([r2 ? c2.map(r2.log2lin) : c2], () => e3.requireSorting && !g2 && w(15, false, e3.chart));
            return { xData: c2, yData: u2, cropped: n2, cropStart: h2, closestPointRange: m2 };
          }
          processData(t3) {
            let e3 = this.xAxis;
            if (this.isCartesian && !this.isDirty && !e3.isDirty && !this.yAxis.isDirty && !t3) return false;
            let i3 = this.getProcessedData();
            this.cropped = i3.cropped, this.cropStart = i3.cropStart, this.processedXData = i3.xData, this.processedYData = i3.yData, this.closestPointRange = this.basePointRange = i3.closestPointRange, O(this, "afterProcessData");
          }
          cropData(t3, e3, i3, s2) {
            let r2 = t3.length, o2, a2, n2 = 0, h2 = r2;
            for (o2 = 0; o2 < r2; o2++) if (t3[o2] >= i3) {
              n2 = Math.max(0, o2 - 1);
              break;
            }
            for (a2 = o2; a2 < r2; a2++) if (t3[a2] > s2) {
              h2 = a2 + 1;
              break;
            }
            return { xData: t3.slice(n2, h2), yData: e3.slice(n2, h2), start: n2, end: h2 };
          }
          generatePoints() {
            let t3 = this.options, e3 = this.processedData || t3.data, i3 = this.processedXData, s2 = this.processedYData, r2 = this.pointClass, o2 = i3.length, a2 = this.cropStart || 0, n2 = this.hasGroupedData, h2 = t3.keys, l2 = [], d2 = t3.dataGrouping && t3.dataGrouping.groupAll ? a2 : 0, p2, c2, u2, g2, f2 = this.data;
            if (!f2 && !n2) {
              let t4 = [];
              t4.length = e3.length, f2 = this.data = t4;
            }
            for (h2 && n2 && (this.options.keys = false), g2 = 0; g2 < o2; g2++) c2 = a2 + g2, n2 ? ((u2 = new r2(this, [i3[g2]].concat(X(s2[g2])))).dataGroup = this.groupMap[d2 + g2], u2.dataGroup.options && (u2.options = u2.dataGroup.options, M(u2, u2.dataGroup.options), delete u2.dataLabels)) : (u2 = f2[c2]) || void 0 === e3[c2] || (f2[c2] = u2 = new r2(this, e3[c2], i3[g2])), u2 && (u2.index = n2 ? d2 + g2 : c2, l2[g2] = u2);
            if (this.options.keys = h2, f2 && (o2 !== (p2 = f2.length) || n2)) for (g2 = 0; g2 < p2; g2++) g2 !== a2 || n2 || (g2 += o2), f2[g2] && (f2[g2].destroyElements(), f2[g2].plotX = void 0);
            this.data = f2, this.points = l2, O(this, "afterGeneratePoints");
          }
          getXExtremes(t3) {
            return { min: x(t3), max: y(t3) };
          }
          getExtremes(t3, e3) {
            let i3 = this.xAxis, s2 = this.yAxis, r2 = [], o2 = this.requireSorting && !this.is("column") ? 1 : 0, a2 = !!s2 && s2.positiveValuesOnly, n2 = e3 || this.getExtremesFromAll || this.options.getExtremesFromAll, { processedXData: h2, processedYData: l2 } = this, d2, p2, c2, u2, g2, f2, m2, b2 = 0, S2 = 0, v2 = 0;
            if (this.cropped && n2) {
              let t4 = this.getProcessedData(true);
              h2 = t4.xData, l2 = t4.yData;
            }
            let C2 = (t3 = t3 || this.stackedYData || l2 || []).length, k2 = h2 || this.xData;
            for (i3 && (b2 = (d2 = i3.getExtremes()).min, S2 = d2.max), f2 = 0; f2 < C2; f2++) if (u2 = k2[f2], p2 = (j(g2 = t3[f2]) || B(g2)) && ((j(g2) ? g2 > 0 : g2.length) || !a2), c2 = e3 || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !i3 || (k2[f2 + o2] || u2) >= b2 && (k2[f2 - o2] || u2) <= S2, p2 && c2) {
              if (m2 = g2.length) for (; m2--; ) j(g2[m2]) && (r2[v2++] = g2[m2]);
              else r2[v2++] = g2;
            }
            let A2 = { activeYData: r2, dataMin: x(r2), dataMax: y(r2) };
            return O(this, "afterGetExtremes", { dataExtremes: A2 }), A2;
          }
          applyExtremes() {
            let t3 = this.getExtremes();
            return this.dataMin = t3.dataMin, this.dataMax = t3.dataMax, t3;
          }
          getFirstValidPoint(t3, e3 = 0, i3 = 1) {
            let s2 = t3.length, r2 = e3;
            for (; r2 >= 0 && r2 < s2; ) {
              if (C(t3[r2])) return t3[r2];
              r2 += i3;
            }
          }
          translate() {
            var _a;
            this.processedXData || this.processData(), this.generatePoints();
            let t3 = this.options, e3 = t3.stacking, i3 = this.xAxis, s2 = i3.categories, r2 = this.enabledDataSorting, o2 = this.yAxis, a2 = this.points, n2 = a2.length, h2 = this.pointPlacementToXValue(), l2 = !!h2, d2 = t3.threshold, p2 = t3.startFromThreshold ? d2 : 0, c2, u2, g2, f2, m2 = Number.MAX_VALUE;
            function y2(t4) {
              return b(t4, -1e5, 1e5);
            }
            for (c2 = 0; c2 < n2; c2++) {
              let t4;
              let n3 = a2[c2], x2 = n3.x, b2, v2, k2 = n3.y, A2 = n3.low, D2 = e3 && ((_a = o2.stacking) == null ? void 0 : _a.stacks[(this.negStacks && k2 < (p2 ? 0 : d2) ? "-" : "") + this.stackKey]);
              u2 = i3.translate(x2, false, false, false, true, h2), n3.plotX = j(u2) ? S(y2(u2)) : void 0, e3 && this.visible && D2 && D2[x2] && (f2 = this.getStackIndicator(f2, x2, this.index), !n3.isNull && f2.key && (v2 = (b2 = D2[x2]).points[f2.key]), b2 && B(v2) && (A2 = v2[0], k2 = v2[1], A2 === p2 && f2.key === D2[x2].base && (A2 = G(j(d2) ? d2 : o2.min)), o2.positiveValuesOnly && C(A2) && A2 <= 0 && (A2 = void 0), n3.total = n3.stackTotal = G(b2.total), n3.percentage = C(n3.y) && b2.total ? n3.y / b2.total * 100 : void 0, n3.stackY = k2, this.irregularWidths || b2.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), n3.yBottom = C(A2) ? y2(o2.translate(A2, false, true, false, true)) : void 0, this.dataModify && (k2 = this.dataModify.modifyValue(k2, c2)), j(k2) && void 0 !== n3.plotX && (t4 = j(t4 = o2.translate(k2, false, true, false, true)) ? y2(t4) : void 0), n3.plotY = t4, n3.isInside = this.isPointInside(n3), n3.clientX = l2 ? S(i3.translate(x2, false, false, false, true, h2)) : u2, n3.negative = (n3.y || 0) < (d2 || 0), n3.category = G(s2 && s2[n3.x], n3.x), n3.isNull || false === n3.visible || (void 0 !== g2 && (m2 = Math.min(m2, Math.abs(u2 - g2))), g2 = u2), n3.zone = this.zones.length ? n3.getZone() : void 0, !n3.graphic && this.group && r2 && (n3.isNew = true);
            }
            this.closestPointRangePx = m2, O(this, "afterTranslate");
          }
          getValidPoints(t3, e3, i3) {
            let s2 = this.chart;
            return (t3 || this.points || []).filter(function(t4) {
              let { plotX: r2, plotY: o2 } = t4;
              return !!((i3 || !t4.isNull && j(o2)) && (!e3 || s2.isInsidePlot(r2, o2, { inverted: s2.inverted }))) && false !== t4.visible;
            });
          }
          getClipBox() {
            let { chart: t3, xAxis: e3, yAxis: i3 } = this, { x: s2, y: r2, width: o2, height: a2 } = I(t3.clipBox);
            return e3 && e3.len !== t3.plotSizeX && (o2 = e3.len), i3 && i3.len !== t3.plotSizeY && (a2 = i3.len), t3.inverted && !this.invertible && ([o2, a2] = [a2, o2]), { x: s2, y: r2, width: o2, height: a2 };
          }
          getSharedClipKey() {
            return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
          }
          setClip() {
            let { chart: t3, group: e3, markerGroup: i3 } = this, s2 = t3.sharedClips, r2 = t3.renderer, o2 = this.getClipBox(), a2 = this.getSharedClipKey(), n2 = s2[a2];
            n2 ? n2.animate(o2) : s2[a2] = n2 = r2.clipRect(o2), e3 && e3.clip(false === this.options.clip ? void 0 : n2), i3 && i3.clip();
          }
          animate(t3) {
            let { chart: e3, group: i3, markerGroup: s2 } = this, r2 = e3.inverted, o2 = d(this.options.animation), a2 = [this.getSharedClipKey(), o2.duration, o2.easing, o2.defer].join(","), n2 = e3.sharedClips[a2], h2 = e3.sharedClips[a2 + "m"];
            if (t3 && i3) {
              let t4 = this.getClipBox();
              if (n2) n2.attr("height", t4.height);
              else {
                t4.width = 0, r2 && (t4.x = e3.plotHeight), n2 = e3.renderer.clipRect(t4), e3.sharedClips[a2] = n2;
                let i4 = { x: -99, y: -99, width: r2 ? e3.plotWidth + 199 : 99, height: r2 ? 99 : e3.plotHeight + 199 };
                h2 = e3.renderer.clipRect(i4), e3.sharedClips[a2 + "m"] = h2;
              }
              i3.clip(n2), s2 == null ? void 0 : s2.clip(h2);
            } else if (n2 && !n2.hasClass("highcharts-animating")) {
              let t4 = this.getClipBox(), i4 = o2.step;
              ((s2 == null ? void 0 : s2.element.childNodes.length) || e3.series.length > 1) && (o2.step = function(t5, e4) {
                i4 && i4.apply(e4, arguments), "width" === e4.prop && (h2 == null ? void 0 : h2.element) && h2.attr(r2 ? "height" : "width", t5 + 99);
              }), n2.addClass("highcharts-animating").animate(t4, o2);
            }
          }
          afterAnimate() {
            this.setClip(), W(this.chart.sharedClips, (t3, e3, i3) => {
              t3 && !this.chart.container.querySelector(`[clip-path="url(#${t3.id})"]`) && (t3.destroy(), delete i3[e3]);
            }), this.finishedAnimating = true, O(this, "afterAnimate");
          }
          drawPoints(t3 = this.points) {
            let e3, i3, s2, r2, o2, a2, n2;
            let h2 = this.chart, l2 = h2.styledMode, { colorAxis: d2, options: p2 } = this, c2 = p2.marker, u2 = this[this.specialGroup || "markerGroup"], g2 = this.xAxis, f2 = G(c2.enabled, !g2 || !!g2.isRadial || null, this.closestPointRangePx >= c2.enabledThreshold * c2.radius);
            if (false !== c2.enabled || this._hasPointMarkers) for (e3 = 0; e3 < t3.length; e3++) if (r2 = (s2 = (i3 = t3[e3]).graphic) ? "animate" : "attr", o2 = i3.marker || {}, a2 = !!i3.marker, (f2 && void 0 === o2.enabled || o2.enabled) && !i3.isNull && false !== i3.visible) {
              let t4 = G(o2.symbol, this.symbol, "rect");
              n2 = this.markerAttribs(i3, i3.selected && "select"), this.enabledDataSorting && (i3.startXPos = g2.reversed ? -(n2.width || 0) : g2.width);
              let e4 = false !== i3.isInside;
              if (!s2 && e4 && ((n2.width || 0) > 0 || i3.hasImage) && (i3.graphic = s2 = h2.renderer.symbol(t4, n2.x, n2.y, n2.width, n2.height, a2 ? o2 : c2).add(u2), this.enabledDataSorting && h2.hasRendered && (s2.attr({ x: i3.startXPos }), r2 = "animate")), s2 && "animate" === r2 && s2[e4 ? "show" : "hide"](e4).animate(n2), s2) {
                let t5 = this.pointAttribs(i3, l2 || !i3.selected ? void 0 : "select");
                l2 ? d2 && s2.css({ fill: t5.fill }) : s2[r2](t5);
              }
              s2 && s2.addClass(i3.getClassName(), true);
            } else s2 && (i3.graphic = s2.destroy());
          }
          markerAttribs(t3, e3) {
            let i3 = this.options, s2 = i3.marker, r2 = t3.marker || {}, o2 = r2.symbol || s2.symbol, a2 = {}, n2, h2, l2 = G(r2.radius, s2 && s2.radius);
            e3 && (n2 = s2.states[e3], l2 = G((h2 = r2.states && r2.states[e3]) && h2.radius, n2 && n2.radius, l2 && l2 + (n2 && n2.radiusPlus || 0))), t3.hasImage = o2 && 0 === o2.indexOf("url"), t3.hasImage && (l2 = 0);
            let d2 = t3.pos();
            return j(l2) && d2 && (i3.crisp && (d2[0] = v(d2[0], t3.hasImage ? 0 : "rect" === o2 ? (s2 == null ? void 0 : s2.lineWidth) || 0 : 1)), a2.x = d2[0] - l2, a2.y = d2[1] - l2), l2 && (a2.width = a2.height = 2 * l2), a2;
          }
          pointAttribs(t3, e3) {
            let i3 = this.options.marker, s2 = t3 && t3.options, r2 = s2 && s2.marker || {}, o2 = s2 && s2.color, a2 = t3 && t3.color, n2 = t3 && t3.zone && t3.zone.color, h2, l2, d2 = this.color, p2, c2, u2 = G(r2.lineWidth, i3.lineWidth), g2 = 1;
            return d2 = o2 || n2 || a2 || d2, p2 = r2.fillColor || i3.fillColor || d2, c2 = r2.lineColor || i3.lineColor || d2, e3 = e3 || "normal", h2 = i3.states[e3] || {}, u2 = G((l2 = r2.states && r2.states[e3] || {}).lineWidth, h2.lineWidth, u2 + G(l2.lineWidthPlus, h2.lineWidthPlus, 0)), p2 = l2.fillColor || h2.fillColor || p2, { stroke: c2 = l2.lineColor || h2.lineColor || c2, "stroke-width": u2, fill: p2, opacity: g2 = G(l2.opacity, h2.opacity, g2) };
          }
          destroy(t3) {
            let e3, i3, s2;
            let r2 = this, o2 = r2.chart, a2 = /AppleWebKit\/533/.test(f.navigator.userAgent), n2 = r2.data || [];
            for (O(r2, "destroy", { keepEventsForUpdate: t3 }), this.removeEvents(t3), (r2.axisTypes || []).forEach(function(t4) {
              (s2 = r2[t4]) && s2.series && (D(s2.series, r2), s2.isDirty = s2.forceRedraw = true);
            }), r2.legendItem && r2.chart.legend.destroyItem(r2), e3 = n2.length; e3--; ) (i3 = n2[e3]) && i3.destroy && i3.destroy();
            for (let t4 of r2.zones) k(t4, void 0, true);
            l.clearTimeout(r2.animationTimeout), W(r2, function(t4, e4) {
              t4 instanceof h && !t4.survive && t4[a2 && "group" === e4 ? "hide" : "destroy"]();
            }), o2.hoverSeries === r2 && (o2.hoverSeries = void 0), D(o2.series, r2), o2.orderItems("series"), W(r2, function(e4, i4) {
              t3 && "hcEvents" === i4 || delete r2[i4];
            });
          }
          applyZones() {
            let { area: t3, chart: e3, graph: i3, zones: s2, points: r2, xAxis: o2, yAxis: a2, zoneAxis: n2 } = this, { inverted: h2, renderer: l2 } = e3, d2 = this[`${n2}Axis`], { isXAxis: p2, len: c2 = 0 } = d2 || {}, u2 = ((i3 == null ? void 0 : i3.strokeWidth()) || 0) / 2 + 1, g2 = (t4, e4 = 0, i4 = 0) => {
              h2 && (i4 = c2 - i4);
              let { translated: s3 = 0, lineClip: r3 } = t4, o3 = i4 - s3;
              r3 == null ? void 0 : r3.push(["L", e4, Math.abs(o3) < u2 ? i4 - u2 * (o3 <= 0 ? -1 : 1) : s3]);
            };
            if (s2.length && (i3 || t3) && d2 && j(d2.min)) {
              let e4 = d2.getExtremes().max, u3 = (t4) => {
                t4.forEach((e5, i4) => {
                  ("M" === e5[0] || "L" === e5[0]) && (t4[i4] = [e5[0], p2 ? c2 - e5[1] : e5[1], p2 ? e5[2] : c2 - e5[2]]);
                });
              };
              if (s2.forEach((t4) => {
                t4.lineClip = [], t4.translated = b(d2.toPixels(G(t4.value, e4), true) || 0, 0, c2);
              }), i3 && !this.showLine && i3.hide(), t3 && t3.hide(), "y" === n2 && r2.length < o2.len) for (let t4 of r2) {
                let { plotX: e5, plotY: i4, zone: r3 } = t4, o3 = r3 && s2[s2.indexOf(r3) - 1];
                r3 && g2(r3, e5, i4), o3 && g2(o3, e5, i4);
              }
              let f2 = [], m2 = d2.toPixels(d2.getExtremes().min, true);
              s2.forEach((e5) => {
                var _a, _b;
                let s3 = e5.lineClip || [], r3 = Math.round(e5.translated || 0);
                o2.reversed && s3.reverse();
                let { clip: n3, simpleClip: d3 } = e5, c3 = 0, g3 = 0, y2 = o2.len, x2 = a2.len;
                p2 ? (c3 = r3, y2 = m2) : (g3 = r3, x2 = m2);
                let b2 = [["M", c3, g3], ["L", y2, g3], ["L", y2, x2], ["L", c3, x2], ["Z"]], S2 = [b2[0], ...s3, b2[1], b2[2], ...f2, b2[3], b2[4]];
                f2 = s3.reverse(), m2 = r3, h2 && (u3(S2), t3 && u3(b2)), n3 ? (n3.animate({ d: S2 }), d3 == null ? void 0 : d3.animate({ d: b2 })) : (n3 = e5.clip = l2.path(S2), t3 && (d3 = e5.simpleClip = l2.path(b2))), i3 && ((_a = e5.graph) == null ? void 0 : _a.clip(n3)), t3 && ((_b = e5.area) == null ? void 0 : _b.clip(d3));
              });
            } else this.visible && (i3 && i3.show(), t3 && t3.show());
          }
          plotGroup(t3, e3, i3, s2, r2) {
            let o2 = this[t3], a2 = !o2, n2 = { visibility: i3, zIndex: s2 || 0.1 };
            return C(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (n2.opacity = this.opacity), o2 || (this[t3] = o2 = this.chart.renderer.g().add(r2)), o2.addClass("highcharts-" + e3 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (C(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (o2.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true), o2.attr(n2)[a2 ? "attr" : "animate"](this.getPlotBox(e3)), o2;
          }
          getPlotBox(t3) {
            let e3 = this.xAxis, i3 = this.yAxis, s2 = this.chart, r2 = s2.inverted && !s2.polar && e3 && this.invertible && "series" === t3;
            return s2.inverted && (e3 = i3, i3 = this.xAxis), { translateX: e3 ? e3.left : s2.plotLeft, translateY: i3 ? i3.top : s2.plotTop, rotation: r2 ? 90 : 0, rotationOriginX: r2 ? (e3.len - i3.len) / 2 : 0, rotationOriginY: r2 ? (e3.len + i3.len) / 2 : 0, scaleX: r2 ? -1 : 1, scaleY: 1 };
          }
          removeEvents(t3) {
            let { eventsToUnbind: e3 } = this;
            t3 || N(this), e3.length && (e3.forEach((t4) => {
              t4();
            }), e3.length = 0);
          }
          render() {
            var _a, _b, _c, _d, _e;
            let t3 = this, { chart: e3, options: i3, hasRendered: s2 } = t3, r2 = d(i3.animation), o2 = t3.visible ? "inherit" : "hidden", a2 = i3.zIndex, n2 = e3.seriesGroup, h2 = t3.finishedAnimating ? 0 : r2.duration;
            O(this, "render"), t3.plotGroup("group", "series", o2, a2, n2), t3.markerGroup = t3.plotGroup("markerGroup", "markers", o2, a2, n2), false !== i3.clip && t3.setClip(), h2 && ((_a = t3.animate) == null ? void 0 : _a.call(t3, true)), t3.drawGraph && (t3.drawGraph(), t3.applyZones()), t3.visible && t3.drawPoints(), (_b = t3.drawDataLabels) == null ? void 0 : _b.call(t3), (_c = t3.redrawPoints) == null ? void 0 : _c.call(t3), i3.enableMouseTracking && ((_d = t3.drawTracker) == null ? void 0 : _d.call(t3)), h2 && ((_e = t3.animate) == null ? void 0 : _e.call(t3)), s2 || (h2 && r2.defer && (h2 += r2.defer), t3.animationTimeout = z(() => {
              t3.afterAnimate();
            }, h2 || 0)), t3.isDirty = false, t3.hasRendered = true, O(t3, "afterRender");
          }
          redraw() {
            let t3 = this.isDirty || this.isDirtyData;
            this.translate(), this.render(), t3 && delete this.kdTree;
          }
          reserveSpace() {
            return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
          }
          searchPoint(t3, e3) {
            let { xAxis: i3, yAxis: s2 } = this, r2 = this.chart.inverted;
            return this.searchKDTree({ clientX: r2 ? i3.len - t3.chartY + i3.pos : t3.chartX - i3.pos, plotY: r2 ? s2.len - t3.chartX + s2.pos : t3.chartY - s2.pos }, e3, t3);
          }
          buildKDTree(t3) {
            this.buildingKdTree = true;
            let e3 = this, i3 = e3.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
            delete e3.kdTree, z(function() {
              e3.kdTree = function t4(i4, s2, r2) {
                let o2, a2;
                let n2 = i4 == null ? void 0 : i4.length;
                if (n2) return o2 = e3.kdAxisArray[s2 % r2], i4.sort((t5, e4) => (t5[o2] || 0) - (e4[o2] || 0)), { point: i4[a2 = Math.floor(n2 / 2)], left: t4(i4.slice(0, a2), s2 + 1, r2), right: t4(i4.slice(a2 + 1), s2 + 1, r2) };
              }(e3.getValidPoints(void 0, !e3.directTouch), i3, i3), e3.buildingKdTree = false;
            }, e3.options.kdNow || (t3 == null ? void 0 : t3.type) === "touchstart" ? 0 : 1);
          }
          searchKDTree(t3, e3, i3) {
            let s2 = this, [r2, o2] = this.kdAxisArray, a2 = e3 ? "distX" : "dist", n2 = (s2.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, h2 = !!s2.isBubble;
            if (this.kdTree || this.buildingKdTree || this.buildKDTree(i3), this.kdTree) return function t4(e4, i4, n3, l2) {
              var _a;
              let d2 = i4.point, p2 = s2.kdAxisArray[n3 % l2], c2, u2, g2 = d2;
              !function(t5, e5) {
                var _a2;
                let i5 = t5[r2], s3 = e5[r2], a3 = C(i5) && C(s3) ? i5 - s3 : null, n4 = t5[o2], l3 = e5[o2], d3 = C(n4) && C(l3) ? n4 - l3 : 0, p3 = h2 && ((_a2 = e5.marker) == null ? void 0 : _a2.radius) || 0;
                e5.dist = Math.sqrt((a3 && a3 * a3 || 0) + d3 * d3) - p3, e5.distX = C(a3) ? Math.abs(a3) - p3 : Number.MAX_VALUE;
              }(e4, d2);
              let f2 = (e4[p2] || 0) - (d2[p2] || 0) + (h2 && ((_a = d2.marker) == null ? void 0 : _a.radius) || 0), m2 = f2 < 0 ? "left" : "right", y2 = f2 < 0 ? "right" : "left";
              return i4[m2] && (g2 = (c2 = t4(e4, i4[m2], n3 + 1, l2))[a2] < g2[a2] ? c2 : d2), i4[y2] && Math.sqrt(f2 * f2) < g2[a2] && (g2 = (u2 = t4(e4, i4[y2], n3 + 1, l2))[a2] < g2[a2] ? u2 : g2), g2;
            }(t3, this.kdTree, n2, n2);
          }
          pointPlacementToXValue() {
            let { options: t3, xAxis: e3 } = this, i3 = t3.pointPlacement;
            return "between" === i3 && (i3 = e3.reversed ? -0.5 : 0.5), j(i3) ? i3 * (t3.pointRange || e3.pointRange) : 0;
          }
          isPointInside(t3) {
            let { chart: e3, xAxis: i3, yAxis: s2 } = this, { plotX: r2 = -1, plotY: o2 = -1 } = t3;
            return o2 >= 0 && o2 <= (s2 ? s2.len : e3.plotHeight) && r2 >= 0 && r2 <= (i3 ? i3.len : e3.plotWidth);
          }
          drawTracker() {
            var _a;
            let t3 = this, e3 = t3.options, i3 = e3.trackByArea, s2 = [].concat((i3 ? t3.areaPath : t3.graphPath) || []), r2 = t3.chart, o2 = r2.pointer, a2 = r2.renderer, n2 = ((_a = r2.options.tooltip) == null ? void 0 : _a.snap) || 0, h2 = () => {
              e3.enableMouseTracking && r2.hoverSeries !== t3 && t3.onMouseOver();
            }, l2 = "rgba(192,192,192," + (g ? 1e-4 : 2e-3) + ")", d2 = t3.tracker;
            d2 ? d2.attr({ d: s2 }) : t3.graph && (t3.tracker = d2 = a2.path(s2).attr({ visibility: t3.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(i3 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t3.group), r2.styledMode || d2.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: l2, fill: i3 ? l2 : "none", "stroke-width": t3.graph.strokeWidth() + (i3 ? 0 : 2 * n2) }), [t3.tracker, t3.markerGroup, t3.dataLabelsGroup].forEach((t4) => {
              t4 && (t4.addClass("highcharts-tracker").on("mouseover", h2).on("mouseout", (t5) => {
                o2 == null ? void 0 : o2.onTrackerMouseOut(t5);
              }), e3.cursor && !r2.styledMode && t4.css({ cursor: e3.cursor }), t4.on("touchstart", h2));
            })), O(this, "afterDrawTracker");
          }
          addPoint(t3, e3, i3, s2, r2) {
            let o2, a2;
            let n2 = this.options, h2 = this.data, l2 = this.chart, d2 = this.xAxis, p2 = d2 && d2.hasNames && d2.names, c2 = n2.data, u2 = this.xData;
            e3 = G(e3, true);
            let g2 = { series: this };
            this.pointClass.prototype.applyOptions.apply(g2, [t3]);
            let f2 = g2.x;
            if (a2 = u2.length, this.requireSorting && f2 < u2[a2 - 1]) for (o2 = true; a2 && u2[a2 - 1] > f2; ) a2--;
            this.updateParallelArrays(g2, "splice", [a2, 0, 0]), this.updateParallelArrays(g2, a2), p2 && g2.name && (p2[f2] = g2.name), c2.splice(a2, 0, t3), (o2 || this.processedData) && (this.data.splice(a2, 0, null), this.processData()), "point" === n2.legendType && this.generatePoints(), i3 && (h2[0] && h2[0].remove ? h2[0].remove(false) : (h2.shift(), this.updateParallelArrays(g2, "shift"), c2.shift())), false !== r2 && O(this, "addPoint", { point: g2 }), this.isDirty = true, this.isDirtyData = true, e3 && l2.redraw(s2);
          }
          removePoint(t3, e3, i3) {
            let s2 = this, r2 = s2.data, o2 = r2[t3], a2 = s2.points, n2 = s2.chart, h2 = function() {
              a2 && a2.length === r2.length && a2.splice(t3, 1), r2.splice(t3, 1), s2.options.data.splice(t3, 1), s2.updateParallelArrays(o2 || { series: s2 }, "splice", [t3, 1]), o2 && o2.destroy(), s2.isDirty = true, s2.isDirtyData = true, e3 && n2.redraw();
            };
            p(i3, n2), e3 = G(e3, true), o2 ? o2.firePointEvent("remove", null, h2) : h2();
          }
          remove(t3, e3, i3, s2) {
            let r2 = this, o2 = r2.chart;
            function a2() {
              r2.destroy(s2), o2.isDirtyLegend = o2.isDirtyBox = true, o2.linkSeries(s2), G(t3, true) && o2.redraw(e3);
            }
            false !== i3 ? O(r2, "remove", null, a2) : a2();
          }
          update(t3, e3) {
            var _a, _b, _c;
            O(this, "update", { options: t3 = A(t3, this.userOptions) });
            let i3 = this, s2 = i3.chart, r2 = i3.userOptions, o2 = i3.initialType || i3.type, a2 = s2.options.plotOptions, n2 = m[o2].prototype, h2 = i3.finishedAnimating && { animation: false }, l2 = {}, d2, p2, c2 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], u2 = t3.type || r2.type || s2.options.chart.type, g2 = !(this.hasDerivedData || u2 && u2 !== this.type || void 0 !== t3.pointStart || void 0 !== t3.pointInterval || void 0 !== t3.relativeXValue || t3.joinBy || t3.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some((t4) => i3.hasOptionChanged(t4)));
            u2 = u2 || o2, g2 && (c2.push("data", "isDirtyData", "isDirtyCanvas", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"), false !== t3.visible && c2.push("area", "graph"), i3.parallelArrays.forEach(function(t4) {
              c2.push(t4 + "Data");
            }), t3.data && (t3.dataSorting && M(i3.options.dataSorting, t3.dataSorting), this.setData(t3.data, false))), t3 = I(r2, { index: void 0 === r2.index ? i3.index : r2.index, pointStart: ((_a = a2 == null ? void 0 : a2.series) == null ? void 0 : _a.pointStart) ?? r2.pointStart ?? ((_b = i3.xData) == null ? void 0 : _b[0]) }, !g2 && { data: i3.options.data }, t3, h2), g2 && t3.data && (t3.data = i3.options.data), (c2 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(c2)).forEach(function(t4) {
              c2[t4] = i3[t4], delete i3[t4];
            });
            let f2 = false;
            if (m[u2]) {
              if (f2 = u2 !== i3.type, i3.remove(false, false, false, true), f2) {
                if (s2.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i3, m[u2].prototype);
                else {
                  let t4 = Object.hasOwnProperty.call(i3, "hcEvents") && i3.hcEvents;
                  for (p2 in n2) i3[p2] = void 0;
                  M(i3, m[u2].prototype), t4 ? i3.hcEvents = t4 : delete i3.hcEvents;
                }
              }
            } else w(17, true, s2, { missingModuleFor: u2 });
            if (c2.forEach(function(t4) {
              i3[t4] = c2[t4];
            }), i3.init(s2, t3), g2 && this.points) for (let t4 of (false === (d2 = i3.options).visible ? (l2.graphic = 1, l2.dataLabel = 1) : (this.hasMarkerChanged(d2, r2) && (l2.graphic = 1), ((_c = i3.hasDataLabels) == null ? void 0 : _c.call(i3)) || (l2.dataLabel = 1)), this.points)) t4 && t4.series && (t4.resolveColor(), Object.keys(l2).length && t4.destroyElements(l2), false === d2.showInLegend && t4.legendItem && s2.legend.destroyItem(t4));
            i3.initialType = o2, s2.linkSeries(), s2.setSortedData(), f2 && i3.linkedSeries.length && (i3.isDirtyData = true), O(this, "afterUpdate"), G(e3, true) && s2.redraw(!!g2 && void 0);
          }
          setName(t3) {
            this.name = this.options.name = this.userOptions.name = t3, this.chart.isDirtyLegend = true;
          }
          hasOptionChanged(t3) {
            var _a, _b;
            let e3 = this.chart, i3 = this.options[t3], s2 = e3.options.plotOptions, r2 = this.userOptions[t3], o2 = G((_a = s2 == null ? void 0 : s2[this.type]) == null ? void 0 : _a[t3], (_b = s2 == null ? void 0 : s2.series) == null ? void 0 : _b[t3]);
            return r2 && !C(o2) ? i3 !== r2 : i3 !== G(o2, i3);
          }
          onMouseOver() {
            let t3 = this.chart, e3 = t3.hoverSeries, i3 = t3.pointer;
            i3 == null ? void 0 : i3.setHoverChartIndex(), e3 && e3 !== this && e3.onMouseOut(), this.options.events.mouseOver && O(this, "mouseOver"), this.setState("hover"), t3.hoverSeries = this;
          }
          onMouseOut() {
            let t3 = this.options, e3 = this.chart, i3 = e3.tooltip, s2 = e3.hoverPoint;
            e3.hoverSeries = null, s2 && s2.onMouseOut(), this && t3.events.mouseOut && O(this, "mouseOut"), i3 && !this.stickyTracking && (!i3.shared || this.noSharedTooltip) && i3.hide(), e3.series.forEach(function(t4) {
              t4.setState("", true);
            });
          }
          setState(t3, e3) {
            let i3 = this, s2 = i3.options, r2 = i3.graph, o2 = s2.inactiveOtherPoints, a2 = s2.states, n2 = G(a2[t3 || "normal"] && a2[t3 || "normal"].animation, i3.chart.options.chart.animation), h2 = s2.lineWidth, l2 = s2.opacity;
            if (t3 = t3 || "", i3.state !== t3 && ([i3.group, i3.markerGroup, i3.dataLabelsGroup].forEach(function(e4) {
              e4 && (i3.state && e4.removeClass("highcharts-series-" + i3.state), t3 && e4.addClass("highcharts-series-" + t3));
            }), i3.state = t3, !i3.chart.styledMode)) {
              if (a2[t3] && false === a2[t3].enabled) return;
              if (t3 && (h2 = a2[t3].lineWidth || h2 + (a2[t3].lineWidthPlus || 0), l2 = G(a2[t3].opacity, l2)), r2 && !r2.dashstyle && j(h2)) for (let t4 of [r2, ...this.zones.map((t5) => t5.graph)]) t4 == null ? void 0 : t4.animate({ "stroke-width": h2 }, n2);
              o2 || [i3.group, i3.markerGroup, i3.dataLabelsGroup, i3.labelBySeries].forEach(function(t4) {
                t4 && t4.animate({ opacity: l2 }, n2);
              });
            }
            e3 && o2 && i3.points && i3.setAllPointsToState(t3 || void 0);
          }
          setAllPointsToState(t3) {
            this.points.forEach(function(e3) {
              e3.setState && e3.setState(t3);
            });
          }
          setVisible(t3, e3) {
            var _a;
            let i3 = this, s2 = i3.chart, r2 = s2.options.chart.ignoreHiddenSeries, o2 = i3.visible;
            i3.visible = t3 = i3.options.visible = i3.userOptions.visible = void 0 === t3 ? !o2 : t3;
            let a2 = t3 ? "show" : "hide";
            ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach((t4) => {
              var _a2;
              (_a2 = i3[t4]) == null ? void 0 : _a2[a2]();
            }), (s2.hoverSeries === i3 || ((_a = s2.hoverPoint) == null ? void 0 : _a.series) === i3) && i3.onMouseOut(), i3.legendItem && s2.legend.colorizeItem(i3, t3), i3.isDirty = true, i3.options.stacking && s2.series.forEach((t4) => {
              t4.options.stacking && t4.visible && (t4.isDirty = true);
            }), i3.linkedSeries.forEach((e4) => {
              e4.setVisible(t3, false);
            }), r2 && (s2.isDirtyBox = true), O(i3, a2), false !== e3 && s2.redraw();
          }
          show() {
            this.setVisible(true);
          }
          hide() {
            this.setVisible(false);
          }
          select(t3) {
            this.selected = t3 = this.options.selected = void 0 === t3 ? !this.selected : t3, this.checkbox && (this.checkbox.checked = t3), O(this, t3 ? "select" : "unselect");
          }
          shouldShowTooltip(t3, e3, i3 = {}) {
            return i3.series = this, i3.visiblePlotOnly = true, this.chart.isInsidePlot(t3, e3, i3);
          }
          drawLegendSymbol(t3, e3) {
            var _a;
            (_a = r[this.options.legendSymbol || "rectangle"]) == null ? void 0 : _a.call(this, t3, e3);
          }
        }
        return V.defaultOptions = a, V.types = n.seriesTypes, V.registerType = n.registerSeriesType, M(V.prototype, { axisTypes: ["xAxis", "yAxis"], coll: "series", colorCounter: 0, directTouch: false, invertible: true, isCartesian: true, kdAxisArray: ["clientX", "plotY"], parallelArrays: ["x", "y"], pointClass: o, requireSorting: true, sorted: true }), n.series = V, V;
      }), i(e, "Core/Renderer/RendererRegistry.js", [e["Core/Globals.js"]], function(t2) {
        var e2, i2;
        let s;
        return (i2 = e2 || (e2 = {})).rendererTypes = {}, i2.getRendererType = function(t3 = s) {
          return i2.rendererTypes[t3] || i2.rendererTypes[s];
        }, i2.registerRendererType = function(e3, r, o) {
          i2.rendererTypes[e3] = r, (!s || o) && (s = e3, t2.Renderer = r);
        }, e2;
      }), i(e, "Core/Renderer/SVG/SVGLabel.js", [e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { defined: i2, extend: s, isNumber: r, merge: o, pick: a, removeEvent: n } = e2;
        class h extends t2 {
          constructor(t3, e3, i3, s2, r2, o2, a2, n2, l, d) {
            let p;
            super(t3, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = false, this.textStr = e3, this.x = i3, this.y = s2, this.anchorX = o2, this.anchorY = a2, this.baseline = l, this.className = d, this.addClass("button" === d ? "highcharts-no-tooltip" : "highcharts-label"), d && this.addClass("highcharts-" + d), this.text = t3.text(void 0, 0, 0, n2).attr({ zIndex: 1 }), "string" == typeof r2 && ((p = /^url\((.*?)\)$/.test(r2)) || this.renderer.symbols[r2]) && (this.symbolKey = r2), this.bBox = h.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t3.styledMode || p, this.deferredAttr = {}, this.alignFactor = 0;
          }
          alignSetter(t3) {
            let e3 = { left: 0, center: 0.5, right: 1 }[t3];
            e3 !== this.alignFactor && (this.alignFactor = e3, this.bBox && r(this.xSetting) && this.attr({ x: this.xSetting }));
          }
          anchorXSetter(t3, e3) {
            this.anchorX = t3, this.boxAttr(e3, Math.round(t3) - this.getCrispAdjust() - this.xSetting);
          }
          anchorYSetter(t3, e3) {
            this.anchorY = t3, this.boxAttr(e3, t3 - this.ySetting);
          }
          boxAttr(t3, e3) {
            this.box ? this.box.attr(t3, e3) : this.deferredAttr[t3] = e3;
          }
          css(e3) {
            if (e3) {
              let t3 = {};
              e3 = o(e3), h.textProps.forEach((i3) => {
                void 0 !== e3[i3] && (t3[i3] = e3[i3], delete e3[i3]);
              }), this.text.css(t3), "fontSize" in t3 || "fontWeight" in t3 ? this.updateTextPadding() : ("width" in t3 || "textOverflow" in t3) && this.updateBoxSize();
            }
            return t2.prototype.css.call(this, e3);
          }
          destroy() {
            n(this.element, "mouseenter"), n(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), t2.prototype.destroy.call(this);
          }
          fillSetter(t3, e3) {
            t3 && (this.needsBox = true), this.fill = t3, this.boxAttr(e3, t3);
          }
          getBBox(t3, e3) {
            this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
            let { padding: i3, height: s2 = 0, translateX: r2 = 0, translateY: o2 = 0, width: n2 = 0 } = this, h2 = a(this.paddingLeft, i3), l = e3 ?? (this.rotation || 0), d = { width: n2, height: s2, x: r2 + this.bBox.x - h2, y: o2 + this.bBox.y - i3 + this.baselineOffset };
            return l && (d = this.getRotatedBox(d, l)), d;
          }
          getCrispAdjust() {
            return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
          }
          heightSetter(t3) {
            this.heightSetting = t3, this.doUpdate = true;
          }
          afterSetters() {
            super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = false);
          }
          onAdd() {
            this.text.add(this), this.attr({ text: a(this.textStr, ""), x: this.x || 0, y: this.y || 0 }), this.box && i2(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
          }
          paddingSetter(t3, e3) {
            r(t3) ? t3 !== this[e3] && (this[e3] = t3, this.updateTextPadding()) : this[e3] = void 0;
          }
          rSetter(t3, e3) {
            this.boxAttr(e3, t3);
          }
          strokeSetter(t3, e3) {
            this.stroke = t3, this.boxAttr(e3, t3);
          }
          "stroke-widthSetter"(t3, e3) {
            t3 && (this.needsBox = true), this["stroke-width"] = t3, this.boxAttr(e3, t3);
          }
          "text-alignSetter"(t3) {
            this.textAlign = t3;
          }
          textSetter(t3) {
            void 0 !== t3 && this.text.attr({ text: t3 }), this.updateTextPadding(), this.reAlign();
          }
          updateBoxSize() {
            let t3;
            let e3 = this.text, o2 = {}, a2 = this.padding, n2 = this.bBox = (!r(this.widthSetting) || !r(this.heightSetting) || this.textAlign) && i2(e3.textStr) ? e3.getBBox(void 0, 0) : h.emptyBBox;
            this.width = this.getPaddedWidth(), this.height = (this.heightSetting || n2.height || 0) + 2 * a2;
            let l = this.renderer.fontMetrics(e3);
            if (this.baselineOffset = a2 + Math.min((this.text.firstLineMetrics || l).b, n2.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2), this.needsBox && !e3.textPath) {
              if (!this.box) {
                let t4 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
                t4.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t4.add(this);
              }
              t3 = this.getCrispAdjust(), o2.x = t3, o2.y = (this.baseline ? -this.baselineOffset : 0) + t3, o2.width = Math.round(this.width), o2.height = Math.round(this.height), this.box.attr(s(o2, this.deferredAttr)), this.deferredAttr = {};
            }
          }
          updateTextPadding() {
            let t3 = this.text;
            if (!t3.textPath) {
              this.updateBoxSize();
              let e3 = this.baseline ? 0 : this.baselineOffset, s2 = a(this.paddingLeft, this.padding);
              i2(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (s2 += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width)), (s2 !== t3.x || e3 !== t3.y) && (t3.attr("x", s2), t3.hasBoxWidthChanged && (this.bBox = t3.getBBox(true)), void 0 !== e3 && t3.attr("y", e3)), t3.x = s2, t3.y = e3;
            }
          }
          widthSetter(t3) {
            this.widthSetting = r(t3) ? t3 : void 0, this.doUpdate = true;
          }
          getPaddedWidth() {
            let t3 = this.padding, e3 = a(this.paddingLeft, t3), i3 = a(this.paddingRight, t3);
            return (this.widthSetting || this.bBox.width || 0) + e3 + i3;
          }
          xSetter(t3) {
            this.x = t3, this.alignFactor && (t3 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true), this.xSetting = Math.round(t3), this.attr("translateX", this.xSetting);
          }
          ySetter(t3) {
            this.ySetting = this.y = Math.round(t3), this.attr("translateY", this.ySetting);
          }
        }
        return h.emptyBBox = { width: 0, height: 0, x: 0, y: 0 }, h.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"], h;
      }), i(e, "Core/Renderer/SVG/Symbols.js", [e["Core/Utilities.js"]], function(t2) {
        let { defined: e2, isNumber: i2, pick: s } = t2;
        function r(t3, i3, r2, o2, a2) {
          let n = [];
          if (a2) {
            let h = a2.start || 0, l = s(a2.r, r2), d = s(a2.r, o2 || r2), p = 2e-4 / (a2.borderRadius ? 1 : Math.max(l, 1)), c = Math.abs((a2.end || 0) - h - 2 * Math.PI) < p, u = (a2.end || 0) - (c ? p : 0), g = a2.innerR, f = s(a2.open, c), m = Math.cos(h), y = Math.sin(h), x = Math.cos(u), b = Math.sin(u), S = s(a2.longArc, u - h - Math.PI < p ? 0 : 1), v = ["A", l, d, 0, S, s(a2.clockwise, 1), t3 + l * x, i3 + d * b];
            v.params = { start: h, end: u, cx: t3, cy: i3 }, n.push(["M", t3 + l * m, i3 + d * y], v), e2(g) && ((v = ["A", g, g, 0, S, e2(a2.clockwise) ? 1 - a2.clockwise : 0, t3 + g * m, i3 + g * y]).params = { start: u, end: h, cx: t3, cy: i3 }, n.push(f ? ["M", t3 + g * x, i3 + g * b] : ["L", t3 + g * x, i3 + g * b], v)), f || n.push(["Z"]);
          }
          return n;
        }
        function o(t3, e3, i3, s2, r2) {
          return r2 && r2.r ? a(t3, e3, i3, s2, r2) : [["M", t3, e3], ["L", t3 + i3, e3], ["L", t3 + i3, e3 + s2], ["L", t3, e3 + s2], ["Z"]];
        }
        function a(t3, e3, i3, s2, r2) {
          let o2 = (r2 == null ? void 0 : r2.r) || 0;
          return [["M", t3 + o2, e3], ["L", t3 + i3 - o2, e3], ["A", o2, o2, 0, 0, 1, t3 + i3, e3 + o2], ["L", t3 + i3, e3 + s2 - o2], ["A", o2, o2, 0, 0, 1, t3 + i3 - o2, e3 + s2], ["L", t3 + o2, e3 + s2], ["A", o2, o2, 0, 0, 1, t3, e3 + s2 - o2], ["L", t3, e3 + o2], ["A", o2, o2, 0, 0, 1, t3 + o2, e3], ["Z"]];
        }
        return { arc: r, callout: function(t3, e3, s2, r2, o2) {
          let n = Math.min(o2 && o2.r || 0, s2, r2), h = n + 6, l = o2 && o2.anchorX, d = o2 && o2.anchorY || 0, p = a(t3, e3, s2, r2, { r: n });
          if (!i2(l) || l < s2 && l > 0 && d < r2 && d > 0) return p;
          if (t3 + l > s2 - h) {
            if (d > e3 + h && d < e3 + r2 - h) p.splice(3, 1, ["L", t3 + s2, d - 6], ["L", t3 + s2 + 6, d], ["L", t3 + s2, d + 6], ["L", t3 + s2, e3 + r2 - n]);
            else if (l < s2) {
              let i3 = d < e3 + h, o3 = i3 ? e3 : e3 + r2;
              p.splice(i3 ? 2 : 5, 0, ["L", l, d], ["L", t3 + s2 - n, o3]);
            } else p.splice(3, 1, ["L", t3 + s2, r2 / 2], ["L", l, d], ["L", t3 + s2, r2 / 2], ["L", t3 + s2, e3 + r2 - n]);
          } else if (t3 + l < h) {
            if (d > e3 + h && d < e3 + r2 - h) p.splice(7, 1, ["L", t3, d + 6], ["L", t3 - 6, d], ["L", t3, d - 6], ["L", t3, e3 + n]);
            else if (l > 0) {
              let i3 = d < e3 + h, s3 = i3 ? e3 : e3 + r2;
              p.splice(i3 ? 1 : 6, 0, ["L", l, d], ["L", t3 + n, s3]);
            } else p.splice(7, 1, ["L", t3, r2 / 2], ["L", l, d], ["L", t3, r2 / 2], ["L", t3, e3 + n]);
          } else d > r2 && l < s2 - h ? p.splice(5, 1, ["L", l + 6, e3 + r2], ["L", l, e3 + r2 + 6], ["L", l - 6, e3 + r2], ["L", t3 + n, e3 + r2]) : d < 0 && l > h && p.splice(1, 1, ["L", l - 6, e3], ["L", l, e3 - 6], ["L", l + 6, e3], ["L", s2 - n, e3]);
          return p;
        }, circle: function(t3, e3, i3, s2) {
          return r(t3 + i3 / 2, e3 + s2 / 2, i3 / 2, s2 / 2, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: false });
        }, diamond: function(t3, e3, i3, s2) {
          return [["M", t3 + i3 / 2, e3], ["L", t3 + i3, e3 + s2 / 2], ["L", t3 + i3 / 2, e3 + s2], ["L", t3, e3 + s2 / 2], ["Z"]];
        }, rect: o, roundedRect: a, square: o, triangle: function(t3, e3, i3, s2) {
          return [["M", t3 + i3 / 2, e3], ["L", t3 + i3, e3 + s2], ["L", t3, e3 + s2], ["Z"]];
        }, "triangle-down": function(t3, e3, i3, s2) {
          return [["M", t3, e3], ["L", t3 + i3, e3], ["L", t3 + i3 / 2, e3 + s2], ["Z"]];
        } };
      }), i(e, "Core/Renderer/SVG/TextBuilder.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { doc: s, SVG_NS: r, win: o } = e2, { attr: a, extend: n, fireEvent: h, isString: l, objectEach: d, pick: p } = i2;
        return class {
          constructor(t3) {
            let e3 = t3.styles;
            this.renderer = t3.renderer, this.svgElement = t3, this.width = t3.textWidth, this.textLineHeight = e3 && e3.lineHeight, this.textOutline = e3 && e3.textOutline, this.ellipsis = !!(e3 && "ellipsis" === e3.textOverflow), this.noWrap = !!(e3 && "nowrap" === e3.whiteSpace);
          }
          buildSVG() {
            let e3 = this.svgElement, i3 = e3.element, r2 = e3.renderer, o2 = p(e3.textStr, "").toString(), a2 = -1 !== o2.indexOf("<"), n2 = i3.childNodes, h2 = !e3.added && r2.box, d2 = [o2, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, e3.getStyle("font-size"), this.width].join(",");
            if (d2 !== e3.textCache) {
              e3.textCache = d2, delete e3.actualWidth;
              for (let t3 = n2.length; t3--; ) i3.removeChild(n2[t3]);
              if (a2 || this.ellipsis || this.width || e3.textPath || -1 !== o2.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(o2))) {
                if ("" !== o2) {
                  h2 && h2.appendChild(i3);
                  let s2 = new t2(o2);
                  this.modifyTree(s2.nodes), s2.addToDOM(i3), this.modifyDOM(), this.ellipsis && -1 !== (i3.textContent || "").indexOf("…") && e3.attr("title", this.unescapeEntities(e3.textStr || "", ["&lt;", "&gt;"])), h2 && h2.removeChild(i3);
                }
              } else i3.appendChild(s.createTextNode(this.unescapeEntities(o2)));
              l(this.textOutline) && e3.applyTextOutline && e3.applyTextOutline(this.textOutline);
            }
          }
          modifyDOM() {
            let t3;
            let e3 = this.svgElement, i3 = a(e3.element, "x");
            for (e3.firstLineMetrics = void 0; t3 = e3.element.firstChild; ) if (/^[\s\u200B]*$/.test(t3.textContent || " ")) e3.element.removeChild(t3);
            else break;
            [].forEach.call(e3.element.querySelectorAll("tspan.highcharts-br"), (t4, s2) => {
              t4.nextSibling && t4.previousSibling && (0 === s2 && 1 === t4.previousSibling.nodeType && (e3.firstLineMetrics = e3.renderer.fontMetrics(t4.previousSibling)), a(t4, { dy: this.getLineHeight(t4.nextSibling), x: i3 }));
            });
            let n2 = this.width || 0;
            if (!n2) return;
            let h2 = (t4, o2) => {
              let h3 = t4.textContent || "", l3 = h3.replace(/([^\^])-/g, "$1- ").split(" "), d2 = !this.noWrap && (l3.length > 1 || e3.element.childNodes.length > 1), p2 = this.getLineHeight(o2), c = 0, u = e3.actualWidth;
              if (this.ellipsis) h3 && this.truncate(t4, h3, void 0, 0, Math.max(0, n2 - 0.8 * p2), (t5, e4) => t5.substring(0, e4) + "…");
              else if (d2) {
                let h4 = [], d3 = [];
                for (; o2.firstChild && o2.firstChild !== t4; ) d3.push(o2.firstChild), o2.removeChild(o2.firstChild);
                for (; l3.length; ) l3.length && !this.noWrap && c > 0 && (h4.push(t4.textContent || ""), t4.textContent = l3.join(" ").replace(/- /g, "-")), this.truncate(t4, void 0, l3, 0 === c && u || 0, n2, (t5, e4) => l3.slice(0, e4).join(" ").replace(/- /g, "-")), u = e3.actualWidth, c++;
                d3.forEach((e4) => {
                  o2.insertBefore(e4, t4);
                }), h4.forEach((e4) => {
                  o2.insertBefore(s.createTextNode(e4), t4);
                  let n3 = s.createElementNS(r, "tspan");
                  n3.textContent = "​", a(n3, { dy: p2, x: i3 }), o2.insertBefore(n3, t4);
                });
              }
            }, l2 = (t4) => {
              [].slice.call(t4.childNodes).forEach((i4) => {
                i4.nodeType === o.Node.TEXT_NODE ? h2(i4, t4) : (-1 !== i4.className.baseVal.indexOf("highcharts-br") && (e3.actualWidth = 0), l2(i4));
              });
            };
            l2(e3.element);
          }
          getLineHeight(t3) {
            let e3 = t3.nodeType === o.Node.TEXT_NODE ? t3.parentElement : t3;
            return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e3 || this.svgElement.element).h;
          }
          modifyTree(t3) {
            let e3 = (i3, s2) => {
              let { attributes: r2 = {}, children: o2, style: a2 = {}, tagName: h2 } = i3, l2 = this.renderer.styledMode;
              if ("b" === h2 || "strong" === h2 ? l2 ? r2.class = "highcharts-strong" : a2.fontWeight = "bold" : ("i" === h2 || "em" === h2) && (l2 ? r2.class = "highcharts-emphasized" : a2.fontStyle = "italic"), a2 && a2.color && (a2.fill = a2.color), "br" === h2) {
                r2.class = "highcharts-br", i3.textContent = "​";
                let e4 = t3[s2 + 1];
                e4 && e4.textContent && (e4.textContent = e4.textContent.replace(/^ +/gm, ""));
              } else "a" === h2 && o2 && o2.some((t4) => "#text" === t4.tagName) && (i3.children = [{ children: o2, tagName: "tspan" }]);
              "#text" !== h2 && "a" !== h2 && (i3.tagName = "tspan"), n(i3, { attributes: r2, style: a2 }), o2 && o2.filter((t4) => "#text" !== t4.tagName).forEach(e3);
            };
            t3.forEach(e3), h(this.svgElement, "afterModifyTree", { nodes: t3 });
          }
          truncate(t3, e3, i3, s2, r2, o2) {
            let a2, n2;
            let h2 = this.svgElement, { rotation: l2 } = h2, d2 = [], p2 = i3 ? 1 : 0, c = (e3 || i3 || "").length, u = c, g = function(e4, r3) {
              let o3 = r3 || e4, a3 = t3.parentNode;
              if (a3 && void 0 === d2[o3] && a3.getSubStringLength) try {
                d2[o3] = s2 + a3.getSubStringLength(0, i3 ? o3 + 1 : o3);
              } catch (t4) {
              }
              return d2[o3];
            };
            if (h2.rotation = 0, s2 + (n2 = g(t3.textContent.length)) > r2) {
              for (; p2 <= c; ) u = Math.ceil((p2 + c) / 2), i3 && (a2 = o2(i3, u)), n2 = g(u, a2 && a2.length - 1), p2 === c ? p2 = c + 1 : n2 > r2 ? c = u - 1 : p2 = u;
              0 === c ? t3.textContent = "" : e3 && c === e3.length - 1 || (t3.textContent = a2 || o2(e3 || i3, u));
            }
            i3 && i3.splice(0, u), h2.actualWidth = n2, h2.rotation = l2;
          }
          unescapeEntities(t3, e3) {
            return d(this.renderer.escapes, function(i3, s2) {
              e3 && -1 !== e3.indexOf(i3) || (t3 = t3.toString().replace(RegExp(i3, "g"), s2));
            }), t3;
          }
        };
      }), i(e, "Core/Renderer/SVG/SVGRenderer.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Defaults.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGLabel.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Renderer/SVG/TextBuilder.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, r, o, a, n, h, l) {
        let d;
        let { defaultOptions: p } = e2, { charts: c, deg2rad: u, doc: g, isFirefox: f, isMS: m, isWebKit: y, noop: x, SVG_NS: b, symbolSizes: S, win: v } = s, { addEvent: C, attr: k, createElement: A, crisp: D, css: w, defined: M, destroyObjectProperties: L, extend: O, isArray: T, isNumber: P, isObject: E, isString: B, merge: j, pick: R, pInt: I, replaceNested: W, uniqueKey: G } = l;
        class N {
          constructor(t3, e3, i3, s2, r2, o2, a2) {
            let n2, h2;
            let l2 = this.createElement("svg").attr({ version: "1.1", class: "highcharts-root" }), d2 = l2.element;
            a2 || l2.css(this.getStyle(s2 || {})), t3.appendChild(d2), k(t3, "dir", "ltr"), -1 === t3.innerHTML.indexOf("xmlns") && k(d2, "xmlns", this.SVG_NS), this.box = d2, this.boxWrapper = l2, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(g.createTextNode("Created with Highcharts 11.4.7")), this.defs = this.createElement("defs").add(), this.allowHTML = o2, this.forExport = r2, this.styledMode = a2, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l2.getStyle("font-size"), this.setSize(e3, i3, false), f && t3.getBoundingClientRect && ((n2 = function() {
              w(t3, { left: 0, top: 0 }), h2 = t3.getBoundingClientRect(), w(t3, { left: Math.ceil(h2.left) - h2.left + "px", top: Math.ceil(h2.top) - h2.top + "px" });
            })(), this.unSubPixelFix = C(v, "resize", n2));
          }
          definition(e3) {
            return new t2([e3]).addToDOM(this.defs.element);
          }
          getReferenceURL() {
            if ((f || y) && g.getElementsByTagName("base").length) {
              if (!M(d)) {
                let e3 = G(), i3 = new t2([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{ tagName: "defs", children: [{ tagName: "clipPath", attributes: { id: e3 }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }] }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${e3})`, fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(g.body);
                w(i3, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
                let s2 = g.elementFromPoint(6, 6);
                d = "hitme" === (s2 && s2.id), g.body.removeChild(i3);
              }
              if (d) return W(v.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]);
            }
            return "";
          }
          getStyle(t3) {
            return this.style = O({ fontFamily: "Helvetica, Arial, sans-serif", fontSize: "1rem" }, t3), this.style;
          }
          setStyle(t3) {
            this.boxWrapper.css(this.getStyle(t3));
          }
          isHidden() {
            return !this.boxWrapper.getBBox().width;
          }
          destroy() {
            let t3 = this.defs;
            return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), L(this.gradients || {}), this.gradients = null, this.defs = t3.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
          }
          createElement(t3) {
            return new this.Element(this, t3);
          }
          getRadialAttr(t3, e3) {
            return { cx: t3[0] - t3[2] / 2 + (e3.cx || 0) * t3[2], cy: t3[1] - t3[2] / 2 + (e3.cy || 0) * t3[2], r: (e3.r || 0) * t3[2] };
          }
          shadowDefinition(t3) {
            let e3 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t3).map((e4) => `${e4}-${t3[e4]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i3 = j({ color: "#000000", offsetX: 1, offsetY: 1, opacity: 0.15, width: 5 }, t3);
            return this.defs.element.querySelector(`#${e3}`) || this.definition({ tagName: "filter", attributes: { id: e3, filterUnits: i3.filterUnits }, children: this.getShadowFilterContent(i3) }), e3;
          }
          getShadowFilterContent(t3) {
            return [{ tagName: "feDropShadow", attributes: { dx: t3.offsetX, dy: t3.offsetY, "flood-color": t3.color, "flood-opacity": Math.min(5 * t3.opacity, 1), stdDeviation: t3.width / 2 } }];
          }
          buildText(t3) {
            new h(t3).buildSVG();
          }
          getContrast(t3) {
            let e3 = i2.parse(t3).rgba.map((t4) => {
              let e4 = t4 / 255;
              return e4 <= 0.03928 ? e4 / 12.92 : Math.pow((e4 + 0.055) / 1.055, 2.4);
            }), s2 = 0.2126 * e3[0] + 0.7152 * e3[1] + 0.0722 * e3[2];
            return 1.05 / (s2 + 0.05) > (s2 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
          }
          button(e3, i3, s2, r2, o2 = {}, a2, n2, h2, l2, d2) {
            let c2 = this.label(e3, i3, s2, l2, void 0, void 0, d2, void 0, "button"), u2 = this.styledMode, g2 = arguments, f2 = 0;
            o2 = j(p.global.buttonTheme, o2), u2 && (delete o2.fill, delete o2.stroke, delete o2["stroke-width"]);
            let y2 = o2.states || {}, x2 = o2.style || {};
            delete o2.states, delete o2.style;
            let b2 = [t2.filterUserAttributes(o2)], S2 = [x2];
            return u2 || ["hover", "select", "disabled"].forEach((e4, i4) => {
              b2.push(j(b2[0], t2.filterUserAttributes(g2[i4 + 5] || y2[e4] || {}))), S2.push(b2[i4 + 1].style), delete b2[i4 + 1].style;
            }), C(c2.element, m ? "mouseover" : "mouseenter", function() {
              3 !== f2 && c2.setState(1);
            }), C(c2.element, m ? "mouseout" : "mouseleave", function() {
              3 !== f2 && c2.setState(f2);
            }), c2.setState = (t3 = 0) => {
              if (1 !== t3 && (c2.state = f2 = t3), c2.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][t3]), !u2) {
                c2.attr(b2[t3]);
                let e4 = S2[t3];
                E(e4) && c2.css(e4);
              }
            }, c2.attr(b2[0]), !u2 && (c2.css(O({ cursor: "default" }, x2)), d2 && c2.text.css({ pointerEvents: "none" })), c2.on("touchstart", (t3) => t3.stopPropagation()).on("click", function(t3) {
              3 !== f2 && r2.call(c2, t3);
            });
          }
          crispLine(t3, e3) {
            let [i3, s2] = t3;
            return M(i3[1]) && i3[1] === s2[1] && (i3[1] = s2[1] = D(i3[1], e3)), M(i3[2]) && i3[2] === s2[2] && (i3[2] = s2[2] = D(i3[2], e3)), t3;
          }
          path(t3) {
            let e3 = this.styledMode ? {} : { fill: "none" };
            return T(t3) ? e3.d = t3 : E(t3) && O(e3, t3), this.createElement("path").attr(e3);
          }
          circle(t3, e3, i3) {
            let s2 = E(t3) ? t3 : void 0 === t3 ? {} : { x: t3, y: e3, r: i3 }, r2 = this.createElement("circle");
            return r2.xSetter = r2.ySetter = function(t4, e4, i4) {
              i4.setAttribute("c" + e4, t4);
            }, r2.attr(s2);
          }
          arc(t3, e3, i3, s2, r2, o2) {
            let a2;
            E(t3) ? (e3 = (a2 = t3).y, i3 = a2.r, s2 = a2.innerR, r2 = a2.start, o2 = a2.end, t3 = a2.x) : a2 = { innerR: s2, start: r2, end: o2 };
            let n2 = this.symbol("arc", t3, e3, i3, i3, a2);
            return n2.r = i3, n2;
          }
          rect(t3, e3, i3, s2, r2, o2) {
            let a2 = E(t3) ? t3 : void 0 === t3 ? {} : { x: t3, y: e3, r: r2, width: Math.max(i3 || 0, 0), height: Math.max(s2 || 0, 0) }, n2 = this.createElement("rect");
            return this.styledMode || (void 0 !== o2 && (a2["stroke-width"] = o2, O(a2, n2.crisp(a2))), a2.fill = "none"), n2.rSetter = function(t4, e4, i4) {
              n2.r = t4, k(i4, { rx: t4, ry: t4 });
            }, n2.rGetter = function() {
              return n2.r || 0;
            }, n2.attr(a2);
          }
          roundedRect(t3) {
            return this.symbol("roundedRect").attr(t3);
          }
          setSize(t3, e3, i3) {
            this.width = t3, this.height = e3, this.boxWrapper.animate({ width: t3, height: e3 }, { step: function() {
              this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
            }, duration: R(i3, true) ? void 0 : 0 }), this.alignElements();
          }
          g(t3) {
            let e3 = this.createElement("g");
            return t3 ? e3.attr({ class: "highcharts-" + t3 }) : e3;
          }
          image(t3, e3, i3, s2, r2, o2) {
            let a2 = { preserveAspectRatio: "none" };
            P(e3) && (a2.x = e3), P(i3) && (a2.y = i3), P(s2) && (a2.width = s2), P(r2) && (a2.height = r2);
            let n2 = this.createElement("image").attr(a2), h2 = function(e4) {
              n2.attr({ href: t3 }), o2.call(n2, e4);
            };
            if (o2) {
              n2.attr({ href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" });
              let e4 = new v.Image();
              C(e4, "load", h2), e4.src = t3, e4.complete && h2({});
            } else n2.attr({ href: t3 });
            return n2;
          }
          symbol(t3, e3, i3, s2, r2, o2) {
            let a2, n2, h2, l2;
            let d2 = this, p2 = /^url\((.*?)\)$/, u2 = p2.test(t3), f2 = !u2 && (this.symbols[t3] ? t3 : "circle"), m2 = f2 && this.symbols[f2];
            if (m2) "number" == typeof e3 && (n2 = m2.call(this.symbols, e3 || 0, i3 || 0, s2 || 0, r2 || 0, o2)), a2 = this.path(n2), d2.styledMode || a2.attr("fill", "none"), O(a2, { symbolName: f2 || void 0, x: e3, y: i3, width: s2, height: r2 }), o2 && O(a2, o2);
            else if (u2) {
              h2 = t3.match(p2)[1];
              let s3 = a2 = this.image(h2);
              s3.imgwidth = R(o2 && o2.width, S[h2] && S[h2].width), s3.imgheight = R(o2 && o2.height, S[h2] && S[h2].height), l2 = (t4) => t4.attr({ width: t4.width, height: t4.height }), ["width", "height"].forEach((t4) => {
                s3[`${t4}Setter`] = function(t5, e4) {
                  this[e4] = t5;
                  let { alignByTranslate: i4, element: s4, width: r3, height: a3, imgwidth: n3, imgheight: h3 } = this, l3 = "width" === e4 ? n3 : h3, d3 = 1;
                  o2 && "within" === o2.backgroundSize && r3 && a3 && n3 && h3 ? (d3 = Math.min(r3 / n3, a3 / h3), k(s4, { width: Math.round(n3 * d3), height: Math.round(h3 * d3) })) : s4 && l3 && s4.setAttribute(e4, l3), !i4 && n3 && h3 && this.translate(((r3 || 0) - n3 * d3) / 2, ((a3 || 0) - h3 * d3) / 2);
                };
              }), M(e3) && s3.attr({ x: e3, y: i3 }), s3.isImg = true, M(s3.imgwidth) && M(s3.imgheight) ? l2(s3) : (s3.attr({ width: 0, height: 0 }), A("img", { onload: function() {
                let t4 = c[d2.chartIndex];
                0 === this.width && (w(this, { position: "absolute", top: "-999em" }), g.body.appendChild(this)), S[h2] = { width: this.width, height: this.height }, s3.imgwidth = this.width, s3.imgheight = this.height, s3.element && l2(s3), this.parentNode && this.parentNode.removeChild(this), d2.imgCount--, d2.imgCount || !t4 || t4.hasLoaded || t4.onload();
              }, src: h2 }), this.imgCount++);
            }
            return a2;
          }
          clipRect(t3, e3, i3, s2) {
            return this.rect(t3, e3, i3, s2, 0);
          }
          text(t3, e3, i3, s2) {
            let r2 = {};
            if (s2 && (this.allowHTML || !this.forExport)) return this.html(t3, e3, i3);
            r2.x = Math.round(e3 || 0), i3 && (r2.y = Math.round(i3)), M(t3) && (r2.text = t3);
            let o2 = this.createElement("text").attr(r2);
            return s2 && (!this.forExport || this.allowHTML) || (o2.xSetter = function(t4, e4, i4) {
              let s3 = i4.getElementsByTagName("tspan"), r3 = i4.getAttribute(e4);
              for (let i5 = 0, o3; i5 < s3.length; i5++) (o3 = s3[i5]).getAttribute(e4) === r3 && o3.setAttribute(e4, t4);
              i4.setAttribute(e4, t4);
            }), o2;
          }
          fontMetrics(t3) {
            let e3 = I(o.prototype.getStyle.call(t3, "font-size") || 0), i3 = e3 < 24 ? e3 + 3 : Math.round(1.2 * e3), s2 = Math.round(0.8 * i3);
            return { h: i3, b: s2, f: e3 };
          }
          rotCorr(t3, e3, i3) {
            let s2 = t3;
            return e3 && i3 && (s2 = Math.max(s2 * Math.cos(e3 * u), 4)), { x: -t3 / 3 * Math.sin(e3 * u), y: s2 };
          }
          pathToSegments(t3) {
            let e3 = [], i3 = [], s2 = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
            for (let r2 = 0; r2 < t3.length; r2++) B(i3[0]) && P(t3[r2]) && i3.length === s2[i3[0].toUpperCase()] && t3.splice(r2, 0, i3[0].replace("M", "L").replace("m", "l")), "string" == typeof t3[r2] && (i3.length && e3.push(i3.slice(0)), i3.length = 0), i3.push(t3[r2]);
            return e3.push(i3.slice(0)), e3;
          }
          label(t3, e3, i3, s2, r2, o2, n2, h2, l2) {
            return new a(this, t3, e3, i3, s2, r2, o2, n2, h2, l2);
          }
          alignElements() {
            this.alignedObjects.forEach((t3) => t3.align());
          }
        }
        return O(N.prototype, { Element: o, SVG_NS: b, escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, symbols: n, draw: x }), r.registerRendererType("svg", N, true), N;
      }), i(e, "Series/ArcDiagram/ArcDiagramSeries.js", [e["Series/ArcDiagram/ArcDiagramPoint.js"], e["Series/ArcDiagram/ArcDiagramSeriesDefaults.js"], e["Series/Sankey/SankeyColumnComposition.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Utilities.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Extensions/TextPath.js"]], function(t2, e2, i2, s, r, o, a, n, h) {
        h.compose(n);
        let { prototype: { symbols: l } } = o, { seriesTypes: { column: d, sankey: p } } = r, { crisp: c, extend: u, merge: g, pick: f, relativeLength: m } = a;
        class y extends p {
          createNodeColumns() {
            let t3 = this, e3 = t3.chart, s2 = i2.compose([], t3);
            return s2.sankeyColumn.maxLength = e3.inverted ? e3.plotHeight : e3.plotWidth, s2.sankeyColumn.getTranslationFactor = (t4) => {
              let i3 = s2.slice(), r2 = this.options.minLinkWidth || 0, o2, a2 = 0, n2, h2, l2 = 0, d2 = 1, p2 = 0, c2 = (e3.plotSizeX || 0) - (t4.options.marker && t4.options.marker.lineWidth || 0) - (s2.length - 1) * t4.nodePadding;
              for (; s2.length; ) {
                for (a2 = c2 / s2.sankeyColumn.sum(), o2 = false, n2 = s2.length; n2--; ) {
                  h2 = s2[n2].getSum() * a2 * d2;
                  let t5 = Math.min(e3.plotHeight, e3.plotWidth);
                  h2 > t5 ? d2 = Math.min(t5 / h2, d2) : h2 < r2 && (s2.splice(n2, 1), c2 -= r2, h2 = r2, o2 = true), p2 += h2 * (1 - d2) / 2, l2 = Math.max(l2, h2);
                }
                if (!o2) break;
              }
              return s2.length = 0, i3.forEach((t5) => {
                t5.scale = d2, s2.push(t5);
              }), s2.sankeyColumn.maxRadius = l2, s2.sankeyColumn.scale = d2, s2.sankeyColumn.additionalSpace = p2, a2;
            }, s2.sankeyColumn.offset = function(i3, r2) {
              let o2 = i3.series.options.equalNodes, a2 = t3.nodePadding, n2 = Math.min(e3.plotWidth, e3.plotHeight, (s2.sankeyColumn.maxLength || 0) / t3.nodes.length - a2), h2 = s2.sankeyColumn.additionalSpace || 0, l2;
              for (let e4 = 0; e4 < s2.length; e4++) {
                let d2 = s2[e4].getSum() * (s2.sankeyColumn.scale || 0), p2 = o2 ? n2 : Math.max(d2 * r2, t3.options.minLinkWidth || 0);
                if (l2 = d2 ? p2 + a2 : 0, s2[e4] === i3) return { relativeLeft: h2 + m(i3.options.offset || 0, l2) };
                h2 += l2;
              }
            }, t3.nodes.forEach(function(t4) {
              t4.column = 0, s2.push(t4);
            }), [s2];
          }
          translateLink(t3) {
            let e3 = t3.fromNode, i3 = t3.toNode, s2 = this.chart, r2 = this.translationFactor, o2 = t3.options, a2 = this.options, n2 = f(o2.linkWeight, a2.linkWeight, Math.max((t3.weight || 0) * r2 * e3.scale, this.options.minLinkWidth || 0)), h2 = t3.series.options.centeredLinks, l2 = e3.nodeY, d2 = (e4, i4) => {
              let s3 = (e4.offset(t3, i4) || 0) * r2;
              return Math.min(e4.nodeX + s3, e4.nodeX + (e4.shapeArgs && e4.shapeArgs.height || 0) - n2);
            }, p2 = h2 ? e3.nodeX + ((e3.shapeArgs.height || 0) - n2) / 2 : d2(e3, "linksFrom"), c2 = h2 ? i3.nodeX + ((i3.shapeArgs.height || 0) - n2) / 2 : d2(i3, "linksTo"), u2 = l2;
            p2 > c2 && ([p2, c2] = [c2, p2]), a2.reversed && ([p2, c2] = [c2, p2], u2 = (s2.plotSizeY || 0) - u2), t3.shapeType = "path", t3.linkBase = [p2, p2 + n2, c2, c2 + n2];
            let g2 = (c2 + n2 - p2) / Math.abs(c2 + n2 - p2) * f(a2.linkRadius, Math.min(Math.abs(c2 + n2 - p2) / 2, e3.nodeY - Math.abs(n2)));
            t3.shapeArgs = { d: [["M", p2, u2], ["A", (c2 + n2 - p2) / 2, g2, 0, 0, 1, c2 + n2, u2], ["L", c2, u2], ["A", (c2 - p2 - n2) / 2, g2 - n2, 0, 0, 0, p2 + n2, u2], ["Z"]] }, t3.dlBox = { x: p2 + (c2 - p2) / 2, y: u2 - g2, height: n2, width: 0 }, t3.tooltipPos = s2.inverted ? [(s2.plotSizeY || 0) - t3.dlBox.y - n2 / 2, (s2.plotSizeX || 0) - t3.dlBox.x] : [t3.dlBox.x, t3.dlBox.y + n2 / 2], t3.y = t3.plotY = 1, t3.x = t3.plotX = 1, t3.color || (t3.color = e3.color);
          }
          translateNode(t3, e3) {
            var _a;
            let i3 = this.translationFactor, s2 = this.chart, r2 = s2.inverted ? s2.plotWidth : s2.plotHeight, o2 = this.options, a2 = Math.min(s2.plotWidth, s2.plotHeight, r2 / t3.series.nodes.length - this.nodePadding), n2 = t3.getSum() * (e3.sankeyColumn.scale || 0), h2 = o2.equalNodes ? a2 : Math.max(n2 * i3, this.options.minLinkWidth || 0), d2 = ((_a = o2.marker) == null ? void 0 : _a.lineWidth) || 0, u2 = e3.sankeyColumn.offset(t3, i3), m2 = c(f(u2 && u2.absoluteLeft, (e3.sankeyColumn.left(i3) || 0) + (u2 && u2.relativeLeft || 0)), d2), y2 = g(o2.marker, t3.options.marker), x = y2.symbol, b = y2.radius, S = parseInt(o2.offset, 10) * ((s2.inverted ? s2.plotWidth : s2.plotHeight) - (c(this.colDistance * (t3.column || 0) + (y2.lineWidth || 0) / 2, d2) + (e3.sankeyColumn.scale || 0) * (e3.sankeyColumn.maxRadius || 0) / 2)) / 100;
            if (t3.sum = n2, n2) {
              t3.nodeX = m2, t3.nodeY = S;
              let e4 = t3.options.width || o2.width || h2, i4 = t3.options.height || o2.height || h2, r3 = S;
              o2.reversed && (r3 = (s2.plotSizeY || 0) - S, s2.inverted && (r3 = (s2.plotSizeY || 0) - S)), this.mapOptionsToLevel && (t3.dlOptions = p.getDLOptions({ level: this.mapOptionsToLevel[t3.level], optionsPoint: t3.options })), t3.plotX = 1, t3.plotY = 1, t3.tooltipPos = s2.inverted ? [(s2.plotSizeY || 0) - r3 - i4 / 2, (s2.plotSizeX || 0) - m2 - e4 / 2] : [m2 + e4 / 2, r3 + i4 / 2], t3.shapeType = "path", t3.shapeArgs = { d: l[x || "circle"](m2, r3 - (b || i4) / 2, b || e4, b || i4), width: b || e4, height: b || i4 }, t3.dlBox = { x: m2 + e4 / 2, y: r3, height: 0, width: 0 };
            } else t3.dlOptions = { enabled: false };
          }
          drawDataLabels() {
            if (this.options.dataLabels) {
              let t3 = this.options.dataLabels.textPath;
              d.prototype.drawDataLabels.call(this, this.nodes), this.options.dataLabels.textPath = this.options.dataLabels.linkTextPath, d.prototype.drawDataLabels.call(this, this.data), this.options.dataLabels.textPath = t3;
            }
          }
          pointAttribs(t3, e3) {
            if (t3 && t3.isNode) {
              let { ...t4 } = s.prototype.pointAttribs.apply(this, arguments);
              return t4;
            }
            return super.pointAttribs.apply(this, arguments);
          }
          markerAttribs(t3) {
            return t3.isNode ? super.markerAttribs.apply(this, arguments) : {};
          }
        }
        return y.defaultOptions = g(p.defaultOptions, e2), u(y.prototype, { orderNodes: false }), y.prototype.pointClass = t2, r.registerSeriesType("arcdiagram", y), y;
      }), i(e, "masters/modules/arc-diagram.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_arc_diagram();
//# sourceMappingURL=highcharts_modules_arc-diagram__js.js.map
