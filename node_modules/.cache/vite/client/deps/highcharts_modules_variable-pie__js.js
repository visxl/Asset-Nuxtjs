import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/variable-pie.js
var require_variable_pie = __commonJS({
  "node_modules/highcharts/modules/variable-pie.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Variable Pie module for Highcharts
    *
    * (c) 2010-2024 Grzegorz Blachliński
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/variable-pie", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function i(t2, i2, a, s) {
        t2.hasOwnProperty(i2) || (t2[i2] = s.apply(null, a), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: t2[i2] } })));
      }
      i(t, "Series/VariablePie/VariablePieSeriesDefaults.js", [], function() {
        return { minPointSize: "10%", maxPointSize: "100%", zMin: void 0, zMax: void 0, sizeBy: "area", tooltip: { pointFormat: '<span style="color:{point.color}">●</span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>' } };
      }), i(t, "Series/VariablePie/VariablePieSeries.js", [t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"], t["Series/VariablePie/VariablePieSeriesDefaults.js"]], function(e2, t2, i2) {
        let { pie: a } = e2.seriesTypes, { arrayMax: s, arrayMin: n, clamp: r, extend: l, fireEvent: o, merge: h, pick: d } = t2;
        class u extends a {
          calculateExtremes() {
            let e3, t3;
            let i3 = this.chart, a2 = i3.plotWidth, l2 = i3.plotHeight, o2 = this.options, h2 = 2 * (o2.slicedOffset || 0), u2 = this.zData, c = Math.min(a2, l2) - h2, p = {}, f = this.center || this.getCenter();
            for (let e4 of ["minPointSize", "maxPointSize"]) {
              let t4 = o2[e4], i4 = /%$/.test(t4);
              t4 = parseInt(t4, 10), p[e4] = i4 ? c * t4 / 100 : 2 * t4;
            }
            this.minPxSize = f[3] + p.minPointSize, this.maxPxSize = r(f[2], f[3] + p.minPointSize, p.maxPointSize), u2.length && (e3 = d(o2.zMin, n(u2.filter(this.zValEval))), t3 = d(o2.zMax, s(u2.filter(this.zValEval))), this.getRadii(e3, t3, this.minPxSize, this.maxPxSize));
          }
          getRadii(e3, t3, i3, a2) {
            let s2, n2, r2;
            let l2 = this.zData, o2 = [], h2 = "radius" !== this.options.sizeBy, d2 = t3 - e3;
            for (let u2 = 0; u2 < l2.length; u2++) (n2 = this.zValEval(l2[u2]) ? l2[u2] : e3) <= e3 ? r2 = i3 / 2 : n2 >= t3 ? r2 = a2 / 2 : (s2 = d2 > 0 ? (n2 - e3) / d2 : 0.5, h2 && (s2 = Math.sqrt(s2)), r2 = Math.ceil(i3 + s2 * (a2 - i3)) / 2), o2.push(r2);
            this.radii = o2;
          }
          redraw() {
            this.center = null, super.redraw();
          }
          getDataLabelPosition(e3, t3) {
            let { center: i3, options: a2 } = this, s2 = e3.angle || 0, n2 = this.radii[e3.index], r2 = i3[0] + Math.cos(s2) * n2, l2 = i3[1] + Math.sin(s2) * n2, o2 = Math.min((a2.slicedOffset || 0) + (a2.borderWidth || 0), t3 / 5);
            return { distance: t3, natural: { x: r2 + Math.cos(s2) * t3, y: l2 + Math.sin(s2) * t3 }, computed: {}, alignment: e3.half ? "right" : "left", connectorPosition: { breakAt: { x: r2 + Math.cos(s2) * o2, y: l2 + Math.sin(s2) * o2 }, touchingSliceAt: { x: r2, y: l2 } } };
          }
          translate(e3) {
            this.generatePoints();
            let t3 = this.options, i3 = t3.slicedOffset, a2 = t3.startAngle || 0, s2 = Math.PI / 180 * (a2 - 90), n2 = Math.PI / 180 * (d(t3.endAngle, a2 + 360) - 90), r2 = n2 - s2, l2 = this.points, h2 = t3.ignoreHiddenPoint, u2 = 0, c, p, f, M, m, P, g;
            this.startAngleRad = s2, this.endAngleRad = n2, this.calculateExtremes(), e3 || (this.center = e3 = this.getCenter());
            for (let t4 = 0; t4 < l2.length; t4++) P = l2[t4], g = this.radii[t4], c = s2 + u2 * r2, (!h2 || P.visible) && (u2 += P.percentage / 100), p = s2 + u2 * r2, P.shapeType = "arc", P.shapeArgs = { x: e3[0], y: e3[1], r: g, innerR: e3[3] / 2, start: Math.round(1e3 * c) / 1e3, end: Math.round(1e3 * p) / 1e3 }, (f = (p + c) / 2) > 1.5 * Math.PI ? f -= 2 * Math.PI : f < -Math.PI / 2 && (f += 2 * Math.PI), P.slicedTranslation = { translateX: Math.round(Math.cos(f) * i3), translateY: Math.round(Math.sin(f) * i3) }, M = Math.cos(f) * e3[2] / 2, m = Math.sin(f) * e3[2] / 2, P.tooltipPos = [e3[0] + 0.7 * M, e3[1] + 0.7 * m], P.half = f < -Math.PI / 2 || f > Math.PI / 2 ? 1 : 0, P.angle = f;
            o(this, "afterTranslate");
          }
          zValEval(e3) {
            return !("number" != typeof e3 || isNaN(e3)) || null;
          }
        }
        return u.defaultOptions = h(a.defaultOptions, i2), l(u.prototype, { pointArrayMap: ["y", "z"], parallelArrays: ["x", "y", "z"] }), e2.registerSeriesType("variablepie", u), u;
      }), i(t, "masters/modules/variable-pie.src.js", [t["Core/Globals.js"]], function(e2) {
        return e2;
      });
    });
  }
});
export default require_variable_pie();
//# sourceMappingURL=highcharts_modules_variable-pie__js.js.map
