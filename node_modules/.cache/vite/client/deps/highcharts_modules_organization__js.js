import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/organization.js
var require_organization = __commonJS({
  "node_modules/highcharts/modules/organization.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    * Organization chart series type
    *
    * (c) 2019-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/organization", ["highcharts", "highcharts/modules/sankey"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, n, s) {
        e2.hasOwnProperty(i2) || (e2[i2] = s.apply(null, n), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Series/Organization/OrganizationPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { sankey: { prototype: { pointClass: i2 } } } = t2.seriesTypes, { defined: n, find: s, pick: o } = e2;
        return class extends i2 {
          constructor(t3, e3, i3) {
            super(t3, e3, i3), this.isNode || (this.dataLabelOnNull = true, this.formatPrefix = "link");
          }
          getSum() {
            return 1;
          }
          setNodeColumn() {
            super.setNodeColumn();
            let t3 = this, e3 = t3.getFromNode().fromNode;
            if (!n(t3.options.column) && 0 !== t3.linksTo.length && e3 && "hanging" === e3.options.layout) {
              let i3 = -1, n2;
              t3.options.layout = o(t3.options.layout, "hanging"), t3.hangsFrom = e3, s(e3.linksFrom, (e4, n3) => {
                let s2 = e4.toNode === t3;
                return s2 && (i3 = n3), s2;
              });
              for (let s2 = 0; s2 < e3.linksFrom.length; ++s2) (n2 = e3.linksFrom[s2]).toNode.id === t3.id ? s2 = e3.linksFrom.length : i3 += function t4(e4) {
                let i4 = e4.linksFrom.length;
                return e4.linksFrom.forEach((e5) => {
                  e5.id === e5.toNode.linksTo[0].id ? i4 += t4(e5.toNode) : i4--;
                }), i4;
              }(n2.toNode);
              t3.column = (t3.column || 0) + i3;
            }
          }
        };
      }), i(e, "Series/Organization/OrganizationSeriesDefaults.js", [], function() {
        return { borderColor: "#666666", borderRadius: 3, link: { color: "#666666", lineWidth: 1, radius: 10, type: "default" }, borderWidth: 1, dataLabels: { nodeFormatter: function() {
          let t2 = { width: "100%", height: "100%", display: "flex", "flex-direction": "row", "align-items": "center", "justify-content": "center" }, e2 = { "max-height": "100%", "border-radius": "50%" }, i2 = { width: "100%", padding: 0, "text-align": "center", "white-space": "normal" };
          function n(t3) {
            return Object.keys(t3).reduce(function(e3, i3) {
              return e3 + i3 + ":" + t3[i3] + ";";
            }, 'style="') + '"';
          }
          let { description: s, image: o, title: r } = this.point;
          o && (e2["max-width"] = "30%", i2.width = "70%"), this.series.chart.renderer.forExport && (t2.display = "block", i2.position = "absolute", i2.left = o ? "30%" : 0, i2.top = 0);
          let a = "<div " + n(t2) + ">";
          return o && (a += '<img src="' + o + '" ' + n(e2) + ">"), a += "<div " + n(i2) + ">", this.point.name && (a += "<h4 " + n({ margin: 0 }) + ">" + this.point.name + "</h4>"), r && (a += "<p " + n({ margin: 0 }) + ">" + (r || "") + "</p>"), s && (a += "<p " + n({ opacity: 0.75, margin: "5px" }) + ">" + s + "</p>"), a += "</div></div>";
        }, style: { fontWeight: "normal", fontSize: "0.9em" }, useHTML: true, linkTextPath: { attributes: { startOffset: "95%", textAnchor: "end" } } }, hangingIndent: 20, hangingIndentTranslation: "inherit", hangingSide: "left", minNodeLength: 10, nodeWidth: 50, tooltip: { nodeFormat: "{point.name}<br>{point.title}<br>{point.description}" } };
      }), i(e, "Series/PathUtilities.js", [], function() {
        function t2(t3, e2) {
          let i2 = [];
          for (let n = 0; n < t3.length; n++) {
            let s = t3[n][1], o = t3[n][2];
            if ("number" == typeof s && "number" == typeof o) {
              if (0 === n) i2.push(["M", s, o]);
              else if (n === t3.length - 1) i2.push(["L", s, o]);
              else if (e2) {
                let r = t3[n - 1], a = t3[n + 1];
                if (r && a) {
                  let t4 = r[1], n2 = r[2], h = a[1], l = a[2];
                  if ("number" == typeof t4 && "number" == typeof h && "number" == typeof n2 && "number" == typeof l && t4 !== h && n2 !== l) {
                    let r2 = t4 < h ? 1 : -1, a2 = n2 < l ? 1 : -1;
                    i2.push(["L", s - r2 * Math.min(Math.abs(s - t4), e2), o - a2 * Math.min(Math.abs(o - n2), e2)], ["C", s, o, s, o, s + r2 * Math.min(Math.abs(s - h), e2), o + a2 * Math.min(Math.abs(o - l), e2)]);
                  }
                }
              } else i2.push(["L", s, o]);
            }
          }
          return i2;
        }
        return { applyRadius: t2, getLinkPath: { default: function(e2) {
          let { x1: i2, y1: n, x2: s, y2: o, width: r = 0, inverted: a = false, radius: h, parentVisible: l } = e2, d = [["M", i2, n], ["L", i2, n], ["C", i2, n, i2, o, i2, o], ["L", i2, o], ["C", i2, n, i2, o, i2, o], ["L", i2, o]];
          return l ? t2([["M", i2, n], ["L", i2 + r * (a ? -0.5 : 0.5), n], ["L", i2 + r * (a ? -0.5 : 0.5), o], ["L", s, o]], h) : d;
        }, straight: function(t3) {
          let { x1: e2, y1: i2, x2: n, y2: s, width: o = 0, inverted: r = false, parentVisible: a } = t3;
          return a ? [["M", e2, i2], ["L", e2 + o * (r ? -1 : 1), s], ["L", n, s]] : [["M", e2, i2], ["L", e2, s], ["L", e2, s]];
        }, curved: function(t3) {
          let { x1: e2, y1: i2, x2: n, y2: s, offset: o = 0, width: r = 0, inverted: a = false, parentVisible: h } = t3;
          return h ? [["M", e2, i2], ["C", e2 + o, i2, e2 - o + r * (a ? -1 : 1), s, e2 + r * (a ? -1 : 1), s], ["L", n, s]] : [["M", e2, i2], ["C", e2, i2, e2, s, e2, s], ["L", n, s]];
        } } };
      }), i(e, "Series/Organization/OrganizationSeries.js", [e["Series/Organization/OrganizationPoint.js"], e["Series/Organization/OrganizationSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Series/PathUtilities.js"], e["Core/Utilities.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Extensions/TextPath.js"]], function(t2, e2, i2, n, s, o, r) {
        let { sankey: a } = i2.seriesTypes, { css: h, crisp: l, extend: d, isNumber: p, merge: g, pick: u } = s;
        r.compose(o);
        class f extends a {
          alignDataLabel(t3, e3, i3) {
            let n2 = t3.shapeArgs;
            if (i3.useHTML && n2) {
              let t4 = this.options.borderWidth + 2 * this.options.dataLabels.padding, i4 = n2.width || 0, s2 = n2.height || 0;
              this.chart.inverted && (i4 = s2, s2 = n2.width || 0), s2 -= t4, i4 -= t4;
              let o2 = e3.text;
              o2 && (h(o2.element.parentNode, { width: i4 + "px", height: s2 + "px" }), h(o2.element, { left: 0, top: 0, width: "100%", height: "100%", overflow: "hidden" })), e3.getBBox = () => ({ width: i4, height: s2, x: 0, y: 0 }), e3.width = i4, e3.height = s2;
            }
            super.alignDataLabel.apply(this, arguments);
          }
          createNode(t3) {
            let e3 = super.createNode.call(this, t3);
            return e3.getSum = () => 1, e3;
          }
          pointAttribs(t3, e3) {
            let i3 = a.prototype.pointAttribs.call(this, t3, e3), n2 = t3.isNode ? t3.level : t3.fromNode.level, s2 = this.mapOptionsToLevel[n2 || 0] || {}, o2 = t3.options, r2 = s2.states && s2.states[e3] || {}, h2 = u(r2.borderRadius, o2.borderRadius, s2.borderRadius, this.options.borderRadius), l2 = u(r2.linkColor, o2.linkColor, s2.linkColor, this.options.linkColor, r2.link && r2.link.color, o2.link && o2.link.color, s2.link && s2.link.color, this.options.link && this.options.link.color), d2 = u(r2.linkLineWidth, o2.linkLineWidth, s2.linkLineWidth, this.options.linkLineWidth, r2.link && r2.link.lineWidth, o2.link && o2.link.lineWidth, s2.link && s2.link.lineWidth, this.options.link && this.options.link.lineWidth), g2 = u(r2.linkOpacity, o2.linkOpacity, s2.linkOpacity, this.options.linkOpacity, r2.link && r2.link.linkOpacity, o2.link && o2.link.linkOpacity, s2.link && s2.link.linkOpacity, this.options.link && this.options.link.linkOpacity);
            return t3.isNode ? p(h2) && (i3.r = h2) : (i3.stroke = l2, i3["stroke-width"] = d2, i3.opacity = g2, delete i3.fill), i3;
          }
          translateLink(t3) {
            let e3 = this.chart, i3 = this.options, s2 = t3.fromNode, o2 = t3.toNode, r2 = u(i3.linkLineWidth, i3.link.lineWidth, 0), a2 = u(i3.link.offset, 0.5), h2 = u(t3.options.link && t3.options.link.type, i3.link.type);
            if (s2.shapeArgs && o2.shapeArgs) {
              let d2 = i3.hangingIndent, p2 = "right" === i3.hangingSide, g2 = o2.options.offset, f2 = /%$/.test(g2) && parseInt(g2, 10), c = e3.inverted, k = l((s2.shapeArgs.x || 0) + (s2.shapeArgs.width || 0), r2), m = l((s2.shapeArgs.y || 0) + (s2.shapeArgs.height || 0) / 2, r2), y = l(o2.shapeArgs.x || 0, r2), L = l((o2.shapeArgs.y || 0) + (o2.shapeArgs.height || 0) / 2, r2), b;
              if (c && (k -= s2.shapeArgs.width || 0, y += o2.shapeArgs.width || 0), b = this.colDistance ? l(y + (c ? 1 : -1) * (this.colDistance - this.nodeWidth) / 2, r2) : l((y + k) / 2, r2), f2 && (f2 >= 50 || f2 <= -50) && (b = y = l(y + (c ? -0.5 : 0.5) * (o2.shapeArgs.width || 0), r2), L = o2.shapeArgs.y || 0, f2 > 0 && (L += o2.shapeArgs.height || 0)), o2.hangsFrom === s2 && (e3.inverted ? (m = p2 ? l((s2.shapeArgs.y || 0) + d2 / 2, r2) : l((s2.shapeArgs.y || 0) + (s2.shapeArgs.height || 0) - d2 / 2, r2), L = p2 ? (o2.shapeArgs.y || 0) + d2 / 2 : (o2.shapeArgs.y || 0) + (o2.shapeArgs.height || 0)) : m = l((s2.shapeArgs.y || 0) + d2 / 2, r2), b = y = l((o2.shapeArgs.x || 0) + (o2.shapeArgs.width || 0) / 2, r2)), t3.plotX = b, t3.plotY = (m + L) / 2, t3.shapeType = "path", "straight" === h2) t3.shapeArgs = { d: [["M", k, m], ["L", y, L]] };
              else if ("curved" === h2) {
                let e4 = Math.abs(y - k) * a2 * (c ? -1 : 1);
                t3.shapeArgs = { d: [["M", k, m], ["C", k + e4, m, y - e4, L, y, L]] };
              } else t3.shapeArgs = { d: n.applyRadius([["M", k, m], ["L", b, m], ["L", b, L], ["L", y, L]], u(i3.linkRadius, i3.link.radius)) };
              t3.dlBox = { x: (k + y) / 2, y: (m + L) / 2, height: r2, width: 0 };
            }
          }
          translateNode(t3, e3) {
            super.translateNode(t3, e3);
            let i3 = this.chart, n2 = this.options, s2 = Math.max(Math.round(t3.getSum() * this.translationFactor), n2.minLinkWidth || 0), o2 = "right" === n2.hangingSide, r2 = n2.hangingIndent || 0, a2 = n2.hangingIndentTranslation, h2 = n2.minNodeLength || 10, l2 = Math.round(this.nodeWidth), d2 = t3.shapeArgs, p2 = i3.inverted ? -1 : 1, u2 = t3.hangsFrom;
            if (u2) {
              if ("cumulative" === a2) for (d2.height -= r2, i3.inverted && !o2 && (d2.y -= p2 * r2); u2; ) d2.y += (o2 ? 1 : p2) * r2, u2 = u2.hangsFrom;
              else if ("shrink" === a2) for (; u2 && d2.height > r2 + h2; ) d2.height -= r2, (!i3.inverted || o2) && (d2.y += r2), u2 = u2.hangsFrom;
              else d2.height -= r2, (!i3.inverted || o2) && (d2.y += r2);
            }
            t3.nodeHeight = i3.inverted ? d2.width : d2.height, t3.shapeArgs && !t3.hangsFrom && (t3.shapeArgs = g(t3.shapeArgs, { x: (t3.shapeArgs.x || 0) + l2 / 2 - (t3.shapeArgs.width || 0) / 2, y: (t3.shapeArgs.y || 0) + s2 / 2 - (t3.shapeArgs.height || 0) / 2 }));
          }
          drawDataLabels() {
            let t3 = this.options.dataLabels;
            if (t3.linkTextPath && t3.linkTextPath.enabled) for (let t4 of this.points) t4.options.dataLabels = g(t4.options.dataLabels, { useHTML: false });
            super.drawDataLabels();
          }
        }
        return f.defaultOptions = g(a.defaultOptions, e2), d(f.prototype, { pointClass: t2 }), i2.registerSeriesType("organization", f), f;
      }), i(e, "masters/modules/organization.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_organization();
//# sourceMappingURL=highcharts_modules_organization__js.js.map
