import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/networkgraph.js
var require_networkgraph = __commonJS({
  "node_modules/highcharts/modules/networkgraph.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Force directed graph module
    *
    * (c) 2010-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/networkgraph", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, s, o) {
        e2.hasOwnProperty(i2) || (e2[i2] = o.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Series/DragNodesComposition.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { composed: i2 } = t2, { addEvent: s, pushUnique: o } = e2;
        function r() {
          let t3, e3, i3;
          let o2 = this;
          o2.container && (t3 = s(o2.container, "mousedown", (t4) => {
            let r2 = o2.hoverPoint;
            r2 && r2.series && r2.series.hasDraggableNodes && r2.series.options.draggable && (r2.series.onMouseDown(r2, t4), e3 = s(o2.container, "mousemove", (t5) => r2 && r2.series && r2.series.onMouseMove(r2, t5)), i3 = s(o2.container.ownerDocument, "mouseup", (t5) => (e3(), i3(), r2 && r2.series && r2.series.onMouseUp(r2, t5))));
          })), s(o2, "destroy", function() {
            t3();
          });
        }
        return { compose: function(t3) {
          o(i2, "DragNodes") && s(t3, "load", r);
        }, onMouseDown: function(t3, e3) {
          var _a;
          let i3 = ((_a = this.chart.pointer) == null ? void 0 : _a.normalize(e3)) || e3;
          t3.fixedPosition = { chartX: i3.chartX, chartY: i3.chartY, plotX: t3.plotX, plotY: t3.plotY }, t3.inDragMode = true;
        }, onMouseMove: function(t3, e3) {
          var _a;
          if (t3.fixedPosition && t3.inDragMode) {
            let i3, s2;
            let o2 = this.chart, r2 = ((_a = o2.pointer) == null ? void 0 : _a.normalize(e3)) || e3, a = t3.fixedPosition.chartX - r2.chartX, n = t3.fixedPosition.chartY - r2.chartY, h = o2.graphLayoutsLookup;
            (Math.abs(a) > 5 || Math.abs(n) > 5) && (i3 = t3.fixedPosition.plotX - a, s2 = t3.fixedPosition.plotY - n, o2.isInsidePlot(i3, s2) && (t3.plotX = i3, t3.plotY = s2, t3.hasDragged = true, this.redrawHalo(t3), h.forEach((t4) => {
              t4.restartSimulation();
            })));
          }
        }, onMouseUp: function(t3) {
          t3.fixedPosition && (t3.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), t3.inDragMode = t3.hasDragged = false, this.options.fixedDraggable || delete t3.fixedPosition);
        }, redrawHalo: function(t3) {
          t3 && this.halo && this.halo.attr({ d: t3.haloPath(this.options.states.hover.halo.size) });
        } };
      }), i(e, "Series/GraphLayoutComposition.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { setAnimation: s } = t2, { composed: o } = e2, { addEvent: r, pushUnique: a } = i2;
        function n() {
          this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach((t3) => {
            t3.updateSimulation();
          }), this.redraw());
        }
        function h() {
          this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach((t3) => {
            t3.updateSimulation(false);
          }), this.redraw());
        }
        function l() {
          this.graphLayoutsLookup && this.graphLayoutsLookup.forEach((t3) => {
            t3.stop();
          });
        }
        function d() {
          let t3, e3 = false, i3 = (i4) => {
            i4.maxIterations-- && isFinite(i4.temperature) && !i4.isStable() && !i4.enableSimulation && (i4.beforeStep && i4.beforeStep(), i4.step(), t3 = false, e3 = true);
          };
          if (this.graphLayoutsLookup) {
            for (s(false, this), this.graphLayoutsLookup.forEach((t4) => t4.start()); !t3; ) t3 = true, this.graphLayoutsLookup.forEach(i3);
            e3 && this.series.forEach((t4) => {
              t4 && t4.layout && t4.render();
            });
          }
        }
        return { compose: function(t3) {
          a(o, "GraphLayout") && (r(t3, "afterPrint", n), r(t3, "beforePrint", h), r(t3, "predraw", l), r(t3, "render", d));
        }, integrations: {}, layouts: {} };
      }), i(e, "Series/NodesComposition.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var i2;
        let { series: { prototype: s, prototype: { pointClass: { prototype: o } } } } = t2, { defined: r, extend: a, find: n, merge: h, pick: l } = e2;
        return function(t3) {
          function e3() {
            return this.data = [].concat(this.points || [], this.nodes), s.destroy.apply(this, arguments);
          }
          function i3() {
            this.nodes && (this.nodes.forEach((t4) => {
              t4.destroy();
            }), this.nodes.length = 0), s.setData.apply(this, arguments);
          }
          function d(t4) {
            let e4 = arguments, i4 = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode];
            "select" !== t4 && i4.forEach((t5) => {
              t5 && t5.series && (o.setState.apply(t5, e4), !t5.isNode && (t5.fromNode.graphic && o.setState.apply(t5.fromNode, e4), t5.toNode && t5.toNode.graphic && o.setState.apply(t5.toNode, e4)));
            }), o.setState.apply(this, e4);
          }
          function p(t4, e4, i4, s2) {
            let r2 = this.series.options.nodes, a2 = this.series.options.data, n2 = a2 && a2.length || 0, d2 = a2 && a2[this.index];
            if (o.update.call(this, t4, !this.isNode && e4, i4, s2), this.isNode) {
              let t5 = (r2 || []).reduce((t6, e5, i5) => this.id === e5.id ? i5 : t6, -1), s3 = h(r2 && r2[t5] || {}, a2 && a2[this.index] || {});
              a2 && (d2 ? a2[this.index] = d2 : a2.length = n2), r2 ? t5 >= 0 ? r2[t5] = s3 : r2.push(s3) : this.series.options.nodes = [s3], l(e4, true) && this.series.chart.redraw(i4);
            }
          }
          t3.compose = function(t4, s2) {
            let o2 = t4.prototype, r2 = s2.prototype;
            return o2.setNodeState = d, o2.setState = d, o2.update = p, r2.destroy = e3, r2.setData = i3, s2;
          }, t3.createNode = function(t4) {
            let e4 = this.pointClass, i4 = (t5, e5) => n(t5, (t6) => t6.id === e5), s2 = i4(this.nodes, t4), o2;
            if (!s2) {
              o2 = this.options.nodes && i4(this.options.nodes, t4);
              let r2 = new e4(this, a({ className: "highcharts-node", isNode: true, id: t4, y: 1 }, o2));
              r2.linksTo = [], r2.linksFrom = [], r2.getSum = function() {
                let t5 = 0, e5 = 0;
                return r2.linksTo.forEach((e6) => {
                  t5 += e6.weight || 0;
                }), r2.linksFrom.forEach((t6) => {
                  e5 += t6.weight || 0;
                }), Math.max(t5, e5);
              }, r2.offset = function(t5, e5) {
                let i5 = 0;
                for (let s3 = 0; s3 < r2[e5].length; s3++) {
                  if (r2[e5][s3] === t5) return i5;
                  i5 += r2[e5][s3].weight;
                }
              }, r2.hasShape = function() {
                let t5 = 0;
                return r2.linksTo.forEach((e5) => {
                  e5.outgoing && t5++;
                }), !r2.linksTo.length || t5 !== r2.linksTo.length;
              }, r2.index = this.nodes.push(r2) - 1, s2 = r2;
            }
            return s2.formatPrefix = "node", s2.name = s2.name || s2.options.id || "", s2.mass = l(s2.options.mass, s2.options.marker && s2.options.marker.radius, this.options.marker && this.options.marker.radius, 4), s2;
          }, t3.destroy = e3, t3.generatePoints = function() {
            let t4 = this.chart, e4 = {};
            s.generatePoints.call(this), this.nodes || (this.nodes = []), this.colorCounter = 0, this.nodes.forEach((t5) => {
              t5.linksFrom.length = 0, t5.linksTo.length = 0, t5.level = t5.options.level;
            }), this.points.forEach((i4) => {
              r(i4.from) && (e4[i4.from] || (e4[i4.from] = this.createNode(i4.from)), e4[i4.from].linksFrom.push(i4), i4.fromNode = e4[i4.from], t4.styledMode ? i4.colorIndex = l(i4.options.colorIndex, e4[i4.from].colorIndex) : i4.color = i4.options.color || e4[i4.from].color), r(i4.to) && (e4[i4.to] || (e4[i4.to] = this.createNode(i4.to)), e4[i4.to].linksTo.push(i4), i4.toNode = e4[i4.to]), i4.name = i4.name || i4.id;
            }, this), this.nodeLookup = e4;
          }, t3.setNodeState = d, t3.updateNode = p;
        }(i2 || (i2 = {})), i2;
      }), i(e, "Series/Networkgraph/NetworkgraphPoint.js", [e["Series/NodesComposition.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { series: { prototype: s, prototype: { pointClass: o } } } = e2, { addEvent: r, css: a, defined: n, extend: h, pick: l } = i2;
        class d extends o {
          destroy() {
            return this.isNode && this.linksFrom.concat(this.linksTo).forEach(function(t3) {
              t3.destroyElements && t3.destroyElements();
            }), this.series.layout.removeElementFromCollection(this, this.series.layout[this.isNode ? "nodes" : "links"]), o.prototype.destroy.apply(this, arguments);
          }
          getDegree() {
            let t3 = this.isNode ? this.linksFrom.length + this.linksTo.length : 0;
            return 0 === t3 ? 1 : t3;
          }
          getLinkAttributes() {
            let t3 = this.series.options.link, e3 = this.options;
            return { "stroke-width": l(e3.width, t3.width), stroke: e3.color || t3.color, dashstyle: e3.dashStyle || t3.dashStyle, opacity: l(e3.opacity, t3.opacity, 1) };
          }
          getLinkPath() {
            let t3 = this.fromNode, e3 = this.toNode;
            return t3.plotX > e3.plotX && (t3 = this.toNode, e3 = this.fromNode), [["M", t3.plotX || 0, t3.plotY || 0], ["L", e3.plotX || 0, e3.plotY || 0]];
          }
          getMass() {
            let t3 = this.fromNode.mass, e3 = this.toNode.mass, i3 = t3 + e3;
            return { fromNode: 1 - t3 / i3, toNode: 1 - e3 / i3 };
          }
          constructor(t3, e3, i3) {
            super(t3, e3, i3), this.series.options.draggable && !this.series.chart.styledMode && (r(this, "mouseOver", function() {
              a(this.series.chart.container, { cursor: "move" });
            }), r(this, "mouseOut", function() {
              a(this.series.chart.container, { cursor: "default" });
            }));
          }
          isValid() {
            return !this.isNode || n(this.id);
          }
          redrawLink() {
            let t3;
            let e3 = this.getLinkPath();
            if (this.graphic) {
              this.shapeArgs = { d: e3 }, this.series.chart.styledMode || (t3 = this.series.pointAttribs(this), this.graphic.attr(t3), (this.dataLabels || []).forEach(function(e4) {
                e4 && e4.attr({ opacity: t3.opacity });
              })), this.graphic.animate(this.shapeArgs);
              let i3 = e3[0], s2 = e3[1];
              "M" === i3[0] && "L" === s2[0] && (this.plotX = (i3[1] + s2[1]) / 2, this.plotY = (i3[2] + s2[2]) / 2);
            }
          }
          remove(t3, e3) {
            let i3 = this.series, o2 = i3.options.nodes || [], r2, a2 = o2.length;
            if (this.isNode) {
              for (i3.points = [], [].concat(this.linksFrom).concat(this.linksTo).forEach(function(t4) {
                (r2 = t4.fromNode.linksFrom.indexOf(t4)) > -1 && t4.fromNode.linksFrom.splice(r2, 1), (r2 = t4.toNode.linksTo.indexOf(t4)) > -1 && t4.toNode.linksTo.splice(r2, 1), s.removePoint.call(i3, i3.data.indexOf(t4), false, false);
              }), i3.points = i3.data.slice(), i3.nodes.splice(i3.nodes.indexOf(this), 1); a2--; ) if (o2[a2].id === this.options.id) {
                i3.options.nodes.splice(a2, 1);
                break;
              }
              this && this.destroy(), i3.isDirty = true, i3.isDirtyData = true, t3 && i3.chart.redraw(t3);
            } else i3.removePoint(i3.data.indexOf(this), t3, e3);
          }
          renderLink() {
            let t3;
            this.graphic || (this.graphic = this.series.chart.renderer.path(this.getLinkPath()).addClass(this.getClassName(), true).add(this.series.group), this.series.chart.styledMode || (t3 = this.series.pointAttribs(this), this.graphic.attr(t3), (this.dataLabels || []).forEach(function(e3) {
              e3 && e3.attr({ opacity: t3.opacity });
            })));
          }
        }
        return h(d.prototype, { setState: t2.setNodeState }), d;
      }), i(e, "Series/Networkgraph/NetworkgraphSeriesDefaults.js", [], function() {
        return { stickyTracking: false, inactiveOtherPoints: true, marker: { enabled: true, states: { inactive: { opacity: 0.3, animation: { duration: 50 } } } }, states: { inactive: { linkOpacity: 0.3, animation: { duration: 50 } } }, dataLabels: { formatter: function() {
          return this.key;
        }, linkFormatter: function() {
          return this.point.fromNode.name + "<br>" + this.point.toNode.name;
        }, linkTextPath: { enabled: true }, textPath: { enabled: false }, style: { transition: "opacity 2000ms" }, defer: true, animation: { defer: 1e3 } }, link: { color: "rgba(100, 100, 100, 0.5)", width: 1 }, draggable: true, layoutAlgorithm: { initialPositions: "circle", initialPositionRadius: 1, enableSimulation: false, theta: 0.5, maxSpeed: 10, approximation: "none", type: "reingold-fruchterman", integration: "euler", maxIterations: 1e3, gravitationalConstant: 0.0625, friction: -0.981 }, showInLegend: false };
      }), i(e, "Series/Networkgraph/EulerIntegration.js", [], function() {
        return { attractive: function(t2, e2, i2, s) {
          let o = t2.getMass(), r = i2.x / s * e2, a = i2.y / s * e2;
          t2.fromNode.fixedPosition || (t2.fromNode.dispX -= r * o.fromNode / t2.fromNode.degree, t2.fromNode.dispY -= a * o.fromNode / t2.fromNode.degree), t2.toNode.fixedPosition || (t2.toNode.dispX += r * o.toNode / t2.toNode.degree, t2.toNode.dispY += a * o.toNode / t2.toNode.degree);
        }, attractiveForceFunction: function(t2, e2) {
          return t2 * t2 / e2;
        }, barycenter: function() {
          let t2 = this.options.gravitationalConstant, e2 = this.barycenter.xFactor, i2 = this.barycenter.yFactor;
          this.nodes.forEach(function(s) {
            if (!s.fixedPosition) {
              let o = s.getDegree(), r = o * (1 + o / 2);
              s.dispX += (e2 - s.plotX) * t2 * r / s.degree, s.dispY += (i2 - s.plotY) * t2 * r / s.degree;
            }
          });
        }, getK: function(t2) {
          return Math.pow(t2.box.width * t2.box.height / t2.nodes.length, 0.3);
        }, integrate: function(t2, e2) {
          e2.dispX += e2.dispX * t2.options.friction, e2.dispY += e2.dispY * t2.options.friction;
          let i2 = e2.temperature = t2.vectorLength({ x: e2.dispX, y: e2.dispY });
          0 !== i2 && (e2.plotX += e2.dispX / i2 * Math.min(Math.abs(e2.dispX), t2.temperature), e2.plotY += e2.dispY / i2 * Math.min(Math.abs(e2.dispY), t2.temperature));
        }, repulsive: function(t2, e2, i2, s) {
          t2.dispX += i2.x / s * e2 / t2.degree, t2.dispY += i2.y / s * e2 / t2.degree;
        }, repulsiveForceFunction: function(t2, e2) {
          return e2 * e2 / t2;
        } };
      }), i(e, "Series/Networkgraph/QuadTreeNode.js", [], function() {
        class t2 {
          constructor(t3) {
            this.body = false, this.isEmpty = false, this.isInternal = false, this.nodes = [], this.box = t3, this.boxSize = Math.min(t3.width, t3.height);
          }
          divideBox() {
            let e2 = this.box.width / 2, i2 = this.box.height / 2;
            this.nodes[0] = new t2({ left: this.box.left, top: this.box.top, width: e2, height: i2 }), this.nodes[1] = new t2({ left: this.box.left + e2, top: this.box.top, width: e2, height: i2 }), this.nodes[2] = new t2({ left: this.box.left + e2, top: this.box.top + i2, width: e2, height: i2 }), this.nodes[3] = new t2({ left: this.box.left, top: this.box.top + i2, width: e2, height: i2 });
          }
          getBoxPosition(t3) {
            let e2 = t3.plotX < this.box.left + this.box.width / 2, i2 = t3.plotY < this.box.top + this.box.height / 2;
            return e2 ? i2 ? 0 : 3 : i2 ? 1 : 2;
          }
          insert(e2, i2) {
            let s;
            this.isInternal ? this.nodes[this.getBoxPosition(e2)].insert(e2, i2 - 1) : (this.isEmpty = false, this.body ? i2 ? (this.isInternal = true, this.divideBox(), true !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, i2 - 1), this.body = true), this.nodes[this.getBoxPosition(e2)].insert(e2, i2 - 1)) : ((s = new t2({ top: e2.plotX || NaN, left: e2.plotY || NaN, width: 0.1, height: 0.1 })).body = e2, s.isInternal = false, this.nodes.push(s)) : (this.isInternal = false, this.body = e2));
          }
          updateMassAndCenter() {
            let t3 = 0, e2 = 0, i2 = 0;
            if (this.isInternal) {
              for (let s of this.nodes) s.isEmpty || (t3 += s.mass, e2 += s.plotX * s.mass, i2 += s.plotY * s.mass);
              e2 /= t3, i2 /= t3;
            } else this.body && (t3 = this.body.mass, e2 = this.body.plotX, i2 = this.body.plotY);
            this.mass = t3, this.plotX = e2, this.plotY = i2;
          }
        }
        return t2;
      }), i(e, "Series/Networkgraph/QuadTree.js", [e["Series/Networkgraph/QuadTreeNode.js"]], function(t2) {
        return class {
          constructor(e2, i2, s, o) {
            this.box = { left: e2, top: i2, width: s, height: o }, this.maxDepth = 25, this.root = new t2(this.box), this.root.isInternal = true, this.root.isRoot = true, this.root.divideBox();
          }
          calculateMassAndCenter() {
            this.visitNodeRecursive(null, null, function(t3) {
              t3.updateMassAndCenter();
            });
          }
          insertNodes(t3) {
            for (let e2 of t3) this.root.insert(e2, this.maxDepth);
          }
          visitNodeRecursive(t3, e2, i2) {
            let s;
            if (t3 || (t3 = this.root), t3 === this.root && e2 && (s = e2(t3)), false !== s) {
              for (let o of t3.nodes) {
                if (o.isInternal) {
                  if (e2 && (s = e2(o)), false === s) continue;
                  this.visitNodeRecursive(o, e2, i2);
                } else o.body && e2 && e2(o.body);
                i2 && i2(o);
              }
              t3 === this.root && i2 && i2(t3);
            }
          }
        };
      }), i(e, "Series/Networkgraph/VerletIntegration.js", [], function() {
        return { attractive: function(t2, e2, i2) {
          let s = t2.getMass(), o = -i2.x * e2 * this.diffTemperature, r = -i2.y * e2 * this.diffTemperature;
          t2.fromNode.fixedPosition || (t2.fromNode.plotX -= o * s.fromNode / t2.fromNode.degree, t2.fromNode.plotY -= r * s.fromNode / t2.fromNode.degree), t2.toNode.fixedPosition || (t2.toNode.plotX += o * s.toNode / t2.toNode.degree, t2.toNode.plotY += r * s.toNode / t2.toNode.degree);
        }, attractiveForceFunction: function(t2, e2) {
          return (e2 - t2) / t2;
        }, barycenter: function() {
          let t2 = this.options.gravitationalConstant || 0, e2 = (this.barycenter.xFactor - (this.box.left + this.box.width) / 2) * t2, i2 = (this.barycenter.yFactor - (this.box.top + this.box.height) / 2) * t2;
          this.nodes.forEach(function(t3) {
            t3.fixedPosition || (t3.plotX -= e2 / t3.mass / t3.degree, t3.plotY -= i2 / t3.mass / t3.degree);
          });
        }, getK: function(t2) {
          return Math.pow(t2.box.width * t2.box.height / t2.nodes.length, 0.5);
        }, integrate: function(t2, e2) {
          let i2 = -t2.options.friction, s = t2.options.maxSpeed, o = e2.prevX, r = e2.prevY, a = (e2.plotX + e2.dispX - o) * i2, n = (e2.plotY + e2.dispY - r) * i2, h = Math.abs, l = h(a) / (a || 1), d = h(n) / (n || 1), p = l * Math.min(s, Math.abs(a)), u = d * Math.min(s, Math.abs(n));
          e2.prevX = e2.plotX + e2.dispX, e2.prevY = e2.plotY + e2.dispY, e2.plotX += p, e2.plotY += u, e2.temperature = t2.vectorLength({ x: p, y: u });
        }, repulsive: function(t2, e2, i2) {
          let s = e2 * this.diffTemperature / t2.mass / t2.degree;
          t2.fixedPosition || (t2.plotX += i2.x * s, t2.plotY += i2.y * s);
        }, repulsiveForceFunction: function(t2, e2) {
          return (e2 - t2) / t2 * (e2 > t2 ? 1 : 0);
        } };
      }), i(e, "Series/Networkgraph/ReingoldFruchtermanLayout.js", [e["Series/Networkgraph/EulerIntegration.js"], e["Core/Globals.js"], e["Series/GraphLayoutComposition.js"], e["Series/Networkgraph/QuadTree.js"], e["Core/Utilities.js"], e["Series/Networkgraph/VerletIntegration.js"]], function(t2, e2, i2, s, o, r) {
        let { win: a } = e2, { clamp: n, defined: h, isFunction: l, fireEvent: d, pick: p } = o;
        class u {
          constructor() {
            this.box = {}, this.currentStep = 0, this.initialRendering = true, this.links = [], this.nodes = [], this.series = [], this.simulation = false;
          }
          static compose(e3) {
            i2.compose(e3), i2.integrations.euler = t2, i2.integrations.verlet = r, i2.layouts["reingold-fruchterman"] = u;
          }
          init(t3) {
            this.options = t3, this.nodes = [], this.links = [], this.series = [], this.box = { x: 0, y: 0, width: 0, height: 0 }, this.setInitialRendering(true), this.integration = i2.integrations[t3.integration], this.enableSimulation = t3.enableSimulation, this.attractiveForce = p(t3.attractiveForce, this.integration.attractiveForceFunction), this.repulsiveForce = p(t3.repulsiveForce, this.integration.repulsiveForceFunction), this.approximation = t3.approximation;
          }
          updateSimulation(t3) {
            this.enableSimulation = p(t3, this.options.enableSimulation);
          }
          start() {
            let t3 = this.series, e3 = this.options;
            this.currentStep = 0, this.forces = t3[0] && t3[0].forces || [], this.chart = t3[0] && t3[0].chart, this.initialRendering && (this.initPositions(), t3.forEach(function(t4) {
              t4.finishedAnimating = true, t4.render();
            })), this.setK(), this.resetSimulation(e3), this.enableSimulation && this.step();
          }
          step() {
            let t3 = this.series;
            for (let t4 of (this.currentStep++, "barnes-hut" === this.approximation && (this.createQuadTree(), this.quadTree.calculateMassAndCenter()), this.forces || [])) this[t4 + "Forces"](this.temperature);
            if (this.applyLimits(), this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep), this.prevSystemTemperature = this.systemTemperature, this.systemTemperature = this.getSystemTemperature(), this.enableSimulation) {
              for (let e3 of t3) e3.chart && e3.render();
              this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && a.cancelAnimationFrame(this.simulation), this.simulation = a.requestAnimationFrame(() => this.step())) : (this.simulation = false, this.series.forEach((t4) => {
                d(t4, "afterSimulation");
              }));
            }
          }
          stop() {
            this.simulation && a.cancelAnimationFrame(this.simulation);
          }
          setArea(t3, e3, i3, s2) {
            this.box = { left: t3, top: e3, width: i3, height: s2 };
          }
          setK() {
            this.k = this.options.linkLength || this.integration.getK(this);
          }
          addElementsToCollection(t3, e3) {
            for (let i3 of t3) -1 === e3.indexOf(i3) && e3.push(i3);
          }
          removeElementFromCollection(t3, e3) {
            let i3 = e3.indexOf(t3);
            -1 !== i3 && e3.splice(i3, 1);
          }
          clear() {
            this.nodes.length = 0, this.links.length = 0, this.series.length = 0, this.resetSimulation();
          }
          resetSimulation() {
            this.forcedStop = false, this.systemTemperature = 0, this.setMaxIterations(), this.setTemperature(), this.setDiffTemperature();
          }
          restartSimulation() {
            this.simulation ? this.resetSimulation() : (this.setInitialRendering(false), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(true));
          }
          setMaxIterations(t3) {
            this.maxIterations = p(t3, this.options.maxIterations);
          }
          setTemperature() {
            this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
          }
          setDiffTemperature() {
            this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
          }
          setInitialRendering(t3) {
            this.initialRendering = t3;
          }
          createQuadTree() {
            this.quadTree = new s(this.box.left, this.box.top, this.box.width, this.box.height), this.quadTree.insertNodes(this.nodes);
          }
          initPositions() {
            let t3 = this.options.initialPositions;
            if (l(t3)) for (let e3 of (t3.call(this), this.nodes)) h(e3.prevX) || (e3.prevX = e3.plotX), h(e3.prevY) || (e3.prevY = e3.plotY), e3.dispX = 0, e3.dispY = 0;
            else "circle" === t3 ? this.setCircularPositions() : this.setRandomPositions();
          }
          setCircularPositions() {
            let t3;
            let e3 = this.box, i3 = this.nodes, s2 = 2 * Math.PI / (i3.length + 1), o2 = i3.filter(function(t4) {
              return 0 === t4.linksTo.length;
            }), r2 = {}, a2 = this.options.initialPositionRadius, n2 = (t4) => {
              for (let e4 of t4.linksFrom || []) r2[e4.toNode.id] || (r2[e4.toNode.id] = true, h2.push(e4.toNode), n2(e4.toNode));
            }, h2 = [];
            for (let t4 of o2) h2.push(t4), n2(t4);
            if (h2.length) for (let t4 of i3) -1 === h2.indexOf(t4) && h2.push(t4);
            else h2 = i3;
            for (let i4 = 0, o3 = h2.length; i4 < o3; ++i4) (t3 = h2[i4]).plotX = t3.prevX = p(t3.plotX, e3.width / 2 + a2 * Math.cos(i4 * s2)), t3.plotY = t3.prevY = p(t3.plotY, e3.height / 2 + a2 * Math.sin(i4 * s2)), t3.dispX = 0, t3.dispY = 0;
          }
          setRandomPositions() {
            let t3;
            let e3 = this.box, i3 = this.nodes, s2 = i3.length + 1, o2 = (t4) => {
              let e4 = t4 * t4 / Math.PI;
              return e4 - Math.floor(e4);
            };
            for (let r2 = 0, a2 = i3.length; r2 < a2; ++r2) (t3 = i3[r2]).plotX = t3.prevX = p(t3.plotX, e3.width * o2(r2)), t3.plotY = t3.prevY = p(t3.plotY, e3.height * o2(s2 + r2)), t3.dispX = 0, t3.dispY = 0;
          }
          force(t3, ...e3) {
            this.integration[t3].apply(this, e3);
          }
          barycenterForces() {
            this.getBarycenter(), this.force("barycenter");
          }
          getBarycenter() {
            let t3 = 0, e3 = 0, i3 = 0;
            for (let s2 of this.nodes) e3 += s2.plotX * s2.mass, i3 += s2.plotY * s2.mass, t3 += s2.mass;
            return this.barycenter = { x: e3, y: i3, xFactor: e3 / t3, yFactor: i3 / t3 }, this.barycenter;
          }
          barnesHutApproximation(t3, e3) {
            let i3, s2;
            let o2 = this.getDistXY(t3, e3), r2 = this.vectorLength(o2);
            return t3 !== e3 && 0 !== r2 && (e3.isInternal ? e3.boxSize / r2 < this.options.theta && 0 !== r2 ? (s2 = this.repulsiveForce(r2, this.k), this.force("repulsive", t3, s2 * e3.mass, o2, r2), i3 = false) : i3 = true : (s2 = this.repulsiveForce(r2, this.k), this.force("repulsive", t3, s2 * e3.mass, o2, r2))), i3;
          }
          repulsiveForces() {
            if ("barnes-hut" === this.approximation) for (let t3 of this.nodes) this.quadTree.visitNodeRecursive(null, (e3) => this.barnesHutApproximation(t3, e3));
            else {
              let t3, e3, i3;
              for (let s2 of this.nodes) for (let o2 of this.nodes) s2 === o2 || s2.fixedPosition || (i3 = this.getDistXY(s2, o2), 0 !== (e3 = this.vectorLength(i3)) && (t3 = this.repulsiveForce(e3, this.k), this.force("repulsive", s2, t3 * o2.mass, i3, e3)));
            }
          }
          attractiveForces() {
            let t3, e3, i3;
            for (let s2 of this.links) s2.fromNode && s2.toNode && (t3 = this.getDistXY(s2.fromNode, s2.toNode), 0 !== (e3 = this.vectorLength(t3)) && (i3 = this.attractiveForce(e3, this.k), this.force("attractive", s2, i3, t3, e3)));
          }
          applyLimits() {
            for (let t3 of this.nodes) t3.fixedPosition || (this.integration.integrate(this, t3), this.applyLimitBox(t3, this.box), t3.dispX = 0, t3.dispY = 0);
          }
          applyLimitBox(t3, e3) {
            let i3 = t3.radius;
            t3.plotX = n(t3.plotX, e3.left + i3, e3.width - i3), t3.plotY = n(t3.plotY, e3.top + i3, e3.height - i3);
          }
          coolDown(t3, e3, i3) {
            return t3 - e3 * i3;
          }
          isStable() {
            return 1e-5 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || this.temperature <= 0;
          }
          getSystemTemperature() {
            let t3 = 0;
            for (let e3 of this.nodes) t3 += e3.temperature;
            return t3;
          }
          vectorLength(t3) {
            return Math.sqrt(t3.x * t3.x + t3.y * t3.y);
          }
          getDistR(t3, e3) {
            let i3 = this.getDistXY(t3, e3);
            return this.vectorLength(i3);
          }
          getDistXY(t3, e3) {
            let i3 = t3.plotX - e3.plotX, s2 = t3.plotY - e3.plotY;
            return { x: i3, y: s2, absX: Math.abs(i3), absY: Math.abs(s2) };
          }
        }
        return u;
      }), i(e, "Series/SimulationSeriesUtilities.js", [e["Core/Utilities.js"], e["Core/Animation/AnimationUtilities.js"]], function(t2, e2) {
        let { merge: i2, syncTimeout: s } = t2, { animObject: o } = e2;
        return { initDataLabels: function() {
          let t3 = this.options.dataLabels;
          if (!this.dataLabelsGroup) {
            let e3 = this.initDataLabelsGroup();
            return !this.chart.styledMode && (t3 == null ? void 0 : t3.style) && e3.css(t3.style), e3.attr({ opacity: 0 }), this.visible && e3.show(), e3;
          }
          return this.dataLabelsGroup.attr(i2({ opacity: 1 }, this.getPlotBox("data-labels"))), this.dataLabelsGroup;
        }, initDataLabelsDefer: function() {
          var _a;
          let t3 = this.options.dataLabels;
          (t3 == null ? void 0 : t3.defer) && ((_a = this.options.layoutAlgorithm) == null ? void 0 : _a.enableSimulation) ? s(() => {
            this.deferDataLabels = false;
          }, t3 ? o(t3.animation).defer : 0) : this.deferDataLabels = false;
        } };
      }), i(e, "Extensions/TextPath.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { deg2rad: i2 } = t2, { addEvent: s, merge: o, uniqueKey: r, defined: a, extend: n } = e2;
        function h(t3, e3) {
          e3 = o(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, e3);
          let i3 = this.renderer.url, h2 = this.text || this, l2 = h2.textPath, { attributes: d2, enabled: p } = e3;
          if (t3 = t3 || l2 && l2.path, l2 && l2.undo(), t3 && p) {
            let e4 = s(h2, "afterModifyTree", (e5) => {
              if (t3 && p) {
                let s2 = t3.attr("id");
                s2 || t3.attr("id", s2 = r());
                let o2 = { x: 0, y: 0 };
                a(d2.dx) && (o2.dx = d2.dx, delete d2.dx), a(d2.dy) && (o2.dy = d2.dy, delete d2.dy), h2.attr(o2), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy());
                let l3 = e5.nodes.slice(0);
                e5.nodes.length = 0, e5.nodes[0] = { tagName: "textPath", attributes: n(d2, { "text-anchor": d2.textAnchor, href: `${i3}#${s2}` }), children: l3 };
              }
            });
            h2.textPath = { path: t3, undo: e4 };
          } else h2.attr({ dx: 0, dy: 0 }), delete h2.textPath;
          return this.added && (h2.textCache = "", this.renderer.buildText(h2)), this;
        }
        function l(t3) {
          var _a;
          let e3 = t3.bBox, s2 = (_a = this.element) == null ? void 0 : _a.querySelector("textPath");
          if (s2) {
            let t4 = [], { b: o2, h: r2 } = this.renderer.fontMetrics(this.element), a2 = r2 - o2, n2 = RegExp('(<tspan>|<tspan(?!\\sclass="highcharts-br")[^>]*>|<\\/tspan>)', "g"), h2 = s2.innerHTML.replace(n2, "").split(/<tspan class="highcharts-br"[^>]*>/), l2 = h2.length, d2 = (t5, e4) => {
              let { x: r3, y: n3 } = e4, h3 = (s2.getRotationOfChar(t5) - 90) * i2, l3 = Math.cos(h3), d3 = Math.sin(h3);
              return [[r3 - a2 * l3, n3 - a2 * d3], [r3 + o2 * l3, n3 + o2 * d3]];
            };
            for (let e4 = 0, i3 = 0; i3 < l2; i3++) {
              let o3 = h2[i3].length;
              for (let r3 = 0; r3 < o3; r3 += 5) try {
                let o4 = e4 + r3 + i3, [a3, n3] = d2(o4, s2.getStartPositionOfChar(o4));
                0 === r3 ? (t4.push(n3), t4.push(a3)) : (0 === i3 && t4.unshift(n3), i3 === l2 - 1 && t4.push(a3));
              } catch (t5) {
                break;
              }
              e4 += o3 - 1;
              try {
                let o4 = e4 + i3, r3 = s2.getEndPositionOfChar(o4), [a3, n3] = d2(o4, r3);
                t4.unshift(n3), t4.unshift(a3);
              } catch (t5) {
                break;
              }
            }
            t4.length && t4.push(t4[0].slice()), e3.polygon = t4;
          }
          return e3;
        }
        function d(t3) {
          var _a;
          let e3 = t3.labelOptions, i3 = t3.point, s2 = e3[i3.formatPrefix + "TextPath"] || e3.textPath;
          s2 && !e3.useHTML && (this.setTextPath(((_a = i3.getDataLabelPath) == null ? void 0 : _a.call(i3, this)) || i3.graphic, s2), i3.dataLabelPath && !s2.enabled && (i3.dataLabelPath = i3.dataLabelPath.destroy()));
        }
        return { compose: function(t3) {
          s(t3, "afterGetBBox", l), s(t3, "beforeAddingDataLabel", d);
          let e3 = t3.prototype;
          e3.setTextPath || (e3.setTextPath = h);
        } };
      }), i(e, "Series/Networkgraph/NetworkgraphSeries.js", [e["Core/Renderer/SVG/SVGElement.js"], e["Series/DragNodesComposition.js"], e["Series/GraphLayoutComposition.js"], e["Core/Globals.js"], e["Series/Networkgraph/NetworkgraphPoint.js"], e["Series/Networkgraph/NetworkgraphSeriesDefaults.js"], e["Series/NodesComposition.js"], e["Series/Networkgraph/ReingoldFruchtermanLayout.js"], e["Core/Series/SeriesRegistry.js"], e["Series/SimulationSeriesUtilities.js"], e["Core/Utilities.js"], e["Extensions/TextPath.js"]], function(t2, e2, i2, s, o, r, a, n, h, l, d, p) {
        let { noop: u } = s, { series: c, seriesTypes: { column: { prototype: f }, line: { prototype: m } } } = h, { initDataLabels: g, initDataLabelsDefer: y } = l, { addEvent: b, defined: x, extend: N, merge: k, pick: S } = d;
        p.compose(t2);
        class w extends c {
          constructor() {
            super(...arguments), this.deferDataLabels = true;
          }
          static compose(t3) {
            e2.compose(t3), n.compose(t3);
          }
          deferLayout() {
            let t3 = this.options.layoutAlgorithm, e3 = this.chart.options.chart, s2, o2 = this.chart.graphLayoutsStorage, r2 = this.chart.graphLayoutsLookup;
            this.visible && (o2 || (this.chart.graphLayoutsStorage = o2 = {}, this.chart.graphLayoutsLookup = r2 = []), (s2 = o2[t3.type]) || (t3.enableSimulation = x(e3.forExport) ? !e3.forExport : t3.enableSimulation, o2[t3.type] = s2 = new i2.layouts[t3.type](), s2.init(t3), r2.splice(s2.index, 0, s2)), this.layout = s2, s2.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight), s2.addElementsToCollection([this], s2.series), s2.addElementsToCollection(this.nodes, s2.nodes), s2.addElementsToCollection(this.points, s2.links));
          }
          destroy() {
            this.layout && this.layout.removeElementFromCollection(this, this.layout.series), a.destroy.call(this);
          }
          drawDataLabels() {
            let t3;
            if (this.deferDataLabels) return;
            let e3 = this.options.dataLabels;
            (e3 == null ? void 0 : e3.textPath) && (t3 = e3.textPath), c.prototype.drawDataLabels.call(this, this.nodes), (e3 == null ? void 0 : e3.linkTextPath) && (e3.textPath = e3.linkTextPath), c.prototype.drawDataLabels.call(this, this.data), (e3 == null ? void 0 : e3.textPath) && (e3.textPath = t3);
          }
          generatePoints() {
            let t3, e3;
            for (a.generatePoints.apply(this, arguments), this.options.nodes && this.options.nodes.forEach(function(t4) {
              this.nodeLookup[t4.id] || (this.nodeLookup[t4.id] = this.createNode(t4.id));
            }, this), e3 = this.nodes.length - 1; e3 >= 0; e3--) (t3 = this.nodes[e3]).degree = t3.getDegree(), t3.radius = S(t3.marker && t3.marker.radius, this.options.marker && this.options.marker.radius, 0), this.nodeLookup[t3.id] || t3.remove();
            this.data.forEach(function(t4) {
              t4.formatPrefix = "link";
            }), this.indexateNodes();
          }
          getPointsCollection() {
            return this.nodes || [];
          }
          indexateNodes() {
            this.nodes.forEach(function(t3, e3) {
              t3.index = e3;
            });
          }
          init(t3, e3) {
            return super.init(t3, e3), y.call(this), b(this, "updatedData", () => {
              this.layout && this.layout.stop();
            }), b(this, "afterUpdate", () => {
              this.nodes.forEach((t4) => {
                t4 && t4.series && t4.resolveColor();
              });
            }), b(this, "afterSimulation", function() {
              this.deferDataLabels = false, this.drawDataLabels();
            }), this;
          }
          markerAttribs(t3, e3) {
            let i3 = c.prototype.markerAttribs.call(this, t3, e3);
            return x(t3.plotY) || (i3.y = 0), i3.x = (t3.plotX || 0) - (i3.width || 0) / 2, i3;
          }
          pointAttribs(t3, e3) {
            let i3 = e3 || t3 && t3.state || "normal", s2 = this.options.states[i3], o2 = c.prototype.pointAttribs.call(this, t3, i3);
            return t3 && !t3.isNode && (o2 = t3.getLinkAttributes(), s2 && (o2 = { stroke: s2.linkColor || o2.stroke, dashstyle: s2.linkDashStyle || o2.dashstyle, opacity: S(s2.linkOpacity, o2.opacity), "stroke-width": s2.linkColor || o2["stroke-width"] })), o2;
          }
          render() {
            let t3 = this.points, e3 = this.chart.hoverPoint, i3 = [];
            this.points = this.nodes, m.render.call(this), this.points = t3, t3.forEach(function(t4) {
              t4.fromNode && t4.toNode && (t4.renderLink(), t4.redrawLink());
            }), e3 && e3.series === this && this.redrawHalo(e3), this.chart.hasRendered && !this.options.dataLabels.allowOverlap && (this.nodes.concat(this.points).forEach(function(t4) {
              t4.dataLabel && i3.push(t4.dataLabel);
            }), this.chart.hideOverlappingLabels(i3));
          }
          setState(t3, e3) {
            e3 ? (this.points = this.nodes.concat(this.data), c.prototype.setState.apply(this, arguments), this.points = this.data) : c.prototype.setState.apply(this, arguments), this.layout.simulation || t3 || this.render();
          }
          translate() {
            this.processedXData || this.processData(), this.generatePoints(), this.deferLayout(), this.nodes.forEach(function(t3) {
              t3.isInside = true, t3.linksFrom.forEach(function(t4) {
                t4.shapeType = "path", t4.y = 1;
              });
            });
          }
        }
        return w.defaultOptions = k(c.defaultOptions, r), N(w.prototype, { pointClass: o, animate: void 0, directTouch: true, drawGraph: void 0, forces: ["barycenter", "repulsive", "attractive"], hasDraggableNodes: true, isCartesian: false, noSharedTooltip: true, pointArrayMap: ["from", "to"], requireSorting: false, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], initDataLabels: g, buildKDTree: u, createNode: a.createNode, drawTracker: f.drawTracker, onMouseDown: e2.onMouseDown, onMouseMove: e2.onMouseMove, onMouseUp: e2.onMouseUp, redrawHalo: e2.redrawHalo }), h.registerSeriesType("networkgraph", w), w;
      }), i(e, "masters/modules/networkgraph.src.js", [e["Core/Globals.js"], e["Series/Networkgraph/NetworkgraphSeries.js"]], function(t2, e2) {
        return e2.compose(t2.Chart), t2;
      });
    });
  }
});
export default require_networkgraph();
//# sourceMappingURL=highcharts_modules_networkgraph__js.js.map
