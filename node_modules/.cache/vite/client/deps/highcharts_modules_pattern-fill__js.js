import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/pattern-fill.js
var require_pattern_fill = __commonJS({
  "node_modules/highcharts/modules/pattern-fill.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Module for adding patterns and images as point fills.
    *
    * (c) 2010-2024 Highsoft AS
    * Author: Torstein Hønsi, Øystein Moseng
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/pattern-fill", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, r, a) {
        e2.hasOwnProperty(i2) || (e2[i2] = a.apply(null, r), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Extensions/PatternFill.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { animObject: r } = t2, { getOptions: a } = e2, { addEvent: n, defined: o, erase: s, extend: h, merge: l, pick: p, removeEvent: c, wrap: d } = i2, f = function() {
          let t3 = [], e3 = a().colors, i3 = 0;
          for (let r2 of ["M 0 0 L 5 5 M 4.5 -0.5 L 5.5 0.5 M -0.5 4.5 L 0.5 5.5", "M 0 5 L 5 0 M -0.5 0.5 L 0.5 -0.5 M 4.5 5.5 L 5.5 4.5", "M 2 0 L 2 5 M 4 0 L 4 5", "M 0 2 L 5 2 M 0 4 L 5 4", "M 0 1.5 L 2.5 1.5 L 2.5 0 M 2.5 5 L 2.5 3.5 L 5 3.5"]) t3.push({ path: r2, color: e3[i3++], width: 5, height: 5, patternTransform: "scale(1.4 1.4)" });
          for (let r2 of (i3 = 5, ["M 0 0 L 5 10 L 10 0", "M 3 3 L 8 3 L 8 8 L 3 8 Z", "M 5 5 m -4 0 a 4 4 0 1 1 8 0 a 4 4 0 1 1 -8 0", "M 0 0 L 10 10 M 9 -1 L 11 1 M -1 9 L 1 11", "M 0 10 L 10 0 M -1 1 L 1 -1 M 9 11 L 11 9"])) t3.push({ path: r2, color: e3[i3], width: 10, height: 10 }), i3 += 5;
          return t3;
        }();
        function u(t3, e3) {
          let i3 = JSON.stringify(t3), r2 = i3.length || 0, a2 = 0, n2 = 0, o2;
          if (e3) {
            o2 = Math.max(Math.floor(r2 / 500), 1);
            for (let t4 = 0; t4 < r2; t4 += o2) a2 += i3.charCodeAt(t4);
            a2 &= a2;
          }
          for (; n2 < r2; ++n2) a2 = (a2 << 5) - a2 + i3.charCodeAt(n2), a2 &= a2;
          return a2.toString(16).replace("-", "1");
        }
        function g() {
          if (this.renderer && (this.renderer.defIds || []).filter((t3) => t3 && t3.indexOf && 0 === t3.indexOf("highcharts-pattern-")).length) {
            for (let t3 of this.series) if (t3.visible) for (let e3 of t3.points) {
              let t4 = e3.options && e3.options.color;
              t4 && t4.pattern && (t4.pattern._width = "defer", t4.pattern._height = "defer");
            }
            this.redraw(false);
          }
        }
        function m() {
          let t3 = {}, e3 = this.renderer, i3 = (e3.defIds || []).filter((t4) => t4.indexOf && 0 === t4.indexOf("highcharts-pattern-"));
          if (i3.length) for (let r2 of ([].forEach.call(this.renderTo.querySelectorAll('[color^="url("], [fill^="url("], [stroke^="url("]'), (i4) => {
            let r3 = i4.getAttribute("fill") || i4.getAttribute("color") || i4.getAttribute("stroke");
            r3 && (t3[r3.replace(e3.url, "").replace("url(#", "").replace(")", "")] = true);
          }), i3)) !t3[r2] && (s(e3.defIds, r2), e3.patternElements[r2] && (e3.patternElements[r2].destroy(), delete e3.patternElements[r2]));
        }
        function y() {
          let t3 = this.options.color;
          t3 && t3.pattern && ("string" == typeof t3.pattern.path && (t3.pattern.path = { d: t3.pattern.path }), this.color = this.options.color = l(this.series.options.color, t3));
        }
        function x(t3) {
          let e3 = t3.args[0], i3 = t3.args[1], r2 = t3.args[2], a2 = this.chartIndex || 0, n2 = e3.pattern, o2 = "#333333";
          if (void 0 !== e3.patternIndex && f && (n2 = f[e3.patternIndex]), !n2) return true;
          if (n2.image || "string" == typeof n2.path || n2.path && n2.path.d) {
            let t4 = r2.parentNode && r2.parentNode.getAttribute("class");
            t4 = t4 && t4.indexOf("highcharts-legend") > -1, ("defer" === n2._width || "defer" === n2._height) && M.call({ graphic: { element: r2 } }, n2), (t4 || !n2.id) && ((n2 = l({}, n2)).id = "highcharts-pattern-" + a2 + "-" + u(n2) + u(n2, true)), this.addPattern(n2, !this.forExport && p(n2.animation, this.globalAnimation, { duration: 100 })), o2 = `url(${this.url}#${n2.id + (this.forExport ? "-export" : "")})`;
          } else o2 = n2.color || o2;
          return r2.setAttribute(i3, o2), e3.toString = function() {
            return o2;
          }, false;
        }
        function w() {
          let t3 = this.chart.isResizing;
          if (this.isDirtyData || t3 || !this.chart.hasRendered) for (let e3 of this.points) {
            let i3 = e3.options && e3.options.color;
            i3 && i3.pattern && (t3 && !(e3.shapeArgs && e3.shapeArgs.width && e3.shapeArgs.height) ? (i3.pattern._width = "defer", i3.pattern._height = "defer") : e3.calculatePatternDimensions(i3.pattern));
          }
        }
        function M(t3) {
          if (t3.width && t3.height) return;
          let e3 = this.graphic && (this.graphic.getBBox && this.graphic.getBBox(true) || this.graphic.element && this.graphic.element.getBBox()) || {}, i3 = this.shapeArgs;
          if (i3 && (e3.width = i3.width || e3.width, e3.height = i3.height || e3.height, e3.x = i3.x || e3.x, e3.y = i3.y || e3.y), t3.image) {
            if (!e3.width || !e3.height) {
              t3._width = "defer", t3._height = "defer";
              let e4 = this.series.chart.mapView && this.series.chart.mapView.getSVGTransform().scaleY;
              o(e4) && e4 < 0 && (t3._inverted = true);
              return;
            }
            t3.aspectRatio && (e3.aspectRatio = e3.width / e3.height, t3.aspectRatio > e3.aspectRatio ? e3.aspectWidth = e3.height * t3.aspectRatio : e3.aspectHeight = e3.width / t3.aspectRatio), t3._width = t3.width || Math.ceil(e3.aspectWidth || e3.width), t3._height = t3.height || Math.ceil(e3.aspectHeight || e3.height);
          }
          t3.width || (t3._x = t3.x || 0, t3._x += e3.x - Math.round(e3.aspectWidth ? Math.abs(e3.aspectWidth - e3.width) / 2 : 0)), t3.height || (t3._y = t3.y || 0, t3._y += e3.y - Math.round(e3.aspectHeight ? Math.abs(e3.aspectHeight - e3.height) / 2 : 0));
        }
        function L(t3, e3) {
          let a2 = p(e3, true), n2 = r(a2), o2 = t3.color || "#333333", s2 = t3.height || ("number" == typeof t3._height ? t3._height : 0) || 32, h2 = t3.width || ("number" == typeof t3._width ? t3._width : 0) || 32, l2, d2 = t3.id, f2;
          if (!d2 && (this.idCounter = this.idCounter || 0, d2 = "highcharts-pattern-" + this.idCounter + "-" + (this.chartIndex || 0), ++this.idCounter), this.forExport && (d2 += "-export"), this.defIds = this.defIds || [], this.defIds.indexOf(d2) > -1) return;
          this.defIds.push(d2);
          let u2 = { id: d2, patternUnits: "userSpaceOnUse", patternContentUnits: t3.patternContentUnits || "userSpaceOnUse", width: h2, height: s2, x: t3._x || t3.x || 0, y: t3._y || t3.y || 0 };
          t3._inverted && (u2.patternTransform = "scale(1, -1)", t3.patternTransform && (t3.patternTransform += " scale(1, -1)")), t3.patternTransform && (u2.patternTransform = t3.patternTransform);
          let g2 = this.createElement("pattern").attr(u2).add(this.defs);
          if (g2.id = d2, t3.path) {
            if (f2 = i2.isObject(t3.path) ? t3.path : { d: t3.path }, t3.backgroundColor) {
              let e4;
              e4 = t3.backgroundColor, this.rect(0, 0, h2, s2).attr({ fill: e4 }).add(g2);
            }
            l2 = { d: f2.d }, this.styledMode || (l2.stroke = f2.stroke || o2, l2["stroke-width"] = p(f2.strokeWidth, 2), l2.fill = f2.fill || "none"), f2.transform && (l2.transform = f2.transform), this.createElement("path").attr(l2).add(g2), g2.color = o2;
          } else t3.image && (a2 ? this.image(t3.image, 0, 0, h2, s2, function() {
            this.animate({ opacity: p(t3.opacity, 1) }, n2), c(this.element, "load");
          }).attr({ opacity: 0 }).add(g2) : this.image(t3.image, 0, 0, h2, s2).add(g2));
          return t3.image && a2 || void 0 === t3.opacity || [].forEach.call(g2.element.childNodes, (e4) => {
            e4.setAttribute("opacity", t3.opacity);
          }), this.patternElements = this.patternElements || {}, this.patternElements[d2] = g2, g2;
        }
        function b(t3) {
          let e3 = this.options.color;
          e3 && e3.pattern && !e3.pattern.color ? (delete this.options.color, t3.apply(this, [].slice.call(arguments, 1)), e3.pattern.color = this.color, this.color = this.options.color = e3) : t3.apply(this, [].slice.call(arguments, 1));
        }
        function _() {
          var _a, _b;
          if (!((_a = this.chart) == null ? void 0 : _a.mapView)) return;
          let t3 = this.chart.renderer, e3 = t3.patternElements;
          ((_b = t3.defIds) == null ? void 0 : _b.length) && e3 && this.points.filter(function(t4) {
            var _a2, _b2, _c, _d;
            return !!t4.graphic && (t4.graphic.element.hasAttribute("fill") || t4.graphic.element.hasAttribute("color") || t4.graphic.element.hasAttribute("stroke")) && !((_b2 = (_a2 = t4.options.color) == null ? void 0 : _a2.pattern) == null ? void 0 : _b2.image) && !!((_c = t4.group) == null ? void 0 : _c.scaleX) && !!((_d = t4.group) == null ? void 0 : _d.scaleY);
          }).map(function(e4) {
            var _a2, _b2, _c, _d, _e;
            return { id: (((_a2 = e4.graphic) == null ? void 0 : _a2.element.getAttribute("fill")) || ((_b2 = e4.graphic) == null ? void 0 : _b2.element.getAttribute("color")) || ((_c = e4.graphic) == null ? void 0 : _c.element.getAttribute("stroke")) || "").replace(t3.url, "").replace("url(#", "").replace(")", ""), x: ((_d = e4.group) == null ? void 0 : _d.scaleX) || 1, y: ((_e = e4.group) == null ? void 0 : _e.scaleY) || 1 };
          }).filter(function(t4, e4, i3) {
            return "" !== t4.id && -1 !== t4.id.indexOf("highcharts-pattern-") && !i3.some(function(i4, r2) {
              return i4.id === t4.id && r2 < e4;
            });
          }).forEach(function(t4) {
            let i3 = t4.id;
            e3[i3].scaleX = 1 / t4.x, e3[i3].scaleY = 1 / t4.y, e3[i3].updateTransform("patternTransform");
          });
        }
        return { compose: function(t3, e3, i3) {
          let r2 = e3.prototype.pointClass, a2 = r2.prototype;
          a2.calculatePatternDimensions || (n(t3, "endResize", g), n(t3, "redraw", m), h(a2, { calculatePatternDimensions: M }), n(r2, "afterInit", y), n(e3, "render", w), d(e3.prototype, "getColor", b), n(e3, "afterRender", _), n(e3, "mapZoomComplete", _), h(i3.prototype, { addPattern: L }), n(i3, "complexColor", x));
        }, patterns: f };
      }), i(e, "masters/modules/pattern-fill.src.js", [e["Core/Globals.js"], e["Extensions/PatternFill.js"]], function(t2, e2) {
        return t2.patterns = e2.patterns, e2.compose(t2.Chart, t2.Series, t2.SVGRenderer), t2;
      });
    });
  }
});
export default require_pattern_fill();
//# sourceMappingURL=highcharts_modules_pattern-fill__js.js.map
