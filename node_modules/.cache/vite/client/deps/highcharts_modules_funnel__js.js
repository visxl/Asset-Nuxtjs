import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/funnel.js
var require_funnel = __commonJS({
  "node_modules/highcharts/modules/funnel.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Highcharts funnel module
    *
    * (c) 2010-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/funnel", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function i(t2, i2, s, n) {
        t2.hasOwnProperty(i2) || (t2[i2] = n.apply(null, s), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: t2[i2] } })));
      }
      i(t, "Series/Funnel/FunnelSeriesDefaults.js", [], function() {
        return { animation: false, borderRadius: 0, center: ["50%", "50%"], width: "90%", neckWidth: "30%", height: "100%", neckHeight: "25%", reversed: false, size: true, dataLabels: { connectorWidth: 1, verticalAlign: "middle" }, states: { select: { color: "#cccccc", borderColor: "#000000" } } };
      }), i(t, "Series/Funnel/FunnelSeries.js", [t["Series/Funnel/FunnelSeriesDefaults.js"], t["Core/Globals.js"], t["Extensions/BorderRadius.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2, i2, s, n) {
        let { composed: a, noop: d } = t2, { column: o, pie: l } = s.seriesTypes, { addEvent: r, correctFloat: h, extend: u, fireEvent: c, isArray: p, merge: y, pick: f, pushUnique: g, relativeLength: x, splat: b } = n, m = s.series.prototype.alignDataLabel;
        function L(e3, t3) {
          return /%$/.test(e3) ? t3 * parseInt(e3, 10) / 100 : parseInt(e3, 10);
        }
        class S extends l {
          alignDataLabel(e3, t3, i3, s2, n2) {
            let a2 = e3.series, d2 = a2.options.reversed, o2 = e3.dlBox || e3.shapeArgs, { align: l2, padding: r2 = 0, verticalAlign: h2 } = i3, u2 = ((a2.options || {}).dataLabels || {}).inside, c2 = a2.center[1], p2 = e3.plotY || 0, y2 = t3.height ?? t3.getBBox().height, f2 = a2.getWidthAt((d2 ? 2 * c2 - p2 : p2) - o2.height / 2 + y2), g2 = "middle" === h2 ? (o2.topWidth - o2.bottomWidth) / 4 : (f2 - o2.bottomWidth) / 2, x2 = o2.y, b2 = o2.x;
            "middle" === h2 ? x2 = o2.y - o2.height / 2 + y2 / 2 : "top" === h2 && (x2 = o2.y - o2.height + y2 + r2), ("top" === h2 && !d2 || "bottom" === h2 && d2 || "middle" === h2) && ("right" === l2 ? b2 = o2.x - r2 + g2 : "left" === l2 && (b2 = o2.x + r2 - g2)), s2 = { x: b2, y: d2 ? x2 - o2.height : x2, width: o2.bottomWidth, height: o2.height }, i3.verticalAlign = "bottom", u2 && (i3.distance = void 0), u2 && e3.visible && m.call(a2, e3, t3, i3, s2, n2), u2 && (!e3.visible && e3.dataLabel && (e3.dataLabel.placed = false), e3.contrastColor && t3.css({ color: e3.contrastColor }));
          }
          drawDataLabels() {
            (b(this.options.dataLabels)[0].inside ? o : l).prototype.drawDataLabels.call(this);
          }
          getDataLabelPosition(e3, t3) {
            let i3 = e3.plotY || 0, s2 = e3.half ? 1 : -1, n2 = this.getX(i3, !!e3.half, e3);
            return { distance: t3, natural: { x: 0, y: i3 }, computed: {}, alignment: e3.half ? "right" : "left", connectorPosition: { breakAt: { x: n2 + (t3 - 5) * s2, y: i3 }, touchingSliceAt: { x: n2 + t3 * s2, y: i3 } } };
          }
          translate() {
            let e3 = this, t3 = e3.chart, s2 = e3.options, n2 = s2.reversed, a2 = s2.ignoreHiddenPoint, o2 = i2.optionsToObject(s2.borderRadius), l2 = t3.plotWidth, r2 = t3.plotHeight, u2 = s2.center, p2 = L(u2[0], l2), y2 = L(u2[1], r2), g2 = L(s2.width, l2), b2 = L(s2.height, r2), m2 = L(s2.neckWidth, l2), S2 = L(s2.neckHeight, r2), C = y2 - b2 / 2 + b2 - S2, M = e3.points, j = x(o2.radius, g2), v = o2.scope, P = "left" === s2.dataLabels.position ? 1 : 0, W = (e4) => {
              let t4 = Math.tan(e4 / 2), i3 = Math.cos(w), s3 = Math.sin(w), a3 = j, d2 = a3 / t4, o3 = Math.tan((Math.PI - e4) / 3.2104);
              return d2 > I && (a3 = (d2 = I) * t4), { dx: [d2 * i3, (d2 - (o3 *= a3)) * i3, d2 - o3, d2], dy: [d2 * s3, (d2 - o3) * s3, d2 - o3, d2].map((e5) => n2 ? -e5 : e5) };
            }, A = 0, D = 0, F, k, H, w, I, O, B, T, Y, R, E, X;
            for (let t4 of (e3.getWidthAt = function(e4) {
              let t5 = y2 - b2 / 2;
              return e4 > C || b2 === S2 ? m2 : m2 + (g2 - m2) * (1 - (e4 - t5) / (b2 - S2));
            }, e3.getX = function(t5, i3, s3) {
              var _a, _b, _c;
              return p2 + (i3 ? -1 : 1) * (e3.getWidthAt(n2 ? 2 * y2 - t5 : t5) / 2 + (((_b = (_a = s3.dataLabel) == null ? void 0 : _a.dataLabelPosition) == null ? void 0 : _b.distance) ?? x(((_c = this.options.dataLabels) == null ? void 0 : _c.distance) || 0, g2)));
            }, e3.center = [p2, y2, b2], e3.centerX = p2, M)) t4.y && t4.isValid() && (!a2 || false !== t4.visible) && (A += t4.y);
            for (let t4 of M) {
              if (X = null, H = A ? t4.y / A : 0, R = (B = y2 - b2 / 2 + D * b2) + H * b2, T = (O = p2 - (F = e3.getWidthAt(B)) / 2) + F, E = (Y = p2 - (F = e3.getWidthAt(R)) / 2) + F, h(B) >= C ? (O = Y = p2 - m2 / 2, T = E = p2 + m2 / 2) : R > C && (X = R, E = (Y = p2 - (F = e3.getWidthAt(C)) / 2) + F, R = C), n2 && (B = 2 * y2 - B, R = 2 * y2 - R, null !== X && (X = 2 * y2 - X)), j && ("point" === v || 0 === t4.index || t4.index === M.length - 1 || null !== X)) {
                let e4 = Math.abs(R - B), i3 = T - E, s3 = E - Y, n3 = Math.sqrt(i3 * i3 + e4 * e4);
                w = Math.atan(0 !== i3 ? e4 / i3 : 1 / 0), I = n3 / 2, null !== X && (I = Math.min(I, Math.abs(X - R) / 2)), s3 >= 1 && (I = Math.min(I, s3 / 2));
                let a3 = W(w);
                if (k = "stack" === v && 0 !== t4.index ? [["M", O, B], ["L", T, B]] : [["M", O + a3.dx[0], B + a3.dy[0]], ["C", O + a3.dx[1], B + a3.dy[1], O + a3.dx[2], B, O + a3.dx[3], B], ["L", T - a3.dx[3], B], ["C", T - a3.dx[2], B, T - a3.dx[1], B + a3.dy[1], T - a3.dx[0], B + a3.dy[0]]], null !== X) {
                  let e5 = W(Math.PI / 2);
                  a3 = W(Math.PI / 2 + w), k.push(["L", E + a3.dx[0], R - a3.dy[0]], ["C", E + a3.dx[1], R - a3.dy[1], E, R + a3.dy[2], E, R + a3.dy[3]]), "stack" === v && t4.index !== M.length - 1 ? k.push(["L", E, X], ["L", Y, X]) : k.push(["L", E, X - e5.dy[3]], ["C", E, X - e5.dy[2], E - e5.dx[2], X, E - e5.dx[3], X], ["L", Y + e5.dx[3], X], ["C", Y + e5.dx[2], X, Y, X - e5.dy[2], Y, X - e5.dy[3]]), k.push(["L", Y, R + a3.dy[3]], ["C", Y, R + a3.dy[2], Y - a3.dx[1], R - a3.dy[1], Y - a3.dx[0], R - a3.dy[0]]);
                } else s3 >= 1 ? (a3 = W(Math.PI - w), "stack" === v && 0 === t4.index ? k.push(["L", E, R], ["L", Y, R]) : k.push(["L", E + a3.dx[0], R - a3.dy[0]], ["C", E + a3.dx[1], R - a3.dy[1], E - a3.dx[2], R, E - a3.dx[3], R], ["L", Y + a3.dx[3], R], ["C", Y + a3.dx[2], R, Y - a3.dx[1], R - a3.dy[1], Y - a3.dx[0], R - a3.dy[0]])) : (a3 = W(Math.PI - 2 * w), k.push(["L", Y + a3.dx[0], R - a3.dy[0]], ["C", Y + a3.dx[1], R - a3.dy[1], Y - a3.dx[1], R - a3.dy[1], Y - a3.dx[0], R - a3.dy[0]]));
              } else k = [["M", O, B], ["L", T, B], ["L", E, R]], null !== X && k.push(["L", E, X], ["L", Y, X]), k.push(["L", Y, R]);
              k.push(["Z"]), t4.shapeType = "path", t4.shapeArgs = { d: k }, t4.percentage = 100 * H, t4.plotX = p2, t4.plotY = (B + (X || R)) / 2, t4.tooltipPos = [p2, t4.plotY], t4.dlBox = { x: Y, y: B, topWidth: T - O, bottomWidth: E - Y, height: Math.abs(f(X, R) - B), width: NaN }, t4.slice = d, t4.half = P, t4.isValid() && (!a2 || false !== t4.visible) && (D += H);
            }
            c(e3, "afterTranslate");
          }
          sortByAngle(e3) {
            e3.sort((e4, t3) => e4.plotY - t3.plotY);
          }
        }
        return S.defaultOptions = y(l.defaultOptions, e2), u(S.prototype, { animate: d }), function(e3) {
          function t3() {
            for (let e4 of this.series) {
              let t4 = e4.options && e4.options.dataLabels;
              p(t4) && (t4 = t4[0]), e4.is("pie") && e4.placeDataLabels && t4 && !t4.inside && e4.placeDataLabels();
            }
          }
          e3.compose = function(e4) {
            g(a, "FunnelSeries") && r(e4, "afterHideAllOverlappingLabels", t3);
          };
        }(S || (S = {})), s.registerSeriesType("funnel", S), S;
      }), i(t, "Series/Pyramid/PyramidSeriesDefaults.js", [], function() {
        return { neckHeight: "0%", neckWidth: "0%", reversed: true };
      }), i(t, "Series/Pyramid/PyramidSeries.js", [t["Series/Funnel/FunnelSeries.js"], t["Series/Pyramid/PyramidSeriesDefaults.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2, i2, s) {
        let { merge: n } = s;
        class a extends e2 {
        }
        return a.defaultOptions = n(e2.defaultOptions, t2), i2.registerSeriesType("pyramid", a), a;
      }), i(t, "masters/modules/funnel.src.js", [t["Core/Globals.js"], t["Series/Funnel/FunnelSeries.js"]], function(e2, t2) {
        return t2.compose(e2.Chart), e2;
      });
    });
  }
});
export default require_funnel();
//# sourceMappingURL=highcharts_modules_funnel__js.js.map
