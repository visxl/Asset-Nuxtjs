import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/xrange.js
var require_xrange = __commonJS({
  "node_modules/highcharts/modules/xrange.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * X-range series
    *
    * (c) 2010-2024 Torstein Honsi, Lars A. V. Cabrera
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/xrange", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, s, o) {
        e2.hasOwnProperty(i2) || (e2[i2] = o.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Series/XRange/XRangeSeriesDefaults.js", [e["Core/Utilities.js"]], function(t2) {
        let { correctFloat: e2, isNumber: i2, isObject: s } = t2;
        return { colorByPoint: true, dataLabels: { formatter: function() {
          let t3 = this.point.partialFill;
          if (s(t3) && (t3 = t3.amount), i2(t3) && t3 > 0) return e2(100 * t3) + "%";
        }, inside: true, verticalAlign: "middle", style: { whiteSpace: "nowrap" } }, tooltip: { headerFormat: '<span style="font-size: 0.8em">{point.x} - {point.x2}</span><br/>', pointFormat: '<span style="color:{point.color}">‚óè</span> {series.name}: <b>{point.yCategory}</b><br/>' }, borderRadius: 3, pointRange: 0 };
      }), i(e, "Series/XRange/XRangePoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { column: { prototype: { pointClass: i2 } } } = t2.seriesTypes, { extend: s } = e2;
        class o extends i2 {
          static getColorByCategory(t3, e3) {
            let i3 = t3.options.colors || t3.chart.options.colors, s2 = i3 ? i3.length : t3.chart.options.chart.colorCount, o2 = e3.y % s2, r = i3 && i3[o2];
            return { colorIndex: o2, color: r };
          }
          resolveColor() {
            let t3 = this.series;
            if (t3.options.colorByPoint && !this.options.color) {
              let e3 = o.getColorByCategory(t3, this);
              t3.chart.styledMode || (this.color = e3.color), this.options.colorIndex || (this.colorIndex = e3.colorIndex);
            } else this.color = this.options.color || t3.color;
          }
          constructor(t3, e3) {
            super(t3, e3), this.y || (this.y = 0);
          }
          setState() {
            super.setState.apply(this, arguments), this.series.drawPoint(this, this.series.getAnimationVerb());
          }
          getLabelConfig() {
            let t3 = super.getLabelConfig.call(this), e3 = this.series.yAxis.categories;
            return t3.x2 = this.x2, t3.yCategory = this.yCategory = e3 && e3[this.y], t3.key = this.category || this.name, t3;
          }
          isValid() {
            return "number" == typeof this.x && "number" == typeof this.x2;
          }
        }
        return s(o.prototype, { ttBelow: false, tooltipDateKeys: ["x", "x2"] }), o;
      }), i(e, "Series/XRange/XRangeSeries.js", [e["Core/Globals.js"], e["Core/Color/Color.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"], e["Series/XRange/XRangeSeriesDefaults.js"], e["Series/XRange/XRangePoint.js"]], function(t2, e2, i2, s, o, r) {
        let { composed: a, noop: l } = t2, { parse: n } = e2, { column: h } = i2.seriesTypes, { addEvent: p, clamp: d, crisp: c, defined: g, extend: u, find: x, isNumber: f, isObject: y, merge: m, pick: C, pushUnique: A, relativeLength: b } = s;
        function w() {
          let t3, e3;
          if (this.isXAxis) {
            for (let i3 of (t3 = C(this.dataMax, -Number.MAX_VALUE), this.series)) if (i3.x2Data) for (let s2 of i3.x2Data) s2 && s2 > t3 && (t3 = s2, e3 = true);
            e3 && (this.dataMax = t3);
          }
        }
        class R extends h {
          static compose(t3) {
            A(a, "Series.XRange") && p(t3, "afterGetSeriesExtremes", w);
          }
          init() {
            super.init.apply(this, arguments), this.options.stacking = void 0;
          }
          getColumnMetrics() {
            let t3 = () => {
              for (let t4 of this.chart.series) {
                let e4 = t4.xAxis;
                t4.xAxis = t4.yAxis, t4.yAxis = e4;
              }
            };
            t3();
            let e3 = super.getColumnMetrics();
            return t3(), e3;
          }
          cropData(t3, e3, i3, s2) {
            let o2 = super.cropData(this.x2Data, e3, i3, s2);
            return o2.xData = t3.slice(o2.start, o2.end), o2;
          }
          findPointIndex(t3) {
            let e3;
            let { cropStart: i3, points: s2 } = this, { id: o2 } = t3;
            if (o2) {
              let t4 = x(s2, (t5) => t5.id === o2);
              e3 = t4 ? t4.index : void 0;
            }
            if (void 0 === e3) {
              let i4 = x(s2, (e4) => e4.x === t3.x && e4.x2 === t3.x2 && !e4.touched);
              e3 = i4 ? i4.index : void 0;
            }
            return this.cropped && f(e3) && f(i3) && e3 >= i3 && (e3 -= i3), e3;
          }
          alignDataLabel(t3) {
            var _a;
            let e3 = t3.plotX;
            t3.plotX = C(t3.dlBox && t3.dlBox.centerX, t3.plotX), t3.dataLabel && ((_a = t3.shapeArgs) == null ? void 0 : _a.width) && t3.dataLabel.css({ width: `${t3.shapeArgs.width}px` }), super.alignDataLabel.apply(this, arguments), t3.plotX = e3;
          }
          translatePoint(t3) {
            let e3 = this.xAxis, i3 = this.yAxis, s2 = this.columnMetrics, o2 = this.options, r2 = o2.minPointLength || 0, a2 = (t3.shapeArgs && t3.shapeArgs.width || 0) / 2, l2 = this.pointXOffset = s2.offset, n2 = C(t3.x2, t3.x + (t3.len || 0)), h2 = o2.borderRadius, p2 = this.chart.plotTop, u2 = this.chart.plotLeft, x2 = t3.plotX, A2 = e3.translate(n2, 0, 0, 0, 1), w2 = Math.abs(A2 - x2), R2 = this.chart.inverted, X = C(o2.borderWidth, 1), M, S, P = s2.offset, v = Math.round(s2.width), j, D, L, B;
            r2 && ((M = r2 - w2) < 0 && (M = 0), x2 -= M / 2, A2 += M / 2), x2 = Math.max(x2, -10), A2 = d(A2, -10, e3.len + 10), g(t3.options.pointWidth) && (P -= (Math.ceil(t3.options.pointWidth) - v) / 2, v = Math.ceil(t3.options.pointWidth)), o2.pointPlacement && f(t3.plotY) && i3.categories && (t3.plotY = i3.translate(t3.y, 0, 1, 0, 1, o2.pointPlacement));
            let F = c(Math.min(x2, A2), X), I = c(Math.max(x2, A2), X) - F, E = Math.min(b("object" == typeof h2 ? h2.radius : h2 || 0, v), Math.min(I, v) / 2), T = { x: F, y: c((t3.plotY || 0) + P, X), width: I, height: v, r: E };
            t3.shapeArgs = T, R2 ? t3.tooltipPos[1] += l2 + a2 : t3.tooltipPos[0] -= a2 + l2 - T.width / 2, D = (j = T.x) + T.width, j < 0 || D > e3.len ? (j = d(j, 0, e3.len), L = (D = d(D, 0, e3.len)) - j, t3.dlBox = m(T, { x: j, width: D - j, centerX: L ? L / 2 : null })) : t3.dlBox = null;
            let V = t3.tooltipPos, H = R2 ? 1 : 0, N = R2 ? 0 : 1, O = this.columnMetrics ? this.columnMetrics.offset : -s2.width / 2;
            R2 ? V[H] += T.width / 2 : V[H] = d(V[H] + (e3.reversed ? -1 : 0) * T.width, e3.left - u2, e3.left + e3.len - u2 - 1), V[N] = d(V[N] + (R2 ? -1 : 1) * O, i3.top - p2, i3.top + i3.len - p2 - 1), (S = t3.partialFill) && (y(S) && (S = S.amount), f(S) || (S = 0), t3.partShapeArgs = m(T), B = Math.max(Math.round(w2 * S + t3.plotX - x2), 0), t3.clipRectArgs = { x: e3.reversed ? T.x + w2 - B : T.x, y: T.y, width: B, height: T.height });
          }
          translate() {
            for (let t3 of (super.translate.apply(this, arguments), this.points)) this.translatePoint(t3);
          }
          drawPoint(t3, e3) {
            let i3 = this.options, s2 = this.chart.renderer, o2 = t3.shapeType, r2 = t3.shapeArgs, a2 = t3.partShapeArgs, l2 = t3.clipRectArgs, h2 = t3.state, p2 = i3.states[h2 || "normal"] || {}, d2 = void 0 === h2 ? "attr" : e3, c2 = this.pointAttribs(t3, h2), g2 = C(this.chart.options.chart.animation, p2.animation), u2 = t3.graphic, x2 = t3.partialFill;
            if (t3.isNull || false === t3.visible) u2 && (t3.graphic = u2.destroy());
            else if (u2 ? u2.rect[e3](r2) : (t3.graphic = u2 = s2.g("point").addClass(t3.getClassName()).add(t3.group || this.group), u2.rect = s2[o2](m(r2)).addClass(t3.getClassName()).addClass("highcharts-partfill-original").add(u2)), a2 && (u2.partRect ? (u2.partRect[e3](m(a2)), u2.partialClipRect[e3](m(l2))) : (u2.partialClipRect = s2.clipRect(l2.x, l2.y, l2.width, l2.height), u2.partRect = s2[o2](a2).addClass("highcharts-partfill-overlay").add(u2).clip(u2.partialClipRect))), !this.chart.styledMode && (u2.rect[e3](c2, g2).shadow(i3.shadow), a2)) {
              y(x2) || (x2 = {}), y(i3.partialFill) && (x2 = m(i3.partialFill, x2));
              let e4 = x2.fill || n(c2.fill).brighten(-0.3).get() || n(t3.color || this.color).brighten(-0.3).get();
              c2.fill = e4, u2.partRect[d2](c2, g2).shadow(i3.shadow);
            }
          }
          drawPoints() {
            let t3 = this.getAnimationVerb();
            for (let e3 of this.points) this.drawPoint(e3, t3);
          }
          getAnimationVerb() {
            return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
          }
          isPointInside(t3) {
            let e3 = t3.shapeArgs, i3 = t3.plotX, s2 = t3.plotY;
            return e3 ? void 0 !== i3 && void 0 !== s2 && s2 >= 0 && s2 <= this.yAxis.len && (e3.x || 0) + (e3.width || 0) >= 0 && i3 <= this.xAxis.len : super.isPointInside.apply(this, arguments);
          }
        }
        return R.defaultOptions = m(h.defaultOptions, o), u(R.prototype, { pointClass: r, pointArrayMap: ["x2", "y"], getExtremesFromAll: true, parallelArrays: ["x", "x2", "y"], requireSorting: false, type: "xrange", animate: i2.series.prototype.animate, autoIncrement: l, buildKDTree: l }), i2.registerSeriesType("xrange", R), R;
      }), i(e, "masters/modules/xrange.src.js", [e["Core/Globals.js"], e["Series/XRange/XRangeSeries.js"]], function(t2, e2) {
        return e2.compose(t2.Axis), t2;
      });
    });
  }
});
export default require_xrange();
//# sourceMappingURL=highcharts_modules_xrange__js.js.map
