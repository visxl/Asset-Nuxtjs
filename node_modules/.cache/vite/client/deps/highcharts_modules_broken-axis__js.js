import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/broken-axis.js
var require_broken_axis = __commonJS({
  "node_modules/highcharts/modules/broken-axis.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/broken-axis", ["highcharts"], function(i) {
        return t(i), t.Highcharts = i, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var i = t ? t._modules : {};
      function e(i2, e2, s, n) {
        i2.hasOwnProperty(e2) || (i2[e2] = n.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: e2, module: i2[e2] } })));
      }
      e(i, "Core/Axis/BrokenAxis.js", [i["Core/Axis/Stacking/StackItem.js"], i["Core/Utilities.js"]], function(t2, i2) {
        var e2;
        let { addEvent: s, find: n, fireEvent: o, isArray: r, isNumber: a, pick: l } = i2;
        return function(i3) {
          function e3() {
            void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, false);
          }
          function f() {
            var _a;
            ((_a = this.brokenAxis) == null ? void 0 : _a.hasBreaks) && (this.options.ordinal = false);
          }
          function h() {
            let t3 = this.brokenAxis;
            if (t3 == null ? void 0 : t3.hasBreaks) {
              let i4 = this.tickPositions, e4 = this.tickPositions.info, s2 = [];
              for (let e5 = 0; e5 < i4.length; e5++) t3.isInAnyBreak(i4[e5]) || s2.push(i4[e5]);
              this.tickPositions = s2, this.tickPositions.info = e4;
            }
          }
          function u() {
            this.brokenAxis || (this.brokenAxis = new x(this));
          }
          function c() {
            var _a, _b;
            let { isDirty: t3, options: { connectNulls: i4 }, points: e4, xAxis: s2, yAxis: n2 } = this;
            if (t3) {
              let t4 = e4.length;
              for (; t4--; ) {
                let o2 = e4[t4], r2 = !(null === o2.y && false === i4) && (((_a = s2 == null ? void 0 : s2.brokenAxis) == null ? void 0 : _a.isInAnyBreak(o2.x, true)) || ((_b = n2 == null ? void 0 : n2.brokenAxis) == null ? void 0 : _b.isInAnyBreak(o2.y, true)));
                o2.visible = !r2 && false !== o2.options.visible;
              }
            }
          }
          function k() {
            this.drawBreaks(this.xAxis, ["x"]), this.drawBreaks(this.yAxis, l(this.pointArrayMap, ["y"]));
          }
          function p(t3, i4) {
            var _a;
            let e4, s2, n2;
            let r2 = this, f2 = r2.points;
            if ((_a = t3 == null ? void 0 : t3.brokenAxis) == null ? void 0 : _a.hasBreaks) {
              let h2 = t3.brokenAxis;
              i4.forEach(function(i5) {
                var _a2, _b;
                e4 = (h2 == null ? void 0 : h2.breakArray) || [], s2 = t3.isXAxis ? t3.min : l(r2.options.threshold, t3.min);
                let u2 = (_b = (_a2 = t3 == null ? void 0 : t3.options) == null ? void 0 : _a2.breaks) == null ? void 0 : _b.filter(function(t4) {
                  let i6 = true;
                  for (let s3 = 0; s3 < e4.length; s3++) {
                    let n3 = e4[s3];
                    if (n3.from === t4.from && n3.to === t4.to) {
                      i6 = false;
                      break;
                    }
                  }
                  return i6;
                });
                f2.forEach(function(r3) {
                  n2 = l(r3["stack" + i5.toUpperCase()], r3[i5]), e4.forEach(function(i6) {
                    if (a(s2) && a(n2)) {
                      let e5 = "";
                      s2 < i6.from && n2 > i6.to || s2 > i6.from && n2 < i6.from ? e5 = "pointBreak" : (s2 < i6.from && n2 > i6.from && n2 < i6.to || s2 > i6.from && n2 > i6.to && n2 < i6.from) && (e5 = "pointInBreak"), e5 && o(t3, e5, { point: r3, brk: i6 });
                    }
                  }), u2 == null ? void 0 : u2.forEach(function(i6) {
                    o(t3, "pointOutsideOfBreak", { point: r3, brk: i6 });
                  });
                });
              });
            }
          }
          function m() {
            let i4 = this.currentDataGrouping, e4 = i4 == null ? void 0 : i4.gapSize, s2 = this.points.slice(), n2 = this.yAxis, o2 = this.options.gapSize, r2 = s2.length - 1;
            if (o2 && r2 > 0) {
              let i5, a2;
              for ("value" !== this.options.gapUnit && (o2 *= this.basePointRange), e4 && e4 > o2 && e4 >= this.basePointRange && (o2 = e4); r2--; ) if (a2 && false !== a2.visible || (a2 = s2[r2 + 1]), i5 = s2[r2], false !== a2.visible && false !== i5.visible) {
                if (a2.x - i5.x > o2) {
                  let e5 = (i5.x + a2.x) / 2;
                  s2.splice(r2 + 1, 0, { isNull: true, x: e5 }), n2.stacking && this.options.stacking && ((n2.stacking.stacks[this.stackKey][e5] = new t2(n2, n2.options.stackLabels, false, e5, this.stack)).total = 0);
                }
                a2 = i5;
              }
            }
            return this.getGraphPath(s2);
          }
          i3.compose = function(t3, i4) {
            if (!t3.keepProps.includes("brokenAxis")) {
              t3.keepProps.push("brokenAxis"), s(t3, "init", u), s(t3, "afterInit", e3), s(t3, "afterSetTickPositions", h), s(t3, "afterSetOptions", f);
              let n2 = i4.prototype;
              n2.drawBreaks = p, n2.gappedPath = m, s(i4, "afterGeneratePoints", c), s(i4, "afterRender", k);
            }
            return t3;
          };
          class x {
            static isInBreak(t3, i4) {
              let e4 = t3.repeat || 1 / 0, s2 = t3.from, n2 = t3.to - t3.from, o2 = i4 >= s2 ? (i4 - s2) % e4 : e4 - (s2 - i4) % e4;
              return t3.inclusive ? o2 <= n2 : o2 < n2 && 0 !== o2;
            }
            static lin2Val(t3) {
              let i4 = this.brokenAxis, e4 = i4 && i4.breakArray;
              if (!e4 || !a(t3)) return t3;
              let s2 = t3, n2, o2;
              for (o2 = 0; o2 < e4.length && !((n2 = e4[o2]).from >= s2); o2++) n2.to < s2 ? s2 += n2.len : x.isInBreak(n2, s2) && (s2 += n2.len);
              return s2;
            }
            static val2Lin(t3) {
              let i4 = this.brokenAxis, e4 = i4 && i4.breakArray;
              if (!e4 || !a(t3)) return t3;
              let s2 = t3, n2, o2;
              for (o2 = 0; o2 < e4.length; o2++) if ((n2 = e4[o2]).to <= t3) s2 -= n2.len;
              else if (n2.from >= t3) break;
              else if (x.isInBreak(n2, t3)) {
                s2 -= t3 - n2.from;
                break;
              }
              return s2;
            }
            constructor(t3) {
              this.hasBreaks = false, this.axis = t3;
            }
            findBreakAt(t3, i4) {
              return n(i4, function(i5) {
                return i5.from < t3 && t3 < i5.to;
              });
            }
            isInAnyBreak(t3, i4) {
              let e4 = this.axis, s2 = e4.options.breaks || [], n2 = s2.length, o2, r2, f2;
              if (n2 && a(t3)) {
                for (; n2--; ) x.isInBreak(s2[n2], t3) && (o2 = true, r2 || (r2 = l(s2[n2].showPoints, !e4.isXAxis)));
                f2 = o2 && i4 ? o2 && !r2 : o2;
              }
              return f2;
            }
            setBreaks(t3, i4) {
              let e4 = this, s2 = e4.axis, n2 = r(t3) && !!t3.length && !!Object.keys(t3[0]).length;
              s2.isDirty = e4.hasBreaks !== n2, e4.hasBreaks = n2, t3 !== s2.options.breaks && (s2.options.breaks = s2.userOptions.breaks = t3), s2.forceRedraw = true, s2.series.forEach(function(t4) {
                t4.isDirty = true;
              }), n2 || s2.val2lin !== x.val2Lin || (delete s2.val2lin, delete s2.lin2val), n2 && (s2.userOptions.ordinal = false, s2.lin2val = x.lin2Val, s2.val2lin = x.val2Lin, s2.setExtremes = function(t4, i5, n3, o2, r2) {
                if (e4.hasBreaks) {
                  let s3;
                  let n4 = this.options.breaks || [];
                  for (; s3 = e4.findBreakAt(t4, n4); ) t4 = s3.to;
                  for (; s3 = e4.findBreakAt(i5, n4); ) i5 = s3.from;
                  i5 < t4 && (i5 = t4);
                }
                s2.constructor.prototype.setExtremes.call(this, t4, i5, n3, o2, r2);
              }, s2.setAxisTranslation = function() {
                if (s2.constructor.prototype.setAxisTranslation.call(this), e4.unitLength = void 0, e4.hasBreaks) {
                  let t4 = s2.options.breaks || [], i5 = [], n3 = [], r2 = l(s2.pointRangePadding, 0), f2 = 0, h2, u2, c2 = s2.userMin || s2.min, k2 = s2.userMax || s2.max, p2, m2;
                  t4.forEach(function(t5) {
                    u2 = t5.repeat || 1 / 0, a(c2) && a(k2) && (x.isInBreak(t5, c2) && (c2 += t5.to % u2 - c2 % u2), x.isInBreak(t5, k2) && (k2 -= k2 % u2 - t5.from % u2));
                  }), t4.forEach(function(t5) {
                    if (p2 = t5.from, u2 = t5.repeat || 1 / 0, a(c2) && a(k2)) {
                      for (; p2 - u2 > c2; ) p2 -= u2;
                      for (; p2 < c2; ) p2 += u2;
                      for (m2 = p2; m2 < k2; m2 += u2) i5.push({ value: m2, move: "in" }), i5.push({ value: m2 + t5.to - t5.from, move: "out", size: t5.breakSize });
                    }
                  }), i5.sort(function(t5, i6) {
                    return t5.value === i6.value ? ("in" === t5.move ? 0 : 1) - ("in" === i6.move ? 0 : 1) : t5.value - i6.value;
                  }), h2 = 0, p2 = c2, i5.forEach(function(t5) {
                    1 === (h2 += "in" === t5.move ? 1 : -1) && "in" === t5.move && (p2 = t5.value), 0 === h2 && a(p2) && (n3.push({ from: p2, to: t5.value, len: t5.value - p2 - (t5.size || 0) }), f2 += t5.value - p2 - (t5.size || 0));
                  }), e4.breakArray = n3, a(c2) && a(k2) && a(s2.min) && (e4.unitLength = k2 - c2 - f2 + r2, o(s2, "afterBreaks"), s2.staticScale ? s2.transA = s2.staticScale : e4.unitLength && (s2.transA *= (k2 - s2.min + r2) / e4.unitLength), r2 && (s2.minPixelPadding = s2.transA * (s2.minPointOffset || 0)), s2.min = c2, s2.max = k2);
                }
              }), l(i4, true) && s2.chart.redraw();
            }
          }
          i3.Additions = x;
        }(e2 || (e2 = {})), e2;
      }), e(i, "masters/modules/broken-axis.src.js", [i["Core/Globals.js"], i["Core/Axis/BrokenAxis.js"]], function(t2, i2) {
        return t2.BrokenAxis = t2.BrokenAxis || i2, t2.BrokenAxis.compose(t2.Axis, t2.Series), t2;
      });
    });
  }
});
export default require_broken_axis();
//# sourceMappingURL=highcharts_modules_broken-axis__js.js.map
