import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/dumbbell.js
var require_dumbbell = __commonJS({
  "node_modules/highcharts/modules/dumbbell.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2009-2024 Sebastian Bochan, Rafal Sebestjanski
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/dumbbell", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function o(e2, o2, i, s) {
        e2.hasOwnProperty(o2) || (e2[o2] = s.apply(null, i), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: o2, module: e2[o2] } })));
      }
      o(e, "Series/AreaRange/AreaRangePoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { area: { prototype: { pointClass: o2, pointClass: { prototype: i } } } } = t2.seriesTypes, { defined: s, isNumber: r } = e2;
        return class extends o2 {
          setState() {
            let t3 = this.state, e3 = this.series, o3 = e3.chart.polar;
            s(this.plotHigh) || (this.plotHigh = e3.yAxis.toPixels(this.high, true)), s(this.plotLow) || (this.plotLow = this.plotY = e3.yAxis.toPixels(this.low, true)), e3.lowerStateMarkerGraphic = e3.stateMarkerGraphic, e3.stateMarkerGraphic = e3.upperStateMarkerGraphic, this.graphic = this.graphics && this.graphics[1], this.plotY = this.plotHigh, o3 && r(this.plotHighX) && (this.plotX = this.plotHighX), i.setState.apply(this, arguments), this.state = t3, this.plotY = this.plotLow, this.graphic = this.graphics && this.graphics[0], o3 && r(this.plotLowX) && (this.plotX = this.plotLowX), e3.upperStateMarkerGraphic = e3.stateMarkerGraphic, e3.stateMarkerGraphic = e3.lowerStateMarkerGraphic, e3.lowerStateMarkerGraphic = void 0;
            let l = e3.modifyMarkerSettings();
            i.setState.apply(this, arguments), e3.restoreMarkerSettings(l);
          }
          haloPath() {
            let t3 = this.series.chart.polar, e3 = [];
            return this.plotY = this.plotLow, t3 && r(this.plotLowX) && (this.plotX = this.plotLowX), this.isInside && (e3 = i.haloPath.apply(this, arguments)), this.plotY = this.plotHigh, t3 && r(this.plotHighX) && (this.plotX = this.plotHighX), this.isTopInside && (e3 = e3.concat(i.haloPath.apply(this, arguments))), e3;
          }
          isValid() {
            return r(this.low) && r(this.high);
          }
        };
      }), o(e, "Series/Dumbbell/DumbbellPoint.js", [e["Series/AreaRange/AreaRangePoint.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { extend: o2, pick: i } = e2;
        class s extends t2 {
          setState() {
            var _a;
            let t3 = this.series, e3 = t3.chart, s2 = t3.options.lowColor, r = t3.options.marker, l = t3.options.lowMarker, h = this.options, n = h.lowColor, a = this.zone && this.zone.color, p = i(n, l == null ? void 0 : l.fillColor, s2, h.color, a, this.color, t3.color), c = "attr", d, u;
            if (this.pointSetState.apply(this, arguments), !this.state) {
              c = "animate";
              let [t4, s3] = this.graphics || [];
              t4 && !e3.styledMode && (t4.attr({ fill: p }), s3 && (u = { y: this.y, zone: this.zone }, this.y = this.high, this.zone = this.zone ? this.getZone() : void 0, d = i(this.marker ? this.marker.fillColor : void 0, r ? r.fillColor : void 0, h.color, this.zone ? this.zone.color : void 0, this.color), s3.attr({ fill: d }), o2(this, u)));
            }
            (_a = this.connector) == null ? void 0 : _a[c](t3.getConnectorAttribs(this));
          }
          destroy() {
            return this.graphic || (this.graphic = this.connector, this.connector = void 0), super.destroy();
          }
        }
        return o2(s.prototype, { pointSetState: t2.prototype.setState }), s;
      }), o(e, "Series/Dumbbell/DumbbellSeriesDefaults.js", [], function() {
        return { trackByArea: false, fillColor: "none", lineWidth: 0, pointRange: 1, connectorWidth: 1, stickyTracking: false, groupPadding: 0.2, crisp: false, pointPadding: 0.1, legendSymbol: "rectangle", lowColor: "#333333", states: { hover: { lineWidthPlus: 0, connectorWidthPlus: 1, halo: false } } };
      }), o(e, "Series/Dumbbell/DumbbellSeries.js", [e["Series/Dumbbell/DumbbellPoint.js"], e["Series/Dumbbell/DumbbellSeriesDefaults.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Utilities.js"]], function(t2, e2, o2, i, s, r) {
        let { noop: l } = o2, { arearange: h, column: n, columnrange: a } = i.seriesTypes, { extend: p, merge: c, pick: d } = r;
        class u extends h {
          getConnectorAttribs(t3) {
            let e3 = this.chart, o3 = t3.options, i2 = this.options, r2 = this.xAxis, l2 = this.yAxis, h2 = d(i2.states && i2.states.hover && i2.states.hover.connectorWidthPlus, 1), n2 = d(o3.dashStyle, i2.dashStyle), a2 = l2.toPixels(i2.threshold || 0, true), c2 = e3.inverted ? l2.len - a2 : a2, u2 = d(o3.connectorWidth, i2.connectorWidth), g = d(o3.connectorColor, i2.connectorColor, o3.color, t3.zone ? t3.zone.color : void 0, t3.color), y = d(t3.plotLow, t3.plotY), f = d(t3.plotHigh, c2), m;
            if ("number" != typeof y) return {};
            t3.state && (u2 += h2), y < 0 ? y = 0 : y >= l2.len && (y = l2.len), f < 0 ? f = 0 : f >= l2.len && (f = l2.len), (t3.plotX < 0 || t3.plotX > r2.len) && (u2 = 0), t3.graphics && t3.graphics[1] && (m = { y: t3.y, zone: t3.zone }, t3.y = t3.high, t3.zone = t3.zone ? t3.getZone() : void 0, g = d(o3.connectorColor, i2.connectorColor, o3.color, t3.zone ? t3.zone.color : void 0, t3.color), p(t3, m));
            let C = { d: s.prototype.crispLine([["M", t3.plotX, y], ["L", t3.plotX, f]], u2) };
            return !e3.styledMode && (C.stroke = g, C["stroke-width"] = u2, n2 && (C.dashstyle = n2)), C;
          }
          drawConnector(t3) {
            let e3 = d(this.options.animationLimit, 250), o3 = t3.connector && this.chart.pointCount < e3 ? "animate" : "attr";
            t3.connector || (t3.connector = this.chart.renderer.path().addClass("highcharts-lollipop-stem").attr({ zIndex: -1 }).add(this.group)), t3.connector[o3](this.getConnectorAttribs(t3));
          }
          getColumnMetrics() {
            let t3 = n.prototype.getColumnMetrics.apply(this, arguments);
            return t3.offset += t3.width / 2, t3;
          }
          translate() {
            let t3 = this.chart.inverted;
            for (let e3 of (this.setShapeArgs.apply(this), this.translatePoint.apply(this, arguments), this.points)) {
              let { pointWidth: o3, shapeArgs: i2 = {}, tooltipPos: s2 } = e3;
              e3.plotX = i2.x || 0, i2.x = e3.plotX - o3 / 2, s2 && (t3 ? s2[1] = this.xAxis.len - e3.plotX : s2[0] = e3.plotX);
            }
            this.columnMetrics.offset -= this.columnMetrics.width / 2;
          }
          drawPoints() {
            var _a;
            let t3 = this.chart, e3 = this.points.length, o3 = this.lowColor = this.options.lowColor, i2 = this.options.lowMarker, s2 = 0, r2, l2, h2;
            for (this.seriesDrawPoints.apply(this, arguments); s2 < e3; ) {
              let [e4, n2] = (l2 = this.points[s2]).graphics || [];
              this.drawConnector(l2), n2 && (n2.element.point = l2, n2.addClass("highcharts-lollipop-high")), ((_a = l2.connector) == null ? void 0 : _a.element).point = l2, e4 && (h2 = l2.zone && l2.zone.color, r2 = d(l2.options.lowColor, i2 == null ? void 0 : i2.fillColor, o3, l2.options.color, h2, l2.color, this.color), t3.styledMode || e4.attr({ fill: r2 }), e4.addClass("highcharts-lollipop-low")), s2++;
            }
          }
          pointAttribs(t3, e3) {
            let o3 = super.pointAttribs.apply(this, arguments);
            return "hover" === e3 && delete o3.fill, o3;
          }
          setShapeArgs() {
            n.prototype.translate.apply(this), a.prototype.afterColumnTranslate.apply(this);
          }
        }
        return u.defaultOptions = c(h.defaultOptions, e2), p(u.prototype, { crispCol: n.prototype.crispCol, drawGraph: l, drawTracker: n.prototype.drawTracker, pointClass: t2, seriesDrawPoints: h.prototype.drawPoints, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], translatePoint: h.prototype.translate }), i.registerSeriesType("dumbbell", u), u;
      }), o(e, "masters/modules/dumbbell.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_dumbbell();
//# sourceMappingURL=highcharts_modules_dumbbell__js.js.map
