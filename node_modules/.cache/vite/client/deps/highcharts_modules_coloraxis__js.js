import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/coloraxis.js
var require_coloraxis = __commonJS({
  "node_modules/highcharts/modules/coloraxis.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * ColorAxis module
    *
    * (c) 2012-2024 Pawel Potaczek
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/color-axis", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function s(e2, s2, i, o) {
        e2.hasOwnProperty(s2) || (e2[s2] = o.apply(null, i), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: e2[s2] } })));
      }
      s(e, "Core/Axis/Color/ColorAxisComposition.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var s2;
        let { parse: i } = t2, { addEvent: o, extend: l, merge: r, pick: a, splat: n } = e2;
        return function(t3) {
          let e3;
          function s3() {
            let { userOptions: t4 } = this;
            this.colorAxis = [], t4.colorAxis && (t4.colorAxis = n(t4.colorAxis), t4.colorAxis.map((t5) => new e3(this, t5)));
          }
          function h(t4) {
            let e4 = this.chart.colorAxis || [], s4 = (e5) => {
              let s5 = t4.allItems.indexOf(e5);
              -1 !== s5 && (this.destroyItem(t4.allItems[s5]), t4.allItems.splice(s5, 1));
            }, i2 = [], o2, l2;
            for (e4.forEach(function(t5) {
              (o2 = t5.options) && o2.showInLegend && (o2.dataClasses && o2.visible ? i2 = i2.concat(t5.getDataClassLegendSymbols()) : o2.visible && i2.push(t5), t5.series.forEach(function(t6) {
                (!t6.options.showInLegend || o2.dataClasses) && ("point" === t6.options.legendType ? t6.points.forEach(function(t7) {
                  s4(t7);
                }) : s4(t6));
              }));
            }), l2 = i2.length; l2--; ) t4.allItems.unshift(i2[l2]);
          }
          function d(t4) {
            t4.visible && t4.item.legendColor && t4.item.legendItem.symbol.attr({ fill: t4.item.legendColor });
          }
          function c(t4) {
            var _a;
            (_a = this.chart.colorAxis) == null ? void 0 : _a.forEach((e4) => {
              e4.update({}, t4.redraw);
            });
          }
          function p() {
            (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
          }
          function f() {
            let t4 = this.axisTypes;
            t4 ? -1 === t4.indexOf("colorAxis") && t4.push("colorAxis") : this.axisTypes = ["colorAxis"];
          }
          function u(t4) {
            let e4 = this, s4 = t4 ? "show" : "hide";
            e4.visible = e4.options.visible = !!t4, ["graphic", "dataLabel"].forEach(function(t5) {
              e4[t5] && e4[t5][s4]();
            }), this.series.buildKDTree();
          }
          function g() {
            let t4 = this, e4 = this.getPointsCollection(), s4 = this.options.nullColor, i2 = this.colorAxis, o2 = this.colorKey;
            e4.forEach((e5) => {
              let l2 = e5.getNestedProperty(o2), r2 = e5.options.color || (e5.isNull || null === e5.value ? s4 : i2 && void 0 !== l2 ? i2.toColor(l2, e5) : e5.color || t4.color);
              r2 && e5.color !== r2 && (e5.color = r2, "point" === t4.options.legendType && e5.legendItem && e5.legendItem.label && t4.chart.legend.colorizeItem(e5, e5.visible));
            });
          }
          function m() {
            this.elem.attr("fill", i(this.start).tweenTo(i(this.end), this.pos), void 0, true);
          }
          function x() {
            this.elem.attr("stroke", i(this.start).tweenTo(i(this.end), this.pos), void 0, true);
          }
          t3.compose = function(t4, i2, n2, C, y) {
            let A = i2.prototype, b = n2.prototype, v = y.prototype;
            A.collectionsWithUpdate.includes("colorAxis") || (e3 = t4, A.collectionsWithUpdate.push("colorAxis"), A.collectionsWithInit.colorAxis = [A.addColorAxis], o(i2, "afterGetAxes", s3), function(t5) {
              let s4 = t5.prototype.createAxis;
              t5.prototype.createAxis = function(t6, i3) {
                if ("colorAxis" !== t6) return s4.apply(this, arguments);
                let o2 = new e3(this, r(i3.axis, { index: this[t6].length, isX: false }));
                return this.isDirtyLegend = true, this.axes.forEach((t7) => {
                  t7.series = [];
                }), this.series.forEach((t7) => {
                  t7.bindAxes(), t7.isDirtyData = true;
                }), a(i3.redraw, true) && this.redraw(i3.animation), o2;
              };
            }(i2), b.fillSetter = m, b.strokeSetter = x, o(C, "afterGetAllItems", h), o(C, "afterColorizeItem", d), o(C, "afterUpdate", c), l(v, { optionalAxis: "colorAxis", translateColors: g }), l(v.pointClass.prototype, { setVisible: u }), o(y, "afterTranslate", p, { order: 1 }), o(y, "bindAxes", f));
          }, t3.pointSetVisible = u;
        }(s2 || (s2 = {})), s2;
      }), s(e, "Core/Axis/Color/ColorAxisDefaults.js", [], function() {
        return { lineWidth: 0, minPadding: 0, maxPadding: 0, gridLineColor: "#ffffff", gridLineWidth: 1, tickPixelInterval: 72, startOnTick: true, endOnTick: true, offset: 0, marker: { animation: { duration: 50 }, width: 0.01, color: "#999999" }, labels: { distance: 8, overflow: "justify", rotation: 0 }, minColor: "#e6e9ff", maxColor: "#0022ff", tickLength: 5, showInLegend: true };
      }), s(e, "Core/Axis/Color/ColorAxisLike.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var s2, i;
        let { parse: o } = t2, { merge: l } = e2;
        return (i = s2 || (s2 = {})).initDataClasses = function(t3) {
          let e3 = this.chart, s3 = this.legendItem = this.legendItem || {}, i2 = this.options, r = t3.dataClasses || [], a, n, h = e3.options.chart.colorCount, d = 0, c;
          this.dataClasses = n = [], s3.labels = [];
          for (let t4 = 0, s4 = r.length; t4 < s4; ++t4) a = l(a = r[t4]), n.push(a), (e3.styledMode || !a.color) && ("category" === i2.dataClassColor ? (e3.styledMode || (h = (c = e3.options.colors || []).length, a.color = c[d]), a.colorIndex = d, ++d === h && (d = 0)) : a.color = o(i2.minColor).tweenTo(o(i2.maxColor), s4 < 2 ? 0.5 : t4 / (s4 - 1)));
        }, i.initStops = function() {
          let t3 = this.options, e3 = this.stops = t3.stops || [[0, t3.minColor || ""], [1, t3.maxColor || ""]];
          for (let t4 = 0, s3 = e3.length; t4 < s3; ++t4) e3[t4].color = o(e3[t4][1]);
        }, i.normalizedValue = function(t3) {
          let e3 = this.max || 0, s3 = this.min || 0;
          return this.logarithmic && (t3 = this.logarithmic.log2lin(t3)), 1 - (e3 - t3) / (e3 - s3 || 1);
        }, i.toColor = function(t3, e3) {
          let s3, i2, o2, l2, r, a;
          let n = this.dataClasses, h = this.stops;
          if (n) {
            for (a = n.length; a--; ) if (i2 = (r = n[a]).from, o2 = r.to, (void 0 === i2 || t3 >= i2) && (void 0 === o2 || t3 <= o2)) {
              l2 = r.color, e3 && (e3.dataClass = a, e3.colorIndex = r.colorIndex);
              break;
            }
          } else {
            for (s3 = this.normalizedValue(t3), a = h.length; a-- && !(s3 > h[a][0]); ) ;
            i2 = h[a] || h[a + 1], s3 = 1 - ((o2 = h[a + 1] || i2)[0] - s3) / (o2[0] - i2[0] || 1), l2 = i2.color.tweenTo(o2.color, s3);
          }
          return l2;
        }, s2;
      }), s(e, "Core/Axis/Color/ColorAxis.js", [e["Core/Axis/Axis.js"], e["Core/Axis/Color/ColorAxisComposition.js"], e["Core/Axis/Color/ColorAxisDefaults.js"], e["Core/Axis/Color/ColorAxisLike.js"], e["Core/Defaults.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i, o, l, r, a) {
        let { defaultOptions: n } = o, { series: h } = r, { defined: d, extend: c, fireEvent: p, isArray: f, isNumber: u, merge: g, pick: m, relativeLength: x } = a;
        n.colorAxis = g(n.xAxis, s2);
        class C extends t2 {
          static compose(t3, s3, i2, o2) {
            e2.compose(C, t3, s3, i2, o2);
          }
          constructor(t3, e3) {
            super(t3, e3), this.coll = "colorAxis", this.visible = true, this.init(t3, e3);
          }
          init(t3, e3) {
            let s3 = t3.options.legend || {}, i2 = e3.layout ? "vertical" !== e3.layout : "vertical" !== s3.layout;
            this.side = e3.side || i2 ? 2 : 1, this.reversed = e3.reversed || !i2, this.opposite = !i2, super.init(t3, e3, "colorAxis"), this.userOptions = e3, f(t3.userOptions.colorAxis) && (t3.userOptions.colorAxis[this.index] = e3), e3.dataClasses && this.initDataClasses(e3), this.initStops(), this.horiz = i2, this.zoomEnabled = false;
          }
          hasData() {
            return !!(this.tickPositions || []).length;
          }
          setTickPositions() {
            if (!this.dataClasses) return super.setTickPositions();
          }
          setOptions(t3) {
            let e3 = g(n.colorAxis, t3, { showEmpty: false, title: null, visible: this.chart.options.legend.enabled && false !== t3.visible });
            super.setOptions(e3), this.options.crosshair = this.options.marker;
          }
          setAxisSize() {
            var _a;
            let t3 = this.chart, e3 = (_a = this.legendItem) == null ? void 0 : _a.symbol, { width: s3, height: i2 } = this.getSize();
            e3 && (this.left = +e3.attr("x"), this.top = +e3.attr("y"), this.width = s3 = +e3.attr("width"), this.height = i2 = +e3.attr("height"), this.right = t3.chartWidth - this.left - s3, this.bottom = t3.chartHeight - this.top - i2, this.pos = this.horiz ? this.left : this.top), this.len = (this.horiz ? s3 : i2) || C.defaultLegendLength;
          }
          getOffset() {
            var _a;
            let t3 = (_a = this.legendItem) == null ? void 0 : _a.group, e3 = this.chart.axisOffset[this.side];
            if (t3) {
              this.axisParent = t3, super.getOffset();
              let s3 = this.chart.legend;
              s3.allItems.forEach(function(t4) {
                t4 instanceof C && t4.drawLegendSymbol(s3, t4);
              }), s3.render(), this.chart.getMargins(true), this.chart.series.some((t4) => t4.isDrilling) || (this.isDirty = true), this.added || (this.added = true, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = e3;
            }
          }
          setLegendColor() {
            let t3 = this.horiz, e3 = this.reversed, s3 = e3 ? 1 : 0, i2 = e3 ? 0 : 1, o2 = t3 ? [s3, 0, i2, 0] : [0, i2, 0, s3];
            this.legendColor = { linearGradient: { x1: o2[0], y1: o2[1], x2: o2[2], y2: o2[3] }, stops: this.stops };
          }
          drawLegendSymbol(t3, e3) {
            let s3 = e3.legendItem || {}, i2 = t3.padding, o2 = t3.options, l2 = this.options.labels, r2 = m(o2.itemDistance, 10), a2 = this.horiz, { width: n2, height: h2 } = this.getSize(), d2 = m(o2.labelPadding, a2 ? 16 : 30);
            this.setLegendColor(), s3.symbol || (s3.symbol = this.chart.renderer.symbol("roundedRect").attr({ r: o2.symbolRadius ?? 3, zIndex: 1 }).add(s3.group)), s3.symbol.attr({ x: 0, y: (t3.baseline || 0) - 11, width: n2, height: h2 }), s3.labelWidth = n2 + i2 + (a2 ? r2 : m(l2.x, l2.distance) + (this.maxLabelLength || 0)), s3.labelHeight = h2 + i2 + (a2 ? d2 : 0);
          }
          setState(t3) {
            this.series.forEach(function(e3) {
              e3.setState(t3);
            });
          }
          setVisible() {
          }
          getSeriesExtremes() {
            let t3 = this.series, e3, s3, i2, o2, l2, r2, a2 = t3.length, n2, c2;
            for (this.dataMin = 1 / 0, this.dataMax = -1 / 0; a2--; ) {
              if (s3 = (r2 = t3[a2]).colorKey = m(r2.options.colorKey, r2.colorKey, r2.pointValKey, r2.zoneAxis, "y"), o2 = r2.pointArrayMap, l2 = r2[s3 + "Min"] && r2[s3 + "Max"], r2[s3 + "Data"]) e3 = r2[s3 + "Data"];
              else if (o2) {
                if (e3 = [], i2 = o2.indexOf(s3), n2 = r2.yData, i2 >= 0 && n2) for (c2 = 0; c2 < n2.length; c2++) e3.push(m(n2[c2][i2], n2[c2]));
              } else e3 = r2.yData;
              if (l2) r2.minColorValue = r2[s3 + "Min"], r2.maxColorValue = r2[s3 + "Max"];
              else {
                let t4 = h.prototype.getExtremes.call(r2, e3);
                r2.minColorValue = t4.dataMin, r2.maxColorValue = t4.dataMax;
              }
              d(r2.minColorValue) && d(r2.maxColorValue) && (this.dataMin = Math.min(this.dataMin, r2.minColorValue), this.dataMax = Math.max(this.dataMax, r2.maxColorValue)), l2 || h.prototype.applyExtremes.call(r2);
            }
          }
          drawCrosshair(t3, e3) {
            let s3;
            let i2 = this.legendItem || {}, o2 = e3 && e3.plotX, l2 = e3 && e3.plotY, r2 = this.pos, a2 = this.len;
            e3 && ((s3 = this.toPixels(e3.getNestedProperty(e3.series.colorKey))) < r2 ? s3 = r2 - 2 : s3 > r2 + a2 && (s3 = r2 + a2 + 2), e3.plotX = s3, e3.plotY = this.len - s3, super.drawCrosshair(t3, e3), e3.plotX = o2, e3.plotY = l2, this.cross && !this.cross.addedToColorAxis && i2.group && (this.cross.addClass("highcharts-coloraxis-marker").add(i2.group), this.cross.addedToColorAxis = true, this.chart.styledMode || "object" != typeof this.crosshair || this.cross.attr({ fill: this.crosshair.color })));
          }
          getPlotLinePath(t3) {
            let e3 = this.left, s3 = t3.translatedValue, i2 = this.top;
            return u(s3) ? this.horiz ? [["M", s3 - 4, i2 - 6], ["L", s3 + 4, i2 - 6], ["L", s3, i2], ["Z"]] : [["M", e3, s3], ["L", e3 - 6, s3 + 6], ["L", e3 - 6, s3 - 6], ["Z"]] : super.getPlotLinePath(t3);
          }
          update(t3, e3) {
            let s3 = this.chart.legend;
            this.series.forEach((t4) => {
              t4.isDirtyData = true;
            }), (t3.dataClasses && s3.allItems || this.dataClasses) && this.destroyItems(), super.update(t3, e3), this.legendItem && this.legendItem.label && (this.setLegendColor(), s3.colorizeItem(this, true));
          }
          destroyItems() {
            let t3 = this.chart, e3 = this.legendItem || {};
            if (e3.label) t3.legend.destroyItem(this);
            else if (e3.labels) for (let s3 of e3.labels) t3.legend.destroyItem(s3);
            t3.isDirtyLegend = true;
          }
          destroy() {
            this.chart.isDirtyLegend = true, this.destroyItems(), super.destroy(...[].slice.call(arguments));
          }
          remove(t3) {
            this.destroyItems(), super.remove(t3);
          }
          getDataClassLegendSymbols() {
            let t3;
            let e3 = this, s3 = e3.chart, i2 = e3.legendItem && e3.legendItem.labels || [], o2 = s3.options.legend, r2 = m(o2.valueDecimals, -1), a2 = m(o2.valueSuffix, ""), n2 = (t4) => e3.series.reduce((e4, s4) => (e4.push(...s4.points.filter((e5) => e5.dataClass === t4)), e4), []);
            return i2.length || e3.dataClasses.forEach((o3, h2) => {
              let d2 = o3.from, f2 = o3.to, { numberFormatter: u2 } = s3, g2 = true;
              t3 = "", void 0 === d2 ? t3 = "< " : void 0 === f2 && (t3 = "> "), void 0 !== d2 && (t3 += u2(d2, r2) + a2), void 0 !== d2 && void 0 !== f2 && (t3 += " - "), void 0 !== f2 && (t3 += u2(f2, r2) + a2), i2.push(c({ chart: s3, name: t3, options: {}, drawLegendSymbol: l.rectangle, visible: true, isDataClass: true, setState: (t4) => {
                for (let e4 of n2(h2)) e4.setState(t4);
              }, setVisible: function() {
                this.visible = g2 = e3.visible = !g2;
                let t4 = [];
                for (let e4 of n2(h2)) e4.setVisible(g2), e4.hiddenInDataClass = !g2, -1 === t4.indexOf(e4.series) && t4.push(e4.series);
                s3.legend.colorizeItem(this, g2), t4.forEach((t5) => {
                  p(t5, "afterDataClassLegendClick");
                });
              } }, o3));
            }), i2;
          }
          getSize() {
            let { chart: t3, horiz: e3 } = this, { height: s3, width: i2 } = this.options, { legend: o2 } = t3.options;
            return { width: m(d(i2) ? x(i2, t3.chartWidth) : void 0, o2 == null ? void 0 : o2.symbolWidth, e3 ? C.defaultLegendLength : 12), height: m(d(s3) ? x(s3, t3.chartHeight) : void 0, o2 == null ? void 0 : o2.symbolHeight, e3 ? 12 : C.defaultLegendLength) };
          }
        }
        return C.defaultLegendLength = 200, C.keepProps = ["legendItem"], c(C.prototype, i), Array.prototype.push.apply(t2.keepProps, C.keepProps), C;
      }), s(e, "masters/modules/coloraxis.src.js", [e["Core/Globals.js"], e["Core/Axis/Color/ColorAxis.js"]], function(t2, e2) {
        return t2.ColorAxis = t2.ColorAxis || e2, t2.ColorAxis.compose(t2.Chart, t2.Fx, t2.Legend, t2.Series), t2;
      });
    });
  }
});
export default require_coloraxis();
//# sourceMappingURL=highcharts_modules_coloraxis__js.js.map
