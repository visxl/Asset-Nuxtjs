import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/parallel-coordinates.js
var require_parallel_coordinates = __commonJS({
  "node_modules/highcharts/modules/parallel-coordinates.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Support for parallel coordinates in Highcharts
    *
    * (c) 2010-2024 Pawel Fus
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/parallel-coordinates", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function s(e2, s2, l, i) {
        e2.hasOwnProperty(s2) || (e2[s2] = i.apply(null, l), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: e2[s2] } })));
      }
      s(e, "Extensions/ParallelCoordinates/ParallelCoordinatesDefaults.js", [], function() {
        return { chart: { parallelCoordinates: false, parallelAxes: { lineWidth: 1, title: { text: "", reserveSpace: false }, labels: { x: 0, y: 4, align: "center", reserveSpace: false }, offset: 0 } }, xAxis: { lineWidth: 0, tickLength: 0, opposite: true, type: "category" } };
      }), s(e, "Extensions/ParallelCoordinates/ParallelAxis.js", [e["Extensions/ParallelCoordinates/ParallelCoordinatesDefaults.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var s2;
        let { addEvent: l, arrayMax: i, arrayMin: a, isNumber: o, merge: r, pick: n, splat: h } = e2;
        class p {
          constructor(t3) {
            this.axis = t3;
          }
          setPosition(t3, e3) {
            let s3 = this.axis, l2 = s3.chart, i2 = ((this.position || 0) + 0.5) / (l2.parallelInfo.counter + 1);
            l2.polar ? e3.angle = 360 * i2 : (e3[t3[0]] = 100 * i2 + "%", s3[t3[1]] = e3[t3[1]] = 0, s3[t3[2]] = e3[t3[2]] = null, s3[t3[3]] = e3[t3[3]] = null);
          }
        }
        return function(e3) {
          function s3(e4) {
            let s4 = this.chart, l2 = this.parallelCoordinates, i2 = ["left", "width", "height", "top"];
            if (s4.hasParallelCoordinates) {
              if (s4.inverted && (i2 = i2.reverse()), this.isXAxis) this.options = r(this.options, t2.xAxis, e4.userOptions);
              else {
                let t3 = s4.yAxis.indexOf(this);
                this.options = r(this.options, this.chart.options.chart.parallelAxes, e4.userOptions), l2.position = n(l2.position, t3 >= 0 ? t3 : s4.yAxis.length), l2.setPosition(i2, this.options);
              }
            }
          }
          function c(t3) {
            let e4 = this.chart, s4 = this.parallelCoordinates;
            if (s4 && e4 && e4.hasParallelCoordinates && !this.isXAxis) {
              let e5 = s4.position, l2 = [];
              this.series.forEach(function(t4) {
                if (t4.yData && t4.visible && o(e5)) {
                  let s5 = t4.yData[e5];
                  l2.push.apply(l2, h(s5));
                }
              }), l2 = l2.filter(o), this.dataMin = a(l2), this.dataMax = i(l2), t3.preventDefault();
            }
          }
          function d() {
            this.parallelCoordinates || (this.parallelCoordinates = new p(this));
          }
          e3.compose = function(t3) {
            t3.keepProps.includes("parallel") || (t3.keepProps.push("parallel"), l(t3, "init", d), l(t3, "afterSetOptions", s3), l(t3, "getSeriesExtremes", c));
          };
        }(s2 || (s2 = {})), s2;
      }), s(e, "Extensions/ParallelCoordinates/ParallelSeries.js", [e["Core/Globals.js"], e["Core/Templating.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        var l;
        let { composed: i } = t2, { format: a } = e2, { addEvent: o, defined: r, erase: n, extend: h, insertItem: p, isArray: c, isNumber: d, pick: f, pushUnique: u, wrap: x } = s2;
        return function(t3) {
          function e3() {
            let t4 = this.chart, e4 = this.points, s4 = e4 && e4.length, l3 = Number.MAX_VALUE, i2, a2;
            if (this.chart.hasParallelCoordinates) {
              for (let o2 = 0; o2 < s4; o2++) r((a2 = e4[o2]).y) ? (t4.polar ? a2.plotX = t4.yAxis[o2].angleRad || 0 : t4.inverted ? a2.plotX = t4.plotHeight - t4.yAxis[o2].top + t4.plotTop : a2.plotX = t4.yAxis[o2].left - t4.plotLeft, a2.clientX = a2.plotX, a2.plotY = t4.yAxis[o2].translate(a2.y, false, true, void 0, true), d(a2.high) && (a2.plotHigh = t4.yAxis[o2].translate(a2.high, false, true, void 0, true)), void 0 !== i2 && (l3 = Math.min(l3, Math.abs(a2.plotX - i2))), i2 = a2.plotX, a2.isInside = t4.isInsidePlot(a2.plotX, a2.plotY, { inverted: t4.inverted })) : a2.isNull = true;
              this.closestPointRangePx = l3;
            }
          }
          function s3(t4) {
            let e4 = this.chart;
            if (e4.hasParallelCoordinates) {
              for (let t5 of e4.axes) p(this, t5.series), t5.isDirty = true;
              this.xAxis = e4.xAxis[0], this.yAxis = e4.yAxis[0], t4.preventDefault();
            }
          }
          function l2() {
            let t4 = this.chart;
            if (t4.hasParallelCoordinates) for (let e4 of t4.axes || []) e4 && e4.series && (n(e4.series, this), e4.isDirty = e4.forceRedraw = true);
          }
          function C(t4) {
            let e4, s4, l3, i2;
            let o2 = this.series && this.series.chart, n2 = t4.apply(this, [].slice.call(arguments, 1));
            return o2 && o2.hasParallelCoordinates && !r(n2.formattedValue) && (e4 = (l3 = f((s4 = (i2 = o2.yAxis[this.x]).options).tooltipValueFormat, s4.labels.format)) ? a(l3, h(this, { value: this.y }), o2) : i2.dateTime ? o2.time.dateFormat(o2.time.resolveDTLFormat(s4.dateTimeLabelFormats[i2.tickPositions.info.unitName]).main, this.y) : c(s4.categories) ? s4.categories[this.y] : this.y, n2.formattedValue = n2.point.formattedValue = e4), n2;
          }
          t3.compose = function(t4) {
            if (u(i, "ParallelSeries")) {
              let { line: { prototype: { pointClass: i2 } }, spline: { prototype: { pointClass: a2 } } } = t4.types;
              o(t4, "afterTranslate", e3, { order: 1 }), o(t4, "bindAxes", s3), o(t4, "destroy", l2), i2 && x(i2.prototype, "getLabelConfig", C), a2 && x(a2.prototype, "getLabelConfig", C);
            }
          };
        }(l || (l = {})), l;
      }), s(e, "Extensions/ParallelCoordinates/ParallelCoordinates.js", [e["Extensions/ParallelCoordinates/ParallelAxis.js"], e["Extensions/ParallelCoordinates/ParallelCoordinatesDefaults.js"], e["Extensions/ParallelCoordinates/ParallelSeries.js"], e["Core/Utilities.js"]], function(t2, e2, s2, l) {
        var i;
        let { addEvent: a, defined: o, merge: r, splat: n } = l;
        class h {
          constructor(t3) {
            this.chart = t3;
          }
          setParallelInfo(t3) {
            let e3 = this.chart || this, s3 = t3.series;
            for (let t4 of (e3.parallelInfo = { counter: 0 }, s3)) t4.data && (e3.parallelInfo.counter = Math.max(e3.parallelInfo.counter, t4.data.length - 1));
          }
        }
        return function(l2) {
          function i2(t3) {
            let s3 = t3.args[0], l3 = n(s3.yAxis || {}), i3 = [], a2 = l3.length;
            if (this.hasParallelCoordinates = s3.chart && s3.chart.parallelCoordinates, this.hasParallelCoordinates) {
              for (this.setParallelInfo(s3); a2 <= this.parallelInfo.counter; a2++) i3.push({});
              s3.legend || (s3.legend = {}), s3.legend && void 0 === s3.legend.enabled && (s3.legend.enabled = false), r(true, s3, { boost: { seriesThreshold: Number.MAX_VALUE }, plotOptions: { series: { boostThreshold: Number.MAX_VALUE } } }), s3.yAxis = l3.concat(i3), s3.xAxis = r(e2.xAxis, n(s3.xAxis || {})[0]);
            }
          }
          function p(t3) {
            let e3 = t3.options;
            if (e3.chart && (o(e3.chart.parallelCoordinates) && (this.hasParallelCoordinates = e3.chart.parallelCoordinates), this.options.chart.parallelAxes = r(this.options.chart.parallelAxes, e3.chart.parallelAxes)), this.hasParallelCoordinates) for (let t4 of (e3.series && this.setParallelInfo(e3), this.yAxis)) t4.update({}, false);
          }
          l2.compose = function(l3, o2, n2, c) {
            t2.compose(l3), s2.compose(c);
            let d = h.prototype, f = o2.prototype;
            f.setParallelInfo || (f.setParallelInfo = d.setParallelInfo, a(o2, "init", i2), a(o2, "update", p), r(true, n2.chart, e2.chart));
          };
        }(i || (i = {})), i;
      }), s(e, "masters/modules/parallel-coordinates.src.js", [e["Core/Globals.js"], e["Extensions/ParallelCoordinates/ParallelCoordinates.js"]], function(t2, e2) {
        return e2.compose(t2.Axis, t2.Chart, t2.defaultOptions, t2.Series), t2;
      });
    });
  }
});
export default require_parallel_coordinates();
//# sourceMappingURL=highcharts_modules_parallel-coordinates__js.js.map
