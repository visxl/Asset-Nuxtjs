import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/heatmap.js
var require_heatmap = __commonJS({
  "node_modules/highcharts/modules/heatmap.js"(exports, module) {
    !/**
    * Highmaps JS v11.4.7 (2024-08-14)
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/heatmap", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function s(e2, s2, i, o) {
        e2.hasOwnProperty(s2) || (e2[s2] = o.apply(null, i), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: e2[s2] } })));
      }
      s(e, "Core/Axis/Color/ColorAxisComposition.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var s2;
        let { parse: i } = t2, { addEvent: o, extend: r, merge: l, pick: a, splat: n } = e2;
        return function(t3) {
          let e3;
          function s3() {
            let { userOptions: t4 } = this;
            this.colorAxis = [], t4.colorAxis && (t4.colorAxis = n(t4.colorAxis), t4.colorAxis.map((t5) => new e3(this, t5)));
          }
          function h(t4) {
            let e4 = this.chart.colorAxis || [], s4 = (e5) => {
              let s5 = t4.allItems.indexOf(e5);
              -1 !== s5 && (this.destroyItem(t4.allItems[s5]), t4.allItems.splice(s5, 1));
            }, i2 = [], o2, r2;
            for (e4.forEach(function(t5) {
              (o2 = t5.options) && o2.showInLegend && (o2.dataClasses && o2.visible ? i2 = i2.concat(t5.getDataClassLegendSymbols()) : o2.visible && i2.push(t5), t5.series.forEach(function(t6) {
                (!t6.options.showInLegend || o2.dataClasses) && ("point" === t6.options.legendType ? t6.points.forEach(function(t7) {
                  s4(t7);
                }) : s4(t6));
              }));
            }), r2 = i2.length; r2--; ) t4.allItems.unshift(i2[r2]);
          }
          function d(t4) {
            t4.visible && t4.item.legendColor && t4.item.legendItem.symbol.attr({ fill: t4.item.legendColor });
          }
          function p(t4) {
            var _a;
            (_a = this.chart.colorAxis) == null ? void 0 : _a.forEach((e4) => {
              e4.update({}, t4.redraw);
            });
          }
          function c() {
            (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
          }
          function u() {
            let t4 = this.axisTypes;
            t4 ? -1 === t4.indexOf("colorAxis") && t4.push("colorAxis") : this.axisTypes = ["colorAxis"];
          }
          function m(t4) {
            let e4 = this, s4 = t4 ? "show" : "hide";
            e4.visible = e4.options.visible = !!t4, ["graphic", "dataLabel"].forEach(function(t5) {
              e4[t5] && e4[t5][s4]();
            }), this.series.buildKDTree();
          }
          function f() {
            let t4 = this, e4 = this.getPointsCollection(), s4 = this.options.nullColor, i2 = this.colorAxis, o2 = this.colorKey;
            e4.forEach((e5) => {
              let r2 = e5.getNestedProperty(o2), l2 = e5.options.color || (e5.isNull || null === e5.value ? s4 : i2 && void 0 !== r2 ? i2.toColor(r2, e5) : e5.color || t4.color);
              l2 && e5.color !== l2 && (e5.color = l2, "point" === t4.options.legendType && e5.legendItem && e5.legendItem.label && t4.chart.legend.colorizeItem(e5, e5.visible));
            });
          }
          function g() {
            this.elem.attr("fill", i(this.start).tweenTo(i(this.end), this.pos), void 0, true);
          }
          function x() {
            this.elem.attr("stroke", i(this.start).tweenTo(i(this.end), this.pos), void 0, true);
          }
          t3.compose = function(t4, i2, n2, y, C) {
            let b = i2.prototype, v = n2.prototype, A = C.prototype;
            b.collectionsWithUpdate.includes("colorAxis") || (e3 = t4, b.collectionsWithUpdate.push("colorAxis"), b.collectionsWithInit.colorAxis = [b.addColorAxis], o(i2, "afterGetAxes", s3), function(t5) {
              let s4 = t5.prototype.createAxis;
              t5.prototype.createAxis = function(t6, i3) {
                if ("colorAxis" !== t6) return s4.apply(this, arguments);
                let o2 = new e3(this, l(i3.axis, { index: this[t6].length, isX: false }));
                return this.isDirtyLegend = true, this.axes.forEach((t7) => {
                  t7.series = [];
                }), this.series.forEach((t7) => {
                  t7.bindAxes(), t7.isDirtyData = true;
                }), a(i3.redraw, true) && this.redraw(i3.animation), o2;
              };
            }(i2), v.fillSetter = g, v.strokeSetter = x, o(y, "afterGetAllItems", h), o(y, "afterColorizeItem", d), o(y, "afterUpdate", p), r(A, { optionalAxis: "colorAxis", translateColors: f }), r(A.pointClass.prototype, { setVisible: m }), o(C, "afterTranslate", c, { order: 1 }), o(C, "bindAxes", u));
          }, t3.pointSetVisible = m;
        }(s2 || (s2 = {})), s2;
      }), s(e, "Core/Axis/Color/ColorAxisDefaults.js", [], function() {
        return { lineWidth: 0, minPadding: 0, maxPadding: 0, gridLineColor: "#ffffff", gridLineWidth: 1, tickPixelInterval: 72, startOnTick: true, endOnTick: true, offset: 0, marker: { animation: { duration: 50 }, width: 0.01, color: "#999999" }, labels: { distance: 8, overflow: "justify", rotation: 0 }, minColor: "#e6e9ff", maxColor: "#0022ff", tickLength: 5, showInLegend: true };
      }), s(e, "Core/Axis/Color/ColorAxisLike.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var s2, i;
        let { parse: o } = t2, { merge: r } = e2;
        return (i = s2 || (s2 = {})).initDataClasses = function(t3) {
          let e3 = this.chart, s3 = this.legendItem = this.legendItem || {}, i2 = this.options, l = t3.dataClasses || [], a, n, h = e3.options.chart.colorCount, d = 0, p;
          this.dataClasses = n = [], s3.labels = [];
          for (let t4 = 0, s4 = l.length; t4 < s4; ++t4) a = r(a = l[t4]), n.push(a), (e3.styledMode || !a.color) && ("category" === i2.dataClassColor ? (e3.styledMode || (h = (p = e3.options.colors || []).length, a.color = p[d]), a.colorIndex = d, ++d === h && (d = 0)) : a.color = o(i2.minColor).tweenTo(o(i2.maxColor), s4 < 2 ? 0.5 : t4 / (s4 - 1)));
        }, i.initStops = function() {
          let t3 = this.options, e3 = this.stops = t3.stops || [[0, t3.minColor || ""], [1, t3.maxColor || ""]];
          for (let t4 = 0, s3 = e3.length; t4 < s3; ++t4) e3[t4].color = o(e3[t4][1]);
        }, i.normalizedValue = function(t3) {
          let e3 = this.max || 0, s3 = this.min || 0;
          return this.logarithmic && (t3 = this.logarithmic.log2lin(t3)), 1 - (e3 - t3) / (e3 - s3 || 1);
        }, i.toColor = function(t3, e3) {
          let s3, i2, o2, r2, l, a;
          let n = this.dataClasses, h = this.stops;
          if (n) {
            for (a = n.length; a--; ) if (i2 = (l = n[a]).from, o2 = l.to, (void 0 === i2 || t3 >= i2) && (void 0 === o2 || t3 <= o2)) {
              r2 = l.color, e3 && (e3.dataClass = a, e3.colorIndex = l.colorIndex);
              break;
            }
          } else {
            for (s3 = this.normalizedValue(t3), a = h.length; a-- && !(s3 > h[a][0]); ) ;
            i2 = h[a] || h[a + 1], s3 = 1 - ((o2 = h[a + 1] || i2)[0] - s3) / (o2[0] - i2[0] || 1), r2 = i2.color.tweenTo(o2.color, s3);
          }
          return r2;
        }, s2;
      }), s(e, "Core/Axis/Color/ColorAxis.js", [e["Core/Axis/Axis.js"], e["Core/Axis/Color/ColorAxisComposition.js"], e["Core/Axis/Color/ColorAxisDefaults.js"], e["Core/Axis/Color/ColorAxisLike.js"], e["Core/Defaults.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i, o, r, l, a) {
        let { defaultOptions: n } = o, { series: h } = l, { defined: d, extend: p, fireEvent: c, isArray: u, isNumber: m, merge: f, pick: g, relativeLength: x } = a;
        n.colorAxis = f(n.xAxis, s2);
        class y extends t2 {
          static compose(t3, s3, i2, o2) {
            e2.compose(y, t3, s3, i2, o2);
          }
          constructor(t3, e3) {
            super(t3, e3), this.coll = "colorAxis", this.visible = true, this.init(t3, e3);
          }
          init(t3, e3) {
            let s3 = t3.options.legend || {}, i2 = e3.layout ? "vertical" !== e3.layout : "vertical" !== s3.layout;
            this.side = e3.side || i2 ? 2 : 1, this.reversed = e3.reversed || !i2, this.opposite = !i2, super.init(t3, e3, "colorAxis"), this.userOptions = e3, u(t3.userOptions.colorAxis) && (t3.userOptions.colorAxis[this.index] = e3), e3.dataClasses && this.initDataClasses(e3), this.initStops(), this.horiz = i2, this.zoomEnabled = false;
          }
          hasData() {
            return !!(this.tickPositions || []).length;
          }
          setTickPositions() {
            if (!this.dataClasses) return super.setTickPositions();
          }
          setOptions(t3) {
            let e3 = f(n.colorAxis, t3, { showEmpty: false, title: null, visible: this.chart.options.legend.enabled && false !== t3.visible });
            super.setOptions(e3), this.options.crosshair = this.options.marker;
          }
          setAxisSize() {
            var _a;
            let t3 = this.chart, e3 = (_a = this.legendItem) == null ? void 0 : _a.symbol, { width: s3, height: i2 } = this.getSize();
            e3 && (this.left = +e3.attr("x"), this.top = +e3.attr("y"), this.width = s3 = +e3.attr("width"), this.height = i2 = +e3.attr("height"), this.right = t3.chartWidth - this.left - s3, this.bottom = t3.chartHeight - this.top - i2, this.pos = this.horiz ? this.left : this.top), this.len = (this.horiz ? s3 : i2) || y.defaultLegendLength;
          }
          getOffset() {
            var _a;
            let t3 = (_a = this.legendItem) == null ? void 0 : _a.group, e3 = this.chart.axisOffset[this.side];
            if (t3) {
              this.axisParent = t3, super.getOffset();
              let s3 = this.chart.legend;
              s3.allItems.forEach(function(t4) {
                t4 instanceof y && t4.drawLegendSymbol(s3, t4);
              }), s3.render(), this.chart.getMargins(true), this.chart.series.some((t4) => t4.isDrilling) || (this.isDirty = true), this.added || (this.added = true, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = e3;
            }
          }
          setLegendColor() {
            let t3 = this.horiz, e3 = this.reversed, s3 = e3 ? 1 : 0, i2 = e3 ? 0 : 1, o2 = t3 ? [s3, 0, i2, 0] : [0, i2, 0, s3];
            this.legendColor = { linearGradient: { x1: o2[0], y1: o2[1], x2: o2[2], y2: o2[3] }, stops: this.stops };
          }
          drawLegendSymbol(t3, e3) {
            let s3 = e3.legendItem || {}, i2 = t3.padding, o2 = t3.options, r2 = this.options.labels, l2 = g(o2.itemDistance, 10), a2 = this.horiz, { width: n2, height: h2 } = this.getSize(), d2 = g(o2.labelPadding, a2 ? 16 : 30);
            this.setLegendColor(), s3.symbol || (s3.symbol = this.chart.renderer.symbol("roundedRect").attr({ r: o2.symbolRadius ?? 3, zIndex: 1 }).add(s3.group)), s3.symbol.attr({ x: 0, y: (t3.baseline || 0) - 11, width: n2, height: h2 }), s3.labelWidth = n2 + i2 + (a2 ? l2 : g(r2.x, r2.distance) + (this.maxLabelLength || 0)), s3.labelHeight = h2 + i2 + (a2 ? d2 : 0);
          }
          setState(t3) {
            this.series.forEach(function(e3) {
              e3.setState(t3);
            });
          }
          setVisible() {
          }
          getSeriesExtremes() {
            let t3 = this.series, e3, s3, i2, o2, r2, l2, a2 = t3.length, n2, p2;
            for (this.dataMin = 1 / 0, this.dataMax = -1 / 0; a2--; ) {
              if (s3 = (l2 = t3[a2]).colorKey = g(l2.options.colorKey, l2.colorKey, l2.pointValKey, l2.zoneAxis, "y"), o2 = l2.pointArrayMap, r2 = l2[s3 + "Min"] && l2[s3 + "Max"], l2[s3 + "Data"]) e3 = l2[s3 + "Data"];
              else if (o2) {
                if (e3 = [], i2 = o2.indexOf(s3), n2 = l2.yData, i2 >= 0 && n2) for (p2 = 0; p2 < n2.length; p2++) e3.push(g(n2[p2][i2], n2[p2]));
              } else e3 = l2.yData;
              if (r2) l2.minColorValue = l2[s3 + "Min"], l2.maxColorValue = l2[s3 + "Max"];
              else {
                let t4 = h.prototype.getExtremes.call(l2, e3);
                l2.minColorValue = t4.dataMin, l2.maxColorValue = t4.dataMax;
              }
              d(l2.minColorValue) && d(l2.maxColorValue) && (this.dataMin = Math.min(this.dataMin, l2.minColorValue), this.dataMax = Math.max(this.dataMax, l2.maxColorValue)), r2 || h.prototype.applyExtremes.call(l2);
            }
          }
          drawCrosshair(t3, e3) {
            let s3;
            let i2 = this.legendItem || {}, o2 = e3 && e3.plotX, r2 = e3 && e3.plotY, l2 = this.pos, a2 = this.len;
            e3 && ((s3 = this.toPixels(e3.getNestedProperty(e3.series.colorKey))) < l2 ? s3 = l2 - 2 : s3 > l2 + a2 && (s3 = l2 + a2 + 2), e3.plotX = s3, e3.plotY = this.len - s3, super.drawCrosshair(t3, e3), e3.plotX = o2, e3.plotY = r2, this.cross && !this.cross.addedToColorAxis && i2.group && (this.cross.addClass("highcharts-coloraxis-marker").add(i2.group), this.cross.addedToColorAxis = true, this.chart.styledMode || "object" != typeof this.crosshair || this.cross.attr({ fill: this.crosshair.color })));
          }
          getPlotLinePath(t3) {
            let e3 = this.left, s3 = t3.translatedValue, i2 = this.top;
            return m(s3) ? this.horiz ? [["M", s3 - 4, i2 - 6], ["L", s3 + 4, i2 - 6], ["L", s3, i2], ["Z"]] : [["M", e3, s3], ["L", e3 - 6, s3 + 6], ["L", e3 - 6, s3 - 6], ["Z"]] : super.getPlotLinePath(t3);
          }
          update(t3, e3) {
            let s3 = this.chart.legend;
            this.series.forEach((t4) => {
              t4.isDirtyData = true;
            }), (t3.dataClasses && s3.allItems || this.dataClasses) && this.destroyItems(), super.update(t3, e3), this.legendItem && this.legendItem.label && (this.setLegendColor(), s3.colorizeItem(this, true));
          }
          destroyItems() {
            let t3 = this.chart, e3 = this.legendItem || {};
            if (e3.label) t3.legend.destroyItem(this);
            else if (e3.labels) for (let s3 of e3.labels) t3.legend.destroyItem(s3);
            t3.isDirtyLegend = true;
          }
          destroy() {
            this.chart.isDirtyLegend = true, this.destroyItems(), super.destroy(...[].slice.call(arguments));
          }
          remove(t3) {
            this.destroyItems(), super.remove(t3);
          }
          getDataClassLegendSymbols() {
            let t3;
            let e3 = this, s3 = e3.chart, i2 = e3.legendItem && e3.legendItem.labels || [], o2 = s3.options.legend, l2 = g(o2.valueDecimals, -1), a2 = g(o2.valueSuffix, ""), n2 = (t4) => e3.series.reduce((e4, s4) => (e4.push(...s4.points.filter((e5) => e5.dataClass === t4)), e4), []);
            return i2.length || e3.dataClasses.forEach((o3, h2) => {
              let d2 = o3.from, u2 = o3.to, { numberFormatter: m2 } = s3, f2 = true;
              t3 = "", void 0 === d2 ? t3 = "< " : void 0 === u2 && (t3 = "> "), void 0 !== d2 && (t3 += m2(d2, l2) + a2), void 0 !== d2 && void 0 !== u2 && (t3 += " - "), void 0 !== u2 && (t3 += m2(u2, l2) + a2), i2.push(p({ chart: s3, name: t3, options: {}, drawLegendSymbol: r.rectangle, visible: true, isDataClass: true, setState: (t4) => {
                for (let e4 of n2(h2)) e4.setState(t4);
              }, setVisible: function() {
                this.visible = f2 = e3.visible = !f2;
                let t4 = [];
                for (let e4 of n2(h2)) e4.setVisible(f2), e4.hiddenInDataClass = !f2, -1 === t4.indexOf(e4.series) && t4.push(e4.series);
                s3.legend.colorizeItem(this, f2), t4.forEach((t5) => {
                  c(t5, "afterDataClassLegendClick");
                });
              } }, o3));
            }), i2;
          }
          getSize() {
            let { chart: t3, horiz: e3 } = this, { height: s3, width: i2 } = this.options, { legend: o2 } = t3.options;
            return { width: g(d(i2) ? x(i2, t3.chartWidth) : void 0, o2 == null ? void 0 : o2.symbolWidth, e3 ? y.defaultLegendLength : 12), height: g(d(s3) ? x(s3, t3.chartHeight) : void 0, o2 == null ? void 0 : o2.symbolHeight, e3 ? 12 : y.defaultLegendLength) };
          }
        }
        return y.defaultLegendLength = 200, y.keepProps = ["legendItem"], p(y.prototype, i), Array.prototype.push.apply(t2.keepProps, y.keepProps), y;
      }), s(e, "masters/modules/coloraxis.src.js", [e["Core/Globals.js"], e["Core/Axis/Color/ColorAxis.js"]], function(t2, e2) {
        return t2.ColorAxis = t2.ColorAxis || e2, t2.ColorAxis.compose(t2.Chart, t2.Fx, t2.Legend, t2.Series), t2;
      }), s(e, "Series/ColorMapComposition.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        var i;
        let { column: { prototype: o } } = t2.seriesTypes, { addEvent: r, defined: l } = s2;
        return function(t3) {
          function s3(t4) {
            let s4 = this.series, i2 = s4.chart.renderer;
            this.moveToTopOnHover && this.graphic && (s4.stateMarkerGraphic || (s4.stateMarkerGraphic = new e2(i2, "use").css({ pointerEvents: "none" }).add(this.graphic.parentGroup)), (t4 == null ? void 0 : t4.state) === "hover" ? (this.graphic.attr({ id: this.id }), s4.stateMarkerGraphic.attr({ href: `${i2.url}#${this.id}`, visibility: "visible" })) : s4.stateMarkerGraphic.attr({ href: "" }));
          }
          t3.pointMembers = { dataLabelOnNull: true, moveToTopOnHover: true, isValid: function() {
            return null !== this.value && this.value !== 1 / 0 && this.value !== -1 / 0 && (void 0 === this.value || !isNaN(this.value));
          } }, t3.seriesMembers = { colorKey: "value", axisTypes: ["xAxis", "yAxis", "colorAxis"], parallelArrays: ["x", "y", "value"], pointArrayMap: ["value"], trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], colorAttribs: function(t4) {
            let e3 = {};
            return l(t4.color) && (!t4.state || "normal" === t4.state) && (e3[this.colorProp || "fill"] = t4.color), e3;
          }, pointAttribs: o.pointAttribs }, t3.compose = function(t4) {
            return r(t4.prototype.pointClass, "afterSetState", s3), t4;
          };
        }(i || (i = {})), i;
      }), s(e, "Series/Heatmap/HeatmapPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { scatter: { prototype: { pointClass: s2 } } } = t2.seriesTypes, { clamp: i, defined: o, extend: r, pick: l } = e2;
        class a extends s2 {
          applyOptions(t3, e3) {
            return (this.isNull || null === this.value) && delete this.color, super.applyOptions(t3, e3), this.formatPrefix = this.isNull || null === this.value ? "null" : "point", this;
          }
          getCellAttributes() {
            let t3 = this.series, e3 = t3.options, s3 = (e3.colsize || 1) / 2, r2 = (e3.rowsize || 1) / 2, a2 = t3.xAxis, n = t3.yAxis, h = this.options.marker || t3.options.marker, d = t3.pointPlacementToXValue(), p = l(this.pointPadding, e3.pointPadding, 0), c = { x1: i(Math.round(a2.len - a2.translate(this.x - s3, false, true, false, true, -d)), -a2.len, 2 * a2.len), x2: i(Math.round(a2.len - a2.translate(this.x + s3, false, true, false, true, -d)), -a2.len, 2 * a2.len), y1: i(Math.round(n.translate(this.y - r2, false, true, false, true)), -n.len, 2 * n.len), y2: i(Math.round(n.translate(this.y + r2, false, true, false, true)), -n.len, 2 * n.len) };
            for (let t4 of [["width", "x"], ["height", "y"]]) {
              let e4 = t4[0], s4 = t4[1], i2 = s4 + "1", r3 = s4 + "2", l2 = Math.abs(c[i2] - c[r3]), d2 = h && h.lineWidth || 0, u = Math.abs(c[i2] + c[r3]) / 2, m = h && h[e4];
              if (o(m) && m < l2) {
                let t5 = m / 2 + d2 / 2;
                c[i2] = u - t5, c[r3] = u + t5;
              }
              p && (("x" === s4 && a2.reversed || "y" === s4 && !n.reversed) && (i2 = r3, r3 = s4 + "1"), c[i2] += p, c[r3] -= p);
            }
            return c;
          }
          haloPath(t3) {
            if (!t3) return [];
            let { x: e3 = 0, y: s3 = 0, width: i2 = 0, height: o2 = 0 } = this.shapeArgs || {};
            return [["M", e3 - t3, s3 - t3], ["L", e3 - t3, s3 + o2 + t3], ["L", e3 + i2 + t3, s3 + o2 + t3], ["L", e3 + i2 + t3, s3 - t3], ["Z"]];
          }
          isValid() {
            return this.value !== 1 / 0 && this.value !== -1 / 0;
          }
        }
        return r(a.prototype, { dataLabelOnNull: true, moveToTopOnHover: true, ttBelow: false }), a;
      }), s(e, "Series/Heatmap/HeatmapSeriesDefaults.js", [e["Core/Utilities.js"]], function(t2) {
        let { isNumber: e2 } = t2;
        return { animation: false, borderRadius: 0, borderWidth: 0, interpolation: false, nullColor: "#f7f7f7", dataLabels: { formatter: function() {
          let { numberFormatter: t3 } = this.series.chart, { value: s2 } = this.point;
          return e2(s2) ? t3(s2, -1) : "";
        }, inside: true, verticalAlign: "middle", crop: false, overflow: "allow", padding: 0 }, marker: { symbol: "rect", radius: 0, lineColor: void 0, states: { hover: { lineWidthPlus: 0 }, select: {} } }, clip: true, pointRange: null, tooltip: { pointFormat: "{point.x}, {point.y}: {point.value}<br/>" }, states: { hover: { halo: false, brightness: 0.2 } }, legendSymbol: "rectangle" };
      }), s(e, "Series/InterpolationUtilities.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { doc: s2 } = t2, { defined: i, pick: o } = e2;
        return { colorFromPoint: function(t3, e3) {
          let s3 = e3.series.colorAxis;
          if (s3) {
            let r = s3.toColor(t3 || 0, e3).split(")")[0].split("(")[1].split(",").map((t4) => o(parseFloat(t4), parseInt(t4, 10)));
            return r[3] = 255 * o(r[3], 1), i(t3) && e3.visible || (r[3] = 0), r;
          }
          return [0, 0, 0, 0];
        }, getContext: function(t3) {
          let { canvas: e3, context: i2 } = t3;
          return e3 && i2 ? (i2.clearRect(0, 0, e3.width, e3.height), i2) : (t3.canvas = s2.createElement("canvas"), t3.context = t3.canvas.getContext("2d", { willReadFrequently: true }) || void 0, t3.context);
        } };
      }), s(e, "Series/Heatmap/HeatmapSeries.js", [e["Core/Color/Color.js"], e["Series/ColorMapComposition.js"], e["Series/Heatmap/HeatmapPoint.js"], e["Series/Heatmap/HeatmapSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Utilities.js"], e["Series/InterpolationUtilities.js"]], function(t2, e2, s2, i, o, r, l, a) {
        let { series: n, seriesTypes: { column: h, scatter: d } } = o, { prototype: { symbols: p } } = r, { addEvent: c, extend: u, fireEvent: m, isNumber: f, merge: g, pick: x } = l, { colorFromPoint: y, getContext: C } = a;
        class b extends d {
          constructor() {
            super(...arguments), this.valueMax = NaN, this.valueMin = NaN, this.isDirtyCanvas = true;
          }
          drawPoints() {
            let t3 = this, e3 = t3.options, s3 = e3.interpolation, i2 = e3.marker || {};
            if (s3) {
              let { image: e4, chart: s4, xAxis: i3, yAxis: o2 } = t3, { reversed: r2 = false, len: l2 } = i3, { reversed: a2 = false, len: n2 } = o2, h2 = { width: l2, height: n2 };
              if (!e4 || t3.isDirtyData || t3.isDirtyCanvas) {
                let l3 = C(t3), { canvas: n3, options: { colsize: d2 = 1, rowsize: p2 = 1 }, points: c2, points: { length: u2 } } = t3, m2 = s4.colorAxis && s4.colorAxis[0];
                if (n3 && l3 && m2) {
                  let { min: m3, max: f2 } = i3.getExtremes(), { min: g2, max: x2 } = o2.getExtremes(), C2 = f2 - m3, b2 = x2 - g2, v = Math.round(C2 / d2 / 8 * 8), A = Math.round(b2 / p2 / 8 * 8), [M, w] = [[v, v / C2, r2, "ceil"], [A, A / b2, !a2, "floor"]].map(([t4, e5, s5, i4]) => s5 ? (s6) => Math[i4](t4 - e5 * s6) : (t5) => Math[i4](e5 * t5)), L = n3.width = v + 1, k = L * (n3.height = A + 1), S = (u2 - 1) / k, I = new Uint8ClampedArray(4 * k), D = (t4, e5) => 4 * Math.ceil(L * w(e5 - g2) + M(t4 - m3));
                  t3.buildKDTree();
                  for (let t4 = 0; t4 < k; t4++) {
                    let e5 = c2[Math.ceil(S * t4)], { x: s5, y: i4 } = e5;
                    I.set(y(e5.value, e5), D(s5, i4));
                  }
                  l3.putImageData(new ImageData(I, L), 0, 0), e4 ? e4.attr({ ...h2, href: n3.toDataURL("image/png", 1) }) : (t3.directTouch = false, t3.image = s4.renderer.image(n3.toDataURL("image/png", 1)).attr(h2).add(t3.group));
                }
                t3.isDirtyCanvas = false;
              } else (e4.width !== l2 || e4.height !== n2) && e4.attr(h2);
            } else (i2.enabled || t3._hasPointMarkers) && (n.prototype.drawPoints.call(t3), t3.points.forEach((e4) => {
              e4.graphic && (e4.graphic[t3.chart.styledMode ? "css" : "animate"](t3.colorAttribs(e4)), null === e4.value && e4.graphic.addClass("highcharts-null-point"));
            }));
          }
          getExtremes() {
            let { dataMin: t3, dataMax: e3 } = n.prototype.getExtremes.call(this, this.valueData);
            return f(t3) && (this.valueMin = t3), f(e3) && (this.valueMax = e3), n.prototype.getExtremes.call(this);
          }
          getValidPoints(t3, e3) {
            return n.prototype.getValidPoints.call(this, t3, e3, true);
          }
          hasData() {
            return !!this.xData;
          }
          init() {
            super.init.apply(this, arguments);
            let t3 = this.options;
            t3.pointRange = x(t3.pointRange, t3.colsize || 1), this.yAxis.axisPointRange = t3.rowsize || 1, p.ellipse = p.circle, t3.marker && f(t3.borderRadius) && (t3.marker.r = t3.borderRadius);
          }
          markerAttribs(t3, e3) {
            let s3 = t3.shapeArgs || {};
            if (t3.hasImage) return { x: t3.plotX, y: t3.plotY };
            if (e3 && "normal" !== e3) {
              let i2 = t3.options.marker || {}, o2 = this.options.marker || {}, r2 = o2.states && o2.states[e3] || {}, l2 = i2.states && i2.states[e3] || {}, a2 = (l2.width || r2.width || s3.width || 0) + (l2.widthPlus || r2.widthPlus || 0), n2 = (l2.height || r2.height || s3.height || 0) + (l2.heightPlus || r2.heightPlus || 0);
              return { x: (s3.x || 0) + ((s3.width || 0) - a2) / 2, y: (s3.y || 0) + ((s3.height || 0) - n2) / 2, width: a2, height: n2 };
            }
            return s3;
          }
          pointAttribs(e3, s3) {
            let i2 = n.prototype.pointAttribs.call(this, e3, s3), o2 = this.options || {}, r2 = this.chart.options.plotOptions || {}, l2 = r2.series || {}, a2 = r2.heatmap || {}, h2 = e3 && e3.options.borderColor || o2.borderColor || a2.borderColor || l2.borderColor, d2 = e3 && e3.options.borderWidth || o2.borderWidth || a2.borderWidth || l2.borderWidth || i2["stroke-width"];
            if (i2.stroke = e3 && e3.marker && e3.marker.lineColor || o2.marker && o2.marker.lineColor || h2 || this.color, i2["stroke-width"] = d2, s3 && "normal" !== s3) {
              let r3 = g(o2.states && o2.states[s3], o2.marker && o2.marker.states && o2.marker.states[s3], e3 && e3.options.states && e3.options.states[s3] || {});
              i2.fill = r3.color || t2.parse(i2.fill).brighten(r3.brightness || 0).get(), i2.stroke = r3.lineColor || i2.stroke;
            }
            return i2;
          }
          translate() {
            let { borderRadius: t3, marker: e3 } = this.options, s3 = e3 && e3.symbol || "rect", i2 = p[s3] ? s3 : "rect", o2 = -1 !== ["circle", "square"].indexOf(i2);
            if (!this.processedXData) {
              let { xData: t4, yData: e4 } = this.getProcessedData();
              this.processedXData = t4, this.processedYData = e4;
            }
            for (let e4 of (this.generatePoints(), this.points)) {
              let r2 = e4.getCellAttributes(), l2 = Math.min(r2.x1, r2.x2), a2 = Math.min(r2.y1, r2.y2), n2 = Math.max(Math.abs(r2.x2 - r2.x1), 0), h2 = Math.max(Math.abs(r2.y2 - r2.y1), 0);
              if (e4.hasImage = 0 === (e4.marker && e4.marker.symbol || s3 || "").indexOf("url"), o2) {
                let t4 = Math.abs(n2 - h2);
                l2 = Math.min(r2.x1, r2.x2) + (n2 < h2 ? 0 : t4 / 2), a2 = Math.min(r2.y1, r2.y2) + (n2 < h2 ? t4 / 2 : 0), n2 = h2 = Math.min(n2, h2);
              }
              e4.hasImage && (e4.marker = { width: n2, height: h2 }), e4.plotX = e4.clientX = (r2.x1 + r2.x2) / 2, e4.plotY = (r2.y1 + r2.y2) / 2, e4.shapeType = "path", e4.shapeArgs = g(true, { x: l2, y: a2, width: n2, height: h2 }, { d: p[i2](l2, a2, n2, h2, { r: f(t3) ? t3 : 0 }) });
            }
            m(this, "afterTranslate");
          }
        }
        return b.defaultOptions = g(d.defaultOptions, i), c(b, "afterDataClassLegendClick", function() {
          this.isDirtyCanvas = true, this.drawPoints();
        }), u(b.prototype, { axisTypes: e2.seriesMembers.axisTypes, colorKey: e2.seriesMembers.colorKey, directTouch: true, getExtremesFromAll: true, parallelArrays: e2.seriesMembers.parallelArrays, pointArrayMap: ["y", "value"], pointClass: s2, specialGroup: "group", trackerGroups: e2.seriesMembers.trackerGroups, alignDataLabel: h.prototype.alignDataLabel, colorAttribs: e2.seriesMembers.colorAttribs, getSymbol: n.prototype.getSymbol }), e2.compose(b), o.registerSeriesType("heatmap", b), b;
      }), s(e, "masters/modules/heatmap.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_heatmap();
//# sourceMappingURL=highcharts_modules_heatmap__js.js.map
