import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/venn.js
var require_venn = __commonJS({
  "node_modules/highcharts/modules/venn.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2017-2024 Highsoft AS
    * Authors: Jon Arild Nygard
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/venn", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function r(t2, r2, n, i) {
        t2.hasOwnProperty(r2) || (t2[r2] = i.apply(null, n), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: r2, module: t2[r2] } })));
      }
      r(t, "Core/Geometry/CircleUtilities.js", [t["Core/Geometry/GeometryUtilities.js"]], function(e2) {
        var t2;
        let { getAngleBetweenPoints: r2, getCenterOfPoints: n, getDistanceBetweenPoints: i } = e2;
        return function(e3) {
          function t3(e4, t4) {
            let r3 = Math.pow(10, t4);
            return Math.round(e4 * r3) / r3;
          }
          function s(e4) {
            if (e4 <= 0) throw Error("radius of circle must be a positive number.");
            return Math.PI * e4 * e4;
          }
          function o(e4, t4) {
            return e4 * e4 * Math.acos(1 - t4 / e4) - (e4 - t4) * Math.sqrt(t4 * (2 * e4 - t4));
          }
          function l(e4, r3) {
            let n2 = i(e4, r3), s2 = e4.r, o2 = r3.r, l2 = [];
            if (n2 < s2 + o2 && n2 > Math.abs(s2 - o2)) {
              let i2 = s2 * s2, a2 = (i2 - o2 * o2 + n2 * n2) / (2 * n2), u2 = Math.sqrt(i2 - a2 * a2), c2 = e4.x, f2 = r3.x, h = e4.y, p = r3.y, d = c2 + a2 * (f2 - c2) / n2, y = h + a2 * (p - h) / n2, g = -(u2 / n2 * (p - h)), x = -(u2 / n2 * (f2 - c2));
              l2 = [{ x: t3(d + g, 14), y: t3(y - x, 14) }, { x: t3(d - g, 14), y: t3(y + x, 14) }];
            }
            return l2;
          }
          function a(e4) {
            return e4.reduce((e5, t4, r3, n2) => {
              let i2 = n2.slice(r3 + 1).reduce((e6, n3, i3) => {
                let s2 = [r3, i3 + r3 + 1];
                return e6.concat(l(t4, n3).map((e7) => (e7.indexes = s2, e7)));
              }, []);
              return e5.concat(i2);
            }, []);
          }
          function u(e4, t4) {
            return i(e4, t4) <= t4.r + 1e-10;
          }
          function c(e4, t4) {
            return !t4.some(function(t5) {
              return !u(e4, t5);
            });
          }
          function f(e4) {
            return a(e4).filter(function(t4) {
              return c(t4, e4);
            });
          }
          e3.round = t3, e3.getAreaOfCircle = s, e3.getCircularSegmentArea = o, e3.getOverlapBetweenCircles = function(e4, r3, n2) {
            let i2 = 0;
            if (n2 < e4 + r3) {
              if (n2 <= Math.abs(r3 - e4)) i2 = s(e4 < r3 ? e4 : r3);
              else {
                let t4 = (e4 * e4 - r3 * r3 + n2 * n2) / (2 * n2);
                i2 = o(e4, e4 - t4) + o(r3, r3 - (n2 - t4));
              }
              i2 = t3(i2, 14);
            }
            return i2;
          }, e3.getCircleCircleIntersection = l, e3.getCirclesIntersectionPoints = a, e3.isCircle1CompletelyOverlappingCircle2 = function(e4, t4) {
            return i(e4, t4) + t4.r < e4.r + 1e-10;
          }, e3.isPointInsideCircle = u, e3.isPointInsideAllCircles = c, e3.isPointOutsideAllCircles = function(e4, t4) {
            return !t4.some(function(t5) {
              return u(e4, t5);
            });
          }, e3.getCirclesIntersectionPolygon = f, e3.getAreaOfIntersectionBetweenCircles = function(e4) {
            let t4 = f(e4), s2;
            if (t4.length > 1) {
              let o2 = n(t4), l2 = (t4 = t4.map(function(e5) {
                return e5.angle = r2(o2, e5), e5;
              }).sort(function(e5, t5) {
                return t5.angle - e5.angle;
              }))[t4.length - 1], a2 = t4.reduce(function(t5, s3) {
                let { startPoint: o3 } = t5, l3 = n([o3, s3]), a3 = s3.indexes.filter(function(e5) {
                  return o3.indexes.indexOf(e5) > -1;
                }).reduce(function(t6, n2) {
                  let a4 = e4[n2], u2 = r2(a4, s3), c2 = r2(a4, o3), f2 = c2 - u2 + (c2 < u2 ? 2 * Math.PI : 0), h = c2 - f2 / 2, p = i(l3, { x: a4.x + a4.r * Math.sin(h), y: a4.y + a4.r * Math.cos(h) }), { r: d } = a4;
                  return p > 2 * d && (p = 2 * d), (!t6 || t6.width > p) && (t6 = { r: d, largeArc: p > d ? 1 : 0, width: p, x: s3.x, y: s3.y }), t6;
                }, null);
                if (a3) {
                  let { r: e5 } = a3;
                  t5.arcs.push(["A", e5, e5, 0, a3.largeArc, 1, a3.x, a3.y]), t5.startPoint = s3;
                }
                return t5;
              }, { startPoint: l2, arcs: [] }).arcs;
              0 === a2.length || 1 === a2.length || (a2.unshift(["M", l2.x, l2.y]), s2 = { center: o2, d: a2 });
            }
            return s2;
          };
        }(t2 || (t2 = {})), t2;
      }), r(t, "Series/DrawPointUtilities.js", [], function() {
        return { draw: function(e2, t2) {
          let { animatableAttribs: r2, onComplete: n, css: i, renderer: s } = t2, o = e2.series && e2.series.chart.hasRendered ? void 0 : e2.series && e2.series.options.animation, l = e2.graphic;
          if (t2.attribs = { ...t2.attribs, class: e2.getClassName() }, e2.shouldDraw()) l || (l = "text" === t2.shapeType ? s.text() : "image" === t2.shapeType ? s.image(t2.imageUrl || "").attr(t2.shapeArgs || {}) : s[t2.shapeType](t2.shapeArgs || {}), e2.graphic = l, l.add(t2.group)), i && l.css(i), l.attr(t2.attribs).animate(r2, !t2.isNew && o, n);
          else if (l) {
            let t3 = () => {
              e2.graphic = l = l && l.destroy(), "function" == typeof n && n();
            };
            Object.keys(r2).length ? l.animate(r2, void 0, () => t3()) : t3();
          }
        } };
      }), r(t, "Series/Venn/VennPoint.js", [t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { scatter: { prototype: { pointClass: r2 } } } = e2.seriesTypes, { isNumber: n } = t2;
        return class extends r2 {
          isValid() {
            return n(this.value);
          }
          shouldDraw() {
            return !!this.shapeArgs;
          }
        };
      }), r(t, "Series/Venn/VennSeriesDefaults.js", [], function() {
        return { borderColor: "#cccccc", borderDashStyle: "solid", borderWidth: 1, brighten: 0, clip: false, colorByPoint: true, dataLabels: { enabled: true, verticalAlign: "middle", formatter: function() {
          return this.point.name;
        } }, inactiveOtherPoints: true, marker: false, opacity: 0.75, showInLegend: false, legendType: "point", states: { hover: { opacity: 1, borderColor: "#333333" }, select: { color: "#cccccc", borderColor: "#000000", animation: false }, inactive: { opacity: 0.075 } }, tooltip: { pointFormat: "{point.name}: {point.value}" }, legendSymbol: "rectangle" };
      }), r(t, "Series/Venn/VennUtils.js", [t["Core/Geometry/CircleUtilities.js"], t["Core/Geometry/GeometryUtilities.js"], t["Core/Utilities.js"]], function(e2, t2, r2) {
        let { getAreaOfCircle: n, getCircleCircleIntersection: i, getOverlapBetweenCircles: s, isPointInsideAllCircles: o, isPointInsideCircle: l, isPointOutsideAllCircles: a } = e2, { getDistanceBetweenPoints: u } = t2, { extend: c, isArray: f, isNumber: h, isObject: p, isString: d } = r2;
        function y(e3) {
          let t3 = {};
          return e3.filter((e4) => 2 === e4.sets.length).forEach((e4) => {
            e4.sets.forEach((r3, n2, i2) => {
              p(t3[r3]) || (t3[r3] = { totalOverlap: 0, overlapping: {} }), t3[r3] = { totalOverlap: (t3[r3].totalOverlap || 0) + e4.value, overlapping: { ...t3[r3].overlapping || {}, [i2[1 - n2]]: e4.value } };
            });
          }), e3.filter(b).forEach((e4) => {
            let r3 = t3[e4.sets[0]];
            c(e4, r3);
          }), e3;
        }
        function g(e3, t3, r3, n2, i2) {
          let s2 = e3(t3), o2 = e3(r3), l2 = i2 || 100, a2 = n2 || 1e-10, u2 = r3 - t3, c2, f2, h2 = 1;
          if (t3 >= r3) throw Error("a must be smaller than b.");
          if (s2 * o2 > 0) throw Error("f(a) and f(b) must have opposite signs.");
          if (0 === s2) c2 = t3;
          else if (0 === o2) c2 = r3;
          else for (; h2++ <= l2 && 0 !== f2 && u2 > a2; ) u2 = (r3 - t3) / 2, s2 * (f2 = e3(c2 = t3 + u2)) > 0 ? t3 = c2 : r3 = c2;
          return c2;
        }
        function x(e3) {
          let t3 = e3.slice(0, -1), r3 = t3.length, n2 = [], i2 = (e4, t4) => (e4.sum += t4[e4.i], e4);
          for (let e4 = 0; e4 < r3; e4++) n2[e4] = t3.reduce(i2, { sum: 0, i: e4 }).sum / r3;
          return n2;
        }
        function m(e3, t3, r3) {
          let i2 = e3 + t3;
          return r3 <= 0 ? i2 : n(e3 < t3 ? e3 : t3) <= r3 ? 0 : g((n2) => r3 - s(e3, t3, n2), 0, i2);
        }
        function b(e3) {
          return f(e3.sets) && 1 === e3.sets.length;
        }
        function v(e3) {
          let t3 = {};
          return p(e3) && h(e3.value) && e3.value > -1 && f(e3.sets) && e3.sets.length > 0 && !e3.sets.some(function(e4) {
            let r3 = false;
            return !t3[e4] && d(e4) ? t3[e4] = true : r3 = true, r3;
          });
        }
        function C(e3, t3) {
          return t3.reduce(function(t4, r3) {
            let n2 = 0;
            if (r3.sets.length > 1) {
              let t5 = r3.value - function(e4) {
                let t6 = 0;
                if (2 === e4.length) {
                  let r4 = e4[0], n3 = e4[1];
                  t6 = s(r4.r, n3.r, u(r4, n3));
                }
                return t6;
              }(r3.sets.map(function(t6) {
                return e3[t6];
              }));
              n2 = Math.round(t5 * t5 * 1e11) / 1e11;
            }
            return t4 + n2;
          }, 0);
        }
        function A(e3, t3) {
          return void 0 !== t3.totalOverlap && void 0 !== e3.totalOverlap ? t3.totalOverlap - e3.totalOverlap : NaN;
        }
        return { geometry: t2, geometryCircles: e2, addOverlapToSets: y, getCentroid: x, getDistanceBetweenCirclesByOverlap: m, getLabelWidth: function(e3, t3, r3) {
          let n2 = t3.reduce((e4, t4) => Math.min(t4.r, e4), 1 / 0), i2 = r3.filter((t4) => !l(e3, t4)), s2 = function(r4, n3) {
            return g((s3) => {
              let l2 = { x: e3.x + n3 * s3, y: e3.y };
              return -(r4 - s3) + (o(l2, t3) && a(l2, i2) ? 0 : Number.MAX_VALUE);
            }, 0, r4);
          };
          return 2 * Math.min(s2(n2, -1), s2(n2, 1));
        }, getMarginFromCircles: function(e3, t3, r3) {
          let n2 = t3.reduce((t4, r4) => {
            let n3 = r4.r - u(e3, r4);
            return n3 <= t4 ? n3 : t4;
          }, Number.MAX_VALUE);
          return r3.reduce((t4, r4) => {
            let n3 = u(e3, r4) - r4.r;
            return n3 <= t4 ? n3 : t4;
          }, n2);
        }, isSet: b, layoutGreedyVenn: function(e3) {
          let t3 = [], r3 = {};
          e3.filter((e4) => 1 === e4.sets.length).forEach((e4) => {
            r3[e4.sets[0]] = e4.circle = { x: Number.MAX_VALUE, y: Number.MAX_VALUE, r: Math.sqrt(e4.value / Math.PI) };
          });
          let n2 = (e4, r4) => {
            let n3 = e4.circle;
            n3 && (n3.x = r4.x, n3.y = r4.y), t3.push(e4);
          };
          y(e3);
          let s2 = e3.filter(b).sort(A);
          n2(s2.shift(), { x: 0, y: 0 });
          let o2 = e3.filter((e4) => 2 === e4.sets.length);
          for (let e4 of s2) {
            let s3 = e4.circle;
            if (!s3) continue;
            let l2 = s3.r, a2 = e4.overlapping;
            n2(e4, t3.reduce((e5, n3, u2) => {
              let c2 = n3.circle;
              if (!c2 || !a2) return e5;
              let f2 = a2[n3.sets[0]], h2 = m(l2, c2.r, f2), p2 = [{ x: c2.x + h2, y: c2.y }, { x: c2.x - h2, y: c2.y }, { x: c2.x, y: c2.y + h2 }, { x: c2.x, y: c2.y - h2 }];
              for (let e6 of t3.slice(u2 + 1)) {
                let t4 = e6.circle, r4 = a2[e6.sets[0]];
                if (!t4) continue;
                let n4 = m(l2, t4.r, r4);
                p2 = p2.concat(i({ x: c2.x, y: c2.y, r: h2 }, { x: t4.x, y: t4.y, r: n4 }));
              }
              for (let t4 of p2) {
                s3.x = t4.x, s3.y = t4.y;
                let n4 = C(r3, o2);
                n4 < e5.loss && (e5.loss = n4, e5.coordinates = t4);
              }
              return e5;
            }, { loss: Number.MAX_VALUE, coordinates: void 0 }).coordinates);
          }
          return r3;
        }, loss: C, nelderMead: function(e3, t3) {
          let r3 = function(e4, t4) {
            return e4.fx - t4.fx;
          }, n2 = (e4, t4, r4, n3) => t4.map((t5, i3) => e4 * t5 + r4 * n3[i3]), i2 = (t4, r4) => (r4.fx = e3(r4), t4[t4.length - 1] = r4, t4), s2 = (t4) => {
            let r4 = t4[0];
            return t4.map((t5) => {
              let i3 = n2(0.5, r4, 0.5, t5);
              return i3.fx = e3(i3), i3;
            });
          }, o2 = (t4, r4, i3, s3) => {
            let o3 = n2(i3, t4, s3, r4);
            return o3.fx = e3(o3), o3;
          }, l2 = ((t4) => {
            let r4 = t4.length, n3 = Array(r4 + 1);
            n3[0] = t4, n3[0].fx = e3(t4);
            for (let i3 = 0; i3 < r4; ++i3) {
              let r5 = t4.slice();
              r5[i3] = r5[i3] ? 1.05 * r5[i3] : 1e-3, r5.fx = e3(r5), n3[i3 + 1] = r5;
            }
            return n3;
          })(t3);
          for (let e4 = 0; e4 < 100; e4++) {
            l2.sort(r3);
            let e5 = l2[l2.length - 1], t4 = x(l2), n3 = o2(t4, e5, 2, -1);
            if (n3.fx < l2[0].fx) {
              let r4 = o2(t4, e5, 3, -2);
              l2 = i2(l2, r4.fx < n3.fx ? r4 : n3);
            } else if (n3.fx >= l2[l2.length - 2].fx) {
              let r4;
              l2 = n3.fx > e5.fx ? (r4 = o2(t4, e5, 0.5, 0.5)).fx < e5.fx ? i2(l2, r4) : s2(l2) : (r4 = o2(t4, e5, 1.5, -0.5)).fx < n3.fx ? i2(l2, r4) : s2(l2);
            } else l2 = i2(l2, n3);
          }
          return l2[0];
        }, processVennData: function(e3, t3) {
          let r3 = f(e3) ? e3 : [], n2 = r3.reduce(function(e4, t4) {
            var r4;
            return t4.sets && v(r4 = t4) && b(r4) && r4.value > 0 && -1 === e4.indexOf(t4.sets[0]) && e4.push(t4.sets[0]), e4;
          }, []).sort(), i2 = r3.reduce(function(e4, r4) {
            return r4.sets && v(r4) && !r4.sets.some(function(e5) {
              return -1 === n2.indexOf(e5);
            }) && (e4[r4.sets.sort().join(t3)] = { sets: r4.sets, value: r4.value || 0 }), e4;
          }, {});
          return n2.reduce(function(e4, r4, n3, i3) {
            return i3.slice(n3 + 1).forEach(function(n4) {
              e4.push(r4 + t3 + n4);
            }), e4;
          }, []).forEach(function(e4) {
            if (!i2[e4]) {
              let r4 = { sets: e4.split(t3), value: 0 };
              i2[e4] = r4;
            }
          }), Object.keys(i2).map(function(e4) {
            return i2[e4];
          });
        }, sortByTotalOverlap: A };
      }), r(t, "Series/Venn/VennSeries.js", [t["Core/Animation/AnimationUtilities.js"], t["Core/Color/Color.js"], t["Core/Geometry/CircleUtilities.js"], t["Series/DrawPointUtilities.js"], t["Core/Geometry/GeometryUtilities.js"], t["Core/Series/SeriesRegistry.js"], t["Series/Venn/VennPoint.js"], t["Series/Venn/VennSeriesDefaults.js"], t["Series/Venn/VennUtils.js"], t["Core/Utilities.js"]], function(e2, t2, r2, n, i, s, o, l, a, u) {
        let { animObject: c } = e2, { parse: f } = t2, { getAreaOfIntersectionBetweenCircles: h, getCirclesIntersectionPolygon: p, isCircle1CompletelyOverlappingCircle2: d, isPointInsideAllCircles: y, isPointOutsideAllCircles: g } = r2, { getCenterOfPoints: x } = i, { scatter: m } = s.seriesTypes, { addEvent: b, extend: v, isArray: C, isNumber: A, isObject: M, merge: j } = u;
        class O extends m {
          static getLabelPosition(e3, t3) {
            let r3 = e3.reduce((r4, n3) => {
              let i2 = n3.r / 2;
              return [{ x: n3.x, y: n3.y }, { x: n3.x + i2, y: n3.y }, { x: n3.x - i2, y: n3.y }, { x: n3.x, y: n3.y + i2 }, { x: n3.x, y: n3.y - i2 }].reduce((r5, n4) => {
                let i3 = a.getMarginFromCircles(n4, e3, t3);
                return r5.margin < i3 && (r5.point = n4, r5.margin = i3), r5;
              }, r4);
            }, { point: void 0, margin: -Number.MAX_VALUE }).point, n2 = a.nelderMead((r4) => -a.getMarginFromCircles({ x: r4[0], y: r4[1] }, e3, t3), [r3.x, r3.y]);
            return y(r3 = { x: n2[0], y: n2[1] }, e3) && g(r3, t3) || (r3 = e3.length > 1 ? x(p(e3)) : { x: e3[0].x, y: e3[0].y }), r3;
          }
          static getLabelValues(e3, t3) {
            let r3 = e3.sets, n2 = t3.reduce((e4, t4) => {
              let n3 = r3.indexOf(t4.sets[0]) > -1;
              return t4.circle && e4[n3 ? "internal" : "external"].push(t4.circle), e4;
            }, { internal: [], external: [] });
            n2.external = n2.external.filter((e4) => n2.internal.some((t4) => !d(e4, t4)));
            let i2 = O.getLabelPosition(n2.internal, n2.external), s2 = a.getLabelWidth(i2, n2.internal, n2.external);
            return { position: i2, width: s2 };
          }
          static layout(e3) {
            let t3 = {}, r3 = {};
            if (e3.length > 0) {
              let n2 = a.layoutGreedyVenn(e3), i2 = e3.filter(a.isSet);
              for (let s2 of e3) {
                let e4 = s2.sets, o2 = e4.join(), l2 = a.isSet(s2) ? n2[o2] : h(e4.map((e5) => n2[e5]));
                l2 && (t3[o2] = l2, r3[o2] = O.getLabelValues(s2, i2));
              }
            }
            return { mapOfIdToShape: t3, mapOfIdToLabelValues: r3 };
          }
          static getScale(e3, t3, r3) {
            let n2 = r3.bottom - r3.top, i2 = r3.right - r3.left, s2 = (r3.right + r3.left) / 2, o2 = (r3.top + r3.bottom) / 2, l2 = Math.min(i2 > 0 ? 1 / i2 * e3 : 1, n2 > 0 ? 1 / n2 * t3 : 1);
            return { scale: l2, centerX: e3 / 2 - s2 * l2, centerY: t3 / 2 - o2 * l2 };
          }
          static updateFieldBoundaries(e3, t3) {
            let r3 = t3.x - t3.r, n2 = t3.x + t3.r, i2 = t3.y + t3.r, s2 = t3.y - t3.r;
            return (!A(e3.left) || e3.left > r3) && (e3.left = r3), (!A(e3.right) || e3.right < n2) && (e3.right = n2), (!A(e3.top) || e3.top > s2) && (e3.top = s2), (!A(e3.bottom) || e3.bottom < i2) && (e3.bottom = i2), e3;
          }
          animate(e3) {
            if (!e3) {
              let e4 = c(this.options.animation);
              for (let t3 of this.points) {
                let r3 = t3.shapeArgs;
                if (t3.graphic && r3) {
                  let n2 = {}, i2 = {};
                  r3.d ? n2.opacity = 1e-3 : (n2.r = 0, i2.r = r3.r), t3.graphic.attr(n2).animate(i2, e4), r3.d && setTimeout(() => {
                    t3 && t3.graphic && t3.graphic.animate({ opacity: 1 });
                  }, e4.duration);
                }
              }
            }
          }
          drawPoints() {
            let e3 = this.chart, t3 = this.group, r3 = this.points || [], i2 = e3.renderer;
            for (let s2 of r3) {
              let r4 = { zIndex: C(s2.sets) ? s2.sets.length : 0 }, o2 = s2.shapeArgs;
              e3.styledMode || v(r4, this.pointAttribs(s2, s2.state)), n.draw(s2, { isNew: !s2.graphic, animatableAttribs: o2, attribs: r4, group: t3, renderer: i2, shapeType: o2 && o2.d ? "path" : "circle" });
            }
          }
          init() {
            m.prototype.init.apply(this, arguments), delete this.opacity;
          }
          pointAttribs(e3, t3) {
            let r3 = this.options || {}, n2 = e3 && e3.options || {}, i2 = t3 && r3.states[t3] || {}, s2 = j(r3, { color: e3 && e3.color }, n2, i2);
            return { fill: f(s2.color).brighten(s2.brightness).get(), opacity: s2.opacity, stroke: s2.borderColor, "stroke-width": s2.borderWidth, dashstyle: s2.borderDashStyle };
          }
          translate() {
            let e3 = this.chart;
            this.processedXData = this.xData, this.generatePoints();
            let t3 = a.processVennData(this.options.data, O.splitter), { mapOfIdToShape: r3, mapOfIdToLabelValues: n2 } = O.layout(t3), i2 = Object.keys(r3).filter((e4) => {
              let t4 = r3[e4];
              return t4 && A(t4.r);
            }).reduce((e4, t4) => O.updateFieldBoundaries(e4, r3[t4]), { top: 0, bottom: 0, left: 0, right: 0 }), s2 = O.getScale(e3.plotWidth, e3.plotHeight, i2), o2 = s2.scale, l2 = s2.centerX, u2 = s2.centerY;
            for (let e4 of this.points) {
              let t4 = C(e4.sets) ? e4.sets : [], i3 = t4.join(), s3 = r3[i3], a2 = n2[i3] || {}, c2 = e4.options && e4.options.dataLabels, f2, h2 = a2.width, p2 = a2.position;
              if (s3) {
                if (s3.r) f2 = { x: l2 + s3.x * o2, y: u2 + s3.y * o2, r: s3.r * o2 };
                else if (s3.d) {
                  let e5 = s3.d;
                  e5.forEach((e6) => {
                    "M" === e6[0] ? (e6[1] = l2 + e6[1] * o2, e6[2] = u2 + e6[2] * o2) : "A" === e6[0] && (e6[1] = e6[1] * o2, e6[2] = e6[2] * o2, e6[6] = l2 + e6[6] * o2, e6[7] = u2 + e6[7] * o2);
                  }), f2 = { d: e5 };
                }
                p2 ? (p2.x = l2 + p2.x * o2, p2.y = u2 + p2.y * o2) : p2 = {}, A(h2) && (h2 = Math.round(h2 * o2));
              }
              e4.shapeArgs = f2, p2 && f2 && (e4.plotX = p2.x, e4.plotY = p2.y), h2 && f2 && (e4.dlOptions = j(true, { style: { width: h2 } }, M(c2, true) ? c2 : void 0)), e4.name = e4.options.name || t4.join("∩");
            }
          }
        }
        return O.splitter = "highcharts-split", O.defaultOptions = j(m.defaultOptions, l), v(O.prototype, { axisTypes: [], directTouch: true, isCartesian: false, pointArrayMap: ["value"], pointClass: o, utils: a }), b(O, "afterSetOptions", function(e3) {
          let t3 = e3.options.states || {};
          if (this.is("venn")) for (let e4 of Object.keys(t3)) t3[e4].halo = false;
        }), s.registerSeriesType("venn", O), O;
      }), r(t, "masters/modules/venn.src.js", [t["Core/Globals.js"]], function(e2) {
        return e2;
      });
    });
  }
});
export default require_venn();
//# sourceMappingURL=highcharts_modules_venn__js.js.map
