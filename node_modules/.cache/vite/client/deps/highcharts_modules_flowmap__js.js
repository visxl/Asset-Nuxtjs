import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/flowmap.js
var require_flowmap = __commonJS({
  "node_modules/highcharts/modules/flowmap.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2009-2024
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/flowmap", ["highcharts"], function(o) {
        return t(o), t.Highcharts = o, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var o = t ? t._modules : {};
      function e(o2, e2, i, s) {
        o2.hasOwnProperty(e2) || (o2[e2] = s.apply(null, i), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: e2, module: o2[e2] } })));
      }
      e(o, "Series/FlowMap/FlowMapPoint.js", [o["Core/Series/SeriesRegistry.js"], o["Core/Utilities.js"]], function(t2, o2) {
        let { seriesTypes: { mapline: { prototype: { pointClass: e2 } } } } = t2, { pick: i, isString: s, isNumber: r } = o2;
        return class extends e2 {
          isValid() {
            let t3 = !!(this.options.to && this.options.from);
            return [this.options.to, this.options.from].forEach(function(o3) {
              t3 = !!(t3 && o3 && (s(o3) || r(i(o3[0], o3.lat)) && r(i(o3[1], o3.lon))));
            }), t3;
          }
        };
      }), e(o, "Series/FlowMap/FlowMapSeries.js", [o["Series/FlowMap/FlowMapPoint.js"], o["Core/Series/SeriesRegistry.js"], o["Core/Utilities.js"]], function(t2, o2, e2) {
        let { series: { prototype: { pointClass: i } }, seriesTypes: { column: s, map: r, mapline: n } } = o2, { addEvent: a, arrayMax: l, arrayMin: h, defined: p, extend: f, isArray: d, merge: m, pick: u, relativeLength: c } = e2;
        class g extends n {
          static getLength(t3, o3) {
            return Math.sqrt(t3 * t3 + o3 * o3);
          }
          static normalize(t3, o3) {
            let e3 = this.getLength(t3, o3);
            return [t3 / e3, o3 / e3];
          }
          static markerEndPath(t3, o3, e3, i2) {
            let s2 = c(i2.width || 0, this.getLength(o3[0] - t3[0], o3[1] - t3[1])), r2 = i2.markerType || "arrow", [n2, a2] = this.normalize(o3[0] - t3[0], o3[1] - t3[1]), l2 = [];
            if ("arrow" === r2) {
              let [i3, r3] = t3;
              i3 -= n2 * s2, r3 -= a2 * s2, l2.push(["L", i3, r3]), l2.push(["L", e3[0], e3[1]]), [i3, r3] = o3, i3 += n2 * s2, r3 += a2 * s2, l2.push(["L", i3, r3]);
            }
            if ("mushroom" === r2) {
              let [i3, r3] = t3, [h2, p2] = o3, [f2, d2] = e3, m2 = (h2 - i3) / 2 + i3, u2 = (p2 - r3) / 2 + r3;
              i3 -= n2 * s2, r3 -= a2 * s2, l2.push(["L", i3, r3]), h2 += n2 * s2, p2 += a2 * s2, l2.push(["Q", (f2 - m2) * 2 + m2, (d2 - u2) * 2 + u2, h2, p2]);
            }
            return l2;
          }
          animate(t3) {
            let o3 = this.points;
            t3 || o3.forEach((t4) => {
              if (t4.shapeArgs && d(t4.shapeArgs.d) && t4.shapeArgs.d.length) {
                let o4 = t4.shapeArgs.d, e3 = o4[0][1], i2 = o4[0][2];
                if (e3 && i2) {
                  let s2 = [];
                  for (let t5 = 0; t5 < o4.length; t5++) {
                    s2.push([...o4[t5]]);
                    for (let r2 = 1; r2 < o4[t5].length; r2++) s2[t5][r2] = r2 % 2 ? e3 : i2;
                  }
                  t4.graphic && (t4.graphic.attr({ d: s2 }), t4.graphic.animate({ d: o4 }));
                }
              }
            });
          }
          getLinkWidth(t3) {
            let o3 = this.options.width, e3 = t3.options.weight || this.options.weight;
            if (t3.options.weight = e3, o3 && !e3) return o3;
            let i2 = this.smallestWeight, s2 = this.greatestWeight;
            if (!p(e3) || !i2 || !s2) return 0;
            let r2 = this.options.minWidth;
            return (e3 - i2) * (this.options.maxWidth - r2) / (s2 - i2 || 1) + r2;
          }
          autoCurve(t3, o3, e3, i2, s2, r2) {
            let n2 = { x: e3 - t3, y: i2 - o3 }, a2 = { x: (e3 - t3) / 2 + t3, y: (i2 - o3) / 2 + o3 }, l2 = { x: a2.x - s2, y: a2.y - r2 }, h2 = n2.x * l2.x + n2.y * l2.y, p2 = Math.atan2(n2.x * l2.y - n2.y * l2.x, h2), f2 = 180 * p2 / Math.PI;
            return f2 < 0 && (f2 = 360 + f2), -(0.7 * Math.sin(p2 = f2 * Math.PI / 180));
          }
          pointAttribs(t3, o3) {
            let e3 = r.prototype.pointAttribs.call(this, t3, o3);
            return e3.fill = u(t3.options.fillColor, t3.options.color, "none" === this.options.fillColor ? null : this.options.fillColor, this.color), e3["fill-opacity"] = u(t3.options.fillOpacity, this.options.fillOpacity), e3["stroke-width"] = u(t3.options.lineWidth, this.options.lineWidth, 1), t3.options.opacity && (e3.opacity = t3.options.opacity), e3;
          }
          translate() {
            this.chart.hasRendered && (this.isDirtyData || !this.hasRendered) && (this.processData(), this.generatePoints());
            let t3 = [], o3 = 0, e3 = 0;
            this.points.forEach((s2) => {
              let r2, n2;
              let l2 = this.chart, h2 = l2.mapView, p2 = s2.options, f2 = () => {
                s2.series.isDirty = true;
              }, m2 = (t4) => {
                let o4 = l2.get(t4);
                if (o4 instanceof i && o4.plotX && o4.plotY) return a(o4, "update", f2), { x: o4.plotX, y: o4.plotY };
              }, c2 = (t4) => d(t4) ? { lon: t4[0], lat: t4[1] } : t4;
              "string" == typeof p2.from ? r2 = m2(p2.from) : "object" == typeof p2.from && h2 && (r2 = h2.lonLatToPixels(c2(p2.from))), "string" == typeof p2.to ? n2 = m2(p2.to) : "object" == typeof p2.to && h2 && (n2 = h2.lonLatToPixels(c2(p2.to))), s2.fromPos = r2, s2.toPos = n2, r2 && n2 && (o3 += (r2.x + n2.x) / 2, e3 += (r2.y + n2.y) / 2), u(s2.options.weight, this.options.weight) && t3.push(u(s2.options.weight, this.options.weight));
            }), this.smallestWeight = h(t3), this.greatestWeight = l(t3), this.centerOfPoints = { x: o3 / this.points.length, y: e3 / this.points.length }, this.points.forEach((t4) => {
              if (!this.getLinkWidth(t4)) {
                t4.shapeArgs = { d: [] };
                return;
              }
              t4.fromPos && (t4.plotX = t4.fromPos.x, t4.plotY = t4.fromPos.y), t4.shapeType = "path", t4.shapeArgs = this.getPointShapeArgs(t4), t4.color = u(t4.options.color, t4.series.color);
            });
          }
          getPointShapeArgs(t3) {
            let { fromPos: o3, toPos: e3 } = t3;
            if (!o3 || !e3) return {};
            let i2 = this.getLinkWidth(t3) / 2, s2 = t3.options, r2 = m(this.options.markerEnd, s2.markerEnd), n2 = u(s2.growTowards, this.options.growTowards), a2 = o3.x || 0, l2 = o3.y || 0, h2 = e3.x || 0, f2 = e3.y || 0, d2 = u(s2.curveFactor, this.options.curveFactor), y = r2 && r2.enabled && r2.height || 0;
            if (p(d2) || (d2 = this.autoCurve(a2, l2, h2, f2, this.centerOfPoints.x, this.centerOfPoints.y)), y) {
              y = c(y, 4 * i2);
              let t4 = h2 - a2, o4 = f2 - l2, e4 = a2 + (t4 *= 0.5), s3 = l2 + (o4 *= 0.5), r3 = t4, n3 = e4 + (t4 = o4) * d2, p2 = s3 + (o4 = -r3) * d2, [m2, u2] = g.normalize(n3 - h2, p2 - f2);
              m2 *= y, u2 *= y, h2 += m2, f2 += u2;
            }
            let w = h2 - a2, x = f2 - l2, P = a2 + (w *= 0.5), M = l2 + (x *= 0.5), C = w;
            w = x, x = -C;
            let [L, b] = g.normalize(w, x), W = 1 + 0.25 * Math.sqrt(d2 * d2);
            L *= i2 * W, b *= i2 * W;
            let j = P + w * d2, E = M + x * d2, [k, A] = g.normalize(j - a2, E - l2);
            C = k, k = A, A = -C, k *= i2, A *= i2;
            let [S, v] = g.normalize(j - h2, E - f2);
            C = S, S = -v, v = C, S *= i2, v *= i2, n2 && (k /= i2, A /= i2, L /= 4, b /= 4);
            let F = { d: [["M", a2 - k, l2 - A], ["Q", j - L, E - b, h2 - S, f2 - v], ["L", h2 + S, f2 + v], ["Q", j + L, E + b, a2 + k, l2 + A], ["Z"]] };
            if (r2 && r2.enabled && F.d) {
              let t4 = g.markerEndPath([h2 - S, f2 - v], [h2 + S, f2 + v], [e3.x, e3.y], r2);
              F.d.splice(2, 0, ...t4);
            }
            let T = t3.options.from, O = t3.options.to, z = T.lat, D = T.lon, H = O.lat, R = O.lon;
            return z && D && (t3.options.from = `${+z}, ${+D}`), H && R && (t3.options.to = `${+H}, ${+R}`), F;
          }
        }
        return g.defaultOptions = m(n.defaultOptions, { animation: true, dataLabels: { enabled: false }, fillOpacity: 0.5, markerEnd: { enabled: true, height: "40%", width: "40%", markerType: "arrow" }, width: 1, maxWidth: 25, minWidth: 5, lineWidth: void 0, tooltip: { headerFormat: '<span style="font-size: 0.8em">{series.name}</span><br/>', pointFormat: "{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>" } }), f(g.prototype, { pointClass: t2, pointArrayMap: ["from", "to", "weight"], drawPoints: s.prototype.drawPoints, useMapGeometry: true }), o2.registerSeriesType("flowmap", g), g;
      }), e(o, "masters/modules/flowmap.src.js", [o["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_flowmap();
//# sourceMappingURL=highcharts_modules_flowmap__js.js.map
