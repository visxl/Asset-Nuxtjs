import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/sankey.js
var require_sankey = __commonJS({
  "node_modules/highcharts/modules/sankey.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Sankey diagram module
    *
    * (c) 2010-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/sankey", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function o(e2, o2, i, s) {
        e2.hasOwnProperty(o2) || (e2[o2] = s.apply(null, i), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: o2, module: e2[o2] } })));
      }
      o(e, "Series/NodesComposition.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        var o2;
        let { series: { prototype: i, prototype: { pointClass: { prototype: s } } } } = t2, { defined: n, extend: r, find: l, merge: a, pick: h } = e2;
        return function(t3) {
          function e3() {
            return this.data = [].concat(this.points || [], this.nodes), i.destroy.apply(this, arguments);
          }
          function o3() {
            this.nodes && (this.nodes.forEach((t4) => {
              t4.destroy();
            }), this.nodes.length = 0), i.setData.apply(this, arguments);
          }
          function d(t4) {
            let e4 = arguments, o4 = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode];
            "select" !== t4 && o4.forEach((t5) => {
              t5 && t5.series && (s.setState.apply(t5, e4), !t5.isNode && (t5.fromNode.graphic && s.setState.apply(t5.fromNode, e4), t5.toNode && t5.toNode.graphic && s.setState.apply(t5.toNode, e4)));
            }), s.setState.apply(this, e4);
          }
          function p(t4, e4, o4, i2) {
            let n2 = this.series.options.nodes, r2 = this.series.options.data, l2 = r2 && r2.length || 0, d2 = r2 && r2[this.index];
            if (s.update.call(this, t4, !this.isNode && e4, o4, i2), this.isNode) {
              let t5 = (n2 || []).reduce((t6, e5, o5) => this.id === e5.id ? o5 : t6, -1), i3 = a(n2 && n2[t5] || {}, r2 && r2[this.index] || {});
              r2 && (d2 ? r2[this.index] = d2 : r2.length = l2), n2 ? t5 >= 0 ? n2[t5] = i3 : n2.push(i3) : this.series.options.nodes = [i3], h(e4, true) && this.series.chart.redraw(o4);
            }
          }
          t3.compose = function(t4, i2) {
            let s2 = t4.prototype, n2 = i2.prototype;
            return s2.setNodeState = d, s2.setState = d, s2.update = p, n2.destroy = e3, n2.setData = o3, i2;
          }, t3.createNode = function(t4) {
            let e4 = this.pointClass, o4 = (t5, e5) => l(t5, (t6) => t6.id === e5), i2 = o4(this.nodes, t4), s2;
            if (!i2) {
              s2 = this.options.nodes && o4(this.options.nodes, t4);
              let n2 = new e4(this, r({ className: "highcharts-node", isNode: true, id: t4, y: 1 }, s2));
              n2.linksTo = [], n2.linksFrom = [], n2.getSum = function() {
                let t5 = 0, e5 = 0;
                return n2.linksTo.forEach((e6) => {
                  t5 += e6.weight || 0;
                }), n2.linksFrom.forEach((t6) => {
                  e5 += t6.weight || 0;
                }), Math.max(t5, e5);
              }, n2.offset = function(t5, e5) {
                let o5 = 0;
                for (let i3 = 0; i3 < n2[e5].length; i3++) {
                  if (n2[e5][i3] === t5) return o5;
                  o5 += n2[e5][i3].weight;
                }
              }, n2.hasShape = function() {
                let t5 = 0;
                return n2.linksTo.forEach((e5) => {
                  e5.outgoing && t5++;
                }), !n2.linksTo.length || t5 !== n2.linksTo.length;
              }, n2.index = this.nodes.push(n2) - 1, i2 = n2;
            }
            return i2.formatPrefix = "node", i2.name = i2.name || i2.options.id || "", i2.mass = h(i2.options.mass, i2.options.marker && i2.options.marker.radius, this.options.marker && this.options.marker.radius, 4), i2;
          }, t3.destroy = e3, t3.generatePoints = function() {
            let t4 = this.chart, e4 = {};
            i.generatePoints.call(this), this.nodes || (this.nodes = []), this.colorCounter = 0, this.nodes.forEach((t5) => {
              t5.linksFrom.length = 0, t5.linksTo.length = 0, t5.level = t5.options.level;
            }), this.points.forEach((o4) => {
              n(o4.from) && (e4[o4.from] || (e4[o4.from] = this.createNode(o4.from)), e4[o4.from].linksFrom.push(o4), o4.fromNode = e4[o4.from], t4.styledMode ? o4.colorIndex = h(o4.options.colorIndex, e4[o4.from].colorIndex) : o4.color = o4.options.color || e4[o4.from].color), n(o4.to) && (e4[o4.to] || (e4[o4.to] = this.createNode(o4.to)), e4[o4.to].linksTo.push(o4), o4.toNode = e4[o4.to]), o4.name = o4.name || o4.id;
            }, this), this.nodeLookup = e4;
          }, t3.setNodeState = d, t3.updateNode = p;
        }(o2 || (o2 = {})), o2;
      }), o(e, "Series/Sankey/SankeyPoint.js", [e["Core/Series/Point.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, o2) {
        let { column: i } = e2.seriesTypes, { defined: s } = o2;
        class n extends i.prototype.pointClass {
          applyOptions(e3, o3) {
            return t2.prototype.applyOptions.call(this, e3, o3), s(this.options.level) && (this.options.column = this.column = this.options.level), this;
          }
          getClassName() {
            return (this.isNode ? "highcharts-node " : "highcharts-link ") + t2.prototype.getClassName.call(this);
          }
          getFromNode() {
            let t3 = -1, e3;
            for (let o3 = 0; o3 < this.linksTo.length; o3++) {
              let i2 = this.linksTo[o3];
              i2.fromNode.column > t3 && i2.fromNode !== this && (t3 = (e3 = i2.fromNode).column);
            }
            return { fromNode: e3, fromColumn: t3 };
          }
          setNodeColumn() {
            s(this.options.column) || (0 === this.linksTo.length ? this.column = 0 : this.column = this.getFromNode().fromColumn + 1);
          }
          isValid() {
            return this.isNode || "number" == typeof this.weight;
          }
        }
        return n;
      }), o(e, "Series/Sankey/SankeySeriesDefaults.js", [], function() {
        return { borderWidth: 0, colorByPoint: true, curveFactor: 0.33, dataLabels: { enabled: true, backgroundColor: "none", crop: false, nodeFormat: void 0, nodeFormatter: function() {
          return this.point.name;
        }, format: void 0, formatter: function() {
        }, inside: true }, inactiveOtherPoints: true, linkColorMode: "from", linkOpacity: 0.5, opacity: 1, minLinkWidth: 0, nodeAlignment: "center", nodeWidth: 20, nodePadding: 10, nodeDistance: 30, showInLegend: false, states: { hover: { linkOpacity: 1, opacity: 1 }, inactive: { linkOpacity: 0.1, opacity: 0.1, animation: { duration: 50 } } }, tooltip: { followPointer: true, headerFormat: '<span style="font-size: 0.8em">{series.name}</span><br/>', pointFormat: "{point.fromNode.name} â†’ {point.toNode.name}: <b>{point.weight}</b><br/>", nodeFormat: "{point.name}: <b>{point.sum}</b><br/>" } };
      }), o(e, "Series/Sankey/SankeyColumnComposition.js", [e["Core/Utilities.js"]], function(t2) {
        var e2;
        let { defined: o2, relativeLength: i } = t2;
        return function(t3) {
          t3.compose = function(t4, o3) {
            return t4.sankeyColumn = new e3(t4, o3), t4;
          };
          class e3 {
            constructor(t4, e4) {
              this.points = t4, this.series = e4;
            }
            getTranslationFactor(t4) {
              let e4 = this.points, o3 = e4.slice(), i2 = t4.chart, s = t4.options.minLinkWidth || 0, n, r = 0, l, a = (i2.plotSizeY || 0) - (t4.options.borderWidth || 0) - (e4.length - 1) * t4.nodePadding;
              for (; e4.length; ) {
                for (r = a / e4.sankeyColumn.sum(), n = false, l = e4.length; l--; ) e4[l].getSum() * r < s && (e4.splice(l, 1), a = Math.max(0, a - s), n = true);
                if (!n) break;
              }
              for (let t5 of (e4.length = 0, o3)) e4.push(t5);
              return r;
            }
            top(t4) {
              let e4 = this.series, o3 = e4.nodePadding, i2 = this.points.reduce((i3, s) => (i3 > 0 && (i3 += o3), i3 += Math.max(s.getSum() * t4, e4.options.minLinkWidth || 0)), 0);
              return { top: 0, center: 0.5, bottom: 1 }[e4.options.nodeAlignment || "center"] * ((e4.chart.plotSizeY || 0) - i2);
            }
            left(t4) {
              let e4 = this.series, o3 = e4.chart, i2 = e4.options.equalNodes, s = o3.inverted ? o3.plotHeight : o3.plotWidth, n = e4.nodePadding, r = this.points.reduce((o4, r2) => (o4 > 0 && (o4 += n), o4 += i2 ? s / r2.series.nodes.length - n : Math.max(r2.getSum() * t4, e4.options.minLinkWidth || 0)), 0);
              return ((o3.plotSizeX || 0) - Math.round(r)) / 2;
            }
            sum() {
              return this.points.reduce((t4, e4) => t4 + e4.getSum(), 0);
            }
            offset(t4, e4) {
              let s = this.points, n = this.series, r = n.nodePadding, l = 0, a;
              if (n.is("organization") && t4.hangsFrom) return { absoluteTop: t4.hangsFrom.nodeY };
              for (let h = 0; h < s.length; h++) {
                let d = s[h].getSum(), p = Math.max(d * e4, n.options.minLinkWidth || 0), c = t4.options[n.chart.inverted ? "offsetHorizontal" : "offsetVertical"], u = t4.options.offset || 0;
                if (a = d ? p + r : 0, s[h] === t4) return { relativeTop: l + (o2(c) ? i(c, p) : i(u, a)) };
                l += a;
              }
            }
          }
          t3.SankeyColumnAdditions = e3;
        }(e2 || (e2 = {})), e2;
      }), o(e, "Series/TreeUtilities.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { extend: o2, isArray: i, isNumber: s, isObject: n, merge: r, pick: l, relativeLength: a } = e2;
        return { getColor: function(e3, o3) {
          let i2, s2, n2, r2, a2, h;
          let d = o3.index, p = o3.mapOptionsToLevel, c = o3.parentColor, u = o3.parentColorIndex, f = o3.series, m = o3.colors, g = o3.siblings, y = f.points, k = f.chart.options.chart;
          return e3 && (i2 = y[e3.i], s2 = p[e3.level] || {}, i2 && s2.colorByPoint && (r2 = i2.index % (m ? m.length : k.colorCount), n2 = m && m[r2]), f.chart.styledMode || (a2 = l(i2 && i2.options.color, s2 && s2.color, n2, c && ((e4) => {
            let o4 = s2 && s2.colorVariation;
            return o4 && "brightness" === o4.key && d && g ? t2.parse(e4).brighten(o4.to * (d / g)).get() : e4;
          })(c), f.color)), h = l(i2 && i2.options.colorIndex, s2 && s2.colorIndex, r2, u, o3.colorIndex)), { color: a2, colorIndex: h };
        }, getLevelOptions: function(t3) {
          let e3, o3, a2, h, d, p;
          let c = {};
          if (n(t3)) for (h = s(t3.from) ? t3.from : 1, p = t3.levels, o3 = {}, e3 = n(t3.defaults) ? t3.defaults : {}, i(p) && (o3 = p.reduce((t4, o4) => {
            let i2, a3, d2;
            return n(o4) && s(o4.level) && (a3 = l((d2 = r({}, o4)).levelIsConstant, e3.levelIsConstant), delete d2.levelIsConstant, delete d2.level, n(t4[i2 = o4.level + (a3 ? 0 : h - 1)]) ? r(true, t4[i2], d2) : t4[i2] = d2), t4;
          }, {})), d = s(t3.to) ? t3.to : 1, a2 = 0; a2 <= d; a2++) c[a2] = r({}, e3, n(o3[a2]) ? o3[a2] : {});
          return c;
        }, getNodeWidth: function(t3, e3) {
          let { chart: o3, options: i2 } = t3, { nodeDistance: s2 = 0, nodeWidth: n2 = 0 } = i2, { plotSizeX: r2 = 1 } = o3;
          if ("auto" === n2) {
            if ("string" == typeof s2 && /%$/.test(s2)) return r2 / (e3 + parseFloat(s2) / 100 * (e3 - 1));
            let t4 = Number(s2);
            return (r2 + t4) / (e3 || 1) - t4;
          }
          return a(n2, r2);
        }, setTreeValues: function t3(e3, i2) {
          let s2 = i2.before, n2 = i2.idRoot, r2 = i2.mapIdToNode[n2], a2 = false !== i2.levelIsConstant, h = i2.points[e3.i], d = h && h.options || {}, p = [], c = 0;
          e3.levelDynamic = e3.level - (a2 ? 0 : r2.level), e3.name = l(h && h.name, ""), e3.visible = n2 === e3.id || true === i2.visible, "function" == typeof s2 && (e3 = s2(e3, i2)), e3.children.forEach((s3, n3) => {
            let r3 = o2({}, i2);
            o2(r3, { index: n3, siblings: e3.children.length, visible: e3.visible }), s3 = t3(s3, r3), p.push(s3), s3.visible && (c += s3.val);
          });
          let u = l(d.value, c);
          return e3.visible = u >= 0 && (c > 0 || e3.visible), e3.children = p, e3.childrenTotal = c, e3.isLeaf = e3.visible && !c, e3.val = u, e3;
        }, updateRootId: function(t3) {
          let e3, o3;
          return n(t3) && (o3 = n(t3.options) ? t3.options : {}, e3 = l(t3.rootNode, o3.rootId, ""), n(t3.userOptions) && (t3.userOptions.rootId = e3), t3.rootNode = e3), e3;
        } };
      }), o(e, "Extensions/TextPath.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { deg2rad: o2 } = t2, { addEvent: i, merge: s, uniqueKey: n, defined: r, extend: l } = e2;
        function a(t3, e3) {
          e3 = s(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, e3);
          let o3 = this.renderer.url, a2 = this.text || this, h2 = a2.textPath, { attributes: d2, enabled: p } = e3;
          if (t3 = t3 || h2 && h2.path, h2 && h2.undo(), t3 && p) {
            let e4 = i(a2, "afterModifyTree", (e5) => {
              if (t3 && p) {
                let i2 = t3.attr("id");
                i2 || t3.attr("id", i2 = n());
                let s2 = { x: 0, y: 0 };
                r(d2.dx) && (s2.dx = d2.dx, delete d2.dx), r(d2.dy) && (s2.dy = d2.dy, delete d2.dy), a2.attr(s2), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy());
                let h3 = e5.nodes.slice(0);
                e5.nodes.length = 0, e5.nodes[0] = { tagName: "textPath", attributes: l(d2, { "text-anchor": d2.textAnchor, href: `${o3}#${i2}` }), children: h3 };
              }
            });
            a2.textPath = { path: t3, undo: e4 };
          } else a2.attr({ dx: 0, dy: 0 }), delete a2.textPath;
          return this.added && (a2.textCache = "", this.renderer.buildText(a2)), this;
        }
        function h(t3) {
          var _a;
          let e3 = t3.bBox, i2 = (_a = this.element) == null ? void 0 : _a.querySelector("textPath");
          if (i2) {
            let t4 = [], { b: s2, h: n2 } = this.renderer.fontMetrics(this.element), r2 = n2 - s2, l2 = RegExp('(<tspan>|<tspan(?!\\sclass="highcharts-br")[^>]*>|<\\/tspan>)', "g"), a2 = i2.innerHTML.replace(l2, "").split(/<tspan class="highcharts-br"[^>]*>/), h2 = a2.length, d2 = (t5, e4) => {
              let { x: n3, y: l3 } = e4, a3 = (i2.getRotationOfChar(t5) - 90) * o2, h3 = Math.cos(a3), d3 = Math.sin(a3);
              return [[n3 - r2 * h3, l3 - r2 * d3], [n3 + s2 * h3, l3 + s2 * d3]];
            };
            for (let e4 = 0, o3 = 0; o3 < h2; o3++) {
              let s3 = a2[o3].length;
              for (let n3 = 0; n3 < s3; n3 += 5) try {
                let s4 = e4 + n3 + o3, [r3, l3] = d2(s4, i2.getStartPositionOfChar(s4));
                0 === n3 ? (t4.push(l3), t4.push(r3)) : (0 === o3 && t4.unshift(l3), o3 === h2 - 1 && t4.push(r3));
              } catch (t5) {
                break;
              }
              e4 += s3 - 1;
              try {
                let s4 = e4 + o3, n3 = i2.getEndPositionOfChar(s4), [r3, l3] = d2(s4, n3);
                t4.unshift(l3), t4.unshift(r3);
              } catch (t5) {
                break;
              }
            }
            t4.length && t4.push(t4[0].slice()), e3.polygon = t4;
          }
          return e3;
        }
        function d(t3) {
          var _a;
          let e3 = t3.labelOptions, o3 = t3.point, i2 = e3[o3.formatPrefix + "TextPath"] || e3.textPath;
          i2 && !e3.useHTML && (this.setTextPath(((_a = o3.getDataLabelPath) == null ? void 0 : _a.call(o3, this)) || o3.graphic, i2), o3.dataLabelPath && !i2.enabled && (o3.dataLabelPath = o3.dataLabelPath.destroy()));
        }
        return { compose: function(t3) {
          i(t3, "afterGetBBox", h), i(t3, "beforeAddingDataLabel", d);
          let e3 = t3.prototype;
          e3.setTextPath || (e3.setTextPath = a);
        } };
      }), o(e, "Series/Sankey/SankeySeries.js", [e["Core/Globals.js"], e["Series/NodesComposition.js"], e["Series/Sankey/SankeyPoint.js"], e["Series/Sankey/SankeySeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Series/Sankey/SankeyColumnComposition.js"], e["Core/Color/Color.js"], e["Series/TreeUtilities.js"], e["Core/Utilities.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Extensions/TextPath.js"]], function(t2, e2, o2, i, s, n, r, l, a, h, d) {
        let { column: p, line: c } = s.seriesTypes, { parse: u } = r, { getLevelOptions: f, getNodeWidth: m } = l, { clamp: g, crisp: y, extend: k, isObject: C, merge: b, pick: v, relativeLength: x, stableSort: S } = a;
        d.compose(h);
        class N extends p {
          static getDLOptions(t3) {
            let e3 = C(t3.optionsPoint) ? t3.optionsPoint.dataLabels : {};
            return b({ style: {} }, C(t3.level) ? t3.level.dataLabels : {}, e3);
          }
          createNodeColumns() {
            let t3 = [];
            for (let e3 of this.nodes) e3.setNodeColumn(), t3[e3.column] || (t3[e3.column] = n.compose([], this)), t3[e3.column].push(e3);
            for (let e3 = 0; e3 < t3.length; e3++) void 0 === t3[e3] && (t3[e3] = n.compose([], this));
            return t3;
          }
          order(t3, e3) {
            if (void 0 === t3.level) for (let o3 of (t3.level = e3, t3.linksFrom)) o3.toNode && this.order(o3.toNode, e3 + 1);
          }
          generatePoints() {
            if (e2.generatePoints.apply(this, arguments), this.orderNodes) {
              for (let t3 of this.nodes) 0 === t3.linksTo.length && this.order(t3, 0);
              S(this.nodes, (t3, e3) => t3.level - e3.level);
            }
          }
          getNodePadding() {
            let t3 = this.options.nodePadding || 0;
            if (this.nodeColumns) {
              let e3 = this.nodeColumns.reduce((t4, e4) => Math.max(t4, e4.length), 0);
              e3 * t3 > this.chart.plotSizeY && (t3 = this.chart.plotSizeY / e3);
            }
            return t3;
          }
          hasData() {
            return !!this.processedXData.length;
          }
          pointAttribs(t3, e3) {
            if (!t3) return {};
            let o3 = this, i2 = t3.isNode ? t3.level : t3.fromNode.level, s2 = o3.mapOptionsToLevel[i2 || 0] || {}, n2 = t3.options, l2 = s2.states && s2.states[e3 || ""] || {}, a2 = ["colorByPoint", "borderColor", "borderWidth", "linkOpacity", "opacity"].reduce((t4, e4) => (t4[e4] = v(l2[e4], n2[e4], s2[e4], o3.options[e4]), t4), {}), h2 = v(l2.color, n2.color, a2.colorByPoint ? t3.color : s2.color);
            return t3.isNode ? { fill: h2, stroke: a2.borderColor, "stroke-width": a2.borderWidth, opacity: a2.opacity } : { fill: r.parse(h2).setOpacity(a2.linkOpacity).get() };
          }
          drawTracker() {
            p.prototype.drawTracker.call(this, this.points), p.prototype.drawTracker.call(this, this.nodes);
          }
          drawPoints() {
            p.prototype.drawPoints.call(this, this.points), p.prototype.drawPoints.call(this, this.nodes);
          }
          drawDataLabels() {
            p.prototype.drawDataLabels.call(this, this.points), p.prototype.drawDataLabels.call(this, this.nodes);
          }
          translate() {
            this.processedXData || this.processData(), this.generatePoints(), this.nodeColumns = this.createNodeColumns();
            let t3 = this, e3 = this.chart, o3 = this.options, i2 = this.nodeColumns, s2 = i2.length;
            for (let n2 of (this.nodeWidth = m(this, s2), this.nodePadding = this.getNodePadding(), this.translationFactor = i2.reduce((e4, o4) => Math.min(e4, o4.sankeyColumn.getTranslationFactor(t3)), 1 / 0), this.colDistance = (e3.plotSizeX - this.nodeWidth - o3.borderWidth) / Math.max(1, i2.length - 1), t3.mapOptionsToLevel = f({ from: 1, levels: o3.levels, to: i2.length - 1, defaults: { borderColor: o3.borderColor, borderRadius: o3.borderRadius, borderWidth: o3.borderWidth, color: t3.color, colorByPoint: o3.colorByPoint, levelIsConstant: true, linkColor: o3.linkColor, linkLineWidth: o3.linkLineWidth, linkOpacity: o3.linkOpacity, states: o3.states } }), i2)) for (let e4 of n2) t3.translateNode(e4, n2);
            for (let e4 of this.nodes) for (let o4 of e4.linksFrom) (o4.weight || o4.isNull) && o4.to && (t3.translateLink(o4), o4.allowShadow = false);
          }
          translateLink(t3) {
            let e3 = (e4, o4) => {
              let i3 = e4.offset(t3, o4) * r2;
              return Math.min(e4.nodeY + i3, e4.nodeY + (e4.shapeArgs && e4.shapeArgs.height || 0) - f2);
            }, o3 = t3.fromNode, i2 = t3.toNode, s2 = this.chart, { inverted: n2 } = s2, r2 = this.translationFactor, l2 = this.options, a2 = v(t3.linkColorMode, l2.linkColorMode), h2 = (s2.inverted ? -this.colDistance : this.colDistance) * l2.curveFactor, d2 = o3.nodeX, p2 = i2.nodeX, c2 = t3.outgoing, f2 = Math.max(t3.weight * r2, this.options.minLinkWidth), m2 = e3(o3, "linksFrom"), g2 = e3(i2, "linksTo"), y2 = this.nodeWidth, k2 = p2 > d2 + y2;
            if (s2.inverted && (m2 = s2.plotSizeY - m2, g2 = (s2.plotSizeY || 0) - g2, y2 = -y2, f2 = -f2, k2 = d2 > p2), t3.shapeType = "path", t3.linkBase = [m2, m2 + f2, g2, g2 + f2], k2 && "number" == typeof g2) t3.shapeArgs = { d: [["M", d2 + y2, m2], ["C", d2 + y2 + h2, m2, p2 - h2, g2, p2, g2], ["L", p2 + (c2 ? y2 : 0), g2 + f2 / 2], ["L", p2, g2 + f2], ["C", p2 - h2, g2 + f2, d2 + y2 + h2, m2 + f2, d2 + y2, m2 + f2], ["Z"]] };
            else if ("number" == typeof g2) {
              let e4 = s2.plotHeight - m2 - f2, o4 = p2 - 20 - f2, i3 = p2 - 20, n3 = d2 + y2, r3 = n3 + 20, l3 = r3 + f2, a3 = m2, h3 = m2 + f2, c3 = h3 + 20, u2 = c3 + e4, k3 = u2 + 20, C2 = k3 + f2, b2 = g2, v2 = b2 + f2, x2 = v2 + 20, S2 = h3 - 0.7 * f2, N2 = k3 + 0.7 * f2, P = v2 - 0.7 * f2, T = p2 - 0.7 * f2, L = n3 + 0.7 * f2;
              t3.shapeArgs = { d: [["M", n3, a3], ["C", L, a3, l3, S2, l3, c3], ["L", l3, u2], ["C", l3, N2, L, C2, n3, C2], ["L", p2, C2], ["C", T, C2, o4, N2, o4, u2], ["L", o4, x2], ["C", o4, P, T, b2, p2, b2], ["L", p2, v2], ["C", i3, v2, i3, v2, i3, x2], ["L", i3, u2], ["C", i3, k3, i3, k3, p2, k3], ["L", n3, k3], ["C", r3, k3, r3, k3, r3, u2], ["L", r3, c3], ["C", r3, h3, r3, h3, n3, h3], ["Z"]] };
            }
            if (t3.dlBox = { x: d2 + (p2 - d2 + y2) / 2, y: m2 + (g2 - m2) / 2, height: f2, width: 0 }, t3.tooltipPos = s2.inverted ? [s2.plotSizeY - t3.dlBox.y - f2 / 2, s2.plotSizeX - t3.dlBox.x] : [t3.dlBox.x, t3.dlBox.y + f2 / 2], t3.y = t3.plotY = 1, t3.x = t3.plotX = 1, !t3.options.color) {
              if ("from" === a2) t3.color = o3.color;
              else if ("to" === a2) t3.color = i2.color;
              else if ("gradient" === a2) {
                let e4 = u(o3.color).get(), s3 = u(i2.color).get();
                t3.color = { linearGradient: { x1: 1, x2: 0, y1: 0, y2: 0 }, stops: [[0, n2 ? e4 : s3], [1, n2 ? s3 : e4]] };
              }
            }
          }
          translateNode(t3, e3) {
            let o3 = this.translationFactor, i2 = this.chart, s2 = this.options, { borderRadius: n2, borderWidth: r2 = 0 } = s2, l2 = t3.getSum(), a2 = Math.max(Math.round(l2 * o3), this.options.minLinkWidth), h2 = Math.round(this.nodeWidth), d2 = e3.sankeyColumn.offset(t3, o3), p2 = y(v(d2.absoluteTop, e3.sankeyColumn.top(o3) + d2.relativeTop), r2), c2 = y(this.colDistance * t3.column + r2 / 2, r2) + x(t3.options[i2.inverted ? "offsetVertical" : "offsetHorizontal"] || 0, h2), u2 = i2.inverted ? i2.plotSizeX - c2 : c2;
            if (t3.sum = l2, l2) {
              t3.shapeType = "roundedRect", t3.nodeX = u2, t3.nodeY = p2;
              let e4 = u2, o4 = p2, r3 = t3.options.width || s2.width || h2, l3 = t3.options.height || s2.height || a2, d3 = g(x("object" == typeof n2 ? n2.radius : n2 || 0, r3), 0, a2 / 2);
              i2.inverted && (e4 = u2 - h2, o4 = i2.plotSizeY - p2 - a2, r3 = t3.options.height || s2.height || h2, l3 = t3.options.width || s2.width || a2), t3.dlOptions = N.getDLOptions({ level: this.mapOptionsToLevel[t3.level], optionsPoint: t3.options }), t3.plotX = 1, t3.plotY = 1, t3.tooltipPos = i2.inverted ? [i2.plotSizeY - o4 - l3 / 2, i2.plotSizeX - e4 - r3 / 2] : [e4 + r3 / 2, o4 + l3 / 2], t3.shapeArgs = { x: e4, y: o4, width: r3, height: l3, r: d3, display: t3.hasShape() ? "" : "none" };
            } else t3.dlOptions = { enabled: false };
          }
        }
        return N.defaultOptions = b(p.defaultOptions, i), e2.compose(o2, N), k(N.prototype, { animate: c.prototype.animate, createNode: e2.createNode, forceDL: true, invertible: true, isCartesian: false, orderNodes: true, noSharedTooltip: true, pointArrayMap: ["from", "to", "weight"], pointClass: o2, searchPoint: t2.noop }), s.registerSeriesType("sankey", N), N;
      }), o(e, "masters/modules/sankey.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_sankey();
//# sourceMappingURL=highcharts_modules_sankey__js.js.map
