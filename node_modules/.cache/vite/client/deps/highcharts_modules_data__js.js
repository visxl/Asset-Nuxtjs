import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/data.js
var require_data = __commonJS({
  "node_modules/highcharts/modules/data.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Data module
    *
    * (c) 2012-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/data", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function s(t2, s2, r, i) {
        t2.hasOwnProperty(s2) || (t2[s2] = i.apply(null, r), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: t2[s2] } })));
      }
      s(t, "Core/HttpUtilities.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { win: s2 } = e2, { discardElement: r, objectEach: i } = t2, a = { ajax: function(e3) {
          let t3 = { json: "application/json", xml: "application/xml", text: "text/plain", octet: "application/octet-stream" }, s3 = new XMLHttpRequest();
          function r2(t4, s4) {
            e3.error && e3.error(t4, s4);
          }
          if (!e3.url) return false;
          s3.open((e3.type || "get").toUpperCase(), e3.url, true), e3.headers && e3.headers["Content-Type"] || s3.setRequestHeader("Content-Type", t3[e3.dataType || "json"] || t3.text), i(e3.headers, function(e4, t4) {
            s3.setRequestHeader(t4, e4);
          }), e3.responseType && (s3.responseType = e3.responseType), s3.onreadystatechange = function() {
            let t4;
            if (4 === s3.readyState) {
              if (200 === s3.status) {
                if ("blob" !== e3.responseType && (t4 = s3.responseText, "json" === e3.dataType)) try {
                  t4 = JSON.parse(t4);
                } catch (e4) {
                  if (e4 instanceof Error) return r2(s3, e4);
                }
                return e3.success && e3.success(t4, s3);
              }
              r2(s3, s3.responseText);
            }
          }, e3.data && "string" != typeof e3.data && (e3.data = JSON.stringify(e3.data)), s3.send(e3.data);
        }, getJSON: function(e3, t3) {
          a.ajax({ url: e3, success: t3, dataType: "json", headers: { "Content-Type": "text/plain" } });
        }, post: function(e3, t3, a2) {
          let n = new s2.FormData();
          i(t3, function(e4, t4) {
            n.append(t4, e4);
          }), n.append("b64", "true");
          let { filename: o, type: l } = t3;
          return s2.fetch(e3, { method: "POST", body: n, ...a2 }).then((e4) => {
            e4.ok && e4.text().then((e5) => {
              let t4 = document.createElement("a");
              t4.href = `data:${l};base64,${e5}`, t4.download = o, t4.click(), r(t4);
            });
          });
        } };
        return a;
      }), s(t, "Extensions/Data.js", [t["Core/Chart/Chart.js"], t["Core/Defaults.js"], t["Core/Globals.js"], t["Core/HttpUtilities.js"], t["Core/Series/Point.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2, s2, r, i, a, n) {
        let { getOptions: o } = t2, { doc: l } = s2, { ajax: d } = r, { seriesTypes: u } = a, { addEvent: h, defined: m, extend: c, fireEvent: p, isNumber: f, merge: g, objectEach: C, pick: x, splat: y } = n;
        function T(e3) {
          return !!(e3 && (e3.rowsURL || e3.csvURL || e3.columnsURL));
        }
        class v {
          static data(e3, t3 = {}, s3) {
            return new v(e3, t3, s3);
          }
          static rowsToColumns(e3) {
            let t3, s3, r2, i2, a2;
            if (e3) for (t3 = 0, a2 = [], s3 = e3.length; t3 < s3; t3++) for (r2 = 0, i2 = e3[t3].length; r2 < i2; r2++) a2[r2] || (a2[r2] = []), a2[r2][t3] = e3[t3][r2];
            return a2;
          }
          constructor(e3, t3 = {}, s3) {
            this.rowsToColumns = v.rowsToColumns, this.dateFormats = { "YYYY/mm/dd": { regex: /^(\d{4})[\-\/\.](\d{1,2})[\-\/\.](\d{1,2})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[1], e4[2] - 1, +e4[3]) : NaN;
            } }, "dd/mm/YYYY": { regex: /^(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{4})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[3], e4[2] - 1, +e4[1]) : NaN;
            }, alternative: "mm/dd/YYYY" }, "mm/dd/YYYY": { regex: /^(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{4})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[3], e4[1] - 1, +e4[2]) : NaN;
            } }, "dd/mm/YY": { regex: /^(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{2})$/, parser: function(e4) {
              if (!e4) return NaN;
              let t4 = /* @__PURE__ */ new Date(), s4 = +e4[3];
              return s4 > t4.getFullYear() - 2e3 ? s4 += 1900 : s4 += 2e3, Date.UTC(s4, e4[2] - 1, +e4[1]);
            }, alternative: "mm/dd/YY" }, "mm/dd/YY": { regex: /^(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{2})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[3] + 2e3, e4[1] - 1, +e4[2]) : NaN;
            } } }, this.chart = s3, this.chartOptions = t3, this.options = e3, this.rawColumns = [], this.init(e3, t3, s3);
          }
          init(e3, t3, s3) {
            let r2 = e3.decimalPoint, i2;
            t3 && (this.chartOptions = t3), s3 && (this.chart = s3), "." !== r2 && "," !== r2 && (r2 = void 0), this.options = e3, this.columns = e3.columns || this.rowsToColumns(e3.rows) || [], this.firstRowAsNames = x(e3.firstRowAsNames, this.firstRowAsNames, true), this.decimalRegex = r2 && RegExp("^(-?[0-9]+)" + r2 + "([0-9]+)$"), void 0 !== this.liveDataTimeout && clearTimeout(this.liveDataTimeout), this.rawColumns = [], this.columns.length && (this.dataFound(), i2 = !T(e3)), i2 || (i2 = this.fetchLiveData()), i2 || (i2 = !!this.parseCSV().length), i2 || (i2 = !!this.parseTable().length), i2 || (i2 = this.parseGoogleSpreadsheet()), !i2 && e3.afterComplete && e3.afterComplete();
          }
          getColumnDistribution() {
            let e3 = this.chartOptions, t3 = this.options, s3 = [], r2 = function(e4) {
              return (u[e4 || "line"].prototype.pointArrayMap || [0]).length;
            }, i2 = function(e4) {
              return u[e4 || "line"].prototype.pointArrayMap;
            }, a2 = e3 && e3.chart && e3.chart.type, n2 = [], o2 = [], l2 = t3 && t3.seriesMapping || e3 && e3.series && e3.series.map(function() {
              return { x: 0 };
            }) || [], d2 = 0, h2;
            (e3 && e3.series || []).forEach((e4) => {
              n2.push(r2(e4.type || a2));
            }), l2.forEach((e4) => {
              s3.push(e4.x || 0);
            }), 0 === s3.length && s3.push(0), l2.forEach((t4) => {
              let s4 = new R(), l3 = n2[d2] || r2(a2), u2 = (e3 && e3.series || [])[d2] || {}, c3 = i2(u2.type || a2), p2 = c3 || ["y"];
              for ((m(t4.x) || u2.isCartesian || !c3) && s4.addColumnReader(t4.x, "x"), C(t4, function(e4, t5) {
                "x" !== t5 && s4.addColumnReader(e4, t5);
              }), h2 = 0; h2 < l3; h2++) s4.hasReader(p2[h2]) || s4.addColumnReader(void 0, p2[h2]);
              o2.push(s4), d2++;
            });
            let c2 = i2(a2);
            void 0 === c2 && (c2 = ["y"]), this.valueCount = { global: r2(a2), xColumns: s3, individual: n2, seriesBuilders: o2, globalPointArrayMap: c2 };
          }
          dataFound() {
            this.options.switchRowsAndColumns && (this.columns = this.rowsToColumns(this.columns)), this.getColumnDistribution(), this.parseTypes(), false !== this.parsed() && this.complete();
          }
          parseCSV(e3) {
            let t3 = this, s3 = this.columns = [], r2 = e3 || this.options, i2 = void 0 !== r2.startColumn && r2.startColumn ? r2.startColumn : 0, a2 = r2.endColumn || Number.MAX_VALUE, n2 = [], o2 = { ",": 0, ";": 0, "	": 0 }, l2 = r2.csv, d2 = void 0 !== r2.startRow && r2.startRow ? r2.startRow : 0, u2 = r2.endRow || Number.MAX_VALUE, h2, m2, c2 = 0;
            if (l2 && r2.beforeParse && (l2 = r2.beforeParse.call(this, l2)), l2) {
              if (m2 = l2.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split(r2.lineDelimiter || "\n"), (!d2 || d2 < 0) && (d2 = 0), (!u2 || u2 >= m2.length) && (u2 = m2.length - 1), r2.itemDelimiter) h2 = r2.itemDelimiter;
              else {
                let e5, s4, i3;
                h2 = null, e5 = 0, s4 = 0, i3 = false, m2.some(function(t4, r3) {
                  let i4 = false, a3, n3, l3, d3 = "";
                  if (r3 > 13) return true;
                  for (let r4 = 0; r4 < t4.length; r4++) {
                    if (a3 = t4[r4], n3 = t4[r4 + 1], l3 = t4[r4 - 1], "#" === a3) return;
                    if ('"' === a3) {
                      if (i4) {
                        if ('"' !== l3 && '"' !== n3) {
                          for (; " " === n3 && r4 < t4.length; ) n3 = t4[++r4];
                          void 0 !== o2[n3] && o2[n3]++, i4 = false;
                        }
                      } else i4 = true;
                    } else void 0 !== o2[a3] ? (isNaN(Date.parse(d3 = d3.trim())) ? (isNaN(d3) || !isFinite(d3)) && o2[a3]++ : o2[a3]++, d3 = "") : d3 += a3;
                    "," === a3 && s4++, "." === a3 && e5++;
                  }
                }), o2[";"] > o2[","] ? i3 = ";" : (o2[","], o2[";"], i3 = ","), r2.decimalPoint || (e5 > s4 ? r2.decimalPoint = "." : r2.decimalPoint = ",", t3.decimalRegex = RegExp("^(-?[0-9]+)" + r2.decimalPoint + "([0-9]+)$")), h2 = i3;
              }
              let e4 = 0;
              for (c2 = d2; c2 <= u2; c2++) "#" === m2[c2][0] ? e4++ : function(e5, t4, o3, l3) {
                let d3 = 0, u3 = "", m3 = "", c3 = "", p2 = "", f2 = 0, g2 = 0;
                function C2(t5) {
                  u3 = e5[t5], m3 = e5[t5 - 1], c3 = e5[t5 + 1];
                }
                function x2(e6) {
                  n2.length < g2 + 1 && n2.push([e6]), n2[g2][n2[g2].length - 1] !== e6 && n2[g2].push(e6);
                }
                function y2() {
                  if (i2 > f2 || f2 > a2) {
                    ++f2, p2 = "";
                    return;
                  }
                  r2.columnTypes || (!isNaN(parseFloat(p2)) && isFinite(p2) ? (p2 = parseFloat(p2), x2("number")) : isNaN(Date.parse(p2)) ? x2("string") : (p2 = p2.replace(/\//g, "-"), x2("date"))), s3.length < g2 + 1 && s3.push([]), s3[g2][t4] = p2, p2 = "", ++g2, ++f2;
                }
                if (e5.trim().length && "#" !== e5.trim()[0]) {
                  for (; d3 < e5.length; d3++) if (C2(d3), '"' === u3) for (C2(++d3); d3 < e5.length && ('"' !== u3 || '"' === m3 || '"' === c3); ) ('"' !== u3 || '"' === u3 && '"' !== m3) && (p2 += u3), C2(++d3);
                  else u3 === h2 ? y2() : p2 += u3;
                  y2();
                }
              }(m2[c2], c2 - d2 - e4);
              (!r2.columnTypes || 0 === r2.columnTypes.length) && n2.length && n2[0].length && "date" === n2[0][1] && !r2.dateFormat && (r2.dateFormat = function(e5, s4) {
                let i3 = "YYYY/mm/dd", a3 = [], n3 = [], o3, l3 = [], d3, u3 = 0, h3 = false, m3;
                for ((!s4 || s4 > e5.length) && (s4 = e5.length); u3 < s4; u3++) if (void 0 !== e5[u3] && e5[u3] && e5[u3].length) for (m3 = 0, o3 = e5[u3].trim().replace(/\//g, " ").replace(/\-/g, " ").replace(/\./g, " ").split(" "), l3 = ["", "", ""]; m3 < o3.length; m3++) m3 < l3.length && (o3[m3] = parseInt(o3[m3], 10), o3[m3] && (n3[m3] = !n3[m3] || n3[m3] < o3[m3] ? o3[m3] : n3[m3], void 0 !== a3[m3] ? a3[m3] !== o3[m3] && (a3[m3] = false) : a3[m3] = o3[m3], o3[m3] > 31 ? o3[m3] < 100 ? l3[m3] = "YY" : l3[m3] = "YYYY" : o3[m3] > 12 && o3[m3] <= 31 ? (l3[m3] = "dd", h3 = true) : l3[m3].length || (l3[m3] = "mm")));
                if (h3) {
                  for (m3 = 0; m3 < a3.length; m3++) false !== a3[m3] ? n3[m3] > 12 && "YY" !== l3[m3] && "YYYY" !== l3[m3] && (l3[m3] = "YY") : n3[m3] > 12 && "mm" === l3[m3] && (l3[m3] = "dd");
                  return (3 === l3.length && "dd" === l3[1] && "dd" === l3[2] && (l3[2] = "YY"), d3 = l3.join("/"), (r2.dateFormats || t3.dateFormats)[d3]) ? d3 : (p("deduceDateFailed"), i3);
                }
                return i3;
              }(s3[0])), this.dataFound();
            }
            return s3;
          }
          parseTable() {
            let e3 = this.options, t3 = this.columns || [], s3 = e3.startRow || 0, r2 = e3.endRow || Number.MAX_VALUE, i2 = e3.startColumn || 0, a2 = e3.endColumn || Number.MAX_VALUE;
            if (e3.table) {
              let n2 = e3.table;
              "string" == typeof n2 && (n2 = l.getElementById(n2)), [].forEach.call(n2.getElementsByTagName("tr"), (e4, n3) => {
                n3 >= s3 && n3 <= r2 && [].forEach.call(e4.children, (e5, r3) => {
                  let o2 = t3[r3 - i2], l2 = 1;
                  if (("TD" === e5.tagName || "TH" === e5.tagName) && r3 >= i2 && r3 <= a2) for (t3[r3 - i2] || (t3[r3 - i2] = []), t3[r3 - i2][n3 - s3] = e5.innerHTML; n3 - s3 >= l2 && void 0 === o2[n3 - s3 - l2]; ) o2[n3 - s3 - l2] = null, l2++;
                });
              }), this.dataFound();
            }
            return t3;
          }
          fetchLiveData() {
            let e3 = this, t3 = this.chart, s3 = this.options, r2 = s3.enablePolling, i2 = g(s3), a2 = 0, n2 = 1e3 * (s3.dataRefreshRate || 2);
            return !!T(s3) && (n2 < 1e3 && (n2 = 1e3), delete s3.csvURL, delete s3.rowsURL, delete s3.columnsURL, function o2(l2) {
              function u2(i3, u3, h2) {
                if (!i3 || !/^(http|\/|\.\/|\.\.\/)/.test(i3)) return i3 && s3.error && s3.error("Invalid URL"), false;
                function m2() {
                  r2 && t3.liveDataURL === i3 && (e3.liveDataTimeout = setTimeout(o2, n2));
                }
                return l2 && (clearTimeout(e3.liveDataTimeout), t3.liveDataURL = i3), d({ url: i3, dataType: h2 || "json", success: function(e4) {
                  t3 && t3.series && u3(e4), m2();
                }, error: function(e4, t4) {
                  return ++a2 < 3 && m2(), s3.error && s3.error(t4, e4);
                } }), true;
              }
              u2(i2.csvURL, function(e4) {
                t3.update({ data: { csv: e4 } });
              }, "text") || u2(i2.rowsURL, function(e4) {
                t3.update({ data: { rows: e4 } });
              }) || u2(i2.columnsURL, function(e4) {
                t3.update({ data: { columns: e4 } });
              });
            }(true), T(s3));
          }
          parseGoogleSpreadsheet() {
            let e3 = this, t3 = this.options, s3 = t3.googleSpreadsheetKey, r2 = this.chart, i2 = Math.max(1e3 * (t3.dataRefreshRate || 2), 4e3), a2 = () => {
              if (t3.googleSpreadsheetRange) return t3.googleSpreadsheetRange;
              let e4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", s4 = (e4.charAt(t3.startColumn || 0) || "A") + ((t3.startRow || 0) + 1), r3 = e4.charAt(x(t3.endColumn, -1)) || "ZZ";
              return m(t3.endRow) && (r3 += t3.endRow + 1), `${s4}:${r3}`;
            };
            return s3 && (delete t3.googleSpreadsheetKey, function r3(n2) {
              d({ url: ["https://sheets.googleapis.com/v4/spreadsheets", s3, "values", a2(), "?alt=json&majorDimension=COLUMNS&valueRenderOption=UNFORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING&key=" + t3.googleAPIKey].join("/"), dataType: "json", success: function(s4) {
                n2(s4), t3.enablePolling && (e3.liveDataTimeout = setTimeout(function() {
                  r3(n2);
                }, i2));
              }, error: function(e4, s4) {
                return t3.error && t3.error(s4, e4);
              } });
            }(function(t4) {
              let s4 = t4.values;
              if (!s4 || 0 === s4.length) return false;
              let i3 = s4.reduce((e4, t5) => Math.max(e4, t5.length), 0);
              s4.forEach((e4) => {
                for (let t5 = 0; t5 < i3; t5++) void 0 === e4[t5] && (e4[t5] = null);
              }), r2 && r2.series ? r2.update({ data: { columns: s4 } }) : (e3.columns = s4, e3.dataFound());
            })), false;
          }
          trim(e3, t3) {
            return "string" == typeof e3 && (e3 = e3.replace(/^\s+|\s+$/g, ""), t3 && /[\d\s]+/.test(e3) && (e3 = e3.replace(/\s/g, "")), this.decimalRegex && (e3 = e3.replace(this.decimalRegex, "$1.$2"))), e3;
          }
          parseTypes() {
            let e3 = this.columns || [], t3 = e3.length;
            for (; t3--; ) this.parseColumn(e3[t3], t3);
          }
          parseColumn(e3, t3) {
            let s3 = this.rawColumns, r2 = this.columns, i2 = this.firstRowAsNames, a2 = -1 !== this.valueCount.xColumns.indexOf(t3), n2 = [], o2 = this.chartOptions, l2 = (this.options.columnTypes || [])[t3], d2 = a2 && o2 && o2.xAxis && "category" === y(o2.xAxis)[0].type || "string" === l2, u2 = m(e3.name), h2 = e3.length, c2, p2, g2, C2, x2, T2, v2;
            for (s3[t3] || (s3[t3] = []); h2--; ) c2 = n2[h2] || e3[h2], g2 = this.trim(c2), p2 = parseFloat(C2 = this.trim(c2, true)), void 0 === s3[t3][h2] && (s3[t3][h2] = g2), d2 || 0 === h2 && i2 && !u2 ? e3[h2] = "" + g2 : +C2 === p2 ? (e3[h2] = p2, p2 > 31536e6 && "float" !== l2 ? e3.isDatetime = true : e3.isNumeric = true, void 0 !== e3[h2 + 1] && (v2 = p2 > e3[h2 + 1])) : (g2 && g2.length && (x2 = this.parseDate(c2)), a2 && f(x2) && "float" !== l2 ? (n2[h2] = c2, e3[h2] = x2, e3.isDatetime = true, void 0 !== e3[h2 + 1] && ((T2 = x2 > e3[h2 + 1]) !== v2 && void 0 !== v2 && (this.alternativeFormat ? (this.dateFormat = this.alternativeFormat, h2 = e3.length, this.alternativeFormat = this.dateFormats[this.dateFormat].alternative) : e3.unsorted = true), v2 = T2)) : (e3[h2] = "" === g2 ? null : g2, 0 !== h2 && (e3.isDatetime || e3.isNumeric) && (e3.mixed = true)));
            if (a2 && e3.mixed && (r2[t3] = s3[t3]), a2 && v2 && this.options.sort) for (t3 = 0; t3 < r2.length; t3++) r2[t3].reverse(), i2 && r2[t3].unshift(r2[t3].pop());
          }
          parseDate(e3) {
            let t3 = this.options.parseDate, s3, r2, i2, a2 = this.options.dateFormat || this.dateFormat, n2;
            if (t3) s3 = t3(e3);
            else if ("string" == typeof e3) {
              if (a2) (i2 = this.dateFormats[a2]) || (i2 = this.dateFormats["YYYY/mm/dd"]), (n2 = e3.match(i2.regex)) && (s3 = i2.parser(n2));
              else for (r2 in this.dateFormats) if (i2 = this.dateFormats[r2], n2 = e3.match(i2.regex)) {
                this.dateFormat = a2 = r2, this.alternativeFormat = i2.alternative, s3 = i2.parser(n2);
                break;
              }
              !n2 && (e3.match(/:.+(GMT|UTC|[Z+\-])/) && (e3 = e3.replace(/\s*(?:GMT|UTC)?([+\-])(\d\d)(\d\d)$/, "$1$2:$3").replace(/(?:\s+|GMT|UTC)([+\-])/, "$1").replace(/(\d)\s*(?:GMT|UTC|Z)$/, "$1+00:00")), "object" == typeof (n2 = Date.parse(e3)) && null !== n2 && n2.getTime ? s3 = n2.getTime() - 6e4 * n2.getTimezoneOffset() : f(n2) && (s3 = n2 - 6e4 * new Date(n2).getTimezoneOffset()));
            }
            return s3;
          }
          getData() {
            if (this.columns) return this.rowsToColumns(this.columns).slice(1);
          }
          parsed() {
            if (this.options.parsed) return this.options.parsed.call(this, this.columns);
          }
          complete() {
            let e3, t3, s3, r2, i2, a2, n2, o2, l2, d2, u2, h2;
            let c2 = this.columns, p2 = this.options, f2 = [];
            if ([].length = c2.length, p2.complete || p2.afterComplete) {
              if (this.firstRowAsNames) for (r2 = 0; r2 < c2.length; r2++) {
                let e4 = c2[r2];
                m(e4.name) || (e4.name = x(e4.shift(), "").toString());
              }
              for (n2 = 0, t3 = [], d2 = function(e4, t4) {
                let s4, r3, i3;
                let a3 = [], n3 = [];
                for (r3 = 0; r3 < e4; r3 += 1) a3.push(true);
                for (s4 = 0; s4 < t4.length; s4 += 1) for (r3 = 0, i3 = t4[s4].getReferencedColumnIndexes(); r3 < i3.length; r3 += 1) a3[i3[r3]] = false;
                for (r3 = 0; r3 < a3.length; r3 += 1) a3[r3] && n3.push(r3);
                return n3;
              }(c2.length, this.valueCount.seriesBuilders); n2 < this.valueCount.seriesBuilders.length; n2++) (l2 = this.valueCount.seriesBuilders[n2]).populateColumns(d2) && f2.push(l2);
              for (; d2.length > 0; ) {
                for ((l2 = new R()).addColumnReader(0, "x"), -1 !== (h2 = d2.indexOf(0)) && d2.splice(h2, 1), r2 = 0; r2 < this.valueCount.global; r2++) l2.addColumnReader(void 0, this.valueCount.globalPointArrayMap[r2]);
                l2.populateColumns(d2) && f2.push(l2);
              }
              if (f2.length > 0 && f2[0].readers.length > 0 && void 0 !== (u2 = c2[f2[0].readers[0].columnIndex]) && (u2.isDatetime ? e3 = "datetime" : u2.isNumeric || (e3 = "category")), "category" === e3) for (n2 = 0; n2 < f2.length; n2++) for (a2 = 0, l2 = f2[n2]; a2 < l2.readers.length; a2++) "x" === l2.readers[a2].configName && (l2.readers[a2].configName = "name");
              for (n2 = 0; n2 < f2.length; n2++) {
                for (i2 = 0, l2 = f2[n2], s3 = []; i2 < c2[0].length; i2++) s3[i2] = l2.read(c2, i2);
                t3[n2] = { data: s3 }, l2.name && (t3[n2].name = l2.name), "category" === e3 && (t3[n2].turboThreshold = 0);
              }
              o2 = { series: t3 }, e3 && (o2.xAxis = { type: e3 }, "category" === e3 && (o2.xAxis.uniqueNames = false)), p2.complete && p2.complete(o2), p2.afterComplete && p2.afterComplete(o2);
            }
          }
          update(e3, t3) {
            let s3 = this.chart, r2 = s3.options;
            e3 && (e3.afterComplete = function(e4) {
              e4 && (e4.xAxis && s3.xAxis[0] && e4.xAxis.type === s3.xAxis[0].options.type && delete e4.xAxis, s3.update(e4, t3, true));
            }, g(true, r2.data, e3), r2.data && r2.data.googleSpreadsheetKey && !e3.columns && delete r2.data.columns, this.init(r2.data));
          }
        }
        h(e2, "init", function(e3) {
          let t3 = this, s3 = e3.args[1], r2 = o().data, i2 = e3.args[0] || {};
          if ((r2 || i2 && i2.data) && !t3.hasDataDef) {
            t3.hasDataDef = true;
            let a2 = g(r2, i2.data);
            t3.data = new v(c(a2, { afterComplete: function(e4) {
              let r3, a3;
              if (Object.hasOwnProperty.call(i2, "series")) {
                if ("object" == typeof i2.series) for (r3 = Math.max(i2.series.length, e4 && e4.series ? e4.series.length : 0); r3--; ) a3 = i2.series[r3] || {}, i2.series[r3] = g(a3, e4 && e4.series ? e4.series[r3] : {});
                else delete i2.series;
              }
              i2 = g(e4, i2), t3.init(i2, s3);
            } }), i2, t3), e3.preventDefault();
          }
        });
        class R {
          constructor() {
            this.readers = [], this.pointIsArray = true;
          }
          populateColumns(e3) {
            let t3 = true;
            return this.readers.forEach((t4) => {
              void 0 === t4.columnIndex && (t4.columnIndex = e3.shift());
            }), this.readers.forEach((e4) => {
              void 0 === e4.columnIndex && (t3 = false);
            }), t3;
          }
          read(e3, t3) {
            let s3 = this.pointIsArray, r2 = s3 ? [] : {};
            if (this.readers.forEach((a2) => {
              let n2 = e3[a2.columnIndex][t3];
              s3 ? r2.push(n2) : a2.configName.indexOf(".") > 0 ? i.prototype.setNestedProperty(r2, n2, a2.configName) : r2[a2.configName] = n2;
            }), void 0 === this.name && this.readers.length >= 2) {
              let t4 = [];
              this.readers.forEach(function(e4) {
                ("x" === e4.configName || "name" === e4.configName || "y" === e4.configName) && void 0 !== e4.columnIndex && t4.push(e4.columnIndex);
              }), t4.length >= 2 && (t4.shift(), t4.sort(function(e4, t5) {
                return e4 - t5;
              })), this.name = e3[x(t4.shift(), 0)].name;
            }
            return r2;
          }
          addColumnReader(e3, t3) {
            this.readers.push({ columnIndex: e3, configName: t3 }), "x" === t3 || "y" === t3 || void 0 === t3 || (this.pointIsArray = false);
          }
          getReferencedColumnIndexes() {
            let e3, t3;
            let s3 = [];
            for (e3 = 0; e3 < this.readers.length; e3 += 1) void 0 !== (t3 = this.readers[e3]).columnIndex && s3.push(t3.columnIndex);
            return s3;
          }
          hasReader(e3) {
            let t3;
            for (t3 = 0; t3 < this.readers.length; t3 += 1) if (this.readers[t3].configName === e3) return true;
          }
        }
        return v;
      }), s(t, "masters/modules/data.src.js", [t["Core/Globals.js"], t["Core/HttpUtilities.js"], t["Extensions/Data.js"]], function(e2, t2, s2) {
        return e2.Data = e2.Data || s2, e2.HttpUtilities = e2.HttpUtilities || t2, e2.ajax = e2.HttpUtilities.ajax, e2.data = e2.Data.data, e2.getJSON = e2.HttpUtilities.getJSON, e2.post = e2.HttpUtilities.post, e2;
      });
    });
  }
});
export default require_data();
//# sourceMappingURL=highcharts_modules_data__js.js.map
