import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/wordcloud.js
var require_wordcloud = __commonJS({
  "node_modules/highcharts/modules/wordcloud.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2016-2024 Highsoft AS
    * Authors: Jon Arild Nygard
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/wordcloud", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, o, n) {
        e2.hasOwnProperty(i2) || (e2[i2] = n.apply(null, o), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Series/DrawPointUtilities.js", [], function() {
        return { draw: function(t2, e2) {
          let { animatableAttribs: i2, onComplete: o, css: n, renderer: r } = e2, a = t2.series && t2.series.chart.hasRendered ? void 0 : t2.series && t2.series.options.animation, l = t2.graphic;
          if (e2.attribs = { ...e2.attribs, class: t2.getClassName() }, t2.shouldDraw()) l || (l = "text" === e2.shapeType ? r.text() : "image" === e2.shapeType ? r.image(e2.imageUrl || "").attr(e2.shapeArgs || {}) : r[e2.shapeType](e2.shapeArgs || {}), t2.graphic = l, l.add(e2.group)), n && l.css(n), l.attr(e2.attribs).animate(i2, !e2.isNew && a, o);
          else if (l) {
            let e3 = () => {
              t2.graphic = l = l && l.destroy(), "function" == typeof o && o();
            };
            Object.keys(i2).length ? l.animate(i2, void 0, () => e3()) : e3();
          }
        } };
      }), i(e, "Series/Wordcloud/WordcloudPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { column: { prototype: { pointClass: i2 } } } = t2.seriesTypes, { extend: o } = e2;
        class n extends i2 {
          isValid() {
            return true;
          }
        }
        return o(n.prototype, { weight: 1 }), n;
      }), i(e, "Series/Wordcloud/WordcloudSeriesDefaults.js", [], function() {
        return { allowExtendPlayingField: true, animation: { duration: 500 }, borderWidth: 0, clip: false, colorByPoint: true, cropThreshold: 1 / 0, minFontSize: 1, maxFontSize: 25, placementStrategy: "center", rotation: { from: 0, orientations: 2, to: 90 }, showInLegend: false, spiral: "rectangular", style: { fontFamily: "sans-serif", fontWeight: "900", whiteSpace: "nowrap" }, tooltip: { followPointer: true, pointFormat: '<span style="color:{point.color}">‚óè</span> {series.name}: <b>{point.weight}</b><br/>' } };
      }), i(e, "Series/Wordcloud/WordcloudUtils.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { deg2rad: i2 } = t2, { extend: o, find: n, isNumber: r, isObject: a, merge: l } = e2;
        function s(t3, e3) {
          return !(e3.left > t3.right || e3.right < t3.left || e3.top > t3.bottom || e3.bottom < t3.top);
        }
        function h(t3) {
          let e3, i3 = t3.axes || [];
          return i3.length || (i3 = [], t3.concat([t3[0]]).reduce((t4, e4) => {
            let o2 = function(t5, e5) {
              let i4 = e5[0] - t5[0], o3 = e5[1] - t5[1];
              return [[-o3, i4], [o3, -i4]];
            }(t4, e4)[0];
            return n(i3, (t5) => t5[0] === o2[0] && t5[1] === o2[1]) || i3.push(o2), e4;
          }), t3.axes = i3), i3;
        }
        function d(t3, e3) {
          let i3 = t3.map((t4) => {
            let i4 = t4[0], o2 = t4[1];
            return i4 * e3[0] + o2 * e3[1];
          });
          return { min: Math.min.apply(this, i3), max: Math.max.apply(this, i3) };
        }
        function u(t3, e3) {
          let i3 = h(t3), o2 = h(e3);
          return !n(i3.concat(o2), (i4) => function(t4, e4, i5) {
            let o3 = d(e4, t4), n2 = d(i5, t4);
            return !!(n2.min > o3.max || n2.max < o3.min);
          }(i4, t3, e3));
        }
        function c(t3, e3) {
          let i3 = 4 * t3, o2 = Math.ceil((Math.sqrt(i3) - 1) / 2), n2 = 2 * o2 + 1, r2 = Math.pow(n2, 2), a2 = false;
          return n2 -= 1, t3 <= 1e4 && ("boolean" == typeof a2 && i3 >= r2 - n2 && (a2 = { x: o2 - (r2 - i3), y: -o2 }), r2 -= n2, "boolean" == typeof a2 && i3 >= r2 - n2 && (a2 = { x: -o2, y: -o2 + (r2 - i3) }), r2 -= n2, "boolean" == typeof a2 && (a2 = i3 >= r2 - n2 ? { x: -o2 + (r2 - i3), y: o2 } : { x: o2, y: o2 - (r2 - i3 - n2) }), a2.x *= 5, a2.y *= 5), a2;
        }
        function p(t3, e3) {
          let i3 = Math.pow(10, r(e3) ? e3 : 14);
          return Math.round(t3 * i3) / i3;
        }
        function m(t3, e3) {
          let o2 = t3[0], n2 = t3[1], r2 = -(i2 * e3), a2 = Math.cos(r2), l2 = Math.sin(r2);
          return [p(o2 * a2 - n2 * l2), p(o2 * l2 + n2 * a2)];
        }
        function g(t3, e3, i3) {
          let o2 = m([t3[0] - e3[0], t3[1] - e3[1]], i3);
          return [o2[0] + e3[0], o2[1] + e3[1]];
        }
        return { archimedeanSpiral: function(t3, e3) {
          let i3 = e3.field, o2 = i3.width * i3.width + i3.height * i3.height, n2 = 0.8 * t3, r2 = false;
          return t3 <= 1e4 && !(Math.min(Math.abs((r2 = { x: n2 * Math.cos(n2), y: n2 * Math.sin(n2) }).x), Math.abs(r2.y)) < o2) && (r2 = false), r2;
        }, extendPlayingField: function(t3, e3) {
          let i3, o2, n2, r2, s2, h2, d2, u2;
          return a(t3) && a(e3) ? (i3 = e3.bottom - e3.top, h2 = (s2 = (o2 = e3.right - e3.left) * (n2 = t3.ratioX) > i3 * (r2 = t3.ratioY) ? o2 : i3) * n2, d2 = s2 * r2, u2 = l(t3, { width: t3.width + 2 * h2, height: t3.height + 2 * d2 })) : u2 = t3, u2;
        }, getBoundingBoxFromPolygon: function(t3) {
          return t3.reduce(function(t4, e3) {
            let i3 = e3[0], o2 = e3[1];
            return t4.left = Math.min(i3, t4.left), t4.right = Math.max(i3, t4.right), t4.bottom = Math.max(o2, t4.bottom), t4.top = Math.min(o2, t4.top), t4;
          }, { left: Number.MAX_VALUE, right: -Number.MAX_VALUE, bottom: -Number.MAX_VALUE, top: Number.MAX_VALUE });
        }, getPlayingField: function(t3, e3, i3) {
          let o2 = i3.reduce(function(t4, e4) {
            let i4 = e4.dimensions, o3 = Math.max(i4.width, i4.height);
            return t4.maxHeight = Math.max(t4.maxHeight, i4.height), t4.maxWidth = Math.max(t4.maxWidth, i4.width), t4.area += o3 * o3, t4;
          }, { maxHeight: 0, maxWidth: 0, area: 0 }), n2 = Math.max(o2.maxHeight, o2.maxWidth, 0.85 * Math.sqrt(o2.area)), r2 = t3 > e3 ? t3 / e3 : 1, a2 = e3 > t3 ? e3 / t3 : 1;
          return { width: n2 * r2, height: n2 * a2, ratioX: r2, ratioY: a2 };
        }, getPolygon: function(t3, e3, i3, o2, n2) {
          let r2 = [t3, e3], a2 = t3 - i3 / 2, l2 = t3 + i3 / 2, s2 = e3 - o2 / 2, h2 = e3 + o2 / 2;
          return [[a2, s2], [l2, s2], [l2, h2], [a2, h2]].map(function(t4) {
            return g(t4, r2, -n2);
          });
        }, getRandomPosition: function(t3) {
          return Math.round(t3 * (Math.random() + 0.5) / 2);
        }, getRotation: function(t3, e3, i3, o2) {
          let n2 = false, a2;
          return r(t3) && r(e3) && r(i3) && r(o2) && t3 > 0 && e3 > -1 && o2 > i3 && (a2 = (o2 - i3) / (t3 - 1 || 1), n2 = i3 + e3 % t3 * a2), n2;
        }, getScale: function(t3, e3, i3) {
          let o2 = 2 * Math.max(Math.abs(i3.top), Math.abs(i3.bottom)), n2 = 2 * Math.max(Math.abs(i3.left), Math.abs(i3.right));
          return Math.min(n2 > 0 ? 1 / n2 * t3 : 1, o2 > 0 ? 1 / o2 * e3 : 1);
        }, getSpiral: function(t3, e3) {
          let i3 = [];
          for (let o2 = 1; o2 < 1e4; o2++) i3.push(t3(o2, e3));
          return (t4) => t4 <= 1e4 && i3[t4 - 1];
        }, intersectionTesting: function(t3, e3) {
          let i3 = e3.placed, r2 = e3.field, l2 = e3.rectangle, h2 = e3.polygon, d2 = e3.spiral, c2 = t3.rect = o({}, l2), p2 = 1, m2 = { x: 0, y: 0 };
          for (t3.polygon = h2, t3.rotation = e3.rotation; false !== m2 && (function(t4, e4) {
            let i4 = t4.rect, o2 = t4.polygon, r3 = t4.lastCollidedWith, a2 = function(e5) {
              let n2 = s(i4, e5.rect);
              return n2 && (t4.rotation % 90 || e5.rotation % 90) && (n2 = u(o2, e5.polygon)), n2;
            }, l3 = false;
            return !r3 || (l3 = a2(r3)) || delete t4.lastCollidedWith, l3 || (l3 = !!n(e4, function(e5) {
              let i5 = a2(e5);
              return i5 && (t4.lastCollidedWith = e5), i5;
            })), l3;
          }(t3, i3) || function(t4, e4) {
            let i4 = { left: -(e4.width / 2), right: e4.width / 2, top: -(e4.height / 2), bottom: e4.height / 2 };
            return !(i4.left < t4.left && i4.right > t4.right && i4.top < t4.top && i4.bottom > t4.bottom);
          }(c2, r2)); ) a(m2 = d2(p2)) && (c2.left = l2.left + m2.x, c2.right = l2.right + m2.x, c2.top = l2.top + m2.y, c2.bottom = l2.bottom + m2.y, t3.polygon = function(t4, e4, i4) {
            return i4.map(function(i5) {
              return [i5[0] + t4, i5[1] + e4];
            });
          }(m2.x, m2.y, h2)), p2++;
          return m2;
        }, isPolygonsColliding: u, isRectanglesIntersecting: s, rectangularSpiral: function(t3, e3) {
          let i3 = c(t3, e3), o2 = e3.field;
          return i3 && (i3.x *= o2.ratioX, i3.y *= o2.ratioY), i3;
        }, rotate2DToOrigin: m, rotate2DToPoint: g, squareSpiral: c, updateFieldBoundaries: function(t3, e3) {
          return (!r(t3.left) || t3.left > e3.left) && (t3.left = e3.left), (!r(t3.right) || t3.right < e3.right) && (t3.right = e3.right), (!r(t3.top) || t3.top > e3.top) && (t3.top = e3.top), (!r(t3.bottom) || t3.bottom < e3.bottom) && (t3.bottom = e3.bottom), t3;
        } };
      }), i(e, "Series/Wordcloud/WordcloudSeries.js", [e["Series/DrawPointUtilities.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"], e["Series/Wordcloud/WordcloudPoint.js"], e["Series/Wordcloud/WordcloudSeriesDefaults.js"], e["Series/Wordcloud/WordcloudUtils.js"]], function(t2, e2, i2, o, n, r, a) {
        let { noop: l } = e2, { column: s } = i2.seriesTypes, { extend: h, isArray: d, isNumber: u, isObject: c, merge: p } = o, { archimedeanSpiral: m, extendPlayingField: g, getBoundingBoxFromPolygon: f, getPlayingField: y, getPolygon: x, getRandomPosition: b, getRotation: w, getScale: M, getSpiral: S, intersectionTesting: W, isPolygonsColliding: A, rectangularSpiral: j, rotate2DToOrigin: C, rotate2DToPoint: F, squareSpiral: P, updateFieldBoundaries: v } = a;
        class T extends s {
          pointAttribs(t3, i3) {
            let o2 = e2.seriesTypes.column.prototype.pointAttribs.call(this, t3, i3);
            return delete o2.stroke, delete o2["stroke-width"], o2;
          }
          deriveFontSize(t3, e3, i3) {
            let o2 = u(t3) ? t3 : 0, n2 = u(e3) ? e3 : 1;
            return Math.floor(Math.max(u(i3) ? i3 : 1, o2 * n2));
          }
          drawPoints() {
            let e3 = this.hasRendered, i3 = this.xAxis, o2 = this.yAxis, n2 = this.chart, r2 = this.group, a2 = this.options, l2 = a2.animation, s2 = a2.allowExtendPlayingField, d2 = n2.renderer, p2 = [], m2 = this.placementStrategy[a2.placementStrategy], b2 = a2.rotation, w2 = this.points.map(function(t3) {
              return t3.weight;
            }), A2 = Math.max.apply(null, w2), j2 = this.points.concat().sort((t3, e4) => e4.weight - t3.weight), C2 = d2.text().add(r2), F2;
            for (let t3 of (this.group.attr({ scaleX: 1, scaleY: 1 }), j2)) {
              let e4 = 1 / A2 * t3.weight, i4 = h({ fontSize: this.deriveFontSize(e4, a2.maxFontSize, a2.minFontSize) + "px" }, a2.style);
              C2.css(i4).attr({ x: 0, y: 0, text: t3.name });
              let o3 = C2.getBBox(true);
              t3.dimensions = { height: o3.height, width: o3.width };
            }
            F2 = y(i3.len, o2.len, j2);
            let P2 = S(this.spirals[a2.spiral], { field: F2 });
            for (let i4 of j2) {
              let o3 = 1 / A2 * i4.weight, n3 = h({ fontSize: this.deriveFontSize(o3, a2.maxFontSize, a2.minFontSize) + "px" }, a2.style), y2 = m2(i4, { data: j2, field: F2, placed: p2, rotation: b2 }), w3 = h(this.pointAttribs(i4, i4.selected && "select"), { align: "center", "alignment-baseline": "middle", "dominant-baseline": "middle", x: y2.x, y: y2.y, text: i4.name, rotation: u(y2.rotation) ? y2.rotation : void 0 }), M2 = x(y2.x, y2.y, i4.dimensions.width, i4.dimensions.height, y2.rotation), S2 = f(M2), C3 = W(i4, { rectangle: S2, polygon: M2, field: F2, placed: p2, spiral: P2, rotation: y2.rotation }), T3;
              !C3 && s2 && (F2 = g(F2, S2), C3 = W(i4, { rectangle: S2, polygon: M2, field: F2, placed: p2, spiral: P2, rotation: y2.rotation })), c(C3) ? (w3.x = (w3.x || 0) + C3.x, w3.y = (w3.y || 0) + C3.y, S2.left += C3.x, S2.right += C3.x, S2.top += C3.y, S2.bottom += C3.y, F2 = v(F2, S2), p2.push(i4), i4.isNull = false, i4.isInside = true) : i4.isNull = true, l2 && (T3 = { x: w3.x, y: w3.y }, e3 ? (delete w3.x, delete w3.y) : (w3.x = 0, w3.y = 0)), t2.draw(i4, { animatableAttribs: T3, attribs: w3, css: n3, group: r2, renderer: d2, shapeArgs: void 0, shapeType: "text" });
            }
            C2 = C2.destroy();
            let T2 = M(i3.len, o2.len, F2);
            this.group.attr({ scaleX: T2, scaleY: T2 });
          }
          hasData() {
            return c(this) && true === this.visible && d(this.points) && this.points.length > 0;
          }
          getPlotBox() {
            let t3 = this.chart, e3 = t3.inverted, i3 = this[e3 ? "yAxis" : "xAxis"], o2 = this[e3 ? "xAxis" : "yAxis"], n2 = i3 ? i3.len : t3.plotWidth, r2 = o2 ? o2.len : t3.plotHeight;
            return { translateX: (i3 ? i3.left : t3.plotLeft) + n2 / 2, translateY: (o2 ? o2.top : t3.plotTop) + r2 / 2, scaleX: 1, scaleY: 1 };
          }
        }
        return T.defaultOptions = p(s.defaultOptions, r), h(T.prototype, { animate: l, animateDrilldown: l, animateDrillupFrom: l, isCartesian: false, pointClass: n, setClip: l, placementStrategy: { random: function(t3, e3) {
          let i3 = e3.field, o2 = e3.rotation;
          return { x: b(i3.width) - i3.width / 2, y: b(i3.height) - i3.height / 2, rotation: w(o2.orientations, t3.index, o2.from, o2.to) };
        }, center: function(t3, e3) {
          let i3 = e3.rotation;
          return { x: 0, y: 0, rotation: w(i3.orientations, t3.index, i3.from, i3.to) };
        } }, pointArrayMap: ["weight"], spirals: { archimedean: m, rectangular: j, square: P }, utils: { extendPlayingField: g, getRotation: w, isPolygonsColliding: A, rotate2DToOrigin: C, rotate2DToPoint: F } }), i2.registerSeriesType("wordcloud", T), T;
      }), i(e, "masters/modules/wordcloud.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_wordcloud();
//# sourceMappingURL=highcharts_modules_wordcloud__js.js.map
