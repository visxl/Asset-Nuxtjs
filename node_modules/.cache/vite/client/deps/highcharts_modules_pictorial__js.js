import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/pictorial.js
var require_pictorial = __commonJS({
  "node_modules/highcharts/modules/pictorial.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Pictorial graph series type for Highcharts
    *
    * (c) 2010-2024 Torstein Honsi, Magdalena Gut
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/pictorial", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, r, s) {
        e2.hasOwnProperty(i2) || (e2[i2] = s.apply(null, r), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Extensions/PatternFill.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { animObject: r } = t2, { getOptions: s } = e2, { addEvent: a, defined: o, erase: n, extend: h, merge: l, pick: d, removeEvent: p, wrap: c } = i2, f = function() {
          let t3 = [], e3 = s().colors, i3 = 0;
          for (let r2 of ["M 0 0 L 5 5 M 4.5 -0.5 L 5.5 0.5 M -0.5 4.5 L 0.5 5.5", "M 0 5 L 5 0 M -0.5 0.5 L 0.5 -0.5 M 4.5 5.5 L 5.5 4.5", "M 2 0 L 2 5 M 4 0 L 4 5", "M 0 2 L 5 2 M 0 4 L 5 4", "M 0 1.5 L 2.5 1.5 L 2.5 0 M 2.5 5 L 2.5 3.5 L 5 3.5"]) t3.push({ path: r2, color: e3[i3++], width: 5, height: 5, patternTransform: "scale(1.4 1.4)" });
          for (let r2 of (i3 = 5, ["M 0 0 L 5 10 L 10 0", "M 3 3 L 8 3 L 8 8 L 3 8 Z", "M 5 5 m -4 0 a 4 4 0 1 1 8 0 a 4 4 0 1 1 -8 0", "M 0 0 L 10 10 M 9 -1 L 11 1 M -1 9 L 1 11", "M 0 10 L 10 0 M -1 1 L 1 -1 M 9 11 L 11 9"])) t3.push({ path: r2, color: e3[i3], width: 10, height: 10 }), i3 += 5;
          return t3;
        }();
        function u(t3, e3) {
          let i3 = JSON.stringify(t3), r2 = i3.length || 0, s2 = 0, a2 = 0, o2;
          if (e3) {
            o2 = Math.max(Math.floor(r2 / 500), 1);
            for (let t4 = 0; t4 < r2; t4 += o2) s2 += i3.charCodeAt(t4);
            s2 &= s2;
          }
          for (; a2 < r2; ++a2) s2 = (s2 << 5) - s2 + i3.charCodeAt(a2), s2 &= s2;
          return s2.toString(16).replace("-", "1");
        }
        function g() {
          if (this.renderer && (this.renderer.defIds || []).filter((t3) => t3 && t3.indexOf && 0 === t3.indexOf("highcharts-pattern-")).length) {
            for (let t3 of this.series) if (t3.visible) for (let e3 of t3.points) {
              let t4 = e3.options && e3.options.color;
              t4 && t4.pattern && (t4.pattern._width = "defer", t4.pattern._height = "defer");
            }
            this.redraw(false);
          }
        }
        function m() {
          let t3 = {}, e3 = this.renderer, i3 = (e3.defIds || []).filter((t4) => t4.indexOf && 0 === t4.indexOf("highcharts-pattern-"));
          if (i3.length) for (let r2 of ([].forEach.call(this.renderTo.querySelectorAll('[color^="url("], [fill^="url("], [stroke^="url("]'), (i4) => {
            let r3 = i4.getAttribute("fill") || i4.getAttribute("color") || i4.getAttribute("stroke");
            r3 && (t3[r3.replace(e3.url, "").replace("url(#", "").replace(")", "")] = true);
          }), i3)) !t3[r2] && (n(e3.defIds, r2), e3.patternElements[r2] && (e3.patternElements[r2].destroy(), delete e3.patternElements[r2]));
        }
        function x() {
          let t3 = this.options.color;
          t3 && t3.pattern && ("string" == typeof t3.pattern.path && (t3.pattern.path = { d: t3.pattern.path }), this.color = this.options.color = l(this.series.options.color, t3));
        }
        function w(t3) {
          let e3 = t3.args[0], i3 = t3.args[1], r2 = t3.args[2], s2 = this.chartIndex || 0, a2 = e3.pattern, o2 = "#333333";
          if (void 0 !== e3.patternIndex && f && (a2 = f[e3.patternIndex]), !a2) return true;
          if (a2.image || "string" == typeof a2.path || a2.path && a2.path.d) {
            let t4 = r2.parentNode && r2.parentNode.getAttribute("class");
            t4 = t4 && t4.indexOf("highcharts-legend") > -1, ("defer" === a2._width || "defer" === a2._height) && C.call({ graphic: { element: r2 } }, a2), (t4 || !a2.id) && ((a2 = l({}, a2)).id = "highcharts-pattern-" + s2 + "-" + u(a2) + u(a2, true)), this.addPattern(a2, !this.forExport && d(a2.animation, this.globalAnimation, { duration: 100 })), o2 = `url(${this.url}#${a2.id + (this.forExport ? "-export" : "")})`;
          } else o2 = a2.color || o2;
          return r2.setAttribute(i3, o2), e3.toString = function() {
            return o2;
          }, false;
        }
        function y() {
          let t3 = this.chart.isResizing;
          if (this.isDirtyData || t3 || !this.chart.hasRendered) for (let e3 of this.points) {
            let i3 = e3.options && e3.options.color;
            i3 && i3.pattern && (t3 && !(e3.shapeArgs && e3.shapeArgs.width && e3.shapeArgs.height) ? (i3.pattern._width = "defer", i3.pattern._height = "defer") : e3.calculatePatternDimensions(i3.pattern));
          }
        }
        function C(t3) {
          if (t3.width && t3.height) return;
          let e3 = this.graphic && (this.graphic.getBBox && this.graphic.getBBox(true) || this.graphic.element && this.graphic.element.getBBox()) || {}, i3 = this.shapeArgs;
          if (i3 && (e3.width = i3.width || e3.width, e3.height = i3.height || e3.height, e3.x = i3.x || e3.x, e3.y = i3.y || e3.y), t3.image) {
            if (!e3.width || !e3.height) {
              t3._width = "defer", t3._height = "defer";
              let e4 = this.series.chart.mapView && this.series.chart.mapView.getSVGTransform().scaleY;
              o(e4) && e4 < 0 && (t3._inverted = true);
              return;
            }
            t3.aspectRatio && (e3.aspectRatio = e3.width / e3.height, t3.aspectRatio > e3.aspectRatio ? e3.aspectWidth = e3.height * t3.aspectRatio : e3.aspectHeight = e3.width / t3.aspectRatio), t3._width = t3.width || Math.ceil(e3.aspectWidth || e3.width), t3._height = t3.height || Math.ceil(e3.aspectHeight || e3.height);
          }
          t3.width || (t3._x = t3.x || 0, t3._x += e3.x - Math.round(e3.aspectWidth ? Math.abs(e3.aspectWidth - e3.width) / 2 : 0)), t3.height || (t3._y = t3.y || 0, t3._y += e3.y - Math.round(e3.aspectHeight ? Math.abs(e3.aspectHeight - e3.height) / 2 : 0));
        }
        function A(t3, e3) {
          let s2 = d(e3, true), a2 = r(s2), o2 = t3.color || "#333333", n2 = t3.height || ("number" == typeof t3._height ? t3._height : 0) || 32, h2 = t3.width || ("number" == typeof t3._width ? t3._width : 0) || 32, l2, c2 = t3.id, f2;
          if (!c2 && (this.idCounter = this.idCounter || 0, c2 = "highcharts-pattern-" + this.idCounter + "-" + (this.chartIndex || 0), ++this.idCounter), this.forExport && (c2 += "-export"), this.defIds = this.defIds || [], this.defIds.indexOf(c2) > -1) return;
          this.defIds.push(c2);
          let u2 = { id: c2, patternUnits: "userSpaceOnUse", patternContentUnits: t3.patternContentUnits || "userSpaceOnUse", width: h2, height: n2, x: t3._x || t3.x || 0, y: t3._y || t3.y || 0 };
          t3._inverted && (u2.patternTransform = "scale(1, -1)", t3.patternTransform && (t3.patternTransform += " scale(1, -1)")), t3.patternTransform && (u2.patternTransform = t3.patternTransform);
          let g2 = this.createElement("pattern").attr(u2).add(this.defs);
          if (g2.id = c2, t3.path) {
            if (f2 = i2.isObject(t3.path) ? t3.path : { d: t3.path }, t3.backgroundColor) {
              let e4;
              e4 = t3.backgroundColor, this.rect(0, 0, h2, n2).attr({ fill: e4 }).add(g2);
            }
            l2 = { d: f2.d }, this.styledMode || (l2.stroke = f2.stroke || o2, l2["stroke-width"] = d(f2.strokeWidth, 2), l2.fill = f2.fill || "none"), f2.transform && (l2.transform = f2.transform), this.createElement("path").attr(l2).add(g2), g2.color = o2;
          } else t3.image && (s2 ? this.image(t3.image, 0, 0, h2, n2, function() {
            this.animate({ opacity: d(t3.opacity, 1) }, a2), p(this.element, "load");
          }).attr({ opacity: 0 }).add(g2) : this.image(t3.image, 0, 0, h2, n2).add(g2));
          return t3.image && s2 || void 0 === t3.opacity || [].forEach.call(g2.element.childNodes, (e4) => {
            e4.setAttribute("opacity", t3.opacity);
          }), this.patternElements = this.patternElements || {}, this.patternElements[c2] = g2, g2;
        }
        function b(t3) {
          let e3 = this.options.color;
          e3 && e3.pattern && !e3.pattern.color ? (delete this.options.color, t3.apply(this, [].slice.call(arguments, 1)), e3.pattern.color = this.color, this.color = this.options.color = e3) : t3.apply(this, [].slice.call(arguments, 1));
        }
        function M() {
          var _a, _b;
          if (!((_a = this.chart) == null ? void 0 : _a.mapView)) return;
          let t3 = this.chart.renderer, e3 = t3.patternElements;
          ((_b = t3.defIds) == null ? void 0 : _b.length) && e3 && this.points.filter(function(t4) {
            var _a2, _b2, _c, _d;
            return !!t4.graphic && (t4.graphic.element.hasAttribute("fill") || t4.graphic.element.hasAttribute("color") || t4.graphic.element.hasAttribute("stroke")) && !((_b2 = (_a2 = t4.options.color) == null ? void 0 : _a2.pattern) == null ? void 0 : _b2.image) && !!((_c = t4.group) == null ? void 0 : _c.scaleX) && !!((_d = t4.group) == null ? void 0 : _d.scaleY);
          }).map(function(e4) {
            var _a2, _b2, _c, _d, _e;
            return { id: (((_a2 = e4.graphic) == null ? void 0 : _a2.element.getAttribute("fill")) || ((_b2 = e4.graphic) == null ? void 0 : _b2.element.getAttribute("color")) || ((_c = e4.graphic) == null ? void 0 : _c.element.getAttribute("stroke")) || "").replace(t3.url, "").replace("url(#", "").replace(")", ""), x: ((_d = e4.group) == null ? void 0 : _d.scaleX) || 1, y: ((_e = e4.group) == null ? void 0 : _e.scaleY) || 1 };
          }).filter(function(t4, e4, i3) {
            return "" !== t4.id && -1 !== t4.id.indexOf("highcharts-pattern-") && !i3.some(function(i4, r2) {
              return i4.id === t4.id && r2 < e4;
            });
          }).forEach(function(t4) {
            let i3 = t4.id;
            e3[i3].scaleX = 1 / t4.x, e3[i3].scaleY = 1 / t4.y, e3[i3].updateTransform("patternTransform");
          });
        }
        return { compose: function(t3, e3, i3) {
          let r2 = e3.prototype.pointClass, s2 = r2.prototype;
          s2.calculatePatternDimensions || (a(t3, "endResize", g), a(t3, "redraw", m), h(s2, { calculatePatternDimensions: C }), a(r2, "afterInit", x), a(e3, "render", y), c(e3.prototype, "getColor", b), a(e3, "afterRender", M), a(e3, "mapZoomComplete", M), h(i3.prototype, { addPattern: A }), a(i3, "complexColor", w));
        }, patterns: f };
      }), i(e, "Series/Pictorial/PictorialUtilities.js", [e["Core/Utilities.js"]], function(t2) {
        let { defined: e2 } = t2;
        return { rescalePatternFill: function(t3, e3, i2, r, s = 1) {
          let a = t3 && t3.attr("fill"), o = a && a.match(/url\(([^)]+)\)/);
          if (o) {
            let a2 = document.querySelector(`${o[1]} path`);
            if (a2) {
              let o2 = a2.getBBox();
              if (0 === o2.width) {
                let e4 = a2.parentElement;
                t3.renderer.box.appendChild(a2), o2 = a2.getBBox(), e4.appendChild(a2);
              }
              let n = 1 / (o2.width + s), h = e3 / r / o2.height, l = o2.width / o2.height, d = i2 / e3, p = -o2.width / 2;
              l < d && (n = n * l / d), a2.setAttribute("stroke-width", s / (i2 * n)), a2.setAttribute("transform", `translate(0.5, 0)scale(${n} ${h}) translate(${p + s * n / 2}, ${-o2.y})`);
            }
          }
        }, invertShadowGroup: function(t3, e3) {
          let i2 = e3.chart.inverted;
          i2 && t3.attr({ rotation: i2 ? 90 : 0, scaleX: i2 ? -1 : 1 });
        }, getStackMetrics: function(t3, i2) {
          let r = t3.len, s = 0;
          return i2 && e2(i2.max) && (s = t3.toPixels(i2.max, true), r = t3.len - s), { height: r, y: s };
        } };
      }), i(e, "Series/Pictorial/PictorialPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Series/Pictorial/PictorialUtilities.js"]], function(t2, e2) {
        let i2 = t2.seriesTypes.column.prototype.pointClass, { rescalePatternFill: r, getStackMetrics: s } = e2;
        return class extends i2 {
          setState() {
            super.setState.apply(this, arguments);
            let t3 = this.series, e3 = t3.options.paths;
            if (this.graphic && this.shapeArgs && e3) {
              let i3 = e3[this.index % e3.length];
              r(this.graphic, s(t3.yAxis, i3).height, this.shapeArgs.width || 0, this.shapeArgs.height || 1 / 0, this.series.options.borderWidth || 0);
            }
          }
        };
      }), i(e, "Series/Pictorial/PictorialSeries.js", [e["Extensions/PatternFill.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Chart/Chart.js"], e["Series/Pictorial/PictorialPoint.js"], e["Series/Pictorial/PictorialUtilities.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Utilities.js"]], function(t2, e2, i2, r, s, a, o, n, h, l) {
        let d = o.seriesTypes.column;
        t2.compose(i2, a, h);
        let { animObject: p } = e2, { getStackMetrics: c, invertShadowGroup: f, rescalePatternFill: u } = s, { addEvent: g, defined: m, merge: x, objectEach: w, pick: y } = l;
        class C extends d {
          animate(t3) {
            let { chart: e3, group: i3 } = this, r2 = p(this.options.animation), s2 = [this.getSharedClipKey(), r2.duration, r2.easing, r2.defer].join(","), a2 = e3.sharedClips[s2];
            if (t3 && i3) {
              let t4 = this.getClipBox();
              a2 || (t4.y = t4.height, t4.height = 0, a2 = e3.renderer.clipRect(t4), e3.sharedClips[s2] = a2), i3.clip(a2);
            } else if (a2 && !a2.hasClass("highcharts-animating")) {
              let t4 = this.getClipBox();
              a2.addClass("highcharts-animating").animate(t4, r2);
            }
          }
          animateDrilldown() {
          }
          animateDrillupFrom() {
          }
          pointAttribs(t3) {
            let e3 = super.pointAttribs.apply(this, arguments), i3 = this.options.paths;
            if (t3 && t3.shapeArgs && i3) {
              let r2 = i3[t3.index % i3.length], { y: s2, height: a2 } = c(this.yAxis, r2), o2 = r2.definition;
              o2 !== t3.pathDef ? (t3.pathDef = o2, e3.fill = { pattern: { path: { d: o2, fill: e3.fill, strokeWidth: e3["stroke-width"], stroke: e3.stroke }, x: t3.shapeArgs.x, y: s2, width: t3.shapeArgs.width || 0, height: a2, patternContentUnits: "objectBoundingBox", backgroundColor: "none", color: "#ff0000" } }) : t3.pathDef && t3.graphic && delete e3.fill;
            }
            return delete e3.stroke, delete e3.strokeWidth, e3;
          }
          getExtremes() {
            let t3 = super.getExtremes.apply(this, arguments), e3 = this.options.paths;
            return e3 && e3.forEach(function(e4) {
              m(e4.max) && m(t3.dataMax) && e4.max > t3.dataMax && (t3.dataMax = e4.max);
            }), t3;
          }
        }
        function A(t3) {
          let e3 = Object.keys(t3.points).filter((t4) => t4.split(",").length > 1), i3 = t3.axis.chart.series, r2 = e3.map((t4) => parseFloat(t4.split(",")[0])), s2 = -1;
          r2.forEach((t4) => {
            i3[t4] && i3[t4].visible && (s2 = t4);
          });
          let a2 = t3.axis.chart.series[s2];
          if (a2 && a2.is("pictorial") && t3.axis.hasData() && a2.xAxis.hasData()) {
            let e4 = a2.xAxis, i4 = t3.axis.options, r3 = t3.axis.chart, s3 = t3.shadow, o2 = e4.toPixels(t3.x, true), n2 = r3.inverted ? e4.len - o2 : o2, h2 = a2.options.paths || [], l2 = t3.x % h2.length, d2 = h2[l2], p2 = a2.getColumnMetrics && a2.getColumnMetrics().width, { height: g2, y: m2 } = c(a2.yAxis, d2), x2 = i4.stackShadow, w2 = y(x2 && x2.borderWidth, a2.options.borderWidth, 1);
            if (!s3 && x2 && x2.enabled && d2) t3.shadowGroup || (t3.shadowGroup = r3.renderer.g("shadow-group").add()), t3.shadowGroup.attr({ translateX: r3.inverted ? t3.axis.pos : e4.pos, translateY: r3.inverted ? e4.pos : t3.axis.pos }), t3.shadow = r3.renderer.rect(n2, m2, p2, g2).attr({ fill: { pattern: { path: { d: d2.definition, fill: x2.color || "#dedede", strokeWidth: w2, stroke: x2.borderColor || "transparent" }, x: n2, y: m2, width: p2, height: g2, patternContentUnits: "objectBoundingBox", backgroundColor: "none", color: "#dedede" } } }).add(t3.shadowGroup), f(t3.shadowGroup, t3.axis), u(t3.shadow, g2, p2, g2, w2), t3.setOffset(a2.pointXOffset || 0, a2.barW || 0);
            else if (s3 && t3.shadowGroup) {
              s3.animate({ x: n2, y: m2, width: p2, height: g2 });
              let i5 = s3.attr("fill"), o3 = i5 && i5.match(/url\(([^)]+)\)/);
              o3 && r3.renderer.patternElements && r3.renderer.patternElements[o3[1].slice(1)].animate({ x: n2, y: m2, width: p2, height: g2 }), t3.shadowGroup.animate({ translateX: r3.inverted ? t3.axis.pos : e4.pos, translateY: r3.inverted ? e4.pos : t3.axis.pos }), f(t3.shadowGroup, t3.axis), u(s3, g2, p2, g2, w2), t3.setOffset(a2.pointXOffset || 0, a2.barW || 0);
            }
          } else t3.shadow && t3.shadowGroup && (t3.shadow.destroy(), t3.shadow = void 0, t3.shadowGroup.destroy(), t3.shadowGroup = void 0);
        }
        function b(t3, e3) {
          t3.axes && t3.axes.forEach(function(t4) {
            t4.stacking && w(t4.stacking.stacks, function(t5) {
              w(t5, function(t6) {
                e3(t6);
              });
            });
          });
        }
        function M(t3) {
          b(t3, function(t4) {
            t4.shadow && t4.shadowGroup && (t4.shadow.destroy(), t4.shadowGroup.destroy(), delete t4.shadow, delete t4.shadowGroup);
          });
        }
        return C.defaultOptions = x(d.defaultOptions, { borderWidth: 0 }), g(C, "afterRender", function() {
          let t3 = this, e3 = t3.options.paths, i3 = /url\(([^)]+)\)/;
          t3.points.forEach(function(r2) {
            if (r2.graphic && r2.shapeArgs && e3) {
              let s2 = e3[r2.index % e3.length], a2 = r2.graphic.attr("fill"), o2 = a2 && a2.match(i3), { y: n2, height: h2 } = c(t3.yAxis, s2);
              if (o2 && t3.chart.renderer.patternElements) {
                let e4 = t3.chart.renderer.patternElements[o2[1].slice(1)];
                e4 && e4.animate({ x: r2.shapeArgs.x, y: n2, width: r2.shapeArgs.width || 0, height: h2 });
              }
              u(r2.graphic, c(t3.yAxis, s2).height, r2.shapeArgs.width || 0, r2.shapeArgs.height || 1 / 0, t3.options.borderWidth || 0);
            }
          });
        }), g(i2, "render", function() {
          b(this, A);
        }), g(n, "afterSetOffset", function(t3) {
          if (this.shadow) {
            let { chart: e3, len: i3 } = this.axis, { xOffset: r2, width: s2 } = t3, a2 = e3.inverted ? r2 - e3.xAxis[0].len : r2, o2 = e3.inverted ? -i3 : 0;
            this.shadow.attr({ translateX: a2, translateY: o2 }), this.shadow.animate({ width: s2 });
          }
        }), g(i2, "afterDrilldown", function() {
          M(this);
        }), g(i2, "afterDrillUp", function() {
          M(this);
        }), C.prototype.pointClass = r, o.registerSeriesType("pictorial", C), C;
      }), i(e, "masters/modules/pictorial.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_pictorial();
//# sourceMappingURL=highcharts_modules_pictorial__js.js.map
