import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/treegraph.js
var require_treegraph = __commonJS({
  "node_modules/highcharts/modules/treegraph.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    * Treegraph chart series type
    *
    *  (c) 2010-2024 Pawel Lysy Grzegorz Blachlinski
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/treegraph", ["highcharts", "highcharts/modules/treemap"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function i(t2, i2, s, o) {
        t2.hasOwnProperty(i2) || (t2[i2] = o.apply(null, s), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: t2[i2] } })));
      }
      i(t, "Series/PathUtilities.js", [], function() {
        function e2(e3, t2) {
          let i2 = [];
          for (let s = 0; s < e3.length; s++) {
            let o = e3[s][1], r = e3[s][2];
            if ("number" == typeof o && "number" == typeof r) {
              if (0 === s) i2.push(["M", o, r]);
              else if (s === e3.length - 1) i2.push(["L", o, r]);
              else if (t2) {
                let l = e3[s - 1], n = e3[s + 1];
                if (l && n) {
                  let e4 = l[1], s2 = l[2], a = n[1], h = n[2];
                  if ("number" == typeof e4 && "number" == typeof a && "number" == typeof s2 && "number" == typeof h && e4 !== a && s2 !== h) {
                    let l2 = e4 < a ? 1 : -1, n2 = s2 < h ? 1 : -1;
                    i2.push(["L", o - l2 * Math.min(Math.abs(o - e4), t2), r - n2 * Math.min(Math.abs(r - s2), t2)], ["C", o, r, o, r, o + l2 * Math.min(Math.abs(o - a), t2), r + n2 * Math.min(Math.abs(r - h), t2)]);
                  }
                }
              } else i2.push(["L", o, r]);
            }
          }
          return i2;
        }
        return { applyRadius: e2, getLinkPath: { default: function(t2) {
          let { x1: i2, y1: s, x2: o, y2: r, width: l = 0, inverted: n = false, radius: a, parentVisible: h } = t2, d = [["M", i2, s], ["L", i2, s], ["C", i2, s, i2, r, i2, r], ["L", i2, r], ["C", i2, s, i2, r, i2, r], ["L", i2, r]];
          return h ? e2([["M", i2, s], ["L", i2 + l * (n ? -0.5 : 0.5), s], ["L", i2 + l * (n ? -0.5 : 0.5), r], ["L", o, r]], a) : d;
        }, straight: function(e3) {
          let { x1: t2, y1: i2, x2: s, y2: o, width: r = 0, inverted: l = false, parentVisible: n } = e3;
          return n ? [["M", t2, i2], ["L", t2 + r * (l ? -1 : 1), o], ["L", s, o]] : [["M", t2, i2], ["L", t2, o], ["L", t2, o]];
        }, curved: function(e3) {
          let { x1: t2, y1: i2, x2: s, y2: o, offset: r = 0, width: l = 0, inverted: n = false, parentVisible: a } = e3;
          return a ? [["M", t2, i2], ["C", t2 + r, i2, t2 - r + l * (n ? -1 : 1), o, t2 + l * (n ? -1 : 1), o], ["L", s, o]] : [["M", t2, i2], ["C", t2, i2, t2, o, t2, o], ["L", s, o]];
        } } };
      }), i(t, "Series/Treegraph/TreegraphNode.js", [t["Core/Series/SeriesRegistry.js"]], function(e2) {
        let { seriesTypes: { treemap: { prototype: { NodeClass: t2 } } } } = e2;
        return class extends t2 {
          constructor() {
            super(...arguments), this.mod = 0, this.shift = 0, this.change = 0, this.children = [], this.preX = 0, this.hidden = false, this.wasVisited = false, this.collapsed = false;
          }
          nextLeft() {
            return this.getLeftMostChild() || this.thread;
          }
          nextRight() {
            return this.getRightMostChild() || this.thread;
          }
          getAncestor(e3, t3) {
            return e3.ancestor.children[0] === this.children[0] ? e3.ancestor : t3;
          }
          getLeftMostSibling() {
            let e3 = this.getParent();
            if (e3) {
              for (let t3 of e3.children) if (t3 && t3.point.visible) return t3;
            }
          }
          hasChildren() {
            let e3 = this.children;
            for (let t3 = 0; t3 < e3.length; t3++) if (e3[t3].point.visible) return true;
            return false;
          }
          getLeftSibling() {
            let e3 = this.getParent();
            if (e3) {
              let t3 = e3.children;
              for (let e4 = this.relativeXPosition - 1; e4 >= 0; e4--) if (t3[e4] && t3[e4].point.visible) return t3[e4];
            }
          }
          getLeftMostChild() {
            let e3 = this.children;
            for (let t3 = 0; t3 < e3.length; t3++) if (e3[t3].point.visible) return e3[t3];
          }
          getRightMostChild() {
            let e3 = this.children;
            for (let t3 = e3.length - 1; t3 >= 0; t3--) if (e3[t3].point.visible) return e3[t3];
          }
          getParent() {
            return this.parentNode;
          }
          getFirstChild() {
            let e3 = this.children;
            for (let t3 = 0; t3 < e3.length; t3++) if (e3[t3].point.visible) return e3[t3];
          }
        };
      }), i(t, "Series/Treegraph/TreegraphPoint.js", [t["Core/Series/Point.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        let { seriesTypes: { treemap: { prototype: { pointClass: s } } } } = t2, { addEvent: o, fireEvent: r, merge: l } = i2;
        class n extends s {
          constructor() {
            super(...arguments), this.dataLabelOnHidden = true, this.isLink = false, this.setState = e2.prototype.setState;
          }
          draw() {
            super.draw.apply(this, arguments);
            let e3 = this.graphic;
            e3 && e3.animate({ visibility: this.visible ? "inherit" : "hidden" }), this.renderCollapseButton();
          }
          renderCollapseButton() {
            let e3 = this.series, t3 = this.graphic && this.graphic.parentGroup, i3 = e3.mapOptionsToLevel[this.node.level || 0] || {}, s2 = l(e3.options.collapseButton, i3.collapseButton, this.options.collapseButton), { width: o2, height: r2, shape: n2, style: a } = s2, h = this.series.chart, d = this.visible && (this.collapsed || !s2.onlyOnHover || "hover" === this.state) ? 1 : 0;
            if (this.shapeArgs) {
              if (this.collapseButtonOptions = s2, this.collapseButton) {
                if (this.node.children.length && s2.enabled) {
                  let { x: e4, y: t4 } = this.getCollapseBtnPosition(s2);
                  this.collapseButton.attr({ text: this.collapsed ? "+" : "-", rotation: h.inverted ? 90 : 0, rotationOriginX: o2 / 2, rotationOriginY: r2 / 2, visibility: this.visible ? "inherit" : "hidden" }).animate({ x: e4, y: t4, opacity: d });
                } else this.collapseButton.destroy(), delete this.collapseButton;
              } else {
                if (!this.node.children.length || !s2.enabled) return;
                let { x: e4, y: i4 } = this.getCollapseBtnPosition(s2), p = s2.fillColor || this.color || "#cccccc";
                this.collapseButton = h.renderer.label(this.collapsed ? "+" : "-", e4, i4, n2).attr({ height: r2 - 4, width: o2 - 4, padding: 2, fill: p, rotation: h.inverted ? 90 : 0, rotationOriginX: o2 / 2, rotationOriginY: r2 / 2, stroke: s2.lineColor || "#ffffff", "stroke-width": s2.lineWidth, "text-align": "center", align: "center", zIndex: 1, opacity: d, visibility: this.visible ? "inherit" : "hidden" }).addClass("highcharts-tracker").addClass("highcharts-collapse-button").removeClass("highcharts-no-tooltip").css(l({ color: "string" == typeof p ? h.renderer.getContrast(p) : "#333333" }, a)).add(t3), this.collapseButton.element.point = this;
              }
            }
          }
          toggleCollapse(e3) {
            let t3 = this.series;
            this.update({ collapsed: e3 ?? !this.collapsed }, false, void 0, false), r(t3, "toggleCollapse"), t3.redraw();
          }
          destroy() {
            this.collapseButton && (this.collapseButton.destroy(), delete this.collapseButton, this.collapseButton = void 0), this.linkToParent && (this.linkToParent.destroy(), delete this.linkToParent), super.destroy.apply(this, arguments);
          }
          getCollapseBtnPosition(e3) {
            let t3 = this.series.chart.inverted, i3 = e3.width, s2 = e3.height, { x: o2 = 0, y: r2 = 0, width: l2 = 0, height: n2 = 0 } = this.shapeArgs || {};
            return { x: o2 + e3.x + (t3 ? -(0.3 * s2) : l2 + -0.3 * i3), y: r2 + n2 / 2 - s2 / 2 + e3.y };
          }
        }
        return o(n, "mouseOut", function() {
          let e3 = this.collapseButton, t3 = this.collapseButtonOptions;
          e3 && (t3 == null ? void 0 : t3.onlyOnHover) && !this.collapsed && e3.animate({ opacity: 0 });
        }), o(n, "mouseOver", function() {
          var _a, _b;
          this.collapseButton && this.visible && this.collapseButton.animate({ opacity: 1 }, (_b = (_a = this.series.options.states) == null ? void 0 : _a.hover) == null ? void 0 : _b.animation);
        }), o(n, "click", function() {
          this.toggleCollapse();
        }), n;
      }), i(t, "Series/Treegraph/TreegraphLink.js", [t["Core/Series/Point.js"], t["Core/Utilities.js"], t["Core/Series/SeriesRegistry.js"]], function(e2, t2, i2) {
        let { pick: s, extend: o } = t2, { seriesTypes: { column: { prototype: { pointClass: r } } } } = i2;
        return class extends r {
          constructor(e3, t3, i3, s2) {
            super(e3, t3, i3), this.dataLabelOnNull = true, this.formatPrefix = "link", this.isLink = true, this.node = {}, this.formatPrefix = "link", this.dataLabelOnNull = true, s2 && (this.fromNode = s2.node.parentNode.point, this.visible = s2.visible, this.toNode = s2, this.id = this.toNode.id + "-" + this.fromNode.id);
          }
          update(t3, i3, r2, l) {
            let n = { id: this.id, formatPrefix: this.formatPrefix };
            e2.prototype.update.call(this, t3, !this.isLink && i3, r2, l), this.visible = this.toNode.visible, o(this, n), s(i3, true) && this.series.chart.redraw(r2);
          }
        };
      }), i(t, "Series/Treegraph/TreegraphLayout.js", [t["Series/Treegraph/TreegraphNode.js"]], function(e2) {
        class t2 {
          static createDummyNode(t3, i2, s) {
            let o = new e2();
            return o.id = t3.id + "-" + s, o.ancestor = t3, o.children.push(i2), o.parent = t3.id, o.parentNode = t3, o.point = i2.point, o.level = i2.level - s, o.relativeXPosition = i2.relativeXPosition, o.visible = i2.visible, t3.children[i2.relativeXPosition] = o, i2.oldParentNode = t3, i2.relativeXPosition = 0, i2.parentNode = o, i2.parent = o.id, o;
          }
          calculatePositions(e3) {
            let t3 = e3.nodeList;
            this.resetValues(t3);
            let i2 = e3.tree;
            i2 && (this.calculateRelativeX(i2, 0), this.beforeLayout(t3), this.firstWalk(i2), this.secondWalk(i2, -i2.preX), this.afterLayout(t3));
          }
          beforeLayout(e3) {
            for (let i2 of e3) for (let e4 of i2.children) if (e4 && e4.level - i2.level > 1) {
              let s = e4.level - i2.level - 1;
              for (; s > 0; ) e4 = t2.createDummyNode(i2, e4, s), s--;
            }
          }
          resetValues(e3) {
            for (let t3 of e3) t3.mod = 0, t3.ancestor = t3, t3.shift = 0, t3.thread = void 0, t3.change = 0, t3.preX = 0;
          }
          calculateRelativeX(e3, t3) {
            let i2 = e3.children;
            for (let e4 = 0, t4 = i2.length; e4 < t4; ++e4) this.calculateRelativeX(i2[e4], e4);
            e3.relativeXPosition = t3;
          }
          firstWalk(e3) {
            let t3;
            if (e3.hasChildren()) {
              let i2 = e3.getLeftMostChild();
              for (let t4 of e3.children) this.firstWalk(t4), i2 = this.apportion(t4, i2);
              this.executeShifts(e3);
              let s = e3.getLeftMostChild(), o = e3.getRightMostChild(), r = (s.preX + o.preX) / 2;
              (t3 = e3.getLeftSibling()) ? (e3.preX = t3.preX + 1, e3.mod = e3.preX - r) : e3.preX = r;
            } else (t3 = e3.getLeftSibling()) ? (e3.preX = t3.preX + 1, e3.mod = e3.preX) : e3.preX = 0;
          }
          secondWalk(e3, t3) {
            for (let i2 of (e3.yPosition = e3.preX + t3, e3.xPosition = e3.level, e3.children)) this.secondWalk(i2, t3 + e3.mod);
          }
          executeShifts(e3) {
            let t3 = 0, i2 = 0;
            for (let s = e3.children.length - 1; s >= 0; s--) {
              let o = e3.children[s];
              o.preX += t3, o.mod += t3, i2 += o.change, t3 += o.shift + i2;
            }
          }
          apportion(e3, t3) {
            let i2 = e3.getLeftSibling();
            if (i2) {
              let s = e3, o = e3, r = i2, l = s.getLeftMostSibling(), n = s.mod, a = o.mod, h = r.mod, d = l.mod;
              for (; r && r.nextRight() && s && s.nextLeft(); ) {
                r = r.nextRight(), l = l.nextLeft(), s = s.nextLeft(), (o = o.nextRight()).ancestor = e3;
                let i3 = r.preX + h - (s.preX + n) + 1;
                i3 > 0 && (this.moveSubtree(e3.getAncestor(r, t3), e3, i3), n += i3, a += i3), h += r.mod, n += s.mod, d += l.mod, a += o.mod;
              }
              r && r.nextRight() && !o.nextRight() && (o.thread = r.nextRight(), o.mod += h - a), s && s.nextLeft() && !l.nextLeft() && (l.thread = s.nextLeft(), l.mod += n - d), t3 = e3;
            }
            return t3;
          }
          moveSubtree(e3, t3, i2) {
            let s = t3.relativeXPosition - e3.relativeXPosition;
            t3.change -= i2 / s, t3.shift += i2, t3.preX += i2, t3.mod += i2, e3.change += i2 / s;
          }
          afterLayout(e3) {
            for (let t3 of e3) t3.oldParentNode && (t3.relativeXPosition = t3.parentNode.relativeXPosition, t3.parent = t3.oldParentNode.parent, t3.parentNode = t3.oldParentNode, delete t3.oldParentNode.children[t3.relativeXPosition], t3.oldParentNode.children[t3.relativeXPosition] = t3, t3.oldParentNode = void 0);
          }
        }
        return t2;
      }), i(t, "Series/Treegraph/TreegraphSeriesDefaults.js", [], function() {
        return { reversed: false, marker: { radius: 10, lineWidth: 0, symbol: "circle", fillOpacity: 1, states: {} }, link: { color: "#666666", lineWidth: 1, radius: 10, cursor: "default", type: "curved" }, collapseButton: { onlyOnHover: true, enabled: true, lineWidth: 1, x: 0, y: 0, height: 18, width: 18, shape: "circle", style: { cursor: "pointer", fontWeight: "bold", fontSize: "1em" } }, fillSpace: false, tooltip: { linkFormat: "{point.fromNode.id} â†’ {point.toNode.id}", pointFormat: "{point.id}" }, dataLabels: { defer: true, linkTextPath: { attributes: { startOffset: "50%" } }, enabled: true, linkFormatter: () => "", style: { textOverflow: "none" } }, nodeDistance: 30, nodeWidth: void 0 };
      }), i(t, "Extensions/TextPath.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { deg2rad: i2 } = e2, { addEvent: s, merge: o, uniqueKey: r, defined: l, extend: n } = t2;
        function a(e3, t3) {
          t3 = o(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, t3);
          let i3 = this.renderer.url, a2 = this.text || this, h2 = a2.textPath, { attributes: d2, enabled: p } = t3;
          if (e3 = e3 || h2 && h2.path, h2 && h2.undo(), e3 && p) {
            let t4 = s(a2, "afterModifyTree", (t5) => {
              if (e3 && p) {
                let s2 = e3.attr("id");
                s2 || e3.attr("id", s2 = r());
                let o2 = { x: 0, y: 0 };
                l(d2.dx) && (o2.dx = d2.dx, delete d2.dx), l(d2.dy) && (o2.dy = d2.dy, delete d2.dy), a2.attr(o2), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy());
                let h3 = t5.nodes.slice(0);
                t5.nodes.length = 0, t5.nodes[0] = { tagName: "textPath", attributes: n(d2, { "text-anchor": d2.textAnchor, href: `${i3}#${s2}` }), children: h3 };
              }
            });
            a2.textPath = { path: e3, undo: t4 };
          } else a2.attr({ dx: 0, dy: 0 }), delete a2.textPath;
          return this.added && (a2.textCache = "", this.renderer.buildText(a2)), this;
        }
        function h(e3) {
          var _a;
          let t3 = e3.bBox, s2 = (_a = this.element) == null ? void 0 : _a.querySelector("textPath");
          if (s2) {
            let e4 = [], { b: o2, h: r2 } = this.renderer.fontMetrics(this.element), l2 = r2 - o2, n2 = RegExp('(<tspan>|<tspan(?!\\sclass="highcharts-br")[^>]*>|<\\/tspan>)', "g"), a2 = s2.innerHTML.replace(n2, "").split(/<tspan class="highcharts-br"[^>]*>/), h2 = a2.length, d2 = (e5, t4) => {
              let { x: r3, y: n3 } = t4, a3 = (s2.getRotationOfChar(e5) - 90) * i2, h3 = Math.cos(a3), d3 = Math.sin(a3);
              return [[r3 - l2 * h3, n3 - l2 * d3], [r3 + o2 * h3, n3 + o2 * d3]];
            };
            for (let t4 = 0, i3 = 0; i3 < h2; i3++) {
              let o3 = a2[i3].length;
              for (let r3 = 0; r3 < o3; r3 += 5) try {
                let o4 = t4 + r3 + i3, [l3, n3] = d2(o4, s2.getStartPositionOfChar(o4));
                0 === r3 ? (e4.push(n3), e4.push(l3)) : (0 === i3 && e4.unshift(n3), i3 === h2 - 1 && e4.push(l3));
              } catch (e5) {
                break;
              }
              t4 += o3 - 1;
              try {
                let o4 = t4 + i3, r3 = s2.getEndPositionOfChar(o4), [l3, n3] = d2(o4, r3);
                e4.unshift(n3), e4.unshift(l3);
              } catch (e5) {
                break;
              }
            }
            e4.length && e4.push(e4[0].slice()), t3.polygon = e4;
          }
          return t3;
        }
        function d(e3) {
          var _a;
          let t3 = e3.labelOptions, i3 = e3.point, s2 = t3[i3.formatPrefix + "TextPath"] || t3.textPath;
          s2 && !t3.useHTML && (this.setTextPath(((_a = i3.getDataLabelPath) == null ? void 0 : _a.call(i3, this)) || i3.graphic, s2), i3.dataLabelPath && !s2.enabled && (i3.dataLabelPath = i3.dataLabelPath.destroy()));
        }
        return { compose: function(e3) {
          s(e3, "afterGetBBox", h), s(e3, "beforeAddingDataLabel", d);
          let t3 = e3.prototype;
          t3.setTextPath || (t3.setTextPath = a);
        } };
      }), i(t, "Series/Treegraph/TreegraphSeries.js", [t["Series/PathUtilities.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Renderer/SVG/SVGRenderer.js"], t["Series/Treegraph/TreegraphNode.js"], t["Series/Treegraph/TreegraphPoint.js"], t["Series/TreeUtilities.js"], t["Core/Utilities.js"], t["Series/Treegraph/TreegraphLink.js"], t["Series/Treegraph/TreegraphLayout.js"], t["Series/Treegraph/TreegraphSeriesDefaults.js"], t["Core/Renderer/SVG/SVGElement.js"], t["Extensions/TextPath.js"]], function(e2, t2, i2, s, o, r, l, n, a, h, d, p) {
        let { getLinkPath: c } = e2, { series: { prototype: u }, seriesTypes: { treemap: f, column: g } } = t2, { prototype: { symbols: y } } = i2, { getLevelOptions: m, getNodeWidth: b } = r, { arrayMax: v, crisp: P, extend: k, merge: L, pick: x, relativeLength: T, splat: C } = l;
        p.compose(d);
        class S extends f {
          constructor() {
            super(...arguments), this.nodeList = [], this.links = [];
          }
          init() {
            super.init.apply(this, arguments), this.layoutAlgorythm = new a();
            let e3 = this, t3 = this.chart.labelCollectors;
            t3.some((e4) => "collectorFunc" === e4.name) || t3.push(function() {
              let t4 = [];
              if (!C(e3.options.dataLabels)[0].allowOverlap) for (let i3 of e3.links) i3.dataLabel && t4.push(i3.dataLabel);
              return t4;
            });
          }
          getLayoutModifiers() {
            let e3 = this.chart, t3 = this, i3 = e3.plotSizeX, s2 = e3.plotSizeY, o2 = v(this.points.map((e4) => e4.node.xPosition)), r2 = 1 / 0, l2 = -1 / 0, n2 = 1 / 0, a2 = -1 / 0, h2 = 0, d2 = 0, p2 = 0, c2 = 0;
            this.points.forEach((e4) => {
              if (this.options.fillSpace && !e4.visible) return;
              let u3 = e4.node, f3 = t3.mapOptionsToLevel[e4.node.level] || {}, g3 = L(this.options.marker, f3.marker, e4.options.marker), y3 = g3.width ?? b(this, o2), m2 = T(g3.radius || 0, Math.min(i3, s2)), v2 = g3.symbol, P2 = "circle" !== v2 && g3.height ? T(g3.height, s2) : 2 * m2, k2 = "circle" !== v2 && y3 ? T(y3, i3) : 2 * m2;
              u3.nodeSizeX = k2, u3.nodeSizeY = P2, u3.xPosition <= r2 && (r2 = u3.xPosition, d2 = Math.max(k2 + (g3.lineWidth || 0), d2)), u3.xPosition >= l2 && (l2 = u3.xPosition, h2 = Math.max(k2 + (g3.lineWidth || 0), h2)), u3.yPosition <= n2 && (n2 = u3.yPosition, c2 = Math.max(P2 + (g3.lineWidth || 0), c2)), u3.yPosition >= a2 && (a2 = u3.yPosition, p2 = Math.max(P2 + (g3.lineWidth || 0), p2));
            });
            let u2 = a2 === n2 ? 1 : (s2 - (c2 + p2) / 2) / (a2 - n2), f2 = a2 === n2 ? s2 / 2 : -u2 * n2 + c2 / 2, g2 = l2 === r2 ? 1 : (i3 - (h2 + h2) / 2) / (l2 - r2), y2 = l2 === r2 ? i3 / 2 : -g2 * r2 + d2 / 2;
            return { ax: g2, bx: y2, ay: u2, by: f2 };
          }
          getLinks() {
            let e3 = this, t3 = [];
            return this.data.forEach((i3) => {
              let s2 = e3.mapOptionsToLevel[i3.node.level || 0] || {};
              if (i3.node.parent) {
                let o2 = L(s2, i3.options);
                if (!i3.linkToParent || i3.linkToParent.destroyed) {
                  let t4 = new e3.LinkClass(e3, o2, void 0, i3);
                  i3.linkToParent = t4;
                } else i3.collapsed = x(i3.collapsed, (this.mapOptionsToLevel[i3.node.level] || {}).collapsed), i3.linkToParent.visible = i3.linkToParent.toNode.visible;
                i3.linkToParent.index = t3.push(i3.linkToParent) - 1;
              } else i3.linkToParent && (e3.links.splice(i3.linkToParent.index), i3.linkToParent.destroy(), delete i3.linkToParent);
            }), t3;
          }
          buildTree(e3, t3, i3, s2, o2) {
            let r2 = this.points[t3];
            return i3 = r2 && r2.level || i3, super.buildTree.call(this, e3, t3, i3, s2, o2);
          }
          markerAttribs() {
            return {};
          }
          setCollapsedStatus(e3, t3) {
            let i3 = e3.point;
            i3 && (i3.collapsed = x(i3.collapsed, (this.mapOptionsToLevel[e3.level] || {}).collapsed), i3.visible = t3, t3 = false !== t3 && !i3.collapsed), e3.children.forEach((e4) => {
              this.setCollapsedStatus(e4, t3);
            });
          }
          drawTracker() {
            g.prototype.drawTracker.apply(this, arguments), g.prototype.drawTracker.call(this, this.links);
          }
          translate() {
            let e3 = this.options, t3 = r.updateRootId(this), i3;
            u.translate.call(this);
            let s2 = this.tree = this.getTree();
            i3 = this.nodeMap[t3], "" === t3 || i3 && i3.children.length || (this.setRootNode("", false), t3 = this.rootNode, i3 = this.nodeMap[t3]), this.mapOptionsToLevel = m({ from: i3.level + 1, levels: e3.levels, to: s2.height, defaults: { levelIsConstant: this.options.levelIsConstant, colorByPoint: e3.colorByPoint } }), this.setCollapsedStatus(s2, true), this.links = this.getLinks(), this.setTreeValues(s2), this.layoutAlgorythm.calculatePositions(this), this.layoutModifier = this.getLayoutModifiers(), this.points.forEach((e4) => {
              this.translateNode(e4);
            }), this.points.forEach((e4) => {
              e4.linkToParent && this.translateLink(e4.linkToParent);
            }), e3.colorByPoint || this.setColorRecursive(this.tree);
          }
          translateLink(e3) {
            var _a, _b, _c, _d, _e;
            let t3 = e3.fromNode, i3 = e3.toNode, s2 = ((_a = this.options.link) == null ? void 0 : _a.lineWidth) || 0, o2 = x((_b = this.options.link) == null ? void 0 : _b.curveFactor, 0.5), r2 = x((_c = e3.options.link) == null ? void 0 : _c.type, (_d = this.options.link) == null ? void 0 : _d.type, "default");
            if (t3.shapeArgs && i3.shapeArgs) {
              let l2 = t3.shapeArgs.width || 0, n2 = this.chart.inverted, a2 = P((t3.shapeArgs.y || 0) + (t3.shapeArgs.height || 0) / 2, s2), h2 = P((i3.shapeArgs.y || 0) + (i3.shapeArgs.height || 0) / 2, s2), d2 = P((t3.shapeArgs.x || 0) + l2, s2), p2 = P(i3.shapeArgs.x || 0, s2);
              n2 && (d2 -= l2, p2 += i3.shapeArgs.width || 0);
              let u2 = i3.node.xPosition - t3.node.xPosition;
              e3.shapeType = "path";
              let f2 = (Math.abs(p2 - d2) + l2) / u2 - l2, g2 = P((p2 + d2) / 2, s2);
              e3.plotX = g2, e3.plotY = h2, e3.shapeArgs = { d: c[r2]({ x1: d2, y1: a2, x2: p2, y2: h2, width: f2, offset: f2 * o2 * (n2 ? -1 : 1), inverted: n2, parentVisible: i3.visible, radius: (_e = this.options.link) == null ? void 0 : _e.radius }) }, e3.dlBox = { x: (d2 + p2) / 2, y: (a2 + h2) / 2, height: s2, width: 0 }, e3.tooltipPos = n2 ? [(this.chart.plotSizeY || 0) - e3.dlBox.y, (this.chart.plotSizeX || 0) - e3.dlBox.x] : [e3.dlBox.x, e3.dlBox.y];
            }
          }
          drawNodeLabels(e3) {
            let t3, i3;
            let s2 = this.mapOptionsToLevel;
            for (let o2 of e3) i3 = s2[o2.node.level], t3 = { style: {} }, i3 && i3.dataLabels && (t3 = L(t3, i3.dataLabels), this.hasDataLabels = () => true), o2.shapeArgs && !C(this.options.dataLabels)[0].style.width && (t3.style.width = o2.shapeArgs.width, o2.dataLabel && o2.dataLabel.css({ width: o2.shapeArgs.width + "px" })), o2.dlOptions = L(t3, o2.options.dataLabels);
            u.drawDataLabels.call(this, e3);
          }
          alignDataLabel(e3, t3) {
            let i3 = e3.visible;
            e3.visible = true, super.alignDataLabel.apply(this, arguments), t3.animate({ opacity: false === i3 ? 0 : 1 }, void 0, function() {
              i3 || t3.hide();
            }), e3.visible = i3;
          }
          drawDataLabels() {
            this.options.dataLabels && (this.options.dataLabels = C(this.options.dataLabels), this.drawNodeLabels(this.points), u.drawDataLabels.call(this, this.links));
          }
          destroy() {
            if (this.links) {
              for (let e3 of this.links) e3.destroy();
              this.links.length = 0;
            }
            return u.destroy.apply(this, arguments);
          }
          pointAttribs(e3, t3) {
            let i3 = e3 && this.mapOptionsToLevel[e3.node.level || 0] || {}, s2 = e3 && e3.options, o2 = i3.states && i3.states[t3] || {};
            e3 && (e3.options.marker = L(this.options.marker, i3.marker, e3.options.marker));
            let r2 = x(o2 && o2.link && o2.link.color, s2 && s2.link && s2.link.color, i3 && i3.link && i3.link.color, this.options.link && this.options.link.color), l2 = x(o2 && o2.link && o2.link.lineWidth, s2 && s2.link && s2.link.lineWidth, i3 && i3.link && i3.link.lineWidth, this.options.link && this.options.link.lineWidth), n2 = u.pointAttribs.call(this, e3, t3);
            return e3 && (e3.isLink && (n2.stroke = r2, n2["stroke-width"] = l2, delete n2.fill), e3.visible || (n2.opacity = 0)), n2;
          }
          drawPoints() {
            f.prototype.drawPoints.apply(this, arguments), g.prototype.drawPoints.call(this, this.links);
          }
          translateNode(e3) {
            let t3 = this.chart, i3 = e3.node, s2 = t3.plotSizeY, o2 = t3.plotSizeX, { ax: r2, bx: l2, ay: n2, by: a2 } = this.layoutModifier, h2 = r2 * i3.xPosition + l2, d2 = n2 * i3.yPosition + a2, p2 = this.mapOptionsToLevel[i3.level] || {}, c2 = L(this.options.marker, p2.marker, e3.options.marker).symbol, u2 = i3.nodeSizeY, f2 = i3.nodeSizeX, g2 = this.options.reversed, m2 = i3.x = t3.inverted ? o2 - f2 / 2 - h2 : h2 - f2 / 2, b2 = i3.y = g2 ? d2 - u2 / 2 : s2 - d2 - u2 / 2, v2 = x(e3.options.borderRadius, p2.borderRadius, this.options.borderRadius), P2 = y[c2 || "circle"];
            if (void 0 === P2 ? (e3.hasImage = true, e3.shapeType = "image", e3.imageUrl = c2.match(/^url\((.*?)\)$/)[1]) : e3.shapeType = "path", !e3.visible && e3.linkToParent) {
              let t4 = e3.linkToParent.fromNode;
              if (t4) {
                let { x: i4 = 0, y: s3 = 0, width: o3 = 0, height: r3 = 0 } = t4.shapeArgs || {};
                e3.shapeArgs || (e3.shapeArgs = {}), e3.hasImage || k(e3.shapeArgs, { d: P2(i4, s3, o3, r3, v2 ? { r: v2 } : void 0) }), k(e3.shapeArgs, { x: i4, y: s3 }), e3.plotX = t4.plotX, e3.plotY = t4.plotY;
              }
            } else e3.plotX = m2, e3.plotY = b2, e3.shapeArgs = { x: m2, y: b2, width: f2, height: u2, cursor: e3.node.isLeaf ? "default" : "pointer" }, e3.hasImage || (e3.shapeArgs.d = P2(m2, b2, f2, u2, v2 ? { r: v2 } : void 0));
            e3.tooltipPos = t3.inverted ? [s2 - b2 - u2 / 2, o2 - m2 - f2 / 2] : [m2 + f2 / 2, b2];
          }
        }
        return S.defaultOptions = L(f.defaultOptions, h), k(S.prototype, { pointClass: o, NodeClass: s, LinkClass: n }), t2.registerSeriesType("treegraph", S), S;
      }), i(t, "masters/modules/treegraph.src.js", [t["Core/Globals.js"]], function(e2) {
        return e2;
      });
    });
  }
});
export default require_treegraph();
//# sourceMappingURL=highcharts_modules_treegraph__js.js.map
