import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/datagrouping.js
var require_datagrouping = __commonJS({
  "node_modules/highcharts/modules/datagrouping.js"(exports, module) {
    !/**
    * Highstock JS v11.4.7 (2024-08-14)
    *
    * Data grouping module
    *
    * (c) 2010-2024 Torstein HÃ¸nsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/datagrouping", ["highcharts"], function(i) {
        return t(i), t.Highcharts = i, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var i = t ? t._modules : {};
      function o(i2, o2, e, a) {
        i2.hasOwnProperty(o2) || (i2[o2] = a.apply(null, e), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: o2, module: i2[o2] } })));
      }
      o(i, "Extensions/DataGrouping/ApproximationRegistry.js", [], function() {
        return {};
      }), o(i, "Extensions/DataGrouping/ApproximationDefaults.js", [i["Extensions/DataGrouping/ApproximationRegistry.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { arrayMax: o2, arrayMin: e, correctFloat: a, extend: n, isNumber: s } = i2;
        function r(t3) {
          let i3 = t3.length, o3 = p(t3);
          return s(o3) && i3 && (o3 = a(o3 / i3)), o3;
        }
        function p(t3) {
          let i3 = t3.length, o3;
          if (!i3 && t3.hasNulls) o3 = null;
          else if (i3) for (o3 = 0; i3--; ) o3 += t3[i3];
          return o3;
        }
        let u = { average: r, averages: function() {
          let t3 = [];
          return [].forEach.call(arguments, function(i3) {
            t3.push(r(i3));
          }), void 0 === t3[0] ? void 0 : t3;
        }, close: function(t3) {
          return t3.length ? t3[t3.length - 1] : t3.hasNulls ? null : void 0;
        }, high: function(t3) {
          return t3.length ? o2(t3) : t3.hasNulls ? null : void 0;
        }, hlc: function(i3, o3, e2) {
          if (i3 = t2.high(i3), o3 = t2.low(o3), e2 = t2.close(e2), s(i3) || s(o3) || s(e2)) return [i3, o3, e2];
        }, low: function(t3) {
          return t3.length ? e(t3) : t3.hasNulls ? null : void 0;
        }, ohlc: function(i3, o3, e2, a2) {
          if (i3 = t2.open(i3), o3 = t2.high(o3), e2 = t2.low(e2), a2 = t2.close(a2), s(i3) || s(o3) || s(e2) || s(a2)) return [i3, o3, e2, a2];
        }, open: function(t3) {
          return t3.length ? t3[0] : t3.hasNulls ? null : void 0;
        }, range: function(i3, o3) {
          return (i3 = t2.low(i3), o3 = t2.high(o3), s(i3) || s(o3)) ? [i3, o3] : null === i3 && null === o3 ? null : void 0;
        }, sum: p };
        return n(t2, u), u;
      }), o(i, "Extensions/DataGrouping/DataGroupingDefaults.js", [], function() {
        return { common: { groupPixelWidth: 2, dateTimeLabelFormats: { millisecond: ["%A, %e %b, %H:%M:%S.%L", "%A, %e %b, %H:%M:%S.%L", "-%H:%M:%S.%L"], second: ["%A, %e %b, %H:%M:%S", "%A, %e %b, %H:%M:%S", "-%H:%M:%S"], minute: ["%A, %e %b, %H:%M", "%A, %e %b, %H:%M", "-%H:%M"], hour: ["%A, %e %b, %H:%M", "%A, %e %b, %H:%M", "-%H:%M"], day: ["%A, %e %b %Y", "%A, %e %b", "-%A, %e %b %Y"], week: ["Week from %A, %e %b %Y", "%A, %e %b", "-%A, %e %b %Y"], month: ["%B %Y", "%B", "-%B %Y"], year: ["%Y", "%Y", "-%Y"] } }, seriesSpecific: { line: {}, spline: {}, area: {}, areaspline: {}, arearange: {}, column: { groupPixelWidth: 10 }, columnrange: { groupPixelWidth: 10 }, candlestick: { groupPixelWidth: 10 }, ohlc: { groupPixelWidth: 5 }, hlc: { groupPixelWidth: 5 }, heikinashi: { groupPixelWidth: 10 } }, units: [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]] };
      }), o(i, "Extensions/DataGrouping/DataGroupingAxisComposition.js", [i["Extensions/DataGrouping/DataGroupingDefaults.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let o2;
        let { addEvent: e, extend: a, merge: n, pick: s } = i2;
        function r(t3) {
          let i3 = this, o3 = i3.series;
          o3.forEach(function(t4) {
            t4.groupPixelWidth = void 0;
          }), o3.forEach(function(o4) {
            o4.groupPixelWidth = i3.getGroupPixelWidth && i3.getGroupPixelWidth(), o4.groupPixelWidth && (o4.hasProcessed = true), o4.applyGrouping(!!t3.hasExtremesChanged);
          });
        }
        function p() {
          let i3 = this.series, o3 = i3.length, e2 = 0, a2 = false, n2, r2;
          for (; o3--; ) (r2 = i3[o3].options.dataGrouping) && (e2 = Math.max(e2, s(r2.groupPixelWidth, t2.common.groupPixelWidth)), n2 = (i3[o3].processedXData || i3[o3].data).length, (i3[o3].groupPixelWidth || n2 > this.chart.plotSizeX / e2 || n2 && r2.forced) && (a2 = true));
          return a2 ? e2 : 0;
        }
        function u() {
          this.series.forEach(function(t3) {
            t3.hasProcessed = false;
          });
        }
        function l(t3, i3) {
          let e2;
          if (i3 = s(i3, true), t3 || (t3 = { forced: false, units: null }), this instanceof o2) for (e2 = this.series.length; e2--; ) this.series[e2].update({ dataGrouping: t3 }, false);
          else this.chart.options.series.forEach(function(i4) {
            i4.dataGrouping = "boolean" == typeof t3 ? t3 : n(t3, i4.dataGrouping);
          });
          this.ordinal && (this.ordinal.slope = void 0), i3 && this.chart.redraw();
        }
        return { compose: function(t3) {
          o2 = t3;
          let i3 = t3.prototype;
          i3.applyGrouping || (e(t3, "afterSetScale", u), e(t3, "postProcessData", r), a(i3, { applyGrouping: r, getGroupPixelWidth: p, setDataGrouping: l }));
        } };
      }), o(i, "Extensions/DataGrouping/DataGroupingSeriesComposition.js", [i["Extensions/DataGrouping/ApproximationRegistry.js"], i["Extensions/DataGrouping/DataGroupingDefaults.js"], i["Core/Axis/DateTimeAxis.js"], i["Core/Defaults.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function(t2, i2, o2, e, a, n) {
        let { series: { prototype: s } } = a, { addEvent: r, defined: p, error: u, extend: l, isNumber: h, merge: g, pick: d } = n, c = s.generatePoints;
        function f(t3) {
          var e2;
          let a2, n2;
          let r2 = this.chart, l2 = this.options.dataGrouping, g2 = false !== this.allowDG && l2 && d(l2.enabled, r2.options.isStock), c2 = this.reserveSpace(), f2 = this.currentDataGrouping, m2, x2, D2 = false;
          g2 && !this.requireSorting && (this.requireSorting = D2 = true);
          let G2 = false == !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !t3) || !g2;
          if (D2 && (this.requireSorting = false), G2) return;
          this.destroyGroupedData();
          let y2 = l2.groupAll ? this.xData : this.processedXData, M = l2.groupAll ? this.yData : this.processedYData, A = r2.plotSizeX, S = this.xAxis, j = S.options.ordinal, P = this.groupPixelWidth;
          if (P && y2 && y2.length && A) {
            n2 = true, this.isDirty = true, this.points = null;
            let t4 = S.getExtremes(), g3 = t4.min, d2 = t4.max, f3 = j && S.ordinal && S.ordinal.getGroupIntervalFactor(g3, d2, this) || 1, D3 = P * (d2 - g3) / A * f3, G3 = S.getTimeTicks(o2.Additions.prototype.normalizeTimeTickInterval(D3, l2.units || i2.units), Math.min(g3, y2[0]), Math.max(d2, y2[y2.length - 1]), S.options.startOfWeek, y2, this.closestPointRange), b = s.groupData.apply(this, [y2, M, G3, l2.approximation]), E = b.groupedXData, v = b.groupedYData, C = 0;
            for (l2 && l2.smoothed && E.length && (l2.firstAnchor = "firstPoint", l2.anchor = "middle", l2.lastAnchor = "lastPoint", u(32, false, r2, { "dataGrouping.smoothed": "use dataGrouping.anchor" })), a2 = 1; a2 < G3.length; a2++) G3.info.segmentStarts && -1 !== G3.info.segmentStarts.indexOf(a2) || (C = Math.max(G3[a2] - G3[a2 - 1], C));
            (m2 = G3.info).gapSize = C, this.closestPointRange = G3.info.totalRange, this.groupMap = b.groupMap, this.currentDataGrouping = m2, function(t5, i3, o3) {
              let e3 = t5.options.dataGrouping, a3 = t5.currentDataGrouping && t5.currentDataGrouping.gapSize;
              if (!(e3 && t5.xData && a3 && t5.groupMap)) return;
              let n3 = i3.length - 1, s2 = e3.anchor, r3 = e3.firstAnchor, p2 = e3.lastAnchor, u2 = i3.length - 1, l3 = 0;
              if (r3 && t5.xData[0] >= i3[0]) {
                let o4;
                l3++;
                let e4 = t5.groupMap[0].start, n4 = t5.groupMap[0].length;
                h(e4) && h(n4) && (o4 = e4 + (n4 - 1)), i3[0] = { start: i3[0], middle: i3[0] + 0.5 * a3, end: i3[0] + a3, firstPoint: t5.xData[0], lastPoint: o4 && t5.xData[o4] }[r3];
              }
              if (n3 > 0 && p2 && a3 && i3[n3] >= o3 - a3) {
                u2--;
                let o4 = t5.groupMap[t5.groupMap.length - 1].start;
                i3[n3] = { start: i3[n3], middle: i3[n3] + 0.5 * a3, end: i3[n3] + a3, firstPoint: o4 && t5.xData[o4], lastPoint: t5.xData[t5.xData.length - 1] }[p2];
              }
              if (s2 && "start" !== s2) {
                let t6 = a3 * { middle: 0.5, end: 1 }[s2];
                for (; u2 >= l3; ) i3[u2] += t6, u2--;
              }
            }(this, E, d2), c2 && (p((e2 = E)[0]) && h(S.min) && h(S.dataMin) && e2[0] < S.min && ((!p(S.options.min) && S.min <= S.dataMin || S.min === S.dataMin) && (S.min = Math.min(e2[0], S.min)), S.dataMin = Math.min(e2[0], S.dataMin)), p(e2[e2.length - 1]) && h(S.max) && h(S.dataMax) && e2[e2.length - 1] > S.max && ((!p(S.options.max) && h(S.dataMax) && S.max >= S.dataMax || S.max === S.dataMax) && (S.max = Math.max(e2[e2.length - 1], S.max)), S.dataMax = Math.max(e2[e2.length - 1], S.dataMax))), l2.groupAll && (this.allGroupedData = v, E = (x2 = this.cropData(E, v, S.min, S.max)).xData, v = x2.yData, this.cropStart = x2.start), this.processedXData = E, this.processedYData = v;
          } else this.groupMap = null, this.currentDataGrouping = void 0;
          this.hasGroupedData = n2, this.preventGraphAnimation = (f2 && f2.totalRange) !== (m2 && m2.totalRange);
        }
        function m() {
          this.groupedData && (this.groupedData.forEach(function(t3, i3) {
            t3 && (this.groupedData[i3] = t3.destroy ? t3.destroy() : null);
          }, this), this.groupedData.length = 0, delete this.allGroupedData);
        }
        function x() {
          c.apply(this), this.destroyGroupedData(), this.groupedData = this.hasGroupedData ? this.points : null;
        }
        function D() {
          return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") || this.options.cumulative ? "sum" : "average";
        }
        function G(i3, o3, e2, a2) {
          let n2 = this, s2 = n2.data, r2 = n2.options && n2.options.data, u2 = [], l2 = [], d2 = [], c2 = i3.length, f2 = !!o3, m2 = [], x2 = n2.pointArrayMap, D2 = x2 && x2.length, G2 = ["x"].concat(x2 || ["y"]), y2 = this.options.dataGrouping && this.options.dataGrouping.groupAll, M, A, S, j = 0, P = 0, b = "function" == typeof a2 ? a2 : a2 && t2[a2] ? t2[a2] : t2[n2.getDGApproximation && n2.getDGApproximation() || "average"];
          if (D2) {
            let t3 = x2.length;
            for (; t3--; ) m2.push([]);
          } else m2.push([]);
          let E = D2 || 1;
          for (let t3 = 0; t3 <= c2; t3++) if (!(i3[t3] < e2[0])) {
            for (; void 0 !== e2[j + 1] && i3[t3] >= e2[j + 1] || t3 === c2; ) {
              M = e2[j], n2.dataGroupInfo = { start: y2 ? P : n2.cropStart + P, length: m2[0].length, groupStart: M }, S = b.apply(n2, m2), n2.pointClass && !p(n2.dataGroupInfo.options) && (n2.dataGroupInfo.options = g(n2.pointClass.prototype.optionsToObject.call({ series: n2 }, n2.options.data[n2.cropStart + P])), G2.forEach(function(t4) {
                delete n2.dataGroupInfo.options[t4];
              })), void 0 !== S && (u2.push(M), l2.push(S), d2.push(n2.dataGroupInfo)), P = t3;
              for (let t4 = 0; t4 < E; t4++) m2[t4].length = 0, m2[t4].hasNulls = false;
              if (j += 1, t3 === c2) break;
            }
            if (t3 === c2) break;
            if (x2) {
              let i4;
              let o4 = n2.options.dataGrouping && n2.options.dataGrouping.groupAll ? t3 : n2.cropStart + t3, e3 = s2 && s2[o4] || n2.pointClass.prototype.applyOptions.apply({ series: n2 }, [r2[o4]]);
              for (let t4 = 0; t4 < D2; t4++) h(i4 = e3[x2[t4]]) ? m2[t4].push(i4) : null === i4 && (m2[t4].hasNulls = true);
            } else h(A = f2 ? o3[t3] : null) ? m2[0].push(A) : null === A && (m2[0].hasNulls = true);
          }
          return { groupedXData: u2, groupedYData: l2, groupMap: d2 };
        }
        function y(t3) {
          let o3 = t3.options, a2 = this.type, n2 = this.chart.options.plotOptions, s2 = this.useCommonDataGrouping && i2.common, r2 = i2.seriesSpecific, p2 = e.defaultOptions.plotOptions[a2].dataGrouping;
          if (n2 && (r2[a2] || s2)) {
            let t4 = this.chart.rangeSelector;
            p2 || (p2 = g(i2.common, r2[a2])), o3.dataGrouping = g(s2, p2, n2.series && n2.series.dataGrouping, n2[a2].dataGrouping, this.userOptions.dataGrouping, !o3.isInternal && t4 && h(t4.selected) && t4.buttonOptions[t4.selected].dataGrouping);
          }
        }
        return { compose: function(t3) {
          let i3 = t3.prototype;
          i3.applyGrouping || (r(t3.prototype.pointClass, "update", function() {
            if (this.dataGroup) return u(24, false, this.series.chart), false;
          }), r(t3, "afterSetOptions", y), r(t3, "destroy", m), l(i3, { applyGrouping: f, destroyGroupedData: m, generatePoints: x, getDGApproximation: D, groupData: G }));
        }, groupData: G };
      }), o(i, "Extensions/DataGrouping/DataGrouping.js", [i["Extensions/DataGrouping/DataGroupingAxisComposition.js"], i["Extensions/DataGrouping/DataGroupingDefaults.js"], i["Extensions/DataGrouping/DataGroupingSeriesComposition.js"], i["Core/Templating.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2, o2, e, a, n) {
        let { format: s } = e, { composed: r } = a, { addEvent: p, extend: u, isNumber: l, pick: h, pushUnique: g } = n;
        function d(t3) {
          var _a;
          let o3 = this.chart, e2 = o3.time, a2 = t3.labelConfig, n2 = a2.series, r2 = a2.point, p2 = n2.options, g2 = n2.tooltipOptions, d2 = p2.dataGrouping, c = n2.xAxis, f = g2.xDateFormat, m, x, D, G, y, M = g2[t3.isFooter ? "footerFormat" : "headerFormat"];
          if (c && "datetime" === c.options.type && d2 && l(a2.key)) {
            x = n2.currentDataGrouping, D = d2.dateTimeLabelFormats || i2.common.dateTimeLabelFormats, x ? (G = D[x.unitName], 1 === x.count ? f = G[0] : (f = G[1], m = G[2])) : !f && D && c.dateTime && (f = c.dateTime.getXDateFormat(a2.x, g2.dateTimeLabelFormats));
            let p3 = h((_a = n2.groupMap) == null ? void 0 : _a[r2.index].groupStart, a2.key), l2 = p3 + (x == null ? void 0 : x.totalRange) - 1;
            y = e2.dateFormat(f, p3), m && (y += e2.dateFormat(m, l2)), n2.chart.styledMode && (M = this.styledModeFormat(M)), t3.text = s(M, { point: u(a2.point, { key: y }), series: n2 }, o3), t3.preventDefault();
          }
        }
        return { compose: function(i3, e2, a2) {
          t2.compose(i3), o2.compose(e2), a2 && g(r, "DataGrouping") && p(a2, "headerFormatter", d);
        }, groupData: o2.groupData };
      }), o(i, "masters/modules/datagrouping.src.js", [i["Core/Globals.js"], i["Extensions/DataGrouping/ApproximationDefaults.js"], i["Extensions/DataGrouping/ApproximationRegistry.js"], i["Extensions/DataGrouping/DataGrouping.js"]], function(t2, i2, o2, e) {
        return t2.dataGrouping = t2.dataGrouping || {}, t2.dataGrouping.approximationDefaults = t2.dataGrouping.approximationDefaults || i2, t2.dataGrouping.approximations = t2.dataGrouping.approximations || o2, e.compose(t2.Axis, t2.Series, t2.Tooltip), t2;
      });
    });
  }
});
export default require_datagrouping();
//# sourceMappingURL=highcharts_modules_datagrouping__js.js.map
