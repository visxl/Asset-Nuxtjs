import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/boost.js
var require_boost = __commonJS({
  "node_modules/highcharts/modules/boost.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Boost module
    *
    * (c) 2010-2024 Highsoft AS
    * Author: Torstein Honsi
    *
    * License: www.highcharts.com/license
    *
    * */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/boost", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function i(t2, i2, s, r) {
        t2.hasOwnProperty(i2) || (t2[i2] = r.apply(null, s), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: t2[i2] } })));
      }
      i(t, "Extensions/Boost/Boostables.js", [], function() {
        return ["area", "areaspline", "arearange", "column", "columnrange", "bar", "line", "scatter", "heatmap", "bubble", "treemap"];
      }), i(t, "Extensions/Boost/BoostableMap.js", [t["Extensions/Boost/Boostables.js"]], function(e2) {
        let t2 = {};
        return e2.forEach((e3) => {
          t2[e3] = true;
        }), t2;
      }), i(t, "Extensions/Boost/BoostChart.js", [t["Extensions/Boost/BoostableMap.js"], t["Core/Globals.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        let { composed: s } = t2, { addEvent: r, pick: o, pushUnique: n } = i2;
        function a(t3) {
          let i3 = t3.series, s2 = t3.boost = t3.boost || {}, r2 = t3.options.boost || {}, n2 = o(r2.seriesThreshold, 50);
          if (i3.length >= n2) return true;
          if (1 === i3.length) return false;
          let a2 = r2.allowForce;
          if (void 0 === a2) {
            for (let e3 of (a2 = true, t3.xAxis)) if (o(e3.min, -1 / 0) > o(e3.dataMin, -1 / 0) || o(e3.max, 1 / 0) < o(e3.dataMax, 1 / 0)) {
              a2 = false;
              break;
            }
          }
          if (void 0 !== s2.forceChartBoost) {
            if (a2) return s2.forceChartBoost;
            s2.forceChartBoost = void 0;
          }
          let l2 = 0, h = 0, d;
          for (let t4 of i3) 0 !== (d = t4.options).boostThreshold && false !== t4.visible && "heatmap" !== t4.type && (e2[t4.type] && ++l2, function(...e3) {
            let t5 = -Number.MAX_VALUE;
            return e3.forEach(function(e4) {
              if (null != e4 && void 0 !== e4.length && e4.length > 0) return t5 = e4.length, true;
            }), t5;
          }(t4.processedXData, d.data, t4.points) >= (d.boostThreshold || Number.MAX_VALUE) && ++h);
          return s2.forceChartBoost = a2 && (l2 === i3.length && h === l2 || h > 5), s2.forceChartBoost;
        }
        function l(e3) {
          function t3() {
            e3.boost && e3.boost.wgl && a(e3) && e3.boost.wgl.render(e3);
          }
          r(e3, "predraw", function() {
            var _a, _b;
            e3.boost = e3.boost || {}, e3.boost.forceChartBoost = void 0, e3.boosted = false, e3.axes.some((e4) => e4.isPanning) || ((_b = (_a = e3.boost).clear) == null ? void 0 : _b.call(_a)), e3.boost.canvas && e3.boost.wgl && a(e3) && e3.boost.wgl.allocateBuffer(e3), e3.boost.markerGroup && e3.xAxis && e3.xAxis.length > 0 && e3.yAxis && e3.yAxis.length > 0 && e3.boost.markerGroup.translate(e3.xAxis[0].pos, e3.yAxis[0].pos);
          }), r(e3, "load", t3, { order: -1 }), r(e3, "redraw", t3);
          let i3 = -1, s2 = -1;
          r(e3.pointer, "afterGetHoverData", (t4) => {
            var _a;
            let r2 = (_a = t4.hoverPoint) == null ? void 0 : _a.series;
            if (e3.boost = e3.boost || {}, e3.boost.markerGroup && r2) {
              let t5 = e3.inverted ? r2.yAxis : r2.xAxis, o2 = e3.inverted ? r2.xAxis : r2.yAxis;
              (t5 && t5.pos !== i3 || o2 && o2.pos !== s2) && (e3.series.forEach((e4) => {
                var _a2;
                (_a2 = e4.halo) == null ? void 0 : _a2.hide();
              }), e3.boost.markerGroup.translate(t5.pos, o2.pos), i3 = t5.pos, s2 = o2.pos);
            }
          });
        }
        return { compose: function(e3, t3) {
          return t3 && n(s, "Boost.Chart") && e3.prototype.callbacks.push(l), e3;
        }, getBoostClipRect: function(e3, t3) {
          let i3 = e3.navigator, s2 = { x: e3.plotLeft, y: e3.plotTop, width: e3.plotWidth, height: e3.plotHeight };
          if (i3 && e3.inverted ? (s2.width += i3.top + i3.height, i3.opposite || (s2.x = i3.left)) : i3 && !e3.inverted && (s2.height = i3.top + i3.height - e3.plotTop), t3.getClipBox) {
            let { xAxis: i4, yAxis: r2 } = t3;
            if (s2 = t3.getClipBox(), e3.inverted) {
              let e4 = s2.width;
              s2.width = s2.height, s2.height = e4, s2.x = r2.pos, s2.y = i4.pos;
            } else s2.x = i4.pos, s2.y = r2.pos;
          }
          if (t3 === e3) {
            let t4 = e3.inverted ? e3.xAxis : e3.yAxis;
            t4.length <= 1 && (s2.y = Math.min(t4[0].pos, s2.y), s2.height = t4[0].pos - e3.plotTop + t4[0].len);
          }
          return s2;
        }, isChartSeriesBoosting: a };
      }), i(t, "Extensions/Boost/WGLDrawMode.js", [], function() {
        return { area: "LINES", arearange: "LINES", areaspline: "LINES", column: "LINES", columnrange: "LINES", bar: "LINES", line: "LINE_STRIP", scatter: "POINTS", heatmap: "TRIANGLES", treemap: "TRIANGLES", bubble: "POINTS" };
      }), i(t, "Extensions/Boost/WGLShader.js", [t["Core/Utilities.js"]], function(e2) {
        let { clamp: t2, error: i2, pick: s } = e2;
        return class {
          constructor(e3) {
            if (this.errors = [], this.uLocations = {}, this.gl = e3, e3 && !this.createShader()) return;
          }
          bind() {
            this.gl && this.shaderProgram && this.gl.useProgram(this.shaderProgram);
          }
          createShader() {
            let e3 = this.stringToProgram("#version 100\n#define LN10 2.302585092994046\nprecision highp float;\nattribute vec4 aVertexPosition;\nattribute vec4 aColor;\nvarying highp vec2 position;\nvarying highp vec4 vColor;\nuniform mat4 uPMatrix;\nuniform float pSize;\nuniform float translatedThreshold;\nuniform bool hasThreshold;\nuniform bool skipTranslation;\nuniform float xAxisTrans;\nuniform float xAxisMin;\nuniform float xAxisMinPad;\nuniform float xAxisPointRange;\nuniform float xAxisLen;\nuniform bool  xAxisPostTranslate;\nuniform float xAxisOrdinalSlope;\nuniform float xAxisOrdinalOffset;\nuniform float xAxisPos;\nuniform bool  xAxisCVSCoord;\nuniform bool  xAxisIsLog;\nuniform bool  xAxisReversed;\nuniform float yAxisTrans;\nuniform float yAxisMin;\nuniform float yAxisMinPad;\nuniform float yAxisPointRange;\nuniform float yAxisLen;\nuniform bool  yAxisPostTranslate;\nuniform float yAxisOrdinalSlope;\nuniform float yAxisOrdinalOffset;\nuniform float yAxisPos;\nuniform bool  yAxisCVSCoord;\nuniform bool  yAxisIsLog;\nuniform bool  yAxisReversed;\nuniform bool  isBubble;\nuniform bool  bubbleSizeByArea;\nuniform float bubbleZMin;\nuniform float bubbleZMax;\nuniform float bubbleZThreshold;\nuniform float bubbleMinSize;\nuniform float bubbleMaxSize;\nuniform bool  bubbleSizeAbs;\nuniform bool  isInverted;\nfloat bubbleRadius(){\nfloat value = aVertexPosition.w;\nfloat zMax = bubbleZMax;\nfloat zMin = bubbleZMin;\nfloat radius = 0.0;\nfloat pos = 0.0;\nfloat zRange = zMax - zMin;\nif (bubbleSizeAbs){\nvalue = value - bubbleZThreshold;\nzMax = max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);\nzMin = 0.0;\n}\nif (value < zMin){\nradius = bubbleZMin / 2.0 - 1.0;\n} else {\npos = zRange > 0.0 ? (value - zMin) / zRange : 0.5;\nif (bubbleSizeByArea && pos > 0.0){\npos = sqrt(pos);\n}\nradius = ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;\n}\nreturn radius * 2.0;\n}\nfloat translate(float val,\nfloat pointPlacement,\nfloat localA,\nfloat localMin,\nfloat minPixelPadding,\nfloat pointRange,\nfloat len,\nbool  cvsCoord,\nbool  isLog,\nbool  reversed\n){\nfloat sign = 1.0;\nfloat cvsOffset = 0.0;\nif (cvsCoord) {\nsign *= -1.0;\ncvsOffset = len;\n}\nif (isLog) {\nval = log(val) / LN10;\n}\nif (reversed) {\nsign *= -1.0;\ncvsOffset -= sign * len;\n}\nreturn sign * (val - localMin) * localA + cvsOffset + \n(sign * minPixelPadding);\n}\nfloat xToPixels(float value) {\nif (skipTranslation){\nreturn value;// + xAxisPos;\n}\nreturn translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord, xAxisIsLog, xAxisReversed);// + xAxisPos;\n}\nfloat yToPixels(float value, float checkTreshold) {\nfloat v;\nif (skipTranslation){\nv = value;// + yAxisPos;\n} else {\nv = translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord, yAxisIsLog, yAxisReversed);// + yAxisPos;\nif (v > yAxisLen) {\nv = yAxisLen;\n}\n}\nif (checkTreshold > 0.0 && hasThreshold) {\nv = min(v, translatedThreshold);\n}\nreturn v;\n}\nvoid main(void) {\nif (isBubble){\ngl_PointSize = bubbleRadius();\n} else {\ngl_PointSize = pSize;\n}\nvColor = aColor;\nif (skipTranslation && isInverted) {\ngl_Position = uPMatrix * vec4(aVertexPosition.y + yAxisPos, aVertexPosition.x + xAxisPos, 0.0, 1.0);\n} else if (isInverted) {\ngl_Position = uPMatrix * vec4(yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, xToPixels(aVertexPosition.x) + xAxisPos, 0.0, 1.0);\n} else {\ngl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);\n}\n}", "vertex"), t3 = this.stringToProgram("precision highp float;\nuniform vec4 fillColor;\nvarying highp vec2 position;\nvarying highp vec4 vColor;\nuniform sampler2D uSampler;\nuniform bool isCircle;\nuniform bool hasColor;\nvoid main(void) {\nvec4 col = fillColor;\nvec4 tcol = texture2D(uSampler, gl_PointCoord.st);\nif (hasColor) {\ncol = vColor;\n}\nif (isCircle) {\ncol *= tcol;\nif (tcol.r < 0.0) {\ndiscard;\n} else {\ngl_FragColor = col;\n}\n} else {\ngl_FragColor = col;\n}\n}", "fragment"), i3 = (e4) => this.gl.getUniformLocation(this.shaderProgram, e4);
            return e3 && t3 ? (this.shaderProgram = this.gl.createProgram(), this.gl.attachShader(this.shaderProgram, e3), this.gl.attachShader(this.shaderProgram, t3), this.gl.linkProgram(this.shaderProgram), this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) ? (this.gl.useProgram(this.shaderProgram), this.gl.bindAttribLocation(this.shaderProgram, 0, "aVertexPosition"), this.pUniform = i3("uPMatrix"), this.psUniform = i3("pSize"), this.fcUniform = i3("fillColor"), this.isBubbleUniform = i3("isBubble"), this.bubbleSizeAbsUniform = i3("bubbleSizeAbs"), this.bubbleSizeAreaUniform = i3("bubbleSizeByArea"), this.uSamplerUniform = i3("uSampler"), this.skipTranslationUniform = i3("skipTranslation"), this.isCircleUniform = i3("isCircle"), this.isInverted = i3("isInverted"), true) : (this.errors.push(this.gl.getProgramInfoLog(this.shaderProgram)), this.handleErrors(), this.shaderProgram = false, false) : (this.shaderProgram = false, this.handleErrors(), false);
          }
          handleErrors() {
            this.errors.length && i2("[highcharts boost] shader error - " + this.errors.join("\n"));
          }
          stringToProgram(e3, t3) {
            let i3 = this.gl.createShader("vertex" === t3 ? this.gl.VERTEX_SHADER : this.gl.FRAGMENT_SHADER);
            return (this.gl.shaderSource(i3, e3), this.gl.compileShader(i3), this.gl.getShaderParameter(i3, this.gl.COMPILE_STATUS)) ? i3 : (this.errors.push("when compiling " + t3 + " shader:\n" + this.gl.getShaderInfoLog(i3)), false);
          }
          destroy() {
            this.gl && this.shaderProgram && (this.gl.deleteProgram(this.shaderProgram), this.shaderProgram = false);
          }
          fillColorUniform() {
            return this.fcUniform;
          }
          getProgram() {
            return this.shaderProgram;
          }
          pointSizeUniform() {
            return this.psUniform;
          }
          perspectiveUniform() {
            return this.pUniform;
          }
          reset() {
            this.gl && this.shaderProgram && (this.gl.uniform1i(this.isBubbleUniform, 0), this.gl.uniform1i(this.isCircleUniform, 0));
          }
          setBubbleUniforms(e3, i3, r, o = 1) {
            let n = e3.options, a = Number.MAX_VALUE, l = -Number.MAX_VALUE;
            if (this.gl && this.shaderProgram && e3.is("bubble")) {
              let h = e3.getPxExtremes();
              a = s(n.zMin, t2(i3, false === n.displayNegative ? n.zThreshold : -Number.MAX_VALUE, a)), l = s(n.zMax, Math.max(l, r)), this.gl.uniform1i(this.isBubbleUniform, 1), this.gl.uniform1i(this.isCircleUniform, 1), this.gl.uniform1i(this.bubbleSizeAreaUniform, "width" !== e3.options.sizeBy), this.gl.uniform1i(this.bubbleSizeAbsUniform, e3.options.sizeByAbsoluteValue), this.setUniform("bubbleMinSize", h.minPxSize * o), this.setUniform("bubbleMaxSize", h.maxPxSize * o), this.setUniform("bubbleZMin", a), this.setUniform("bubbleZMax", l), this.setUniform("bubbleZThreshold", e3.options.zThreshold);
            }
          }
          setColor(e3) {
            this.gl && this.shaderProgram && this.gl.uniform4f(this.fcUniform, e3[0] / 255, e3[1] / 255, e3[2] / 255, e3[3]);
          }
          setDrawAsCircle(e3) {
            this.gl && this.shaderProgram && this.gl.uniform1i(this.isCircleUniform, e3 ? 1 : 0);
          }
          setInverted(e3) {
            this.gl && this.shaderProgram && this.gl.uniform1i(this.isInverted, e3);
          }
          setPMatrix(e3) {
            this.gl && this.shaderProgram && this.gl.uniformMatrix4fv(this.pUniform, false, e3);
          }
          setPointSize(e3) {
            this.gl && this.shaderProgram && this.gl.uniform1f(this.psUniform, e3);
          }
          setSkipTranslation(e3) {
            this.gl && this.shaderProgram && this.gl.uniform1i(this.skipTranslationUniform, true === e3 ? 1 : 0);
          }
          setTexture(e3) {
            this.gl && this.shaderProgram && this.gl.uniform1i(this.uSamplerUniform, e3);
          }
          setUniform(e3, t3) {
            if (this.gl && this.shaderProgram) {
              let i3 = this.uLocations[e3] = this.uLocations[e3] || this.gl.getUniformLocation(this.shaderProgram, e3);
              this.gl.uniform1f(i3, t3);
            }
          }
        };
      }), i(t, "Extensions/Boost/WGLVertexBuffer.js", [], function() {
        return class {
          constructor(e2, t2, i2) {
            this.buffer = false, this.iterator = 0, this.preAllocated = false, this.vertAttribute = false, this.components = i2 || 2, this.dataComponents = i2, this.gl = e2, this.shader = t2;
          }
          allocate(e2) {
            this.iterator = -1, this.preAllocated = new Float32Array(4 * e2);
          }
          bind() {
            if (!this.buffer) return false;
            this.gl.vertexAttribPointer(this.vertAttribute, this.components, this.gl.FLOAT, false, 0, 0);
          }
          build(e2, t2, i2) {
            let s;
            return (this.data = e2 || [], this.data && 0 !== this.data.length || this.preAllocated) ? (this.components = i2 || this.components, this.buffer && this.gl.deleteBuffer(this.buffer), this.preAllocated || (s = new Float32Array(this.data)), this.buffer = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, this.preAllocated || s, this.gl.STATIC_DRAW), this.vertAttribute = this.gl.getAttribLocation(this.shader.getProgram(), t2), this.gl.enableVertexAttribArray(this.vertAttribute), s = false, true) : (this.destroy(), false);
          }
          destroy() {
            this.buffer && (this.gl.deleteBuffer(this.buffer), this.buffer = false, this.vertAttribute = false), this.iterator = 0, this.components = this.dataComponents || 2, this.data = [];
          }
          push(e2, t2, i2, s) {
            this.preAllocated && (this.preAllocated[++this.iterator] = e2, this.preAllocated[++this.iterator] = t2, this.preAllocated[++this.iterator] = i2, this.preAllocated[++this.iterator] = s);
          }
          render(e2, t2, i2) {
            let s = this.preAllocated ? this.preAllocated.length : this.data.length;
            return !!this.buffer && !!s && ((!e2 || e2 > s || e2 < 0) && (e2 = 0), (!t2 || t2 > s) && (t2 = s), !(e2 >= t2) && (i2 = i2 || "POINTS", this.gl.drawArrays(this.gl[i2], e2 / this.components, (t2 - e2) / this.components), true));
          }
        };
      }), i(t, "Extensions/Boost/WGLRenderer.js", [t["Core/Color/Color.js"], t["Core/Globals.js"], t["Core/Utilities.js"], t["Extensions/Boost/WGLDrawMode.js"], t["Extensions/Boost/WGLShader.js"], t["Extensions/Boost/WGLVertexBuffer.js"]], function(e2, t2, i2, s, r, o) {
        let { parse: n } = e2, { doc: a, win: l } = t2, { isNumber: h, isObject: d, merge: f, objectEach: u, pick: g } = i2, c = { column: true, columnrange: true, bar: true, area: true, areaspline: true, arearange: true }, m = { scatter: true, bubble: true }, p = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
        class b {
          static orthoMatrix(e3, t3) {
            return [2 / e3, 0, 0, 0, 0, -(2 / t3), 0, 0, 0, 0, -2, 0, -1, 1, -1, 1];
          }
          static seriesPointCount(e3) {
            let t3, i3, s2;
            return e3.boosted ? (t3 = !!e3.options.stacking, i3 = e3.xData || e3.options.xData || e3.processedXData, s2 = (t3 ? e3.data : i3 || e3.options.data).length, "treemap" === e3.type ? s2 *= 12 : "heatmap" === e3.type ? s2 *= 6 : c[e3.type] && (s2 *= 2), s2) : 0;
          }
          constructor(e3) {
            this.data = [], this.height = 0, this.isInited = false, this.markerData = [], this.series = [], this.textureHandles = {}, this.width = 0, this.postRenderCallback = e3, this.settings = { pointSize: 1, lineWidth: 1, fillColor: "#AA00AA", useAlpha: true, usePreallocated: false, useGPUTranslations: false, debug: { timeRendering: false, timeSeriesProcessing: false, timeSetup: false, timeBufferCopy: false, timeKDTree: false, showSkipSummary: false } };
          }
          getPixelRatio() {
            return this.settings.pixelRatio || l.devicePixelRatio || 1;
          }
          setOptions(e3) {
            "pixelRatio" in e3 || (e3.pixelRatio = 1), f(true, this.settings, e3);
          }
          allocateBuffer(e3) {
            let t3 = this.vbuffer, i3 = 0;
            this.settings.usePreallocated && (e3.series.forEach((e4) => {
              e4.boosted && (i3 += b.seriesPointCount(e4));
            }), t3 && t3.allocate(i3));
          }
          allocateBufferForSingleSeries(e3) {
            let t3 = this.vbuffer, i3 = 0;
            this.settings.usePreallocated && (e3.boosted && (i3 = b.seriesPointCount(e3)), t3 && t3.allocate(i3));
          }
          clear() {
            let e3 = this.gl;
            e3 && e3.clear(e3.COLOR_BUFFER_BIT | e3.DEPTH_BUFFER_BIT);
          }
          pushSeriesData(e3, t3) {
            let i3 = this.data, s2 = this.settings, r2 = this.vbuffer, o2 = e3.pointArrayMap && "low,high" === e3.pointArrayMap.join(","), { chart: a2, options: l2, sorted: h2, xAxis: f2, yAxis: u2 } = e3, g2 = !!l2.stacking, m2 = l2.data, p2 = e3.xAxis.getExtremes(), b2 = p2.min - (e3.xAxis.minPointOffset || 0), x = p2.max + (e3.xAxis.minPointOffset || 0), A = e3.yAxis.getExtremes(), y = A.min - (e3.yAxis.minPointOffset || 0), P = A.max + (e3.yAxis.minPointOffset || 0), v = e3.xData || l2.xData || e3.processedXData, T = e3.yData || l2.yData || e3.processedYData, E = e3.zData || l2.zData || e3.processedZData, k = !v || 0 === v.length, S = l2.connectNulls, M = e3.points || false, C = g2 ? e3.data : v || m2, U = { x: Number.MAX_VALUE, y: 0 }, w = { x: -Number.MAX_VALUE, y: 0 }, R = void 0 === a2.index, B = c[e3.type], D = l2.zoneAxis || "y", L = l2.zones || false, z = l2.threshold, _ = this.getPixelRatio(), G = e3.chart.plotWidth, N = false, I = false, O, X, V = 0, j = false, F, W, H, Y, q = -1, Z = false, K = false, Q, J = false, $ = false, ee = false, et = false, ei = true, es = true, er, eo = false, en = false, ea = 0;
            if (l2.boostData && l2.boostData.length > 0) return;
            l2.gapSize && (en = "value" !== l2.gapUnit ? l2.gapSize * e3.closestPointRange : l2.gapSize), L && (er = [], L.forEach((e4, t4) => {
              if (e4.color) {
                let i4 = n(e4.color).rgba;
                i4[0] /= 255, i4[1] /= 255, i4[2] /= 255, er[t4] = i4, eo || void 0 !== e4.value || (eo = i4);
              }
            }), eo || (eo = n(e3.pointAttribs && e3.pointAttribs().fill || e3.color).rgba, eo[0] /= 255, eo[1] /= 255, eo[2] /= 255)), a2.inverted && (G = e3.chart.plotHeight), e3.closestPointRangePx = Number.MAX_VALUE;
            let el = (e4) => {
              e4 && (t3.colorData.push(e4[0]), t3.colorData.push(e4[1]), t3.colorData.push(e4[2]), t3.colorData.push(e4[3]));
            }, eh = (e4, o3, n2, a3 = 1, l3) => {
              el(l3), 1 !== _ && (!s2.useGPUTranslations || t3.skipTranslation) && (e4 *= _, o3 *= _, a3 *= _), s2.usePreallocated && r2 ? (r2.push(e4, o3, n2 ? 1 : 0, a3), ea += 4) : (i3.push(e4), i3.push(o3), i3.push(n2 ? _ : 0), i3.push(a3));
            }, ed = () => {
              t3.segments.length && (t3.segments[t3.segments.length - 1].to = i3.length || ea);
            }, ef = () => {
              t3.segments.length && t3.segments[t3.segments.length - 1].from === (i3.length || ea) || (ed(), t3.segments.push({ from: i3.length || ea }));
            }, eu = (e4, t4, i4, s3, r3) => {
              el(r3), eh(e4 + i4, t4), el(r3), eh(e4, t4), el(r3), eh(e4, t4 + s3), el(r3), eh(e4, t4 + s3), el(r3), eh(e4 + i4, t4 + s3), el(r3), eh(e4 + i4, t4);
            };
            if (ef(), M && M.length > 0) {
              t3.skipTranslation = true, t3.drawMode = "TRIANGLES", M[0].node && M[0].node.levelDynamic && M.sort((e4, t4) => {
                if (e4.node) {
                  if (e4.node.levelDynamic > t4.node.levelDynamic) return 1;
                  if (e4.node.levelDynamic < t4.node.levelDynamic) return -1;
                }
                return 0;
              }), M.forEach((t4) => {
                let i4, s3;
                let r3 = t4.plotY;
                if (void 0 !== r3 && !isNaN(r3) && null !== t4.y && t4.shapeArgs) {
                  let { x: r4 = 0, y: o3 = 0, width: l3 = 0, height: h3 = 0 } = t4.shapeArgs;
                  i4 = (s3 = a2.styledMode ? t4.series.colorAttribs(t4) : s3 = t4.series.pointAttribs(t4))["stroke-width"] || 0, ee = n(s3.fill).rgba, ee[0] /= 255, ee[1] /= 255, ee[2] /= 255, e3.is("treemap") && (i4 = i4 || 1, X = n(s3.stroke).rgba, X[0] /= 255, X[1] /= 255, X[2] /= 255, eu(r4, o3, l3, h3, X), i4 /= 2), e3.is("heatmap") && a2.inverted && (r4 = f2.len - r4, o3 = u2.len - o3, l3 = -l3, h3 = -h3), eu(r4 + i4, o3 + i4, l3 - 2 * i4, h3 - 2 * i4, ee);
                }
              }), ed();
              return;
            }
            for (; q < C.length - 1; ) {
              if (void 0 === (H = C[++q])) continue;
              if (R) break;
              let i4 = m2 && m2[q];
              if (!k && d(i4, true) && i4.color && (ee = n(i4.color).rgba, ee[0] /= 255, ee[1] /= 255, ee[2] /= 255), k ? (F = H[0], W = H[1], C[q + 1] && (K = C[q + 1][0]), C[q - 1] && (Z = C[q - 1][0]), H.length >= 3 && (Y = H[2], H[2] > t3.zMax && (t3.zMax = H[2]), H[2] < t3.zMin && (t3.zMin = H[2]))) : (F = H, W = T[q], C[q + 1] && (K = C[q + 1]), C[q - 1] && (Z = C[q - 1]), E && E.length && (Y = E[q], E[q] > t3.zMax && (t3.zMax = E[q]), E[q] < t3.zMin && (t3.zMin = E[q]))), !S && (null === F || null === W)) {
                ef();
                continue;
              }
              if (K && K >= b2 && K <= x && (J = true), Z && Z >= b2 && Z <= x && ($ = true), o2 ? (k && (W = H.slice(1, 3)), Q = W[0], W = W[1]) : g2 && (F = H.x, Q = (W = H.stackY) - H.y), null != y && null != P && (ei = W >= y && W <= P), F > x && w.x < x && (w.x = F, w.y = W), F < b2 && U.x > b2 && (U.x = F, U.y = W), null !== W || !S) {
                if (null === W || !ei && !J && !$) {
                  ef();
                  continue;
                }
                if (h2 && (K >= b2 || F >= b2) && (Z <= x || F <= x) && (et = true), et || J || $) {
                  if (en && F - Z > en && ef(), L) {
                    let e4;
                    L.some((t4, i5) => {
                      let s3 = L[i5 - 1];
                      return "x" === D ? void 0 !== t4.value && F <= t4.value && (er[i5] && (!s3 || F >= s3.value) && (e4 = er[i5]), true) : void 0 !== t4.value && W <= t4.value && (er[i5] && (!s3 || W >= s3.value) && (e4 = er[i5]), true);
                    }), ee = e4 || eo || ee;
                  }
                  if (s2.useGPUTranslations || (t3.skipTranslation = true, F = f2.toPixels(F, true), W = u2.toPixels(W, true), !(F > G) || "POINTS" !== t3.drawMode)) {
                    if (t3.hasMarkers && et && false !== N && (e3.closestPointRangePx = Math.min(e3.closestPointRangePx, Math.abs(F - N))), !s2.useGPUTranslations && !s2.usePreallocated && N && 1 > Math.abs(F - N) && I && 1 > Math.abs(W - I)) {
                      s2.debug.showSkipSummary && ++V;
                      continue;
                    }
                    B && (O = Q, (false === Q || void 0 === Q) && (O = W < 0 ? W : 0), (o2 || g2) && !u2.logarithmic || (O = Math.max(null === z ? y : z, y)), s2.useGPUTranslations || (O = u2.toPixels(O, true)), eh(F, O, 0, 0, ee)), l2.step && !es && eh(F, I, 0, 2, ee), eh(F, W, 0, "bubble" === e3.type ? Y || 1 : 2, ee), N = F, I = W, j = true, es = false;
                  }
                }
              }
            }
            s2.debug.showSkipSummary && console.log("skipped points:", V);
            let eg = (e4, i4) => {
              if (s2.useGPUTranslations || (t3.skipTranslation = true, e4.x = f2.toPixels(e4.x, true), e4.y = u2.toPixels(e4.y, true)), i4) {
                this.data = [e4.x, e4.y, 0, 2].concat(this.data);
                return;
              }
              eh(e4.x, e4.y, 0, 2);
            };
            !j && false !== S && "line_strip" === e3.drawMode && (U.x < Number.MAX_VALUE && eg(U, true), w.x > -Number.MAX_VALUE && eg(w)), ed();
          }
          pushSeries(e3) {
            let t3 = this.markerData, i3 = this.series, r2 = this.settings;
            i3.length > 0 && i3[i3.length - 1].hasMarkers && (i3[i3.length - 1].markerTo = t3.length), r2.debug.timeSeriesProcessing && console.time("building " + e3.type + " series");
            let o2 = { segments: [], markerFrom: t3.length, colorData: [], series: e3, zMin: Number.MAX_VALUE, zMax: -Number.MAX_VALUE, hasMarkers: !!e3.options.marker && false !== e3.options.marker.enabled, showMarkers: true, drawMode: s[e3.type] || "LINE_STRIP" };
            e3.index >= i3.length ? i3.push(o2) : i3[e3.index] = o2, this.pushSeriesData(e3, o2), r2.debug.timeSeriesProcessing && console.timeEnd("building " + e3.type + " series");
          }
          flush() {
            let e3 = this.vbuffer;
            this.data = [], this.markerData = [], this.series = [], e3 && e3.destroy();
          }
          setXAxis(e3) {
            let t3 = this.shader;
            if (!t3) return;
            let i3 = this.getPixelRatio();
            t3.setUniform("xAxisTrans", e3.transA * i3), t3.setUniform("xAxisMin", e3.min), t3.setUniform("xAxisMinPad", e3.minPixelPadding * i3), t3.setUniform("xAxisPointRange", e3.pointRange), t3.setUniform("xAxisLen", e3.len * i3), t3.setUniform("xAxisPos", e3.pos * i3), t3.setUniform("xAxisCVSCoord", !e3.horiz), t3.setUniform("xAxisIsLog", !!e3.logarithmic), t3.setUniform("xAxisReversed", !!e3.reversed);
          }
          setYAxis(e3) {
            let t3 = this.shader;
            if (!t3) return;
            let i3 = this.getPixelRatio();
            t3.setUniform("yAxisTrans", e3.transA * i3), t3.setUniform("yAxisMin", e3.min), t3.setUniform("yAxisMinPad", e3.minPixelPadding * i3), t3.setUniform("yAxisPointRange", e3.pointRange), t3.setUniform("yAxisLen", e3.len * i3), t3.setUniform("yAxisPos", e3.pos * i3), t3.setUniform("yAxisCVSCoord", !e3.horiz), t3.setUniform("yAxisIsLog", !!e3.logarithmic), t3.setUniform("yAxisReversed", !!e3.reversed);
          }
          setThreshold(e3, t3) {
            let i3 = this.shader;
            i3 && (i3.setUniform("hasThreshold", e3), i3.setUniform("translatedThreshold", t3));
          }
          renderChart(i3) {
            let s2 = this.gl, r2 = this.settings, a2 = this.shader, l2 = this.vbuffer, d2 = this.getPixelRatio();
            if (!i3) return false;
            this.width = i3.chartWidth * d2, this.height = i3.chartHeight * d2;
            let f2 = this.height, u2 = this.width;
            if (!s2 || !a2 || !u2 || !f2) return false;
            r2.debug.timeRendering && console.time("gl rendering"), s2.canvas.width = u2, s2.canvas.height = f2, a2.bind(), s2.viewport(0, 0, u2, f2), a2.setPMatrix(b.orthoMatrix(u2, f2)), r2.lineWidth > 1 && !t2.isMS && s2.lineWidth(r2.lineWidth), l2 && (l2.build(this.data, "aVertexPosition", 4), l2.bind()), a2.setInverted(i3.inverted), this.series.forEach((t3, f3) => {
              var _a, _b, _c;
              let u3 = t3.series.options, c2 = u3.marker, p2 = void 0 !== u3.lineWidth ? u3.lineWidth : 1, b2 = u3.threshold, x = h(b2), A = t3.series.yAxis.getThreshold(b2), y = g(u3.marker ? u3.marker.enabled : null, !!t3.series.xAxis.isRadial || null, t3.series.closestPointRangePx > 2 * ((u3.marker ? u3.marker.radius : 10) || 10)), P = this.textureHandles[c2 && c2.symbol || t3.series.symbol] || this.textureHandles.circle, v, T, E, k = [];
              if (0 !== t3.segments.length && t3.segments[0].from !== t3.segments[0].to && (P.isReady && (s2.bindTexture(s2.TEXTURE_2D, P.handle), a2.setTexture(P.handle)), i3.styledMode ? t3.series.markerGroup === ((_a = t3.series.chart.boost) == null ? void 0 : _a.markerGroup) ? (delete t3.series.markerGroup, t3.series.markerGroup = t3.series.plotGroup("markerGroup", "markers", "visible", 1, i3.seriesGroup).addClass("highcharts-tracker"), E = t3.series.markerGroup.getStyle("fill"), t3.series.markerGroup.destroy(), t3.series.markerGroup = (_b = t3.series.chart.boost) == null ? void 0 : _b.markerGroup) : E = (_c = t3.series.markerGroup) == null ? void 0 : _c.getStyle("fill") : (E = "POINTS" === t3.drawMode && t3.series.pointAttribs && t3.series.pointAttribs().fill || t3.series.color, u3.colorByPoint && (E = t3.series.chart.options.colors[f3])), t3.series.fillOpacity && u3.fillOpacity && (E = new e2(E).setOpacity(g(u3.fillOpacity, 1)).get()), k = n(E).rgba, r2.useAlpha || (k[3] = 1), "add" === u3.boostBlending ? (s2.blendFunc(s2.SRC_ALPHA, s2.ONE), s2.blendEquation(s2.FUNC_ADD)) : "mult" === u3.boostBlending || "multiply" === u3.boostBlending ? s2.blendFunc(s2.DST_COLOR, s2.ZERO) : "darken" === u3.boostBlending ? (s2.blendFunc(s2.ONE, s2.ONE), s2.blendEquation(s2.FUNC_MIN)) : s2.blendFuncSeparate(s2.SRC_ALPHA, s2.ONE_MINUS_SRC_ALPHA, s2.ONE, s2.ONE_MINUS_SRC_ALPHA), a2.reset(), t3.colorData.length > 0 ? (a2.setUniform("hasColor", 1), (T = new o(s2, a2)).build(Array(t3.segments[0].from).concat(t3.colorData), "aColor", 4), T.bind()) : (a2.setUniform("hasColor", 0), s2.disableVertexAttribArray(s2.getAttribLocation(a2.getProgram(), "aColor"))), a2.setColor(k), this.setXAxis(t3.series.xAxis), this.setYAxis(t3.series.yAxis), this.setThreshold(x, A), "POINTS" === t3.drawMode && a2.setPointSize(2 * g(u3.marker && u3.marker.radius, 0.5) * d2), a2.setSkipTranslation(t3.skipTranslation), "bubble" === t3.series.type && a2.setBubbleUniforms(t3.series, t3.zMin, t3.zMax, d2), a2.setDrawAsCircle(m[t3.series.type] || false), l2)) {
                if (p2 > 0 || "LINE_STRIP" !== t3.drawMode) for (v = 0; v < t3.segments.length; v++) l2.render(t3.segments[v].from, t3.segments[v].to, t3.drawMode);
                if (t3.hasMarkers && y) for (a2.setPointSize(2 * g(u3.marker && u3.marker.radius, 5) * d2), a2.setDrawAsCircle(true), v = 0; v < t3.segments.length; v++) l2.render(t3.segments[v].from, t3.segments[v].to, "POINTS");
              }
            }), r2.debug.timeRendering && console.timeEnd("gl rendering"), this.postRenderCallback && this.postRenderCallback(this), this.flush();
          }
          render(e3) {
            if (this.clear(), e3.renderer.forExport) return this.renderChart(e3);
            this.isInited ? this.renderChart(e3) : setTimeout(() => {
              this.render(e3);
            }, 1);
          }
          setSize(e3, t3) {
            let i3 = this.shader;
            i3 && (this.width !== e3 || this.height !== t3) && (this.width = e3, this.height = t3, i3.bind(), i3.setPMatrix(b.orthoMatrix(e3, t3)));
          }
          init(e3, t3) {
            let i3 = this.settings;
            if (this.isInited = false, !e3) return false;
            i3.debug.timeSetup && console.time("gl setup");
            for (let t4 = 0; t4 < p.length && (this.gl = e3.getContext(p[t4], {}), !this.gl); ++t4) ;
            let s2 = this.gl;
            if (!s2) return false;
            t3 || this.flush(), s2.enable(s2.BLEND), s2.blendFunc(s2.SRC_ALPHA, s2.ONE_MINUS_SRC_ALPHA), s2.disable(s2.DEPTH_TEST), s2.depthFunc(s2.LESS);
            let n2 = this.shader = new r(s2);
            if (!n2) return false;
            this.vbuffer = new o(s2, n2);
            let l2 = (e4, t4) => {
              let i4 = { isReady: false, texture: a.createElement("canvas"), handle: s2.createTexture() }, r2 = i4.texture.getContext("2d");
              this.textureHandles[e4] = i4, i4.texture.width = 512, i4.texture.height = 512, r2.mozImageSmoothingEnabled = false, r2.webkitImageSmoothingEnabled = false, r2.msImageSmoothingEnabled = false, r2.imageSmoothingEnabled = false, r2.strokeStyle = "rgba(255, 255, 255, 0)", r2.fillStyle = "#FFF", t4(r2);
              try {
                s2.activeTexture(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, i4.handle), s2.texImage2D(s2.TEXTURE_2D, 0, s2.RGBA, s2.RGBA, s2.UNSIGNED_BYTE, i4.texture), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, s2.CLAMP_TO_EDGE), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, s2.CLAMP_TO_EDGE), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, s2.LINEAR), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, s2.LINEAR), s2.bindTexture(s2.TEXTURE_2D, null), i4.isReady = true;
              } catch (e5) {
              }
            };
            return l2("circle", (e4) => {
              e4.beginPath(), e4.arc(256, 256, 256, 0, 2 * Math.PI), e4.stroke(), e4.fill();
            }), l2("square", (e4) => {
              e4.fillRect(0, 0, 512, 512);
            }), l2("diamond", (e4) => {
              e4.beginPath(), e4.moveTo(256, 0), e4.lineTo(512, 256), e4.lineTo(256, 512), e4.lineTo(0, 256), e4.lineTo(256, 0), e4.fill();
            }), l2("triangle", (e4) => {
              e4.beginPath(), e4.moveTo(0, 512), e4.lineTo(256, 0), e4.lineTo(512, 512), e4.lineTo(0, 512), e4.fill();
            }), l2("triangle-down", (e4) => {
              e4.beginPath(), e4.moveTo(0, 0), e4.lineTo(256, 512), e4.lineTo(512, 0), e4.lineTo(0, 0), e4.fill();
            }), this.isInited = true, i3.debug.timeSetup && console.timeEnd("gl setup"), true;
          }
          destroy() {
            let e3 = this.gl, t3 = this.shader, i3 = this.vbuffer;
            this.flush(), i3 && i3.destroy(), t3 && t3.destroy(), e3 && (u(this.textureHandles, (t4) => {
              t4.handle && e3.deleteTexture(t4.handle);
            }), e3.canvas.width = 1, e3.canvas.height = 1);
          }
        }
        return b;
      }), i(t, "Extensions/Boost/BoostSeries.js", [t["Extensions/Boost/BoostableMap.js"], t["Extensions/Boost/Boostables.js"], t["Extensions/Boost/BoostChart.js"], t["Core/Defaults.js"], t["Core/Globals.js"], t["Core/Utilities.js"], t["Extensions/Boost/WGLRenderer.js"]], function(e2, t2, i2, s, r, o, n) {
        let a, l;
        let { getBoostClipRect: h, isChartSeriesBoosting: d } = i2, { getOptions: f } = s, { composed: u, doc: g, noop: c, win: m } = r, { addEvent: p, destroyObjectProperties: b, error: x, extend: A, fireEvent: y, isArray: P, isNumber: v, pick: T, pushUnique: E, wrap: k, defined: S } = o;
        function M(e3, t3) {
          let i3 = t3.boost;
          e3 && i3 && i3.target && i3.canvas && !d(t3.chart) && e3.allocateBufferForSingleSeries(t3);
        }
        function C(e3) {
          return T(e3 && e3.options && e3.options.boost && e3.options.boost.enabled, true);
        }
        function U(e3, t3) {
          var _a, _b, _c;
          let i3 = e3.constructor, s2 = e3.seriesGroup || t3.group, r2 = e3.chartWidth, o2 = e3.chartHeight, a2 = e3, f2 = "undefined" != typeof SVGForeignObjectElement, u2 = false;
          d(e3) ? a2 = e3 : (a2 = t3, u2 = !!(((_a = t3.options.events) == null ? void 0 : _a.click) || ((_c = (_b = t3.options.point) == null ? void 0 : _b.events) == null ? void 0 : _c.click)));
          let c2 = a2.boost = a2.boost || {};
          if (f2 = false, l || (l = g.createElement("canvas")), !c2.target && (c2.canvas = l, e3.renderer.forExport || !f2 ? (a2.renderTarget = c2.target = e3.renderer.image("", 0, 0, r2, o2).addClass("highcharts-boost-canvas").add(s2), c2.clear = function() {
            c2.target.attr({ href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" });
          }, c2.copy = function() {
            c2.resize(), c2.target.attr({ href: c2.canvas.toDataURL("image/png") });
          }) : (c2.targetFo = e3.renderer.createElement("foreignObject").add(s2), a2.renderTarget = c2.target = g.createElement("canvas"), c2.targetCtx = c2.target.getContext("2d"), c2.targetFo.element.appendChild(c2.target), c2.clear = function() {
            c2.target.width = c2.canvas.width, c2.target.height = c2.canvas.height;
          }, c2.copy = function() {
            c2.target.width = c2.canvas.width, c2.target.height = c2.canvas.height, c2.targetCtx.drawImage(c2.canvas, 0, 0);
          }), c2.resize = function() {
            var _a2, _b2;
            r2 = e3.chartWidth, o2 = e3.chartHeight, (c2.targetFo || c2.target).attr({ x: 0, y: 0, width: r2, height: o2 }).css({ pointerEvents: u2 ? void 0 : "none", mixedBlendMode: "normal", opacity: 1 }).addClass(u2 ? "highcharts-tracker" : ""), a2 instanceof i3 && ((_b2 = (_a2 = a2.boost) == null ? void 0 : _a2.markerGroup) == null ? void 0 : _b2.translate(e3.plotLeft, e3.plotTop));
          }, c2.clipRect = e3.renderer.clipRect(), (c2.targetFo || c2.target).attr({ zIndex: t3.options.zIndex }), a2 instanceof i3 && (a2.boost.markerGroup = a2.renderer.g().add(s2).translate(t3.xAxis.pos, t3.yAxis.pos))), c2.canvas.width = r2, c2.canvas.height = o2, c2.clipRect) {
            let t4 = h(e3, a2), i4 = t4.width === e3.clipBox.width && t4.height === e3.clipBox.height ? s2 : c2.targetFo || c2.target;
            c2.clipRect.attr(t4), i4 == null ? void 0 : i4.clip(c2.clipRect);
          }
          return c2.resize(), c2.clear(), !c2.wgl && (c2.wgl = new n((e4) => {
            e4.settings.debug.timeBufferCopy && console.time("buffer copy"), c2.copy(), e4.settings.debug.timeBufferCopy && console.timeEnd("buffer copy");
          }), c2.wgl.init(c2.canvas) || x("[highcharts boost] - unable to init WebGL renderer"), c2.wgl.setOptions(e3.options.boost || {}), a2 instanceof i3 && c2.wgl.allocateBuffer(e3)), c2.wgl.setSize(r2, o2), c2.wgl;
        }
        function w(e3) {
          let t3 = e3.points;
          if (t3) {
            let e4, i3;
            for (i3 = 0; i3 < t3.length; i3 += 1) (e4 = t3[i3]) && e4.destroyElements && e4.destroyElements();
          }
          for (let t4 of (["graph", "area", "tracker"].forEach((t5) => {
            let i3 = e3[t5];
            i3 && (e3[t5] = i3.destroy());
          }), e3.zones)) b(t4, void 0, true);
        }
        function R(e3, t3, i3, s2, r2, o2) {
          let n2 = (r2 = r2 || 0) + (s2 = s2 || 3e3), a2 = true;
          for (; a2 && r2 < n2 && r2 < e3.length; ) a2 = t3(e3[r2], r2), ++r2;
          a2 && (r2 < e3.length ? o2 ? R(e3, t3, i3, s2, r2, o2) : m.requestAnimationFrame ? m.requestAnimationFrame(function() {
            R(e3, t3, i3, s2, r2);
          }) : setTimeout(R, 0, e3, t3, i3, s2, r2) : i3 && i3());
        }
        function B(e3, t3) {
          let i3 = e3.options, s2 = i3.data, r2 = e3.xAxis && e3.xAxis.options, o2 = e3.yAxis && e3.yAxis.options, n2 = e3.colorAxis && e3.colorAxis.options;
          return s2.length > (i3.boostThreshold || Number.MAX_VALUE) && v(o2.min) && v(o2.max) && (!t3 || v(r2.min) && v(r2.max)) && (!n2 || v(n2.min) && v(n2.max));
        }
        let D = (e3, t3) => !e3.forceCrop && (d(e3.chart) || (t3 ? t3.length : 0) >= (e3.options.boostThreshold || Number.MAX_VALUE));
        function L() {
          let e3 = this, t3 = e3.chart;
          t3.boost && t3.boost.markerGroup === e3.markerGroup && (e3.markerGroup = null), t3.hoverPoints && (t3.hoverPoints = t3.hoverPoints.filter(function(t4) {
            return t4.series === e3;
          })), t3.hoverPoint && t3.hoverPoint.series === e3 && (t3.hoverPoint = null);
        }
        function z() {
          let e3 = this.boost;
          e3 && e3.canvas && e3.target && (e3.wgl && e3.wgl.clear(), e3.clear && e3.clear());
        }
        function _(e3) {
          let t3 = e3.boost;
          t3 && t3.canvas && t3.target && t3.wgl && !d(e3.chart) && t3.wgl.render(e3.chart);
        }
        function G(e3, t3) {
          let i3 = e3.options, s2 = e3.xAxis, r2 = e3.pointClass;
          if (t3 instanceof r2) return t3;
          let o2 = e3.xData || i3.xData || e3.processedXData || false, n2 = new r2(e3, (e3.options.data || [])[t3.i], o2 ? o2[t3.i] : void 0);
          return n2.category = T(s2.categories ? s2.categories[n2.x] : n2.x, n2.x), n2.dist = t3.dist, n2.distX = t3.distX, n2.plotX = t3.plotX, n2.plotY = t3.plotY, n2.index = t3.i, n2.percentage = t3.percentage, n2.isInside = e3.isPointInside(n2), n2;
        }
        function N(e3) {
          var t3, i3, s2, r2;
          let { options: o2, xAxis: n2, yAxis: a2 } = this;
          if (!this.isDirty && !n2.isDirty && !a2.isDirty && !e3) return false;
          this.yAxis.setTickInterval();
          let l2 = o2.boostThreshold || 0, h2 = o2.cropThreshold, d2 = o2.data || this.data, f2 = this.xData, u2 = n2.getExtremes(), g2 = u2.max ?? Number.MAX_VALUE, c2 = u2.min ?? -Number.MAX_VALUE, m2 = this.yData, p2 = a2.getExtremes(), b2 = p2.max ?? Number.MAX_VALUE, x2 = p2.min ?? -Number.MAX_VALUE;
          if (!this.boosted && n2.old && a2.old && c2 >= (n2.old.min ?? -Number.MAX_VALUE) && g2 <= (n2.old.max ?? Number.MAX_VALUE) && x2 >= (a2.old.min ?? -Number.MAX_VALUE) && b2 <= (a2.old.max ?? Number.MAX_VALUE)) return this.processedXData ?? (this.processedXData = f2), this.processedYData ?? (this.processedYData = m2), true;
          if (!l2 || d2.length < l2 || h2 && !this.forceCrop && !this.getExtremesFromAll && !o2.getExtremesFromAll && d2.length < h2) return this.processedXData = f2, this.processedYData = m2, true;
          let A2 = [], y2 = [], P2 = [], T2 = !(v(u2.max) || v(u2.min)), E2 = !(v(p2.max) || v(p2.min)), k2 = false, S2, M2 = f2[0], C2 = f2[0], U2, w2 = m2[0], R2 = m2[0];
          for (let e4 = 0, t4 = f2.length; e4 < t4; ++e4) S2 = f2[e4], U2 = m2[e4], S2 >= c2 && S2 <= g2 && U2 >= x2 && U2 <= b2 ? (A2.push({ x: S2, y: U2 }), y2.push(S2), P2.push(U2), T2 && (M2 = Math.max(M2, S2), C2 = Math.min(C2, S2)), E2 && (w2 = Math.max(w2, U2), R2 = Math.min(R2, U2))) : k2 = true;
          return T2 && ((t3 = n2.options).max ?? (t3.max = M2), (i3 = n2.options).min ?? (i3.min = C2)), E2 && ((s2 = a2.options).max ?? (s2.max = w2), (r2 = a2.options).min ?? (r2.min = R2)), this.cropped = k2, this.cropStart = 0, this.processedXData = y2, this.processedYData = P2, D(this, y2) || (this.processedData = A2), true;
        }
        function I() {
          let e3 = this.options || {}, t3 = this.chart, i3 = t3.boost, s2 = this.boost, r2 = this.xAxis, o2 = this.yAxis, n2 = e3.xData || this.processedXData, l2 = e3.yData || this.processedYData, h2 = this.processedData || e3.data, f2 = r2.getExtremes(), u2 = f2.min - (r2.minPointOffset || 0), g2 = f2.max + (r2.minPointOffset || 0), m2 = o2.getExtremes(), p2 = m2.min - (o2.minPointOffset || 0), b2 = m2.max + (o2.minPointOffset || 0), x2 = {}, A2 = !!this.sampling, P2 = e3.enableMouseTracking, v2 = e3.threshold, E2 = this.pointArrayMap && "low,high" === this.pointArrayMap.join(","), k2 = !!e3.stacking, C2 = this.cropStart || 0, B2 = this.requireSorting, D2 = !n2, L2 = "x" === e3.findNearestPointBy, z2 = this.xData || this.options.xData || this.processedXData || false, G2 = T(e3.lineWidth, 1), N2 = false, I2, O2 = o2.getThreshold(v2), X2, V2, j2, F;
          if (r2.isPanning || o2.isPanning || (N2 = U(t3, this), t3.boosted = true, !this.visible)) return;
          (this.points || this.graph) && w(this), d(t3) ? (this.markerGroup && this.markerGroup !== (i3 == null ? void 0 : i3.markerGroup) && this.markerGroup.destroy(), this.markerGroup = i3 == null ? void 0 : i3.markerGroup, s2 && s2.target && (this.renderTarget = s2.target = s2.target.destroy())) : (this.markerGroup === (i3 == null ? void 0 : i3.markerGroup) && (this.markerGroup = void 0), this.markerGroup = this.plotGroup("markerGroup", "markers", "visible", 1, t3.seriesGroup).addClass("highcharts-tracker"));
          let W = this.points = [], H = (e4, i4, s3, n3) => {
            let l3 = !!z2 && z2[C2 + s3], h3 = (e5) => {
              t3.inverted && (e5 = r2.len - e5, i4 = o2.len - i4), W.push({ destroy: c, x: l3, clientX: e5, plotX: e5, plotY: i4, i: C2 + s3, percentage: n3 });
            };
            e4 = Math.ceil(e4), a = L2 ? e4 : e4 + "," + i4, P2 && (x2[a] ? l3 === z2[z2.length - 1] && (W.length--, h3(e4)) : (x2[a] = true, h3(e4)));
          };
          this.buildKDTree = c, y(this, "renderCanvas"), this.is("line") && G2 > 1 && (s2 == null ? void 0 : s2.target) && i3 && !i3.lineWidthFilter && (i3.lineWidthFilter = t3.renderer.definition({ tagName: "filter", children: [{ tagName: "feMorphology", attributes: { operator: "dilate", radius: 0.25 * G2 } }], attributes: { id: "linewidth" } }), s2.target.attr({ filter: "url(#linewidth)" })), N2 && (M(N2, this), N2.pushSeries(this), _(this));
          let Y = N2.settings;
          t3.renderer.forExport || (Y.debug.timeKDTree && console.time("kd tree building"), R(k2 ? this.data.slice(C2) : n2 || h2, function(e4, i4) {
            let s3 = void 0 === t3.index, n3, a2, h3, d2, f3, c2 = false, m3 = true;
            return !S(e4) || (!s3 && (D2 ? (n3 = e4[0], a2 = e4[1]) : (n3 = e4, a2 = l2[i4]), E2 ? (D2 && (a2 = e4.slice(1, 3)), c2 = a2[0], a2 = a2[1]) : k2 && (n3 = e4.x, c2 = (a2 = e4.stackY) - e4.y, f3 = e4.percentage), B2 || (m3 = (a2 || 0) >= p2 && a2 <= b2), null !== a2 && n3 >= u2 && n3 <= g2 && m3 && (h3 = r2.toPixels(n3, true), A2 ? ((void 0 === j2 || h3 === I2) && (E2 || (c2 = a2), (void 0 === F || a2 > V2) && (V2 = a2, F = i4), (void 0 === j2 || c2 < X2) && (X2 = c2, j2 = i4)), L2 && h3 === I2 || (void 0 !== j2 && (d2 = o2.toPixels(V2, true), O2 = o2.toPixels(X2, true), H(h3, d2, F, f3), O2 !== d2 && H(h3, O2, j2, f3)), j2 = F = void 0, I2 = h3)) : H(h3, d2 = Math.ceil(o2.toPixels(a2, true)), i4, f3))), !s3);
          }, () => {
            y(this, "renderedCanvas"), delete this.buildKDTree, this.options && this.buildKDTree(), Y.debug.timeKDTree && console.timeEnd("kd tree building");
          }));
        }
        function O(e3) {
          let t3 = true;
          if (this.chart.options && this.chart.options.boost && (t3 = void 0 === this.chart.options.boost.enabled || this.chart.options.boost.enabled), !t3 || !this.boosted) return e3.call(this);
          this.chart.boosted = true;
          let i3 = U(this.chart, this);
          i3 && (M(i3, this), i3.pushSeries(this)), _(this);
        }
        function X(e3) {
          if (this.boosted) {
            if (B(this)) return {};
            if (this.xAxis.isPanning || this.yAxis.isPanning) return this;
          }
          return e3.apply(this, [].slice.call(arguments, 1));
        }
        function V(t3) {
          var _a, _b;
          let i3 = this.options.data;
          if (C(this.chart) && e2[this.type]) {
            let e3 = this.is("scatter") && !this.is("bubble") && !this.is("heatmap");
            if (!D(this, i3) || e3 || this.options.stacking || !B(this, true)) {
              if (this.boosted && (((_a = this.xAxis) == null ? void 0 : _a.isPanning) || ((_b = this.yAxis) == null ? void 0 : _b.isPanning))) return;
              e3 && !this.yAxis.treeGrid ? N.call(this, arguments[1]) : t3.apply(this, [].slice.call(arguments, 1)), i3 = this.processedXData;
            }
            if (this.boosted = D(this, i3), this.boosted) {
              let e4;
              this.options.data && this.options.data.length && !v(e4 = this.getFirstValidPoint(this.options.data)) && !P(e4) && x(12, false, this.chart), function(e5) {
                var _a2;
                e5.boost = e5.boost || { getPoint: (t5) => G(e5, t5) };
                let t4 = e5.boost.altered = [];
                if (["allowDG", "directTouch", "stickyTracking"].forEach((i4) => {
                  t4.push({ prop: i4, val: e5[i4], own: Object.hasOwnProperty.call(e5, i4) });
                }), e5.allowDG = false, e5.directTouch = false, e5.stickyTracking = true, e5.finishedAnimating = true, e5.labelBySeries && (e5.labelBySeries = e5.labelBySeries.destroy()), e5.is("scatter") && e5.data.length) {
                  for (let t5 of e5.data) (_a2 = t5 == null ? void 0 : t5.destroy) == null ? void 0 : _a2.call(t5);
                  e5.data.length = 0, e5.points.length = 0, delete e5.processedData;
                }
              }(this);
            } else !function(e4) {
              let t4 = e4.boost, i4 = e4.chart, s2 = i4.boost;
              if (s2 == null ? void 0 : s2.markerGroup) for (let e5 of (s2.markerGroup.destroy(), s2.markerGroup = void 0, i4.series)) e5.markerGroup = void 0, e5.markerGroup = e5.plotGroup("markerGroup", "markers", "visible", 1, i4.seriesGroup).addClass("highcharts-tracker");
              t4 && ((t4.altered || []).forEach((t5) => {
                t5.own ? e4[t5.prop] = t5.val : delete e4[t5.prop];
              }), t4.clear && t4.clear());
            }(this);
          } else t3.apply(this, [].slice.call(arguments, 1));
        }
        function j(e3) {
          let t3 = e3.apply(this, [].slice.call(arguments, 1));
          return this.boost && t3 ? this.boost.getPoint(t3) : t3;
        }
        return { compose: function(i3, s2, r2) {
          if (E(u, "Boost.Series")) {
            let o2 = f().plotOptions, n2 = i3.prototype;
            if (p(i3, "destroy", L), p(i3, "hide", z), r2 && (n2.renderCanvas = I), k(n2, "getExtremes", X), k(n2, "processData", V), k(n2, "searchPoint", j), ["translate", "generatePoints", "drawTracker", "drawPoints", "render"].forEach((t3) => function(t4, i4, s3) {
              function r3(t5) {
                let i5 = this.options.stacking && ("translate" === s3 || "generatePoints" === s3);
                this.boosted && !i5 && C(this.chart) && "heatmap" !== this.type && "treemap" !== this.type && e2[this.type] && 0 !== this.options.boostThreshold ? "render" === s3 && this.renderCanvas && this.renderCanvas() : t5.call(this);
              }
              if (k(t4, s3, r3), "translate" === s3) for (let e3 of ["column", "arearange", "columnrange", "heatmap", "treemap"]) i4[e3] && k(i4[e3].prototype, s3, r3);
            }(n2, s2, t3)), t2.forEach((e3) => {
              let t3 = o2[e3];
              t3 && (t3.boostThreshold = 5e3, t3.boostData = [], s2[e3].prototype.fillOpacity = true);
            }), r2) {
              let { area: e3, areaspline: t3, bubble: i4, column: r3, heatmap: o3, scatter: n3, treemap: a2 } = s2;
              if (e3 && A(e3.prototype, { fill: true, fillOpacity: true, sampling: true }), t3 && A(t3.prototype, { fill: true, fillOpacity: true, sampling: true }), i4) {
                let e4 = i4.prototype;
                delete e4.buildKDTree, k(e4, "markerAttribs", function(e5) {
                  return !this.boosted && e5.apply(this, [].slice.call(arguments, 1));
                });
              }
              r3 && A(r3.prototype, { fill: true, sampling: true }), n3 && (n3.prototype.fill = true), [o3, a2].forEach((e4) => {
                e4 && k(e4.prototype, "drawPoints", O);
              });
            }
          }
          return i3;
        }, destroyGraphics: w, eachAsync: R, getPoint: G };
      }), i(t, "Extensions/Boost/NamedColors.js", [], function() {
        return { defaultHTMLColorMap: { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", feldspar: "#d19275", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslateblue: "#8470ff", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", violetred: "#d02090", wheat: "#f5deb3", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" } };
      }), i(t, "Extensions/Boost/Boost.js", [t["Extensions/Boost/BoostChart.js"], t["Extensions/Boost/BoostSeries.js"], t["Core/Globals.js"], t["Extensions/Boost/NamedColors.js"], t["Core/Utilities.js"]], function(e2, t2, i2, s, r) {
        let { doc: o, win: n } = i2, { addEvent: a, error: l } = r, h = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
        function d() {
          let e3;
          if (void 0 !== n.WebGLRenderingContext) {
            e3 = o.createElement("canvas");
            for (let t3 = 0; t3 < h.length; ++t3) try {
              if (null != e3.getContext(h[t3])) return true;
            } catch (e4) {
            }
          }
          return false;
        }
        return { compose: function(r2, o2, n2, h2, f) {
          let u = d();
          u || (void 0 !== i2.initCanvasBoost ? i2.initCanvasBoost() : l(26)), f && !f.names.lightgoldenrodyellow && (f.names = { ...f.names, ...s.defaultHTMLColorMap }), e2.compose(r2, u), t2.compose(n2, h2, u), a(o2, "setExtremes", function(e3) {
            for (let t3 of [this.chart, ...this.series].map((e4) => e4.renderTarget).filter(Boolean)) {
              let { horiz: i3, pos: s2 } = this, r3 = i3 ? "scaleX" : "scaleY", o3 = i3 ? "translateX" : "translateY", n3 = (t3 == null ? void 0 : t3[r3]) ?? 1, a2 = 1, l2 = 0, h3 = 1, d2 = "none";
              this.isPanning && (a2 = (e3.scale ?? 1) * n3, l2 = ((t3 == null ? void 0 : t3[o3]) || 0) - a2 * (e3.move || 0) + n3 * s2 - a2 * s2, h3 = 0.7, d2 = "blur(3px)"), t3 == null ? void 0 : t3.attr({ [r3]: a2, [o3]: l2 }).css({ transition: "250ms filter, 250ms opacity", filter: d2, opacity: h3 });
            }
          });
        }, hasWebGLSupport: d };
      }), i(t, "masters/modules/boost.src.js", [t["Core/Globals.js"], t["Extensions/Boost/Boost.js"]], function(e2, t2) {
        return e2.hasWebGLSupport = t2.hasWebGLSupport, t2.compose(e2.Chart, e2.Axis, e2.Series, e2.seriesTypes, e2.Color), e2;
      });
    });
  }
});
export default require_boost();
//# sourceMappingURL=highcharts_modules_boost__js.js.map
