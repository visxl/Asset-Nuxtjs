import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/cylinder.js
var require_cylinder = __commonJS({
  "node_modules/highcharts/modules/cylinder.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Highcharts cylinder module
    *
    * (c) 2010-2024 Kacper Madej
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/cylinder", ["highcharts", "highcharts/highcharts-3d"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function r(t2, r2, s, i) {
        t2.hasOwnProperty(r2) || (t2[r2] = i.apply(null, s), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: r2, module: t2[r2] } })));
      }
      r(t, "Series/Cylinder/SVGElement3DCylinder.js", [t["Core/Color/Color.js"], t["Core/Renderer/RendererRegistry.js"]], function(e2, t2) {
        let { parse: r2 } = e2, { Element3D: s } = t2.getRendererType().prototype;
        return class extends s {
          constructor() {
            super(...arguments), this.parts = ["top", "bottom", "front", "back"], this.pathType = "cylinder";
          }
          fillSetter(e3) {
            return this.singleSetterForParts("fill", null, { front: e3, back: e3, top: r2(e3).brighten(0.1).get(), bottom: r2(e3).brighten(-0.1).get() }), this.color = this.fill = e3, this;
          }
        };
      }), r(t, "Series/Cylinder/CylinderComposition.js", [t["Core/Globals.js"], t["Core/Math3D.js"], t["Series/Cylinder/SVGElement3DCylinder.js"], t["Core/Utilities.js"]], function(e2, t2, r2, s) {
        let { charts: i, deg2rad: n } = e2, { perspective: o } = t2, { extend: l, pick: u } = s;
        function y(e3) {
          return !e3.some((e4) => "C" === e4[0]);
        }
        function d(e3) {
          return this.element3d("cylinder", e3);
        }
        function h(e3) {
          let t3 = i[this.chartIndex], r3 = this.cuboidPath(e3), s2 = !r3.isTop, n2 = !r3.isFront, o2 = this.getCylinderEnd(t3, e3), l2 = this.getCylinderEnd(t3, e3, true);
          return { front: this.getCylinderFront(o2, l2), back: this.getCylinderBack(o2, l2), top: o2, bottom: l2, zIndexes: { top: s2 ? 3 : 0, bottom: s2 ? 0 : 3, front: n2 ? 2 : 1, back: n2 ? 1 : 2, group: r3.zIndexes.group } };
        }
        function p(e3) {
          let t3 = [["M", e3[0].x, e3[0].y]], r3 = e3.length - 2;
          for (let s2 = 1; s2 < r3; s2 += 3) t3.push(["C", e3[s2].x, e3[s2].y, e3[s2 + 1].x, e3[s2 + 1].y, e3[s2 + 2].x, e3[s2 + 2].y]);
          return t3;
        }
        function c(e3, t3) {
          let r3 = [];
          if (y(e3)) {
            let t4 = e3[0], s2 = e3[2];
            "M" === t4[0] && "L" === s2[0] && (r3.push(["M", s2[1], s2[2]]), r3.push(e3[3]), r3.push(["L", t4[1], t4[2]]));
          } else "C" === e3[2][0] && r3.push(["M", e3[2][5], e3[2][6]]), r3.push(e3[3], e3[4]);
          if (y(t3)) {
            let e4 = t3[0];
            "M" === e4[0] && (r3.push(["L", e4[1], e4[2]]), r3.push(t3[3]), r3.push(t3[2]));
          } else {
            let e4 = t3[2], s2 = t3[3], i2 = t3[4];
            "C" === e4[0] && "C" === s2[0] && "C" === i2[0] && (r3.push(["L", i2[5], i2[6]]), r3.push(["C", i2[3], i2[4], i2[1], i2[2], s2[5], s2[6]]), r3.push(["C", s2[3], s2[4], s2[1], s2[2], e4[5], e4[6]]));
          }
          return r3.push(["Z"]), r3;
        }
        function C(e3, t3, r3) {
          let s2, i2;
          let { width: l2 = 0, height: y2 = 0, alphaCorrection: d2 = 0 } = t3, h2 = u(t3.depth, l2, 0), p2 = Math.min(l2, h2) / 2, c2 = n * (e3.options.chart.options3d.beta - 90 + d2), C2 = (t3.y || 0) + (r3 ? y2 : 0), a2 = 0.5519 * p2, f = l2 / 2 + (t3.x || 0), g = h2 / 2 + (t3.z || 0), m = [{ x: 0, y: C2, z: p2 }, { x: a2, y: C2, z: p2 }, { x: p2, y: C2, z: a2 }, { x: p2, y: C2, z: 0 }, { x: p2, y: C2, z: -a2 }, { x: a2, y: C2, z: -p2 }, { x: 0, y: C2, z: -p2 }, { x: -a2, y: C2, z: -p2 }, { x: -p2, y: C2, z: -a2 }, { x: -p2, y: C2, z: 0 }, { x: -p2, y: C2, z: a2 }, { x: -a2, y: C2, z: p2 }, { x: 0, y: C2, z: p2 }], x = Math.cos(c2), j = Math.sin(c2);
          for (let e4 of m) s2 = e4.x, i2 = e4.z, e4.x = s2 * x - i2 * j + f, e4.z = i2 * x + s2 * j + g;
          let S = o(m, e3, true);
          return 2.5 > Math.abs(S[3].y - S[9].y) && 2.5 > Math.abs(S[0].y - S[6].y) ? this.toLinePath([S[0], S[3], S[6], S[9]], true) : this.getCurvedPath(S);
        }
        function a(e3, t3) {
          let r3 = e3.slice(0, 3);
          if (y(t3)) {
            let e4 = t3[0];
            "M" === e4[0] && (r3.push(t3[2]), r3.push(t3[1]), r3.push(["L", e4[1], e4[2]]));
          } else {
            let e4 = t3[0], s2 = t3[1], i2 = t3[2];
            "M" === e4[0] && "C" === s2[0] && "C" === i2[0] && (r3.push(["L", i2[5], i2[6]]), r3.push(["C", i2[3], i2[4], i2[1], i2[2], s2[5], s2[6]]), r3.push(["C", s2[3], s2[4], s2[1], s2[2], e4[1], e4[2]]));
          }
          return r3.push(["Z"]), r3;
        }
        return { compose: function(e3) {
          let t3 = e3.prototype;
          t3.cylinder || (t3.Element3D.types.cylinder = r2, l(t3, { cylinder: d, cylinderPath: h, getCurvedPath: p, getCylinderBack: c, getCylinderEnd: C, getCylinderFront: a }));
        } };
      }), r(t, "Series/Cylinder/CylinderPoint.js", [t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { column: { prototype: { pointClass: r2 } } } = e2.seriesTypes, { extend: s } = t2;
        class i extends r2 {
        }
        return s(i.prototype, { shapeType: "cylinder" }), i;
      }), r(t, "Series/Cylinder/CylinderSeriesDefaults.js", [], function() {
        return {};
      }), r(t, "Series/Cylinder/CylinderSeries.js", [t["Series/Cylinder/CylinderComposition.js"], t["Series/Cylinder/CylinderPoint.js"], t["Series/Cylinder/CylinderSeriesDefaults.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2, r2, s, i) {
        let { column: n } = s.seriesTypes, { extend: o, merge: l } = i;
        class u extends n {
        }
        return u.compose = e2.compose, u.defaultOptions = l(n.defaultOptions, r2), o(u.prototype, { pointClass: t2 }), s.registerSeriesType("cylinder", u), u;
      }), r(t, "masters/modules/cylinder.src.js", [t["Core/Globals.js"], t["Series/Cylinder/CylinderSeries.js"], t["Core/Renderer/RendererRegistry.js"]], function(e2, t2, r2) {
        return t2.compose(r2.getRendererType()), e2;
      });
    });
  }
});
export default require_cylinder();
//# sourceMappingURL=highcharts_modules_cylinder__js.js.map
