import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/pathfinder.js
var require_pathfinder = __commonJS({
  "node_modules/highcharts/modules/pathfinder.js"(exports, module) {
    !/**
    * Highcharts Gantt JS v11.4.7 (2024-08-14)
    *
    * Pathfinder
    *
    * (c) 2016-2024 Ã˜ystein Moseng
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/pathfinder", ["highcharts"], function(n) {
        return t(n), t.Highcharts = n, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var n = t ? t._modules : {};
      function e(n2, e2, i, r) {
        n2.hasOwnProperty(e2) || (n2[e2] = r.apply(null, i), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: e2, module: n2[e2] } })));
      }
      e(n, "Gantt/Connection.js", [n["Core/Globals.js"], n["Core/Utilities.js"]], function(t2, n2) {
        let { defined: e2, error: i, merge: r, objectEach: a } = n2, o = t2.deg2rad, s = Math.max, h = Math.min;
        return class {
          constructor(t3, n3, e3) {
            this.init(t3, n3, e3);
          }
          init(t3, n3, e3) {
            this.fromPoint = t3, this.toPoint = n3, this.options = e3, this.chart = t3.series.chart, this.pathfinder = this.chart.pathfinder;
          }
          renderPath(t3, n3) {
            let e3 = this.chart, i2 = e3.styledMode, r2 = this.pathfinder, a2 = {}, o2 = this.graphics && this.graphics.path;
            r2.group || (r2.group = e3.renderer.g().addClass("highcharts-pathfinder-group").attr({ zIndex: -1 }).add(e3.seriesGroup)), r2.group.translate(e3.plotLeft, e3.plotTop), o2 && o2.renderer || (o2 = e3.renderer.path().add(r2.group), i2 || o2.attr({ opacity: 0 })), o2.attr(n3), a2.d = t3, i2 || (a2.opacity = 1), o2.animate(a2), this.graphics = this.graphics || {}, this.graphics.path = o2;
          }
          addMarker(t3, n3, e3) {
            let i2, r2, a2, s2, h2, c, l, x;
            let M = this.fromPoint.series.chart, d = M.pathfinder, y = M.renderer, f = "start" === t3 ? this.fromPoint : this.toPoint, u = f.getPathfinderAnchorPoint(n3);
            n3.enabled && ((x = "start" === t3 ? e3[1] : e3[e3.length - 2]) && "M" === x[0] || "L" === x[0]) && (l = { x: x[1], y: x[2] }, r2 = f.getRadiansToVector(l, u), i2 = f.getMarkerVector(r2, n3.radius, u), a2 = -r2 / o, n3.width && n3.height ? (h2 = n3.width, c = n3.height) : h2 = c = 2 * n3.radius, this.graphics = this.graphics || {}, s2 = { x: i2.x - h2 / 2, y: i2.y - c / 2, width: h2, height: c, rotation: a2, rotationOriginX: i2.x, rotationOriginY: i2.y }, this.graphics[t3] ? this.graphics[t3].animate(s2) : (this.graphics[t3] = y.symbol(n3.symbol).addClass("highcharts-point-connecting-path-" + t3 + "-marker highcharts-color-" + this.fromPoint.colorIndex).attr(s2).add(d.group), y.styledMode || this.graphics[t3].attr({ fill: n3.color || this.fromPoint.color, stroke: n3.lineColor, "stroke-width": n3.lineWidth, opacity: 0 }).animate({ opacity: 1 }, f.series.options.animation)));
          }
          getPath(t3) {
            let n3 = this.pathfinder, e3 = this.chart, a2 = n3.algorithms[t3.type], o2 = n3.chartObstacles;
            return "function" != typeof a2 ? (i('"' + t3.type + '" is not a Pathfinder algorithm.'), { path: [], obstacles: [] }) : (a2.requiresObstacles && !o2 && (o2 = n3.chartObstacles = n3.getChartObstacles(t3), e3.options.connectors.algorithmMargin = t3.algorithmMargin, n3.chartObstacleMetrics = n3.getObstacleMetrics(o2)), a2(this.fromPoint.getPathfinderAnchorPoint(t3.startMarker), this.toPoint.getPathfinderAnchorPoint(t3.endMarker), r({ chartObstacles: o2, lineObstacles: n3.lineObstacles || [], obstacleMetrics: n3.chartObstacleMetrics, hardBounds: { xMin: 0, xMax: e3.plotWidth, yMin: 0, yMax: e3.plotHeight }, obstacleOptions: { margin: t3.algorithmMargin }, startDirectionX: n3.getAlgorithmStartDirection(t3.startMarker) }, t3)));
          }
          render() {
            let t3 = this.fromPoint, n3 = t3.series, i2 = n3.chart, a2 = i2.pathfinder, o2 = {}, c = r(i2.options.connectors, n3.options.connectors, t3.options.connectors, this.options);
            !i2.styledMode && (o2.stroke = c.lineColor || t3.color, o2["stroke-width"] = c.lineWidth, c.dashStyle && (o2.dashstyle = c.dashStyle)), o2.class = "highcharts-point-connecting-path highcharts-color-" + t3.colorIndex, e2((c = r(o2, c)).marker.radius) || (c.marker.radius = h(s(Math.ceil((c.algorithmMargin || 8) / 2) - 1, 1), 5));
            let l = this.getPath(c), x = l.path;
            l.obstacles && (a2.lineObstacles = a2.lineObstacles || [], a2.lineObstacles = a2.lineObstacles.concat(l.obstacles)), this.renderPath(x, o2), this.addMarker("start", r(c.marker, c.startMarker), x), this.addMarker("end", r(c.marker, c.endMarker), x);
          }
          destroy() {
            this.graphics && (a(this.graphics, function(t3) {
              t3.destroy();
            }), delete this.graphics);
          }
        };
      }), e(n, "Series/PathUtilities.js", [], function() {
        function t2(t3, n2) {
          let e2 = [];
          for (let i = 0; i < t3.length; i++) {
            let r = t3[i][1], a = t3[i][2];
            if ("number" == typeof r && "number" == typeof a) {
              if (0 === i) e2.push(["M", r, a]);
              else if (i === t3.length - 1) e2.push(["L", r, a]);
              else if (n2) {
                let o = t3[i - 1], s = t3[i + 1];
                if (o && s) {
                  let t4 = o[1], i2 = o[2], h = s[1], c = s[2];
                  if ("number" == typeof t4 && "number" == typeof h && "number" == typeof i2 && "number" == typeof c && t4 !== h && i2 !== c) {
                    let o2 = t4 < h ? 1 : -1, s2 = i2 < c ? 1 : -1;
                    e2.push(["L", r - o2 * Math.min(Math.abs(r - t4), n2), a - s2 * Math.min(Math.abs(a - i2), n2)], ["C", r, a, r, a, r + o2 * Math.min(Math.abs(r - h), n2), a + s2 * Math.min(Math.abs(a - c), n2)]);
                  }
                }
              } else e2.push(["L", r, a]);
            }
          }
          return e2;
        }
        return { applyRadius: t2, getLinkPath: { default: function(n2) {
          let { x1: e2, y1: i, x2: r, y2: a, width: o = 0, inverted: s = false, radius: h, parentVisible: c } = n2, l = [["M", e2, i], ["L", e2, i], ["C", e2, i, e2, a, e2, a], ["L", e2, a], ["C", e2, i, e2, a, e2, a], ["L", e2, a]];
          return c ? t2([["M", e2, i], ["L", e2 + o * (s ? -0.5 : 0.5), i], ["L", e2 + o * (s ? -0.5 : 0.5), a], ["L", r, a]], h) : l;
        }, straight: function(t3) {
          let { x1: n2, y1: e2, x2: i, y2: r, width: a = 0, inverted: o = false, parentVisible: s } = t3;
          return s ? [["M", n2, e2], ["L", n2 + a * (o ? -1 : 1), r], ["L", i, r]] : [["M", n2, e2], ["L", n2, r], ["L", n2, r]];
        }, curved: function(t3) {
          let { x1: n2, y1: e2, x2: i, y2: r, offset: a = 0, width: o = 0, inverted: s = false, parentVisible: h } = t3;
          return h ? [["M", n2, e2], ["C", n2 + a, e2, n2 - a + o * (s ? -1 : 1), r, n2 + o * (s ? -1 : 1), r], ["L", i, r]] : [["M", n2, e2], ["C", n2, e2, n2, r, n2, r], ["L", i, r]];
        } } };
      }), e(n, "Gantt/PathfinderAlgorithms.js", [n["Series/PathUtilities.js"], n["Core/Utilities.js"]], function(t2, n2) {
        let { pick: e2 } = n2, { min: i, max: r, abs: a } = Math;
        function o(t3, n3, e3) {
          let i2 = n3 - 1e-7, r2 = e3 || 0, a2 = t3.length - 1, o2, s2;
          for (; r2 <= a2; ) if ((s2 = i2 - t3[o2 = a2 + r2 >> 1].xMin) > 0) r2 = o2 + 1;
          else {
            if (!(s2 < 0)) return o2;
            a2 = o2 - 1;
          }
          return r2 > 0 ? r2 - 1 : 0;
        }
        function s(t3, n3) {
          let e3 = o(t3, n3.x + 1) + 1;
          for (; e3--; ) {
            var i2;
            if (t3[e3].xMax >= n3.x && (i2 = t3[e3], n3.x <= i2.xMax && n3.x >= i2.xMin && n3.y <= i2.yMax && n3.y >= i2.yMin)) return e3;
          }
          return -1;
        }
        function h(t3) {
          let n3 = [];
          if (t3.length) {
            n3.push(["M", t3[0].start.x, t3[0].start.y]);
            for (let e3 = 0; e3 < t3.length; ++e3) n3.push(["L", t3[e3].end.x, t3[e3].end.y]);
          }
          return n3;
        }
        function c(t3, n3) {
          t3.yMin = r(t3.yMin, n3.yMin), t3.yMax = i(t3.yMax, n3.yMax), t3.xMin = r(t3.xMin, n3.xMin), t3.xMax = i(t3.xMax, n3.xMax);
        }
        let l = function(n3, i2, r2) {
          let o2 = [], c2 = r2.chartObstacles, l2 = s(c2, n3), x2 = s(c2, i2), M, d = e2(r2.startDirectionX, a(i2.x - n3.x) > a(i2.y - n3.y)) ? "x" : "y", y, f, u, p;
          function g(t3, n4, e3, i3, r3) {
            let a2 = { x: t3.x, y: t3.y };
            return a2[n4] = e3[i3 || n4] + (r3 || 0), a2;
          }
          function m(t3, n4, e3) {
            let i3 = a(n4[e3] - t3[e3 + "Min"]) > a(n4[e3] - t3[e3 + "Max"]);
            return g(n4, e3, t3, e3 + (i3 ? "Max" : "Min"), i3 ? 1 : -1);
          }
          x2 > -1 ? (M = { start: f = m(c2[x2], i2, d), end: i2 }, p = f) : p = i2, l2 > -1 && (f = m(y = c2[l2], n3, d), o2.push({ start: n3, end: f }), f[d] >= n3[d] == f[d] >= p[d] && (u = n3[d = "y" === d ? "x" : "y"] < i2[d], o2.push({ start: f, end: g(f, d, y, d + (u ? "Max" : "Min"), u ? 1 : -1) }), d = "y" === d ? "x" : "y"));
          let b = o2.length ? o2[o2.length - 1].end : n3;
          f = g(b, d, p), o2.push({ start: b, end: f });
          let P = g(f, d = "y" === d ? "x" : "y", p);
          return o2.push({ start: f, end: P }), o2.push(M), { path: t2.applyRadius(h(o2), r2.radius), obstacles: o2 };
        };
        function x(t3, n3, l2) {
          let x2 = e2(l2.startDirectionX, a(n3.x - t3.x) > a(n3.y - t3.y)), M = x2 ? "x" : "y", d = [], y = l2.obstacleMetrics, f = i(t3.x, n3.x) - y.maxWidth - 10, u = r(t3.x, n3.x) + y.maxWidth + 10, p = i(t3.y, n3.y) - y.maxHeight - 10, g = r(t3.y, n3.y) + y.maxHeight + 10, m, b, P, v = false, C = l2.chartObstacles, k = o(C, u), O = o(C, f);
          function w(t4, n4, e3) {
            let r2, a2, s2, h2;
            let c2 = t4.x < n4.x ? 1 : -1;
            t4.x < n4.x ? (r2 = t4, a2 = n4) : (r2 = n4, a2 = t4), t4.y < n4.y ? (h2 = t4, s2 = n4) : (h2 = n4, s2 = t4);
            let l3 = c2 < 0 ? i(o(C, a2.x), C.length - 1) : 0;
            for (; C[l3] && (c2 > 0 && C[l3].xMin <= a2.x || c2 < 0 && C[l3].xMax >= r2.x); ) {
              if (C[l3].xMin <= a2.x && C[l3].xMax >= r2.x && C[l3].yMin <= s2.y && C[l3].yMax >= h2.y) {
                if (e3) return { y: t4.y, x: t4.x < n4.x ? C[l3].xMin - 1 : C[l3].xMax + 1, obstacle: C[l3] };
                return { x: t4.x, y: t4.y < n4.y ? C[l3].yMin - 1 : C[l3].yMax + 1, obstacle: C[l3] };
              }
              l3 += c2;
            }
            return n4;
          }
          function L(t4, n4, e3, i2, r2) {
            let o2 = r2.soft, s2 = r2.hard, h2 = i2 ? "x" : "y", c2 = { x: n4.x, y: n4.y }, l3 = { x: n4.x, y: n4.y }, x3 = t4[h2 + "Max"] >= o2[h2 + "Max"], M2 = t4[h2 + "Min"] <= o2[h2 + "Min"], d2 = t4[h2 + "Max"] >= s2[h2 + "Max"], y2 = t4[h2 + "Min"] <= s2[h2 + "Min"], f2 = a(t4[h2 + "Min"] - n4[h2]), u2 = a(t4[h2 + "Max"] - n4[h2]), p2 = 10 > a(f2 - u2) ? n4[h2] < e3[h2] : u2 < f2;
            l3[h2] = t4[h2 + "Min"], c2[h2] = t4[h2 + "Max"];
            let g2 = w(n4, l3, i2)[h2] !== l3[h2], m2 = w(n4, c2, i2)[h2] !== c2[h2];
            return p2 = g2 ? !m2 || p2 : !m2 && p2, p2 = M2 ? !x3 || p2 : !x3 && p2, p2 = y2 ? !d2 || p2 : !d2 && p2;
          }
          for ((k = s(C = C.slice(O, k + 1), n3)) > -1 && (P = function(t4, n4, e3) {
            let r2 = i(t4.xMax - n4.x, n4.x - t4.xMin) < i(t4.yMax - n4.y, n4.y - t4.yMin), a2 = L(t4, n4, e3, r2, { soft: l2.hardBounds, hard: l2.hardBounds });
            return r2 ? { y: n4.y, x: t4[a2 ? "xMax" : "xMin"] + (a2 ? 1 : -1) } : { x: n4.x, y: t4[a2 ? "yMax" : "yMin"] + (a2 ? 1 : -1) };
          }(C[k], n3, t3), d.push({ end: n3, start: P }), n3 = P); (k = s(C, n3)) > -1; ) b = n3[M] - t3[M] < 0, (P = { x: n3.x, y: n3.y })[M] = C[k][b ? M + "Max" : M + "Min"] + (b ? 1 : -1), d.push({ end: n3, start: P }), n3 = P;
          return { path: h(m = (m = function t4(n4, e3, a2) {
            let o2, h2, x3, M2, d2, y2, m2;
            if (n4.x === e3.x && n4.y === e3.y) return [];
            let b2 = a2 ? "x" : "y", P2 = l2.obstacleOptions.margin, k2 = { soft: { xMin: f, xMax: u, yMin: p, yMax: g }, hard: l2.hardBounds };
            return (d2 = s(C, n4)) > -1 ? (M2 = L(d2 = C[d2], n4, e3, a2, k2), c(d2, l2.hardBounds), m2 = a2 ? { y: n4.y, x: d2[M2 ? "xMax" : "xMin"] + (M2 ? 1 : -1) } : { x: n4.x, y: d2[M2 ? "yMax" : "yMin"] + (M2 ? 1 : -1) }, (y2 = s(C, m2)) > -1 && (c(y2 = C[y2], l2.hardBounds), m2[b2] = M2 ? r(d2[b2 + "Max"] - P2 + 1, (y2[b2 + "Min"] + d2[b2 + "Max"]) / 2) : i(d2[b2 + "Min"] + P2 - 1, (y2[b2 + "Max"] + d2[b2 + "Min"]) / 2), n4.x === m2.x && n4.y === m2.y ? (v && (m2[b2] = M2 ? r(d2[b2 + "Max"], y2[b2 + "Max"]) + 1 : i(d2[b2 + "Min"], y2[b2 + "Min"]) - 1), v = !v) : v = false), h2 = [{ start: n4, end: m2 }]) : (o2 = w(n4, { x: a2 ? e3.x : n4.x, y: a2 ? n4.y : e3.y }, a2), h2 = [{ start: n4, end: { x: o2.x, y: o2.y } }], o2[a2 ? "x" : "y"] !== e3[a2 ? "x" : "y"] && (M2 = L(o2.obstacle, o2, e3, !a2, k2), c(o2.obstacle, l2.hardBounds), x3 = { x: a2 ? o2.x : o2.obstacle[M2 ? "xMax" : "xMin"] + (M2 ? 1 : -1), y: a2 ? o2.obstacle[M2 ? "yMax" : "yMin"] + (M2 ? 1 : -1) : o2.y }, a2 = !a2, h2 = h2.concat(t4({ x: o2.x, y: o2.y }, x3, a2)))), h2 = h2.concat(t4(h2[h2.length - 1].end, e3, !a2));
          }(t3, n3, x2)).concat(d.reverse())), obstacles: m };
        }
        return l.requiresObstacles = true, x.requiresObstacles = true, { fastAvoid: x, straight: function(t3, n3) {
          return { path: [["M", t3.x, t3.y], ["L", n3.x, n3.y]], obstacles: [{ start: t3, end: n3 }] };
        }, simpleConnect: l };
      }), e(n, "Gantt/ConnectorsDefaults.js", [], function() {
        return { connectors: { type: "straight", radius: 0, lineWidth: 1, marker: { enabled: false, align: "center", verticalAlign: "middle", inside: false, lineWidth: 1 }, startMarker: { symbol: "diamond" }, endMarker: { symbol: "arrow-filled" } } };
      }), e(n, "Gantt/PathfinderComposition.js", [n["Gantt/ConnectorsDefaults.js"], n["Core/Defaults.js"], n["Core/Utilities.js"]], function(t2, n2, e2) {
        var i;
        let { setOptions: r } = n2, { defined: a, error: o, merge: s } = e2;
        function h(t3) {
          let n3 = t3.shapeArgs;
          if (n3) return { xMin: n3.x || 0, xMax: (n3.x || 0) + (n3.width || 0), yMin: n3.y || 0, yMax: (n3.y || 0) + (n3.height || 0) };
          let e3 = t3.graphic && t3.graphic.getBBox();
          return e3 ? { xMin: t3.plotX - e3.width / 2, xMax: t3.plotX + e3.width / 2, yMin: t3.plotY - e3.height / 2, yMax: t3.plotY + e3.height / 2 } : null;
        }
        return function(n3) {
          function e3(t3) {
            let n4, e4;
            let i3 = h(this);
            switch (t3.align) {
              case "right":
                n4 = "xMax";
                break;
              case "left":
                n4 = "xMin";
            }
            switch (t3.verticalAlign) {
              case "top":
                e4 = "yMin";
                break;
              case "bottom":
                e4 = "yMax";
            }
            return { x: n4 ? i3[n4] : (i3.xMin + i3.xMax) / 2, y: e4 ? i3[e4] : (i3.yMin + i3.yMax) / 2 };
          }
          function i2(t3, n4) {
            let e4;
            return !a(n4) && (e4 = h(this)) && (n4 = { x: (e4.xMin + e4.xMax) / 2, y: (e4.yMin + e4.yMax) / 2 }), Math.atan2(n4.y - t3.y, t3.x - n4.x);
          }
          function c(t3, n4, e4) {
            let i3 = 2 * Math.PI, r2 = h(this), a2 = r2.xMax - r2.xMin, o2 = r2.yMax - r2.yMin, s2 = Math.atan2(o2, a2), c2 = a2 / 2, l = o2 / 2, x = r2.xMin + c2, M = r2.yMin + l, d = { x, y: M }, y = t3, f = 1, u = false, p = 1, g = 1;
            for (; y < -Math.PI; ) y += i3;
            for (; y > Math.PI; ) y -= i3;
            return f = Math.tan(y), y > -s2 && y <= s2 ? (g = -1, u = true) : y > s2 && y <= Math.PI - s2 ? g = -1 : y > Math.PI - s2 || y <= -(Math.PI - s2) ? (p = -1, u = true) : p = -1, u ? (d.x += p * c2, d.y += g * c2 * f) : (d.x += o2 / (2 * f) * p, d.y += g * l), e4.x !== x && (d.x = e4.x), e4.y !== M && (d.y = e4.y), { x: d.x + n4 * Math.cos(y), y: d.y - n4 * Math.sin(y) };
          }
          n3.compose = function(n4, a2, h2) {
            let l = h2.prototype;
            l.getPathfinderAnchorPoint || (n4.prototype.callbacks.push(function(t3) {
              false !== t3.options.connectors.enabled && ((t3.options.pathfinder || t3.series.reduce(function(t4, n5) {
                return n5.options && s(true, n5.options.connectors = n5.options.connectors || {}, n5.options.pathfinder), t4 || n5.options && n5.options.pathfinder;
              }, false)) && (s(true, t3.options.connectors = t3.options.connectors || {}, t3.options.pathfinder), o('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.')), this.pathfinder = new a2(this), this.pathfinder.update(true));
            }), l.getMarkerVector = c, l.getPathfinderAnchorPoint = e3, l.getRadiansToVector = i2, r(t2));
          };
        }(i || (i = {})), i;
      }), e(n, "Gantt/Pathfinder.js", [n["Gantt/Connection.js"], n["Gantt/PathfinderAlgorithms.js"], n["Gantt/PathfinderComposition.js"], n["Core/Series/Point.js"], n["Core/Utilities.js"]], function(t2, n2, e2, i, r) {
        let { addEvent: a, defined: o, pick: s, splat: h } = r, c = Math.max, l = Math.min;
        class x {
          static compose(t3, n3) {
            e2.compose(t3, x, n3);
          }
          constructor(t3) {
            this.init(t3);
          }
          init(t3) {
            this.chart = t3, this.connections = [], a(t3, "redraw", function() {
              this.pathfinder.update();
            });
          }
          update(n3) {
            let e3 = this.chart, r2 = this, a2 = r2.connections;
            r2.connections = [], e3.series.forEach(function(n4) {
              n4.visible && !n4.options.isInternal && n4.points.forEach(function(n5) {
                var _a;
                let a3;
                let o2 = n5.options;
                o2 && o2.dependency && (o2.connect = o2.dependency);
                let s2 = ((_a = n5.options) == null ? void 0 : _a.connect) && h(n5.options.connect);
                n5.visible && false !== n5.isInside && s2 && s2.forEach(function(o3) {
                  (a3 = e3.get("string" == typeof o3 ? o3 : o3.to)) instanceof i && a3.series.visible && a3.visible && false !== a3.isInside && r2.connections.push(new t2(n5, a3, "string" == typeof o3 ? {} : o3));
                });
              });
            });
            for (let t3 = 0, n4, e4, i2 = a2.length, o2 = r2.connections.length; t3 < i2; ++t3) {
              e4 = false;
              let i3 = a2[t3];
              for (n4 = 0; n4 < o2; ++n4) {
                let t4 = r2.connections[n4];
                if ((i3.options && i3.options.type) === (t4.options && t4.options.type) && i3.fromPoint === t4.fromPoint && i3.toPoint === t4.toPoint) {
                  t4.graphics = i3.graphics, e4 = true;
                  break;
                }
              }
              e4 || i3.destroy();
            }
            delete this.chartObstacles, delete this.lineObstacles, r2.renderConnections(n3);
          }
          renderConnections(t3) {
            t3 ? this.chart.series.forEach(function(t4) {
              let n3 = function() {
                let n4 = t4.chart.pathfinder;
                (n4 && n4.connections || []).forEach(function(n5) {
                  n5.fromPoint && n5.fromPoint.series === t4 && n5.render();
                }), t4.pathfinderRemoveRenderEvent && (t4.pathfinderRemoveRenderEvent(), delete t4.pathfinderRemoveRenderEvent);
              };
              false === t4.options.animation ? n3() : t4.pathfinderRemoveRenderEvent = a(t4, "afterAnimate", n3);
            }) : this.connections.forEach(function(t4) {
              t4.render();
            });
          }
          getChartObstacles(t3) {
            let n3 = this.chart.series, e3 = s(t3.algorithmMargin, 0), i2 = [], r2;
            for (let t4 = 0, r3 = n3.length; t4 < r3; ++t4) if (n3[t4].visible && !n3[t4].options.isInternal) for (let r4 = 0, a2 = n3[t4].points.length, o2, s2; r4 < a2; ++r4) (s2 = n3[t4].points[r4]).visible && (o2 = function(t5) {
              let n4 = t5.shapeArgs;
              if (n4) return { xMin: n4.x || 0, xMax: (n4.x || 0) + (n4.width || 0), yMin: n4.y || 0, yMax: (n4.y || 0) + (n4.height || 0) };
              let e4 = t5.graphic && t5.graphic.getBBox();
              return e4 ? { xMin: t5.plotX - e4.width / 2, xMax: t5.plotX + e4.width / 2, yMin: t5.plotY - e4.height / 2, yMax: t5.plotY + e4.height / 2 } : null;
            }(s2)) && i2.push({ xMin: o2.xMin - e3, xMax: o2.xMax + e3, yMin: o2.yMin - e3, yMax: o2.yMax + e3 });
            return i2 = i2.sort(function(t4, n4) {
              return t4.xMin - n4.xMin;
            }), o(t3.algorithmMargin) || (r2 = t3.algorithmMargin = function(t4) {
              let n4;
              let e4 = t4.length, i3 = [];
              for (let r3 = 0; r3 < e4; ++r3) for (let a2 = r3 + 1; a2 < e4; ++a2) (n4 = function t5(n5, e5, i4) {
                let r4 = s(i4, 10), a3 = n5.yMax + r4 > e5.yMin - r4 && n5.yMin - r4 < e5.yMax + r4, o2 = n5.xMax + r4 > e5.xMin - r4 && n5.xMin - r4 < e5.xMax + r4, h2 = a3 ? n5.xMin > e5.xMax ? n5.xMin - e5.xMax : e5.xMin - n5.xMax : 1 / 0, c2 = o2 ? n5.yMin > e5.yMax ? n5.yMin - e5.yMax : e5.yMin - n5.yMax : 1 / 0;
                return o2 && a3 ? r4 ? t5(n5, e5, Math.floor(r4 / 2)) : 1 / 0 : l(h2, c2);
              }(t4[r3], t4[a2])) < 80 && i3.push(n4);
              return i3.push(80), c(Math.floor(i3.sort(function(t5, n5) {
                return t5 - n5;
              })[Math.floor(i3.length / 10)] / 2 - 1), 1);
            }(i2), i2.forEach(function(t4) {
              t4.xMin -= r2, t4.xMax += r2, t4.yMin -= r2, t4.yMax += r2;
            })), i2;
          }
          getObstacleMetrics(t3) {
            let n3 = 0, e3 = 0, i2, r2, a2 = t3.length;
            for (; a2--; ) i2 = t3[a2].xMax - t3[a2].xMin, r2 = t3[a2].yMax - t3[a2].yMin, n3 < i2 && (n3 = i2), e3 < r2 && (e3 = r2);
            return { maxHeight: e3, maxWidth: n3 };
          }
          getAlgorithmStartDirection(t3) {
            let n3 = "left" !== t3.align && "right" !== t3.align, e3 = "top" !== t3.verticalAlign && "bottom" !== t3.verticalAlign;
            return n3 ? !!e3 && void 0 : !!e3 || void 0;
          }
        }
        return x.prototype.algorithms = n2, x;
      }), e(n, "Extensions/ArrowSymbols.js", [], function() {
        function t2(t3, n3, e3, i2) {
          return [["M", t3, n3 + i2 / 2], ["L", t3 + e3, n3], ["L", t3, n3 + i2 / 2], ["L", t3 + e3, n3 + i2]];
        }
        function n2(n3, e3, i2, r) {
          return t2(n3, e3, i2 / 2, r);
        }
        function e2(t3, n3, e3, i2) {
          return [["M", t3 + e3, n3], ["L", t3, n3 + i2 / 2], ["L", t3 + e3, n3 + i2], ["Z"]];
        }
        function i(t3, n3, i2, r) {
          return e2(t3, n3, i2 / 2, r);
        }
        return { compose: function(r) {
          let a = r.prototype.symbols;
          a.arrow = t2, a["arrow-filled"] = e2, a["arrow-filled-half"] = i, a["arrow-half"] = n2, a["triangle-left"] = e2, a["triangle-left-half"] = i;
        } };
      }), e(n, "masters/modules/pathfinder.src.js", [n["Core/Globals.js"], n["Gantt/Pathfinder.js"], n["Extensions/ArrowSymbols.js"]], function(t2, n2, e2) {
        return t2.Pathfinder = t2.Pathfinder || n2, e2.compose(t2.SVGRenderer), t2.Pathfinder.compose(t2.Chart, t2.Point), t2;
      });
    });
  }
});
export default require_pathfinder();
//# sourceMappingURL=highcharts_modules_pathfinder__js.js.map
