import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/boost-canvas.js
var require_boost_canvas = __commonJS({
  "node_modules/highcharts/modules/boost-canvas.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Boost module
    *
    * (c) 2010-2024 Highsoft AS
    * Author: Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/boost-canvas", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, s, o) {
        e2.hasOwnProperty(i2) || (e2[i2] = o.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Extensions/Boost/Boostables.js", [], function() {
        return ["area", "areaspline", "arearange", "column", "columnrange", "bar", "line", "scatter", "heatmap", "bubble", "treemap"];
      }), i(e, "Extensions/Boost/BoostableMap.js", [e["Extensions/Boost/Boostables.js"]], function(t2) {
        let e2 = {};
        return t2.forEach((t3) => {
          e2[t3] = true;
        }), e2;
      }), i(e, "Extensions/Boost/BoostChart.js", [e["Extensions/Boost/BoostableMap.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { composed: s } = e2, { addEvent: o, pick: r, pushUnique: n } = i2;
        function a(e3) {
          let i3 = e3.series, s2 = e3.boost = e3.boost || {}, o2 = e3.options.boost || {}, n2 = r(o2.seriesThreshold, 50);
          if (i3.length >= n2) return true;
          if (1 === i3.length) return false;
          let a2 = o2.allowForce;
          if (void 0 === a2) {
            for (let t3 of (a2 = true, e3.xAxis)) if (r(t3.min, -1 / 0) > r(t3.dataMin, -1 / 0) || r(t3.max, 1 / 0) < r(t3.dataMax, 1 / 0)) {
              a2 = false;
              break;
            }
          }
          if (void 0 !== s2.forceChartBoost) {
            if (a2) return s2.forceChartBoost;
            s2.forceChartBoost = void 0;
          }
          let l2 = 0, h = 0, d;
          for (let e4 of i3) 0 !== (d = e4.options).boostThreshold && false !== e4.visible && "heatmap" !== e4.type && (t2[e4.type] && ++l2, function(...t3) {
            let e5 = -Number.MAX_VALUE;
            return t3.forEach(function(t4) {
              if (null != t4 && void 0 !== t4.length && t4.length > 0) return e5 = t4.length, true;
            }), e5;
          }(e4.processedXData, d.data, e4.points) >= (d.boostThreshold || Number.MAX_VALUE) && ++h);
          return s2.forceChartBoost = a2 && (l2 === i3.length && h === l2 || h > 5), s2.forceChartBoost;
        }
        function l(t3) {
          function e3() {
            t3.boost && t3.boost.wgl && a(t3) && t3.boost.wgl.render(t3);
          }
          o(t3, "predraw", function() {
            var _a, _b;
            t3.boost = t3.boost || {}, t3.boost.forceChartBoost = void 0, t3.boosted = false, t3.axes.some((t4) => t4.isPanning) || ((_b = (_a = t3.boost).clear) == null ? void 0 : _b.call(_a)), t3.boost.canvas && t3.boost.wgl && a(t3) && t3.boost.wgl.allocateBuffer(t3), t3.boost.markerGroup && t3.xAxis && t3.xAxis.length > 0 && t3.yAxis && t3.yAxis.length > 0 && t3.boost.markerGroup.translate(t3.xAxis[0].pos, t3.yAxis[0].pos);
          }), o(t3, "load", e3, { order: -1 }), o(t3, "redraw", e3);
          let i3 = -1, s2 = -1;
          o(t3.pointer, "afterGetHoverData", (e4) => {
            var _a;
            let o2 = (_a = e4.hoverPoint) == null ? void 0 : _a.series;
            if (t3.boost = t3.boost || {}, t3.boost.markerGroup && o2) {
              let e5 = t3.inverted ? o2.yAxis : o2.xAxis, r2 = t3.inverted ? o2.xAxis : o2.yAxis;
              (e5 && e5.pos !== i3 || r2 && r2.pos !== s2) && (t3.series.forEach((t4) => {
                var _a2;
                (_a2 = t4.halo) == null ? void 0 : _a2.hide();
              }), t3.boost.markerGroup.translate(e5.pos, r2.pos), i3 = e5.pos, s2 = r2.pos);
            }
          });
        }
        return { compose: function(t3, e3) {
          return e3 && n(s, "Boost.Chart") && t3.prototype.callbacks.push(l), t3;
        }, getBoostClipRect: function(t3, e3) {
          let i3 = t3.navigator, s2 = { x: t3.plotLeft, y: t3.plotTop, width: t3.plotWidth, height: t3.plotHeight };
          if (i3 && t3.inverted ? (s2.width += i3.top + i3.height, i3.opposite || (s2.x = i3.left)) : i3 && !t3.inverted && (s2.height = i3.top + i3.height - t3.plotTop), e3.getClipBox) {
            let { xAxis: i4, yAxis: o2 } = e3;
            if (s2 = e3.getClipBox(), t3.inverted) {
              let t4 = s2.width;
              s2.width = s2.height, s2.height = t4, s2.x = o2.pos, s2.y = i4.pos;
            } else s2.x = i4.pos, s2.y = o2.pos;
          }
          if (e3 === t3) {
            let e4 = t3.inverted ? t3.xAxis : t3.yAxis;
            e4.length <= 1 && (s2.y = Math.min(e4[0].pos, s2.y), s2.height = e4[0].pos - t3.plotTop + e4[0].len);
          }
          return s2;
        }, isChartSeriesBoosting: a };
      }), i(e, "Extensions/Boost/WGLDrawMode.js", [], function() {
        return { area: "LINES", arearange: "LINES", areaspline: "LINES", column: "LINES", columnrange: "LINES", bar: "LINES", line: "LINE_STRIP", scatter: "POINTS", heatmap: "TRIANGLES", treemap: "TRIANGLES", bubble: "POINTS" };
      }), i(e, "Extensions/Boost/WGLShader.js", [e["Core/Utilities.js"]], function(t2) {
        let { clamp: e2, error: i2, pick: s } = t2;
        return class {
          constructor(t3) {
            if (this.errors = [], this.uLocations = {}, this.gl = t3, t3 && !this.createShader()) return;
          }
          bind() {
            this.gl && this.shaderProgram && this.gl.useProgram(this.shaderProgram);
          }
          createShader() {
            let t3 = this.stringToProgram("#version 100\n#define LN10 2.302585092994046\nprecision highp float;\nattribute vec4 aVertexPosition;\nattribute vec4 aColor;\nvarying highp vec2 position;\nvarying highp vec4 vColor;\nuniform mat4 uPMatrix;\nuniform float pSize;\nuniform float translatedThreshold;\nuniform bool hasThreshold;\nuniform bool skipTranslation;\nuniform float xAxisTrans;\nuniform float xAxisMin;\nuniform float xAxisMinPad;\nuniform float xAxisPointRange;\nuniform float xAxisLen;\nuniform bool  xAxisPostTranslate;\nuniform float xAxisOrdinalSlope;\nuniform float xAxisOrdinalOffset;\nuniform float xAxisPos;\nuniform bool  xAxisCVSCoord;\nuniform bool  xAxisIsLog;\nuniform bool  xAxisReversed;\nuniform float yAxisTrans;\nuniform float yAxisMin;\nuniform float yAxisMinPad;\nuniform float yAxisPointRange;\nuniform float yAxisLen;\nuniform bool  yAxisPostTranslate;\nuniform float yAxisOrdinalSlope;\nuniform float yAxisOrdinalOffset;\nuniform float yAxisPos;\nuniform bool  yAxisCVSCoord;\nuniform bool  yAxisIsLog;\nuniform bool  yAxisReversed;\nuniform bool  isBubble;\nuniform bool  bubbleSizeByArea;\nuniform float bubbleZMin;\nuniform float bubbleZMax;\nuniform float bubbleZThreshold;\nuniform float bubbleMinSize;\nuniform float bubbleMaxSize;\nuniform bool  bubbleSizeAbs;\nuniform bool  isInverted;\nfloat bubbleRadius(){\nfloat value = aVertexPosition.w;\nfloat zMax = bubbleZMax;\nfloat zMin = bubbleZMin;\nfloat radius = 0.0;\nfloat pos = 0.0;\nfloat zRange = zMax - zMin;\nif (bubbleSizeAbs){\nvalue = value - bubbleZThreshold;\nzMax = max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);\nzMin = 0.0;\n}\nif (value < zMin){\nradius = bubbleZMin / 2.0 - 1.0;\n} else {\npos = zRange > 0.0 ? (value - zMin) / zRange : 0.5;\nif (bubbleSizeByArea && pos > 0.0){\npos = sqrt(pos);\n}\nradius = ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;\n}\nreturn radius * 2.0;\n}\nfloat translate(float val,\nfloat pointPlacement,\nfloat localA,\nfloat localMin,\nfloat minPixelPadding,\nfloat pointRange,\nfloat len,\nbool  cvsCoord,\nbool  isLog,\nbool  reversed\n){\nfloat sign = 1.0;\nfloat cvsOffset = 0.0;\nif (cvsCoord) {\nsign *= -1.0;\ncvsOffset = len;\n}\nif (isLog) {\nval = log(val) / LN10;\n}\nif (reversed) {\nsign *= -1.0;\ncvsOffset -= sign * len;\n}\nreturn sign * (val - localMin) * localA + cvsOffset + \n(sign * minPixelPadding);\n}\nfloat xToPixels(float value) {\nif (skipTranslation){\nreturn value;// + xAxisPos;\n}\nreturn translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord, xAxisIsLog, xAxisReversed);// + xAxisPos;\n}\nfloat yToPixels(float value, float checkTreshold) {\nfloat v;\nif (skipTranslation){\nv = value;// + yAxisPos;\n} else {\nv = translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord, yAxisIsLog, yAxisReversed);// + yAxisPos;\nif (v > yAxisLen) {\nv = yAxisLen;\n}\n}\nif (checkTreshold > 0.0 && hasThreshold) {\nv = min(v, translatedThreshold);\n}\nreturn v;\n}\nvoid main(void) {\nif (isBubble){\ngl_PointSize = bubbleRadius();\n} else {\ngl_PointSize = pSize;\n}\nvColor = aColor;\nif (skipTranslation && isInverted) {\ngl_Position = uPMatrix * vec4(aVertexPosition.y + yAxisPos, aVertexPosition.x + xAxisPos, 0.0, 1.0);\n} else if (isInverted) {\ngl_Position = uPMatrix * vec4(yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, xToPixels(aVertexPosition.x) + xAxisPos, 0.0, 1.0);\n} else {\ngl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);\n}\n}", "vertex"), e3 = this.stringToProgram("precision highp float;\nuniform vec4 fillColor;\nvarying highp vec2 position;\nvarying highp vec4 vColor;\nuniform sampler2D uSampler;\nuniform bool isCircle;\nuniform bool hasColor;\nvoid main(void) {\nvec4 col = fillColor;\nvec4 tcol = texture2D(uSampler, gl_PointCoord.st);\nif (hasColor) {\ncol = vColor;\n}\nif (isCircle) {\ncol *= tcol;\nif (tcol.r < 0.0) {\ndiscard;\n} else {\ngl_FragColor = col;\n}\n} else {\ngl_FragColor = col;\n}\n}", "fragment"), i3 = (t4) => this.gl.getUniformLocation(this.shaderProgram, t4);
            return t3 && e3 ? (this.shaderProgram = this.gl.createProgram(), this.gl.attachShader(this.shaderProgram, t3), this.gl.attachShader(this.shaderProgram, e3), this.gl.linkProgram(this.shaderProgram), this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) ? (this.gl.useProgram(this.shaderProgram), this.gl.bindAttribLocation(this.shaderProgram, 0, "aVertexPosition"), this.pUniform = i3("uPMatrix"), this.psUniform = i3("pSize"), this.fcUniform = i3("fillColor"), this.isBubbleUniform = i3("isBubble"), this.bubbleSizeAbsUniform = i3("bubbleSizeAbs"), this.bubbleSizeAreaUniform = i3("bubbleSizeByArea"), this.uSamplerUniform = i3("uSampler"), this.skipTranslationUniform = i3("skipTranslation"), this.isCircleUniform = i3("isCircle"), this.isInverted = i3("isInverted"), true) : (this.errors.push(this.gl.getProgramInfoLog(this.shaderProgram)), this.handleErrors(), this.shaderProgram = false, false) : (this.shaderProgram = false, this.handleErrors(), false);
          }
          handleErrors() {
            this.errors.length && i2("[highcharts boost] shader error - " + this.errors.join("\n"));
          }
          stringToProgram(t3, e3) {
            let i3 = this.gl.createShader("vertex" === e3 ? this.gl.VERTEX_SHADER : this.gl.FRAGMENT_SHADER);
            return (this.gl.shaderSource(i3, t3), this.gl.compileShader(i3), this.gl.getShaderParameter(i3, this.gl.COMPILE_STATUS)) ? i3 : (this.errors.push("when compiling " + e3 + " shader:\n" + this.gl.getShaderInfoLog(i3)), false);
          }
          destroy() {
            this.gl && this.shaderProgram && (this.gl.deleteProgram(this.shaderProgram), this.shaderProgram = false);
          }
          fillColorUniform() {
            return this.fcUniform;
          }
          getProgram() {
            return this.shaderProgram;
          }
          pointSizeUniform() {
            return this.psUniform;
          }
          perspectiveUniform() {
            return this.pUniform;
          }
          reset() {
            this.gl && this.shaderProgram && (this.gl.uniform1i(this.isBubbleUniform, 0), this.gl.uniform1i(this.isCircleUniform, 0));
          }
          setBubbleUniforms(t3, i3, o, r = 1) {
            let n = t3.options, a = Number.MAX_VALUE, l = -Number.MAX_VALUE;
            if (this.gl && this.shaderProgram && t3.is("bubble")) {
              let h = t3.getPxExtremes();
              a = s(n.zMin, e2(i3, false === n.displayNegative ? n.zThreshold : -Number.MAX_VALUE, a)), l = s(n.zMax, Math.max(l, o)), this.gl.uniform1i(this.isBubbleUniform, 1), this.gl.uniform1i(this.isCircleUniform, 1), this.gl.uniform1i(this.bubbleSizeAreaUniform, "width" !== t3.options.sizeBy), this.gl.uniform1i(this.bubbleSizeAbsUniform, t3.options.sizeByAbsoluteValue), this.setUniform("bubbleMinSize", h.minPxSize * r), this.setUniform("bubbleMaxSize", h.maxPxSize * r), this.setUniform("bubbleZMin", a), this.setUniform("bubbleZMax", l), this.setUniform("bubbleZThreshold", t3.options.zThreshold);
            }
          }
          setColor(t3) {
            this.gl && this.shaderProgram && this.gl.uniform4f(this.fcUniform, t3[0] / 255, t3[1] / 255, t3[2] / 255, t3[3]);
          }
          setDrawAsCircle(t3) {
            this.gl && this.shaderProgram && this.gl.uniform1i(this.isCircleUniform, t3 ? 1 : 0);
          }
          setInverted(t3) {
            this.gl && this.shaderProgram && this.gl.uniform1i(this.isInverted, t3);
          }
          setPMatrix(t3) {
            this.gl && this.shaderProgram && this.gl.uniformMatrix4fv(this.pUniform, false, t3);
          }
          setPointSize(t3) {
            this.gl && this.shaderProgram && this.gl.uniform1f(this.psUniform, t3);
          }
          setSkipTranslation(t3) {
            this.gl && this.shaderProgram && this.gl.uniform1i(this.skipTranslationUniform, true === t3 ? 1 : 0);
          }
          setTexture(t3) {
            this.gl && this.shaderProgram && this.gl.uniform1i(this.uSamplerUniform, t3);
          }
          setUniform(t3, e3) {
            if (this.gl && this.shaderProgram) {
              let i3 = this.uLocations[t3] = this.uLocations[t3] || this.gl.getUniformLocation(this.shaderProgram, t3);
              this.gl.uniform1f(i3, e3);
            }
          }
        };
      }), i(e, "Extensions/Boost/WGLVertexBuffer.js", [], function() {
        return class {
          constructor(t2, e2, i2) {
            this.buffer = false, this.iterator = 0, this.preAllocated = false, this.vertAttribute = false, this.components = i2 || 2, this.dataComponents = i2, this.gl = t2, this.shader = e2;
          }
          allocate(t2) {
            this.iterator = -1, this.preAllocated = new Float32Array(4 * t2);
          }
          bind() {
            if (!this.buffer) return false;
            this.gl.vertexAttribPointer(this.vertAttribute, this.components, this.gl.FLOAT, false, 0, 0);
          }
          build(t2, e2, i2) {
            let s;
            return (this.data = t2 || [], this.data && 0 !== this.data.length || this.preAllocated) ? (this.components = i2 || this.components, this.buffer && this.gl.deleteBuffer(this.buffer), this.preAllocated || (s = new Float32Array(this.data)), this.buffer = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, this.preAllocated || s, this.gl.STATIC_DRAW), this.vertAttribute = this.gl.getAttribLocation(this.shader.getProgram(), e2), this.gl.enableVertexAttribArray(this.vertAttribute), s = false, true) : (this.destroy(), false);
          }
          destroy() {
            this.buffer && (this.gl.deleteBuffer(this.buffer), this.buffer = false, this.vertAttribute = false), this.iterator = 0, this.components = this.dataComponents || 2, this.data = [];
          }
          push(t2, e2, i2, s) {
            this.preAllocated && (this.preAllocated[++this.iterator] = t2, this.preAllocated[++this.iterator] = e2, this.preAllocated[++this.iterator] = i2, this.preAllocated[++this.iterator] = s);
          }
          render(t2, e2, i2) {
            let s = this.preAllocated ? this.preAllocated.length : this.data.length;
            return !!this.buffer && !!s && ((!t2 || t2 > s || t2 < 0) && (t2 = 0), (!e2 || e2 > s) && (e2 = s), !(t2 >= e2) && (i2 = i2 || "POINTS", this.gl.drawArrays(this.gl[i2], t2 / this.components, (e2 - t2) / this.components), true));
          }
        };
      }), i(e, "Extensions/Boost/WGLRenderer.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"], e["Extensions/Boost/WGLDrawMode.js"], e["Extensions/Boost/WGLShader.js"], e["Extensions/Boost/WGLVertexBuffer.js"]], function(t2, e2, i2, s, o, r) {
        let { parse: n } = t2, { doc: a, win: l } = e2, { isNumber: h, isObject: d, merge: c, objectEach: u, pick: g } = i2, f = { column: true, columnrange: true, bar: true, area: true, areaspline: true, arearange: true }, p = { scatter: true, bubble: true }, m = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"];
        class b {
          static orthoMatrix(t3, e3) {
            return [2 / t3, 0, 0, 0, 0, -(2 / e3), 0, 0, 0, 0, -2, 0, -1, 1, -1, 1];
          }
          static seriesPointCount(t3) {
            let e3, i3, s2;
            return t3.boosted ? (e3 = !!t3.options.stacking, i3 = t3.xData || t3.options.xData || t3.processedXData, s2 = (e3 ? t3.data : i3 || t3.options.data).length, "treemap" === t3.type ? s2 *= 12 : "heatmap" === t3.type ? s2 *= 6 : f[t3.type] && (s2 *= 2), s2) : 0;
          }
          constructor(t3) {
            this.data = [], this.height = 0, this.isInited = false, this.markerData = [], this.series = [], this.textureHandles = {}, this.width = 0, this.postRenderCallback = t3, this.settings = { pointSize: 1, lineWidth: 1, fillColor: "#AA00AA", useAlpha: true, usePreallocated: false, useGPUTranslations: false, debug: { timeRendering: false, timeSeriesProcessing: false, timeSetup: false, timeBufferCopy: false, timeKDTree: false, showSkipSummary: false } };
          }
          getPixelRatio() {
            return this.settings.pixelRatio || l.devicePixelRatio || 1;
          }
          setOptions(t3) {
            "pixelRatio" in t3 || (t3.pixelRatio = 1), c(true, this.settings, t3);
          }
          allocateBuffer(t3) {
            let e3 = this.vbuffer, i3 = 0;
            this.settings.usePreallocated && (t3.series.forEach((t4) => {
              t4.boosted && (i3 += b.seriesPointCount(t4));
            }), e3 && e3.allocate(i3));
          }
          allocateBufferForSingleSeries(t3) {
            let e3 = this.vbuffer, i3 = 0;
            this.settings.usePreallocated && (t3.boosted && (i3 = b.seriesPointCount(t3)), e3 && e3.allocate(i3));
          }
          clear() {
            let t3 = this.gl;
            t3 && t3.clear(t3.COLOR_BUFFER_BIT | t3.DEPTH_BUFFER_BIT);
          }
          pushSeriesData(t3, e3) {
            let i3 = this.data, s2 = this.settings, o2 = this.vbuffer, r2 = t3.pointArrayMap && "low,high" === t3.pointArrayMap.join(","), { chart: a2, options: l2, sorted: h2, xAxis: c2, yAxis: u2 } = t3, g2 = !!l2.stacking, p2 = l2.data, m2 = t3.xAxis.getExtremes(), b2 = m2.min - (t3.xAxis.minPointOffset || 0), x = m2.max + (t3.xAxis.minPointOffset || 0), A = t3.yAxis.getExtremes(), v = A.min - (t3.yAxis.minPointOffset || 0), y = A.max + (t3.yAxis.minPointOffset || 0), P = t3.xData || l2.xData || t3.processedXData, T = t3.yData || l2.yData || t3.processedYData, E = t3.zData || l2.zData || t3.processedZData, S = !P || 0 === P.length, C = l2.connectNulls, M = t3.points || false, k = g2 ? t3.data : P || p2, U = { x: Number.MAX_VALUE, y: 0 }, R = { x: -Number.MAX_VALUE, y: 0 }, D = void 0 === a2.index, w = f[t3.type], B = l2.zoneAxis || "y", L = l2.zones || false, G = l2.threshold, N = this.getPixelRatio(), _ = t3.chart.plotWidth, z = false, I = false, O, X, V = 0, j = false, F, W, Y, H, K = -1, Z = false, q = false, Q, J = false, $ = false, tt = false, te = false, ti = true, ts = true, to, tr = false, tn = false, ta = 0;
            if (l2.boostData && l2.boostData.length > 0) return;
            l2.gapSize && (tn = "value" !== l2.gapUnit ? l2.gapSize * t3.closestPointRange : l2.gapSize), L && (to = [], L.forEach((t4, e4) => {
              if (t4.color) {
                let i4 = n(t4.color).rgba;
                i4[0] /= 255, i4[1] /= 255, i4[2] /= 255, to[e4] = i4, tr || void 0 !== t4.value || (tr = i4);
              }
            }), tr || (tr = n(t3.pointAttribs && t3.pointAttribs().fill || t3.color).rgba, tr[0] /= 255, tr[1] /= 255, tr[2] /= 255)), a2.inverted && (_ = t3.chart.plotHeight), t3.closestPointRangePx = Number.MAX_VALUE;
            let tl = (t4) => {
              t4 && (e3.colorData.push(t4[0]), e3.colorData.push(t4[1]), e3.colorData.push(t4[2]), e3.colorData.push(t4[3]));
            }, th = (t4, r3, n2, a3 = 1, l3) => {
              tl(l3), 1 !== N && (!s2.useGPUTranslations || e3.skipTranslation) && (t4 *= N, r3 *= N, a3 *= N), s2.usePreallocated && o2 ? (o2.push(t4, r3, n2 ? 1 : 0, a3), ta += 4) : (i3.push(t4), i3.push(r3), i3.push(n2 ? N : 0), i3.push(a3));
            }, td = () => {
              e3.segments.length && (e3.segments[e3.segments.length - 1].to = i3.length || ta);
            }, tc = () => {
              e3.segments.length && e3.segments[e3.segments.length - 1].from === (i3.length || ta) || (td(), e3.segments.push({ from: i3.length || ta }));
            }, tu = (t4, e4, i4, s3, o3) => {
              tl(o3), th(t4 + i4, e4), tl(o3), th(t4, e4), tl(o3), th(t4, e4 + s3), tl(o3), th(t4, e4 + s3), tl(o3), th(t4 + i4, e4 + s3), tl(o3), th(t4 + i4, e4);
            };
            if (tc(), M && M.length > 0) {
              e3.skipTranslation = true, e3.drawMode = "TRIANGLES", M[0].node && M[0].node.levelDynamic && M.sort((t4, e4) => {
                if (t4.node) {
                  if (t4.node.levelDynamic > e4.node.levelDynamic) return 1;
                  if (t4.node.levelDynamic < e4.node.levelDynamic) return -1;
                }
                return 0;
              }), M.forEach((e4) => {
                let i4, s3;
                let o3 = e4.plotY;
                if (void 0 !== o3 && !isNaN(o3) && null !== e4.y && e4.shapeArgs) {
                  let { x: o4 = 0, y: r3 = 0, width: l3 = 0, height: h3 = 0 } = e4.shapeArgs;
                  i4 = (s3 = a2.styledMode ? e4.series.colorAttribs(e4) : s3 = e4.series.pointAttribs(e4))["stroke-width"] || 0, tt = n(s3.fill).rgba, tt[0] /= 255, tt[1] /= 255, tt[2] /= 255, t3.is("treemap") && (i4 = i4 || 1, X = n(s3.stroke).rgba, X[0] /= 255, X[1] /= 255, X[2] /= 255, tu(o4, r3, l3, h3, X), i4 /= 2), t3.is("heatmap") && a2.inverted && (o4 = c2.len - o4, r3 = u2.len - r3, l3 = -l3, h3 = -h3), tu(o4 + i4, r3 + i4, l3 - 2 * i4, h3 - 2 * i4, tt);
                }
              }), td();
              return;
            }
            for (; K < k.length - 1; ) {
              if (void 0 === (Y = k[++K])) continue;
              if (D) break;
              let i4 = p2 && p2[K];
              if (!S && d(i4, true) && i4.color && (tt = n(i4.color).rgba, tt[0] /= 255, tt[1] /= 255, tt[2] /= 255), S ? (F = Y[0], W = Y[1], k[K + 1] && (q = k[K + 1][0]), k[K - 1] && (Z = k[K - 1][0]), Y.length >= 3 && (H = Y[2], Y[2] > e3.zMax && (e3.zMax = Y[2]), Y[2] < e3.zMin && (e3.zMin = Y[2]))) : (F = Y, W = T[K], k[K + 1] && (q = k[K + 1]), k[K - 1] && (Z = k[K - 1]), E && E.length && (H = E[K], E[K] > e3.zMax && (e3.zMax = E[K]), E[K] < e3.zMin && (e3.zMin = E[K]))), !C && (null === F || null === W)) {
                tc();
                continue;
              }
              if (q && q >= b2 && q <= x && (J = true), Z && Z >= b2 && Z <= x && ($ = true), r2 ? (S && (W = Y.slice(1, 3)), Q = W[0], W = W[1]) : g2 && (F = Y.x, Q = (W = Y.stackY) - Y.y), null != v && null != y && (ti = W >= v && W <= y), F > x && R.x < x && (R.x = F, R.y = W), F < b2 && U.x > b2 && (U.x = F, U.y = W), null !== W || !C) {
                if (null === W || !ti && !J && !$) {
                  tc();
                  continue;
                }
                if (h2 && (q >= b2 || F >= b2) && (Z <= x || F <= x) && (te = true), te || J || $) {
                  if (tn && F - Z > tn && tc(), L) {
                    let t4;
                    L.some((e4, i5) => {
                      let s3 = L[i5 - 1];
                      return "x" === B ? void 0 !== e4.value && F <= e4.value && (to[i5] && (!s3 || F >= s3.value) && (t4 = to[i5]), true) : void 0 !== e4.value && W <= e4.value && (to[i5] && (!s3 || W >= s3.value) && (t4 = to[i5]), true);
                    }), tt = t4 || tr || tt;
                  }
                  if (s2.useGPUTranslations || (e3.skipTranslation = true, F = c2.toPixels(F, true), W = u2.toPixels(W, true), !(F > _) || "POINTS" !== e3.drawMode)) {
                    if (e3.hasMarkers && te && false !== z && (t3.closestPointRangePx = Math.min(t3.closestPointRangePx, Math.abs(F - z))), !s2.useGPUTranslations && !s2.usePreallocated && z && 1 > Math.abs(F - z) && I && 1 > Math.abs(W - I)) {
                      s2.debug.showSkipSummary && ++V;
                      continue;
                    }
                    w && (O = Q, (false === Q || void 0 === Q) && (O = W < 0 ? W : 0), (r2 || g2) && !u2.logarithmic || (O = Math.max(null === G ? v : G, v)), s2.useGPUTranslations || (O = u2.toPixels(O, true)), th(F, O, 0, 0, tt)), l2.step && !ts && th(F, I, 0, 2, tt), th(F, W, 0, "bubble" === t3.type ? H || 1 : 2, tt), z = F, I = W, j = true, ts = false;
                  }
                }
              }
            }
            s2.debug.showSkipSummary && console.log("skipped points:", V);
            let tg = (t4, i4) => {
              if (s2.useGPUTranslations || (e3.skipTranslation = true, t4.x = c2.toPixels(t4.x, true), t4.y = u2.toPixels(t4.y, true)), i4) {
                this.data = [t4.x, t4.y, 0, 2].concat(this.data);
                return;
              }
              th(t4.x, t4.y, 0, 2);
            };
            !j && false !== C && "line_strip" === t3.drawMode && (U.x < Number.MAX_VALUE && tg(U, true), R.x > -Number.MAX_VALUE && tg(R)), td();
          }
          pushSeries(t3) {
            let e3 = this.markerData, i3 = this.series, o2 = this.settings;
            i3.length > 0 && i3[i3.length - 1].hasMarkers && (i3[i3.length - 1].markerTo = e3.length), o2.debug.timeSeriesProcessing && console.time("building " + t3.type + " series");
            let r2 = { segments: [], markerFrom: e3.length, colorData: [], series: t3, zMin: Number.MAX_VALUE, zMax: -Number.MAX_VALUE, hasMarkers: !!t3.options.marker && false !== t3.options.marker.enabled, showMarkers: true, drawMode: s[t3.type] || "LINE_STRIP" };
            t3.index >= i3.length ? i3.push(r2) : i3[t3.index] = r2, this.pushSeriesData(t3, r2), o2.debug.timeSeriesProcessing && console.timeEnd("building " + t3.type + " series");
          }
          flush() {
            let t3 = this.vbuffer;
            this.data = [], this.markerData = [], this.series = [], t3 && t3.destroy();
          }
          setXAxis(t3) {
            let e3 = this.shader;
            if (!e3) return;
            let i3 = this.getPixelRatio();
            e3.setUniform("xAxisTrans", t3.transA * i3), e3.setUniform("xAxisMin", t3.min), e3.setUniform("xAxisMinPad", t3.minPixelPadding * i3), e3.setUniform("xAxisPointRange", t3.pointRange), e3.setUniform("xAxisLen", t3.len * i3), e3.setUniform("xAxisPos", t3.pos * i3), e3.setUniform("xAxisCVSCoord", !t3.horiz), e3.setUniform("xAxisIsLog", !!t3.logarithmic), e3.setUniform("xAxisReversed", !!t3.reversed);
          }
          setYAxis(t3) {
            let e3 = this.shader;
            if (!e3) return;
            let i3 = this.getPixelRatio();
            e3.setUniform("yAxisTrans", t3.transA * i3), e3.setUniform("yAxisMin", t3.min), e3.setUniform("yAxisMinPad", t3.minPixelPadding * i3), e3.setUniform("yAxisPointRange", t3.pointRange), e3.setUniform("yAxisLen", t3.len * i3), e3.setUniform("yAxisPos", t3.pos * i3), e3.setUniform("yAxisCVSCoord", !t3.horiz), e3.setUniform("yAxisIsLog", !!t3.logarithmic), e3.setUniform("yAxisReversed", !!t3.reversed);
          }
          setThreshold(t3, e3) {
            let i3 = this.shader;
            i3 && (i3.setUniform("hasThreshold", t3), i3.setUniform("translatedThreshold", e3));
          }
          renderChart(i3) {
            let s2 = this.gl, o2 = this.settings, a2 = this.shader, l2 = this.vbuffer, d2 = this.getPixelRatio();
            if (!i3) return false;
            this.width = i3.chartWidth * d2, this.height = i3.chartHeight * d2;
            let c2 = this.height, u2 = this.width;
            if (!s2 || !a2 || !u2 || !c2) return false;
            o2.debug.timeRendering && console.time("gl rendering"), s2.canvas.width = u2, s2.canvas.height = c2, a2.bind(), s2.viewport(0, 0, u2, c2), a2.setPMatrix(b.orthoMatrix(u2, c2)), o2.lineWidth > 1 && !e2.isMS && s2.lineWidth(o2.lineWidth), l2 && (l2.build(this.data, "aVertexPosition", 4), l2.bind()), a2.setInverted(i3.inverted), this.series.forEach((e3, c3) => {
              var _a, _b, _c;
              let u3 = e3.series.options, f2 = u3.marker, m2 = void 0 !== u3.lineWidth ? u3.lineWidth : 1, b2 = u3.threshold, x = h(b2), A = e3.series.yAxis.getThreshold(b2), v = g(u3.marker ? u3.marker.enabled : null, !!e3.series.xAxis.isRadial || null, e3.series.closestPointRangePx > 2 * ((u3.marker ? u3.marker.radius : 10) || 10)), y = this.textureHandles[f2 && f2.symbol || e3.series.symbol] || this.textureHandles.circle, P, T, E, S = [];
              if (0 !== e3.segments.length && e3.segments[0].from !== e3.segments[0].to && (y.isReady && (s2.bindTexture(s2.TEXTURE_2D, y.handle), a2.setTexture(y.handle)), i3.styledMode ? e3.series.markerGroup === ((_a = e3.series.chart.boost) == null ? void 0 : _a.markerGroup) ? (delete e3.series.markerGroup, e3.series.markerGroup = e3.series.plotGroup("markerGroup", "markers", "visible", 1, i3.seriesGroup).addClass("highcharts-tracker"), E = e3.series.markerGroup.getStyle("fill"), e3.series.markerGroup.destroy(), e3.series.markerGroup = (_b = e3.series.chart.boost) == null ? void 0 : _b.markerGroup) : E = (_c = e3.series.markerGroup) == null ? void 0 : _c.getStyle("fill") : (E = "POINTS" === e3.drawMode && e3.series.pointAttribs && e3.series.pointAttribs().fill || e3.series.color, u3.colorByPoint && (E = e3.series.chart.options.colors[c3])), e3.series.fillOpacity && u3.fillOpacity && (E = new t2(E).setOpacity(g(u3.fillOpacity, 1)).get()), S = n(E).rgba, o2.useAlpha || (S[3] = 1), "add" === u3.boostBlending ? (s2.blendFunc(s2.SRC_ALPHA, s2.ONE), s2.blendEquation(s2.FUNC_ADD)) : "mult" === u3.boostBlending || "multiply" === u3.boostBlending ? s2.blendFunc(s2.DST_COLOR, s2.ZERO) : "darken" === u3.boostBlending ? (s2.blendFunc(s2.ONE, s2.ONE), s2.blendEquation(s2.FUNC_MIN)) : s2.blendFuncSeparate(s2.SRC_ALPHA, s2.ONE_MINUS_SRC_ALPHA, s2.ONE, s2.ONE_MINUS_SRC_ALPHA), a2.reset(), e3.colorData.length > 0 ? (a2.setUniform("hasColor", 1), (T = new r(s2, a2)).build(Array(e3.segments[0].from).concat(e3.colorData), "aColor", 4), T.bind()) : (a2.setUniform("hasColor", 0), s2.disableVertexAttribArray(s2.getAttribLocation(a2.getProgram(), "aColor"))), a2.setColor(S), this.setXAxis(e3.series.xAxis), this.setYAxis(e3.series.yAxis), this.setThreshold(x, A), "POINTS" === e3.drawMode && a2.setPointSize(2 * g(u3.marker && u3.marker.radius, 0.5) * d2), a2.setSkipTranslation(e3.skipTranslation), "bubble" === e3.series.type && a2.setBubbleUniforms(e3.series, e3.zMin, e3.zMax, d2), a2.setDrawAsCircle(p[e3.series.type] || false), l2)) {
                if (m2 > 0 || "LINE_STRIP" !== e3.drawMode) for (P = 0; P < e3.segments.length; P++) l2.render(e3.segments[P].from, e3.segments[P].to, e3.drawMode);
                if (e3.hasMarkers && v) for (a2.setPointSize(2 * g(u3.marker && u3.marker.radius, 5) * d2), a2.setDrawAsCircle(true), P = 0; P < e3.segments.length; P++) l2.render(e3.segments[P].from, e3.segments[P].to, "POINTS");
              }
            }), o2.debug.timeRendering && console.timeEnd("gl rendering"), this.postRenderCallback && this.postRenderCallback(this), this.flush();
          }
          render(t3) {
            if (this.clear(), t3.renderer.forExport) return this.renderChart(t3);
            this.isInited ? this.renderChart(t3) : setTimeout(() => {
              this.render(t3);
            }, 1);
          }
          setSize(t3, e3) {
            let i3 = this.shader;
            i3 && (this.width !== t3 || this.height !== e3) && (this.width = t3, this.height = e3, i3.bind(), i3.setPMatrix(b.orthoMatrix(t3, e3)));
          }
          init(t3, e3) {
            let i3 = this.settings;
            if (this.isInited = false, !t3) return false;
            i3.debug.timeSetup && console.time("gl setup");
            for (let e4 = 0; e4 < m.length && (this.gl = t3.getContext(m[e4], {}), !this.gl); ++e4) ;
            let s2 = this.gl;
            if (!s2) return false;
            e3 || this.flush(), s2.enable(s2.BLEND), s2.blendFunc(s2.SRC_ALPHA, s2.ONE_MINUS_SRC_ALPHA), s2.disable(s2.DEPTH_TEST), s2.depthFunc(s2.LESS);
            let n2 = this.shader = new o(s2);
            if (!n2) return false;
            this.vbuffer = new r(s2, n2);
            let l2 = (t4, e4) => {
              let i4 = { isReady: false, texture: a.createElement("canvas"), handle: s2.createTexture() }, o2 = i4.texture.getContext("2d");
              this.textureHandles[t4] = i4, i4.texture.width = 512, i4.texture.height = 512, o2.mozImageSmoothingEnabled = false, o2.webkitImageSmoothingEnabled = false, o2.msImageSmoothingEnabled = false, o2.imageSmoothingEnabled = false, o2.strokeStyle = "rgba(255, 255, 255, 0)", o2.fillStyle = "#FFF", e4(o2);
              try {
                s2.activeTexture(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, i4.handle), s2.texImage2D(s2.TEXTURE_2D, 0, s2.RGBA, s2.RGBA, s2.UNSIGNED_BYTE, i4.texture), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, s2.CLAMP_TO_EDGE), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, s2.CLAMP_TO_EDGE), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, s2.LINEAR), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, s2.LINEAR), s2.bindTexture(s2.TEXTURE_2D, null), i4.isReady = true;
              } catch (t5) {
              }
            };
            return l2("circle", (t4) => {
              t4.beginPath(), t4.arc(256, 256, 256, 0, 2 * Math.PI), t4.stroke(), t4.fill();
            }), l2("square", (t4) => {
              t4.fillRect(0, 0, 512, 512);
            }), l2("diamond", (t4) => {
              t4.beginPath(), t4.moveTo(256, 0), t4.lineTo(512, 256), t4.lineTo(256, 512), t4.lineTo(0, 256), t4.lineTo(256, 0), t4.fill();
            }), l2("triangle", (t4) => {
              t4.beginPath(), t4.moveTo(0, 512), t4.lineTo(256, 0), t4.lineTo(512, 512), t4.lineTo(0, 512), t4.fill();
            }), l2("triangle-down", (t4) => {
              t4.beginPath(), t4.moveTo(0, 0), t4.lineTo(256, 512), t4.lineTo(512, 0), t4.lineTo(0, 0), t4.fill();
            }), this.isInited = true, i3.debug.timeSetup && console.timeEnd("gl setup"), true;
          }
          destroy() {
            let t3 = this.gl, e3 = this.shader, i3 = this.vbuffer;
            this.flush(), i3 && i3.destroy(), e3 && e3.destroy(), t3 && (u(this.textureHandles, (e4) => {
              e4.handle && t3.deleteTexture(e4.handle);
            }), t3.canvas.width = 1, t3.canvas.height = 1);
          }
        }
        return b;
      }), i(e, "Extensions/Boost/BoostSeries.js", [e["Extensions/Boost/BoostableMap.js"], e["Extensions/Boost/Boostables.js"], e["Extensions/Boost/BoostChart.js"], e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"], e["Extensions/Boost/WGLRenderer.js"]], function(t2, e2, i2, s, o, r, n) {
        let a, l;
        let { getBoostClipRect: h, isChartSeriesBoosting: d } = i2, { getOptions: c } = s, { composed: u, doc: g, noop: f, win: p } = o, { addEvent: m, destroyObjectProperties: b, error: x, extend: A, fireEvent: v, isArray: y, isNumber: P, pick: T, pushUnique: E, wrap: S, defined: C } = r;
        function M(t3, e3) {
          let i3 = e3.boost;
          t3 && i3 && i3.target && i3.canvas && !d(e3.chart) && t3.allocateBufferForSingleSeries(e3);
        }
        function k(t3) {
          return T(t3 && t3.options && t3.options.boost && t3.options.boost.enabled, true);
        }
        function U(t3, e3) {
          var _a, _b, _c;
          let i3 = t3.constructor, s2 = t3.seriesGroup || e3.group, o2 = t3.chartWidth, r2 = t3.chartHeight, a2 = t3, c2 = "undefined" != typeof SVGForeignObjectElement, u2 = false;
          d(t3) ? a2 = t3 : (a2 = e3, u2 = !!(((_a = e3.options.events) == null ? void 0 : _a.click) || ((_c = (_b = e3.options.point) == null ? void 0 : _b.events) == null ? void 0 : _c.click)));
          let f2 = a2.boost = a2.boost || {};
          if (c2 = false, l || (l = g.createElement("canvas")), !f2.target && (f2.canvas = l, t3.renderer.forExport || !c2 ? (a2.renderTarget = f2.target = t3.renderer.image("", 0, 0, o2, r2).addClass("highcharts-boost-canvas").add(s2), f2.clear = function() {
            f2.target.attr({ href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" });
          }, f2.copy = function() {
            f2.resize(), f2.target.attr({ href: f2.canvas.toDataURL("image/png") });
          }) : (f2.targetFo = t3.renderer.createElement("foreignObject").add(s2), a2.renderTarget = f2.target = g.createElement("canvas"), f2.targetCtx = f2.target.getContext("2d"), f2.targetFo.element.appendChild(f2.target), f2.clear = function() {
            f2.target.width = f2.canvas.width, f2.target.height = f2.canvas.height;
          }, f2.copy = function() {
            f2.target.width = f2.canvas.width, f2.target.height = f2.canvas.height, f2.targetCtx.drawImage(f2.canvas, 0, 0);
          }), f2.resize = function() {
            var _a2, _b2;
            o2 = t3.chartWidth, r2 = t3.chartHeight, (f2.targetFo || f2.target).attr({ x: 0, y: 0, width: o2, height: r2 }).css({ pointerEvents: u2 ? void 0 : "none", mixedBlendMode: "normal", opacity: 1 }).addClass(u2 ? "highcharts-tracker" : ""), a2 instanceof i3 && ((_b2 = (_a2 = a2.boost) == null ? void 0 : _a2.markerGroup) == null ? void 0 : _b2.translate(t3.plotLeft, t3.plotTop));
          }, f2.clipRect = t3.renderer.clipRect(), (f2.targetFo || f2.target).attr({ zIndex: e3.options.zIndex }), a2 instanceof i3 && (a2.boost.markerGroup = a2.renderer.g().add(s2).translate(e3.xAxis.pos, e3.yAxis.pos))), f2.canvas.width = o2, f2.canvas.height = r2, f2.clipRect) {
            let e4 = h(t3, a2), i4 = e4.width === t3.clipBox.width && e4.height === t3.clipBox.height ? s2 : f2.targetFo || f2.target;
            f2.clipRect.attr(e4), i4 == null ? void 0 : i4.clip(f2.clipRect);
          }
          return f2.resize(), f2.clear(), !f2.wgl && (f2.wgl = new n((t4) => {
            t4.settings.debug.timeBufferCopy && console.time("buffer copy"), f2.copy(), t4.settings.debug.timeBufferCopy && console.timeEnd("buffer copy");
          }), f2.wgl.init(f2.canvas) || x("[highcharts boost] - unable to init WebGL renderer"), f2.wgl.setOptions(t3.options.boost || {}), a2 instanceof i3 && f2.wgl.allocateBuffer(t3)), f2.wgl.setSize(o2, r2), f2.wgl;
        }
        function R(t3) {
          let e3 = t3.points;
          if (e3) {
            let t4, i3;
            for (i3 = 0; i3 < e3.length; i3 += 1) (t4 = e3[i3]) && t4.destroyElements && t4.destroyElements();
          }
          for (let e4 of (["graph", "area", "tracker"].forEach((e5) => {
            let i3 = t3[e5];
            i3 && (t3[e5] = i3.destroy());
          }), t3.zones)) b(e4, void 0, true);
        }
        function D(t3, e3, i3, s2, o2, r2) {
          let n2 = (o2 = o2 || 0) + (s2 = s2 || 3e3), a2 = true;
          for (; a2 && o2 < n2 && o2 < t3.length; ) a2 = e3(t3[o2], o2), ++o2;
          a2 && (o2 < t3.length ? r2 ? D(t3, e3, i3, s2, o2, r2) : p.requestAnimationFrame ? p.requestAnimationFrame(function() {
            D(t3, e3, i3, s2, o2);
          }) : setTimeout(D, 0, t3, e3, i3, s2, o2) : i3 && i3());
        }
        function w(t3, e3) {
          let i3 = t3.options, s2 = i3.data, o2 = t3.xAxis && t3.xAxis.options, r2 = t3.yAxis && t3.yAxis.options, n2 = t3.colorAxis && t3.colorAxis.options;
          return s2.length > (i3.boostThreshold || Number.MAX_VALUE) && P(r2.min) && P(r2.max) && (!e3 || P(o2.min) && P(o2.max)) && (!n2 || P(n2.min) && P(n2.max));
        }
        let B = (t3, e3) => !t3.forceCrop && (d(t3.chart) || (e3 ? e3.length : 0) >= (t3.options.boostThreshold || Number.MAX_VALUE));
        function L() {
          let t3 = this, e3 = t3.chart;
          e3.boost && e3.boost.markerGroup === t3.markerGroup && (t3.markerGroup = null), e3.hoverPoints && (e3.hoverPoints = e3.hoverPoints.filter(function(e4) {
            return e4.series === t3;
          })), e3.hoverPoint && e3.hoverPoint.series === t3 && (e3.hoverPoint = null);
        }
        function G() {
          let t3 = this.boost;
          t3 && t3.canvas && t3.target && (t3.wgl && t3.wgl.clear(), t3.clear && t3.clear());
        }
        function N(t3) {
          let e3 = t3.boost;
          e3 && e3.canvas && e3.target && e3.wgl && !d(t3.chart) && e3.wgl.render(t3.chart);
        }
        function _(t3, e3) {
          let i3 = t3.options, s2 = t3.xAxis, o2 = t3.pointClass;
          if (e3 instanceof o2) return e3;
          let r2 = t3.xData || i3.xData || t3.processedXData || false, n2 = new o2(t3, (t3.options.data || [])[e3.i], r2 ? r2[e3.i] : void 0);
          return n2.category = T(s2.categories ? s2.categories[n2.x] : n2.x, n2.x), n2.dist = e3.dist, n2.distX = e3.distX, n2.plotX = e3.plotX, n2.plotY = e3.plotY, n2.index = e3.i, n2.percentage = e3.percentage, n2.isInside = t3.isPointInside(n2), n2;
        }
        function z(t3) {
          var e3, i3, s2, o2;
          let { options: r2, xAxis: n2, yAxis: a2 } = this;
          if (!this.isDirty && !n2.isDirty && !a2.isDirty && !t3) return false;
          this.yAxis.setTickInterval();
          let l2 = r2.boostThreshold || 0, h2 = r2.cropThreshold, d2 = r2.data || this.data, c2 = this.xData, u2 = n2.getExtremes(), g2 = u2.max ?? Number.MAX_VALUE, f2 = u2.min ?? -Number.MAX_VALUE, p2 = this.yData, m2 = a2.getExtremes(), b2 = m2.max ?? Number.MAX_VALUE, x2 = m2.min ?? -Number.MAX_VALUE;
          if (!this.boosted && n2.old && a2.old && f2 >= (n2.old.min ?? -Number.MAX_VALUE) && g2 <= (n2.old.max ?? Number.MAX_VALUE) && x2 >= (a2.old.min ?? -Number.MAX_VALUE) && b2 <= (a2.old.max ?? Number.MAX_VALUE)) return this.processedXData ?? (this.processedXData = c2), this.processedYData ?? (this.processedYData = p2), true;
          if (!l2 || d2.length < l2 || h2 && !this.forceCrop && !this.getExtremesFromAll && !r2.getExtremesFromAll && d2.length < h2) return this.processedXData = c2, this.processedYData = p2, true;
          let A2 = [], v2 = [], y2 = [], T2 = !(P(u2.max) || P(u2.min)), E2 = !(P(m2.max) || P(m2.min)), S2 = false, C2, M2 = c2[0], k2 = c2[0], U2, R2 = p2[0], D2 = p2[0];
          for (let t4 = 0, e4 = c2.length; t4 < e4; ++t4) C2 = c2[t4], U2 = p2[t4], C2 >= f2 && C2 <= g2 && U2 >= x2 && U2 <= b2 ? (A2.push({ x: C2, y: U2 }), v2.push(C2), y2.push(U2), T2 && (M2 = Math.max(M2, C2), k2 = Math.min(k2, C2)), E2 && (R2 = Math.max(R2, U2), D2 = Math.min(D2, U2))) : S2 = true;
          return T2 && ((e3 = n2.options).max ?? (e3.max = M2), (i3 = n2.options).min ?? (i3.min = k2)), E2 && ((s2 = a2.options).max ?? (s2.max = R2), (o2 = a2.options).min ?? (o2.min = D2)), this.cropped = S2, this.cropStart = 0, this.processedXData = v2, this.processedYData = y2, B(this, v2) || (this.processedData = A2), true;
        }
        function I() {
          let t3 = this.options || {}, e3 = this.chart, i3 = e3.boost, s2 = this.boost, o2 = this.xAxis, r2 = this.yAxis, n2 = t3.xData || this.processedXData, l2 = t3.yData || this.processedYData, h2 = this.processedData || t3.data, c2 = o2.getExtremes(), u2 = c2.min - (o2.minPointOffset || 0), g2 = c2.max + (o2.minPointOffset || 0), p2 = r2.getExtremes(), m2 = p2.min - (r2.minPointOffset || 0), b2 = p2.max + (r2.minPointOffset || 0), x2 = {}, A2 = !!this.sampling, y2 = t3.enableMouseTracking, P2 = t3.threshold, E2 = this.pointArrayMap && "low,high" === this.pointArrayMap.join(","), S2 = !!t3.stacking, k2 = this.cropStart || 0, w2 = this.requireSorting, B2 = !n2, L2 = "x" === t3.findNearestPointBy, G2 = this.xData || this.options.xData || this.processedXData || false, _2 = T(t3.lineWidth, 1), z2 = false, I2, O2 = r2.getThreshold(P2), X2, V2, j2, F;
          if (o2.isPanning || r2.isPanning || (z2 = U(e3, this), e3.boosted = true, !this.visible)) return;
          (this.points || this.graph) && R(this), d(e3) ? (this.markerGroup && this.markerGroup !== (i3 == null ? void 0 : i3.markerGroup) && this.markerGroup.destroy(), this.markerGroup = i3 == null ? void 0 : i3.markerGroup, s2 && s2.target && (this.renderTarget = s2.target = s2.target.destroy())) : (this.markerGroup === (i3 == null ? void 0 : i3.markerGroup) && (this.markerGroup = void 0), this.markerGroup = this.plotGroup("markerGroup", "markers", "visible", 1, e3.seriesGroup).addClass("highcharts-tracker"));
          let W = this.points = [], Y = (t4, i4, s3, n3) => {
            let l3 = !!G2 && G2[k2 + s3], h3 = (t5) => {
              e3.inverted && (t5 = o2.len - t5, i4 = r2.len - i4), W.push({ destroy: f, x: l3, clientX: t5, plotX: t5, plotY: i4, i: k2 + s3, percentage: n3 });
            };
            t4 = Math.ceil(t4), a = L2 ? t4 : t4 + "," + i4, y2 && (x2[a] ? l3 === G2[G2.length - 1] && (W.length--, h3(t4)) : (x2[a] = true, h3(t4)));
          };
          this.buildKDTree = f, v(this, "renderCanvas"), this.is("line") && _2 > 1 && (s2 == null ? void 0 : s2.target) && i3 && !i3.lineWidthFilter && (i3.lineWidthFilter = e3.renderer.definition({ tagName: "filter", children: [{ tagName: "feMorphology", attributes: { operator: "dilate", radius: 0.25 * _2 } }], attributes: { id: "linewidth" } }), s2.target.attr({ filter: "url(#linewidth)" })), z2 && (M(z2, this), z2.pushSeries(this), N(this));
          let H = z2.settings;
          e3.renderer.forExport || (H.debug.timeKDTree && console.time("kd tree building"), D(S2 ? this.data.slice(k2) : n2 || h2, function(t4, i4) {
            let s3 = void 0 === e3.index, n3, a2, h3, d2, c3, f2 = false, p3 = true;
            return !C(t4) || (!s3 && (B2 ? (n3 = t4[0], a2 = t4[1]) : (n3 = t4, a2 = l2[i4]), E2 ? (B2 && (a2 = t4.slice(1, 3)), f2 = a2[0], a2 = a2[1]) : S2 && (n3 = t4.x, f2 = (a2 = t4.stackY) - t4.y, c3 = t4.percentage), w2 || (p3 = (a2 || 0) >= m2 && a2 <= b2), null !== a2 && n3 >= u2 && n3 <= g2 && p3 && (h3 = o2.toPixels(n3, true), A2 ? ((void 0 === j2 || h3 === I2) && (E2 || (f2 = a2), (void 0 === F || a2 > V2) && (V2 = a2, F = i4), (void 0 === j2 || f2 < X2) && (X2 = f2, j2 = i4)), L2 && h3 === I2 || (void 0 !== j2 && (d2 = r2.toPixels(V2, true), O2 = r2.toPixels(X2, true), Y(h3, d2, F, c3), O2 !== d2 && Y(h3, O2, j2, c3)), j2 = F = void 0, I2 = h3)) : Y(h3, d2 = Math.ceil(r2.toPixels(a2, true)), i4, c3))), !s3);
          }, () => {
            v(this, "renderedCanvas"), delete this.buildKDTree, this.options && this.buildKDTree(), H.debug.timeKDTree && console.timeEnd("kd tree building");
          }));
        }
        function O(t3) {
          let e3 = true;
          if (this.chart.options && this.chart.options.boost && (e3 = void 0 === this.chart.options.boost.enabled || this.chart.options.boost.enabled), !e3 || !this.boosted) return t3.call(this);
          this.chart.boosted = true;
          let i3 = U(this.chart, this);
          i3 && (M(i3, this), i3.pushSeries(this)), N(this);
        }
        function X(t3) {
          if (this.boosted) {
            if (w(this)) return {};
            if (this.xAxis.isPanning || this.yAxis.isPanning) return this;
          }
          return t3.apply(this, [].slice.call(arguments, 1));
        }
        function V(e3) {
          var _a, _b;
          let i3 = this.options.data;
          if (k(this.chart) && t2[this.type]) {
            let t3 = this.is("scatter") && !this.is("bubble") && !this.is("heatmap");
            if (!B(this, i3) || t3 || this.options.stacking || !w(this, true)) {
              if (this.boosted && (((_a = this.xAxis) == null ? void 0 : _a.isPanning) || ((_b = this.yAxis) == null ? void 0 : _b.isPanning))) return;
              t3 && !this.yAxis.treeGrid ? z.call(this, arguments[1]) : e3.apply(this, [].slice.call(arguments, 1)), i3 = this.processedXData;
            }
            if (this.boosted = B(this, i3), this.boosted) {
              let t4;
              this.options.data && this.options.data.length && !P(t4 = this.getFirstValidPoint(this.options.data)) && !y(t4) && x(12, false, this.chart), function(t5) {
                var _a2;
                t5.boost = t5.boost || { getPoint: (e5) => _(t5, e5) };
                let e4 = t5.boost.altered = [];
                if (["allowDG", "directTouch", "stickyTracking"].forEach((i4) => {
                  e4.push({ prop: i4, val: t5[i4], own: Object.hasOwnProperty.call(t5, i4) });
                }), t5.allowDG = false, t5.directTouch = false, t5.stickyTracking = true, t5.finishedAnimating = true, t5.labelBySeries && (t5.labelBySeries = t5.labelBySeries.destroy()), t5.is("scatter") && t5.data.length) {
                  for (let e5 of t5.data) (_a2 = e5 == null ? void 0 : e5.destroy) == null ? void 0 : _a2.call(e5);
                  t5.data.length = 0, t5.points.length = 0, delete t5.processedData;
                }
              }(this);
            } else !function(t4) {
              let e4 = t4.boost, i4 = t4.chart, s2 = i4.boost;
              if (s2 == null ? void 0 : s2.markerGroup) for (let t5 of (s2.markerGroup.destroy(), s2.markerGroup = void 0, i4.series)) t5.markerGroup = void 0, t5.markerGroup = t5.plotGroup("markerGroup", "markers", "visible", 1, i4.seriesGroup).addClass("highcharts-tracker");
              e4 && ((e4.altered || []).forEach((e5) => {
                e5.own ? t4[e5.prop] = e5.val : delete t4[e5.prop];
              }), e4.clear && e4.clear());
            }(this);
          } else e3.apply(this, [].slice.call(arguments, 1));
        }
        function j(t3) {
          let e3 = t3.apply(this, [].slice.call(arguments, 1));
          return this.boost && e3 ? this.boost.getPoint(e3) : e3;
        }
        return { compose: function(i3, s2, o2) {
          if (E(u, "Boost.Series")) {
            let r2 = c().plotOptions, n2 = i3.prototype;
            if (m(i3, "destroy", L), m(i3, "hide", G), o2 && (n2.renderCanvas = I), S(n2, "getExtremes", X), S(n2, "processData", V), S(n2, "searchPoint", j), ["translate", "generatePoints", "drawTracker", "drawPoints", "render"].forEach((e3) => function(e4, i4, s3) {
              function o3(e5) {
                let i5 = this.options.stacking && ("translate" === s3 || "generatePoints" === s3);
                this.boosted && !i5 && k(this.chart) && "heatmap" !== this.type && "treemap" !== this.type && t2[this.type] && 0 !== this.options.boostThreshold ? "render" === s3 && this.renderCanvas && this.renderCanvas() : e5.call(this);
              }
              if (S(e4, s3, o3), "translate" === s3) for (let t3 of ["column", "arearange", "columnrange", "heatmap", "treemap"]) i4[t3] && S(i4[t3].prototype, s3, o3);
            }(n2, s2, e3)), e2.forEach((t3) => {
              let e3 = r2[t3];
              e3 && (e3.boostThreshold = 5e3, e3.boostData = [], s2[t3].prototype.fillOpacity = true);
            }), o2) {
              let { area: t3, areaspline: e3, bubble: i4, column: o3, heatmap: r3, scatter: n3, treemap: a2 } = s2;
              if (t3 && A(t3.prototype, { fill: true, fillOpacity: true, sampling: true }), e3 && A(e3.prototype, { fill: true, fillOpacity: true, sampling: true }), i4) {
                let t4 = i4.prototype;
                delete t4.buildKDTree, S(t4, "markerAttribs", function(t5) {
                  return !this.boosted && t5.apply(this, [].slice.call(arguments, 1));
                });
              }
              o3 && A(o3.prototype, { fill: true, sampling: true }), n3 && (n3.prototype.fill = true), [r3, a2].forEach((t4) => {
                t4 && S(t4.prototype, "drawPoints", O);
              });
            }
          }
          return i3;
        }, destroyGraphics: R, eachAsync: D, getPoint: _ };
      }), i(e, "Extensions/BoostCanvas.js", [e["Extensions/Boost/BoostChart.js"], e["Extensions/Boost/BoostSeries.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, o) {
        var r;
        let { getBoostClipRect: n, isChartSeriesBoosting: a } = t2, { destroyGraphics: l } = e2, { parse: h } = i2, { doc: d, noop: c } = s, { addEvent: u, fireEvent: g, isNumber: f, merge: p, pick: m, wrap: b } = o;
        return function(t3) {
          let s2;
          let r2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";
          function x(t4, e3, i3, s3, o2) {
            o2 && e3 !== o2.clientX && (t4.moveTo(o2.clientX, o2.yBottom), t4.lineTo(o2.clientX, o2.plotY), t4.lineTo(e3, i3), t4.lineTo(e3, s3));
          }
          function A(t4, e3, i3, s3, o2) {
            t4.moveTo(e3, i3), t4.arc(e3, i3, this.radii && this.radii[o2], 0, 2 * Math.PI, false);
          }
          function v(t4, e3, i3, s3) {
            t4.rect(e3 - 1, i3, 1, s3 - i3);
          }
          function y() {
            this.boost && this.boost.copy && this.boost.copy();
          }
          function P() {
            let t4 = this.boost || {};
            t4.target && t4.target.attr({ href: r2 }), t4.canvas && t4.canvas.getContext("2d").clearRect(0, 0, t4.canvas.width, t4.canvas.height);
          }
          function T() {
            a(this.chart) ? this.boost && this.boost.clear && this.boost.clear() : this.boost && this.boost.copy ? this.boost.copy() : this.chart.boost && this.chart.boost.copy && this.chart.boost.copy();
          }
          function E(t4, e3, i3) {
            t4.lineTo(e3, i3);
          }
          function S() {
            let t4;
            let e3 = this.chart, i3 = a(e3) ? e3 : this, s3 = i3 === e3 ? e3.seriesGroup : e3.seriesGroup || this.group, o2 = e3.chartWidth, l2 = e3.chartHeight, h2 = function(t5, e4, i4, s4, o3, r3, n2) {
              t5.call(this, i4, e4, s4, o3, r3, n2);
            }, c2 = i3.boost = i3.boost || {};
            return t4 = c2.targetCtx, c2.canvas || (c2.canvas = d.createElement("canvas"), c2.target = e3.renderer.image("", 0, 0, o2, l2).addClass("highcharts-boost-canvas").add(s3), t4 = c2.targetCtx = c2.canvas.getContext("2d"), e3.inverted && ["moveTo", "lineTo", "rect", "arc"].forEach((e4) => {
              b(t4, e4, h2);
            }), c2.copy = function() {
              c2.target.attr({ href: c2.canvas.toDataURL("image/png") });
            }, c2.clear = function() {
              t4.clearRect(0, 0, c2.canvas.width, c2.canvas.height), i3 === c2.target && c2.target.attr({ href: r2 });
            }, c2.clipRect = e3.renderer.clipRect(), c2.target.clip(c2.clipRect)), c2.canvas.width !== o2 && (c2.canvas.width = o2), c2.canvas.height !== l2 && (c2.canvas.height = l2), c2.target.attr({ x: 0, y: 0, width: o2, height: l2, style: "pointer-events: none", href: r2 }), c2.clipRect && c2.clipRect.attr(n(e3, i3)), t4;
          }
          function C() {
            let t4 = this, n2 = t4.options, a2 = t4.chart, d2 = t4.xAxis, b2 = t4.yAxis, x2 = a2.options.boost || {}, A2 = { timeRendering: x2.timeRendering || false, timeSeriesProcessing: x2.timeSeriesProcessing || false, timeSetup: x2.timeSetup || false }, v2 = t4.processedXData, y2 = t4.processedYData, P2 = n2.data, T2 = d2.getExtremes(), E2 = T2.min, S2 = T2.max, C2 = b2.getExtremes(), M2 = C2.min, k2 = C2.max, U2 = {}, R = !!t4.sampling, D = n2.marker && n2.marker.radius, w = t4.cvsStrokeBatch || 1e3, B = n2.enableMouseTracking, L = n2.threshold, G = f(L), N = b2.getThreshold(L), _ = t4.fill, z = t4.pointArrayMap && "low,high" === t4.pointArrayMap.join(","), I = !!n2.stacking, O = t4.cropStart || 0, X = a2.options.loading, V = t4.requireSorting, j = n2.connectNulls, F = !v2, W = I ? t4.data : v2 || P2, Y = t4.fillOpacity ? i2.parse(t4.color).setOpacity(m(n2.fillOpacity, 0.75)).get() : t4.color, H = "x" === n2.findNearestPointBy, K = this.boost || {}, Z = t4.cvsDrawPoint, q = n2.lineWidth ? t4.cvsLineTo : void 0, Q = D && D <= 1 ? t4.cvsMarkerSquare : t4.cvsMarkerCircle;
            K.target && K.target.attr({ href: r2 }), (t4.points || t4.graph) && l(t4), t4.plotGroup("group", "series", t4.visible ? "visible" : "hidden", n2.zIndex, a2.seriesGroup), t4.markerGroup = t4.group, u(t4, "destroy", function() {
              t4.markerGroup = null;
            });
            let J = this.points = [], $ = this.getContext();
            if (t4.buildKDTree = c, K.clear && K.clear(), !t4.visible) return;
            P2.length > 99999 && (a2.options.loading = p(X, { labelStyle: { backgroundColor: h("#ffffff").setOpacity(0.75).get(), padding: "1em", borderRadius: "0.5em" }, style: { backgroundColor: "none", opacity: 1 } }), o.clearTimeout(s2), a2.showLoading("Drawing..."), a2.options.loading = X), A2.timeRendering && console.time("canvas rendering");
            let tt = 0, te, ti, ts = N, to, tr, tn, ta, tl, th, td = function() {
              _ ? ($.fillStyle = Y, $.fill()) : ($.strokeStyle = t4.color, $.lineWidth = n2.lineWidth, $.stroke());
            }, tc = function(e3, i3, s3, o2) {
              0 === tt && ($.beginPath(), q && ($.lineJoin = "round")), a2.scroller && "highcharts-navigator-series" === t4.options.className ? (i3 += a2.scroller.top, s3 && (s3 += a2.scroller.top)) : i3 += a2.plotTop, e3 += a2.plotLeft, to ? $.moveTo(e3, i3) : Z ? Z($, e3, i3, s3, ti) : q ? q($, e3, i3) : Q && Q.call(t4, $, e3, i3, D, o2), (tt += 1) === w && (td(), tt = 0), ti = { clientX: e3, plotY: i3, yBottom: s3 };
            }, tu = this.xData || this.options.xData || this.processedXData || false, tg = function(t5, e3, i3) {
              th = H ? t5 : t5 + "," + e3, B && !U2[th] && (U2[th] = true, a2.inverted && (t5 = d2.len - t5, e3 = b2.len - e3), J.push({ x: !!tu && tu[O + i3], clientX: t5, plotX: t5, plotY: e3, i: O + i3 }));
            };
            e2.eachAsync(W, (e3, i3) => {
              let s3 = void 0 === a2.index, o2, r3, n3, l2, h2, c2, u2 = false, g2 = false, f2 = NaN, p2 = NaN, m2 = true;
              return !s3 && (F ? (o2 = e3[0], r3 = e3[1], W[i3 + 1] && (f2 = W[i3 + 1][0]), W[i3 - 1] && (p2 = W[i3 - 1][0])) : (o2 = e3, r3 = y2[i3], W[i3 + 1] && (f2 = W[i3 + 1]), W[i3 - 1] && (p2 = W[i3 - 1])), f2 && f2 >= E2 && f2 <= S2 && (u2 = true), p2 && p2 >= E2 && p2 <= S2 && (g2 = true), z ? (F && (r3 = e3.slice(1, 3)), c2 = r3[0], r3 = r3[1]) : I && (o2 = e3.x, c2 = (r3 = e3.stackY) - e3.y), h2 = null === r3, V || (m2 = r3 >= M2 && r3 <= k2), !h2 && (o2 >= E2 && o2 <= S2 && m2 || u2 || g2) && (n3 = Math.round(d2.toPixels(o2, true)), R ? ((void 0 === ta || n3 === te) && (z || (c2 = r3), (void 0 === tl || r3 > tn) && (tn = r3, tl = i3), (void 0 === ta || c2 < tr) && (tr = c2, ta = i3)), n3 !== te && (void 0 !== ta && (l2 = b2.toPixels(tn, true), ts = b2.toPixels(tr, true), tc(n3, G ? Math.min(l2, N) : l2, G ? Math.max(ts, N) : ts, i3), tg(n3, l2, tl), ts !== l2 && tg(n3, ts, ta)), ta = tl = void 0, te = n3)) : (tc(n3, l2 = Math.round(b2.toPixels(r3, true)), ts, i3), tg(n3, l2, i3))), to = h2 && !j, i3 % 5e4 == 0 && (t4.boost && t4.boost.copy ? t4.boost.copy() : t4.chart.boost && t4.chart.boost.copy && t4.chart.boost.copy())), !s3;
            }, function() {
              let e3 = a2.loadingDiv, i3 = a2.loadingShown;
              td(), t4.canvasToSVG(), A2.timeRendering && console.timeEnd("canvas rendering"), g(t4, "renderedCanvas"), i3 && (e3.style.transition = "opacity 250ms", e3.opacity = 0, a2.loadingShown = false, s2 = setTimeout(function() {
                e3.parentNode && e3.parentNode.removeChild(e3), a2.loadingDiv = a2.loadingSpan = null;
              }, 250)), delete t4.buildKDTree, t4.buildKDTree();
            }, a2.renderer.forExport ? Number.MAX_VALUE : void 0);
          }
          function M(t4, e3, i3, s3) {
            t4.moveTo(e3, i3), t4.arc(e3, i3, s3, 0, 2 * Math.PI, false);
          }
          function k(t4, e3, i3, s3) {
            t4.rect(e3 - s3, i3 - s3, 2 * s3, 2 * s3);
          }
          function U() {
            let t4 = this.chart, e3 = this.getContext(), i3 = this.chart.inverted, s3 = this.xAxis, o2 = this.yAxis;
            e3 ? (this.points.forEach((r3) => {
              let n2;
              let a2 = r3.plotY;
              if (void 0 !== a2 && !isNaN(a2) && null !== r3.y && e3) {
                let { x: a3 = 0, y: l2 = 0, width: h2 = 0, height: d2 = 0 } = r3.shapeArgs || {};
                n2 = t4.styledMode ? r3.series.colorAttribs(r3) : r3.series.pointAttribs(r3), e3.fillStyle = n2.fill, i3 ? e3.fillRect(o2.len - l2 + s3.left, s3.len - a3 + o2.top, -d2, -h2) : e3.fillRect(a3 + s3.left, l2 + o2.top, h2, d2);
              }
            }), this.canvasToSVG()) : this.chart.showLoading("Your browser doesn't support HTML5 canvas, <br>please use a modern browser");
          }
          t3.compose = function(t4, e3, i3) {
            let s3 = e3.prototype;
            if (!s3.renderCanvas) {
              let { area: e4, bubble: o2, column: r3, heatmap: n2, scatter: a2 } = i3;
              if (t4.prototype.callbacks.push((t5) => {
                u(t5, "predraw", P), u(t5, "render", y);
              }), s3.canvasToSVG = T, s3.cvsLineTo = E, s3.getContext = S, s3.renderCanvas = C, e4) {
                let t5 = e4.prototype;
                t5.cvsDrawPoint = x, t5.fill = true, t5.fillOpacity = true, t5.sampling = true;
              }
              if (o2) {
                let t5 = o2.prototype;
                t5.cvsMarkerCircle = A, t5.cvsStrokeBatch = 1;
              }
              if (r3) {
                let t5 = r3.prototype;
                t5.cvsDrawPoint = v, t5.fill = true, t5.sampling = true;
              }
              if (n2 && b(n2.prototype, "drawPoints", U), a2) {
                let t5 = a2.prototype;
                t5.cvsMarkerCircle = M, t5.cvsMarkerSquare = k, t5.fill = true;
              }
            }
          };
        }(r || (r = {})), r;
      }), i(e, "masters/modules/boost-canvas.src.js", [e["Core/Globals.js"], e["Extensions/BoostCanvas.js"]], function(t2, e2) {
        return t2.initCanvasBoost = function() {
          e2.compose(t2.Chart, t2.Series, t2.seriesTypes);
        }, t2;
      });
    });
  }
});
export default require_boost_canvas();
//# sourceMappingURL=highcharts_modules_boost-canvas__js.js.map
