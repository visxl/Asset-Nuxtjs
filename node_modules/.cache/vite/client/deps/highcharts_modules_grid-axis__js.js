import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/grid-axis.js
var require_grid_axis = __commonJS({
  "node_modules/highcharts/modules/grid-axis.js"(exports, module) {
    !/**
    * Highcharts Gantt JS v11.4.7 (2024-08-14)
    *
    * GridAxis
    *
    * (c) 2016-2024 Lars A. V. Cabrera
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/grid-axis", ["highcharts"], function(i) {
        return t(i), t.Highcharts = i, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var i = t ? t._modules : {};
      function e(i2, e2, s, r) {
        i2.hasOwnProperty(e2) || (i2[e2] = r.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: e2, module: i2[e2] } })));
      }
      e(i, "Core/Axis/GridAxis.js", [i["Core/Axis/Axis.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2, e2) {
        var s, r;
        let { dateFormats: o } = i2, { addEvent: n, defined: h, erase: l, find: a, isArray: d, isNumber: c, merge: g, pick: f, timeUnits: u, wrap: p } = e2;
        function m(t3) {
          return e2.isObject(t3, true);
        }
        function k(t3, i3) {
          let e3 = { width: 0, height: 0 };
          if (i3.forEach(function(i4) {
            let s2 = t3[i4], r2 = 0, o2 = 0, n2;
            m(s2) && (r2 = (n2 = m(s2.label) ? s2.label : {}).getBBox ? n2.getBBox().height : 0, n2.textStr && !c(n2.textPxLength) && (n2.textPxLength = n2.getBBox().width), o2 = c(n2.textPxLength) ? Math.round(n2.textPxLength) : 0, n2.textStr && (o2 = Math.round(n2.getBBox().width)), e3.height = Math.max(r2, e3.height), e3.width = Math.max(o2, e3.width));
          }), "treegrid" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode) {
            let t4 = this.treeGrid.mapOfPosToGridNode[-1].height || 0;
            e3.width += this.options.labels.indentation * (t4 - 1);
          }
          return e3;
        }
        function x(t3) {
          let { grid: i3 } = this, e3 = 3 === this.side;
          if (e3 || t3.apply(this), !(i3 == null ? void 0 : i3.isColumn)) {
            let t4 = (i3 == null ? void 0 : i3.columns) || [];
            e3 && (t4 = t4.slice().reverse()), t4.forEach((t5) => {
              t5.getOffset();
            });
          }
          e3 && t3.apply(this);
        }
        function b(t3) {
          if (true === (this.options.grid || {}).enabled) {
            let { axisTitle: i3, height: e3, horiz: r2, left: o2, offset: n2, opposite: h2, options: l2, top: a2, width: d2 } = this, c2 = this.tickSize(), g2 = i3 && i3.getBBox().width, u2 = l2.title.x, p2 = l2.title.y, m2 = f(l2.title.margin, r2 ? 5 : 10), k2 = i3 ? this.chart.renderer.fontMetrics(i3).f : 0, x2 = (r2 ? a2 + e3 : o2) + (r2 ? 1 : -1) * (h2 ? -1 : 1) * (c2 ? c2[0] / 2 : 0) + (this.side === s.bottom ? k2 : 0);
            t3.titlePosition.x = r2 ? o2 - (g2 || 0) / 2 - m2 + u2 : x2 + (h2 ? d2 : 0) + n2 + u2, t3.titlePosition.y = r2 ? x2 - (h2 ? e3 : 0) + (h2 ? k2 : -k2) / 2 + n2 + p2 : a2 - m2 + p2;
          }
        }
        function P() {
          let { chart: i3, options: { grid: e3 = {} }, userOptions: s2 } = this;
          if (e3.enabled && function(t3) {
            let i4 = t3.options;
            i4.labels.align = f(i4.labels.align, "center"), t3.categories || (i4.showLastLabel = false), t3.labelRotation = 0, i4.labels.rotation = 0, i4.minTickInterval = 1;
          }(this), e3.columns) {
            let r2 = this.grid.columns = [], o2 = this.grid.columnIndex = 0;
            for (; ++o2 < e3.columns.length; ) {
              let n2 = g(s2, e3.columns[o2], { isInternal: true, linkedTo: 0, scrollbar: { enabled: false } }, { grid: { columns: void 0 } }), h2 = new t2(this.chart, n2, "yAxis");
              h2.grid.isColumn = true, h2.grid.columnIndex = o2, l(i3.axes, h2), l(i3[this.coll] || [], h2), r2.push(h2);
            }
          }
        }
        function y() {
          let { axisTitle: t3, grid: i3, options: e3 } = this;
          if (true === (e3.grid || {}).enabled) {
            let r2 = this.min || 0, o2 = this.max || 0, n2 = this.ticks[this.tickPositions[0]];
            if (t3 && !this.chart.styledMode && (n2 == null ? void 0 : n2.slotWidth) && !this.options.title.style.width && t3.css({ width: `${n2.slotWidth}px` }), this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions), this.rightWall && this.rightWall.destroy(), this.grid && this.grid.isOuterAxis() && this.axisLine) {
              let t4 = e3.lineWidth;
              if (t4) {
                let i4 = this.getLinePath(t4), n3 = i4[0], h2 = i4[1], l2 = (this.tickSize("tick") || [1])[0] * (this.side === s.top || this.side === s.left ? -1 : 1);
                if ("M" === n3[0] && "L" === h2[0] && (this.horiz ? (n3[2] += l2, h2[2] += l2) : (n3[1] += l2, h2[1] += l2)), !this.horiz && this.chart.marginRight) {
                  let t5 = ["L", this.left, n3[2] || 0], i5 = [n3, t5], s2 = ["L", this.chart.chartWidth - this.chart.marginRight, this.toPixels(o2 + this.tickmarkOffset)], l3 = [["M", h2[1] || 0, this.toPixels(o2 + this.tickmarkOffset)], s2];
                  this.grid.upperBorder || r2 % 1 == 0 || (this.grid.upperBorder = this.grid.renderBorder(i5)), this.grid.upperBorder && (this.grid.upperBorder.attr({ stroke: e3.lineColor, "stroke-width": e3.lineWidth }), this.grid.upperBorder.animate({ d: i5 })), this.grid.lowerBorder || o2 % 1 == 0 || (this.grid.lowerBorder = this.grid.renderBorder(l3)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({ stroke: e3.lineColor, "stroke-width": e3.lineWidth }), this.grid.lowerBorder.animate({ d: l3 }));
                }
                this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({ stroke: e3.lineColor, "stroke-width": e3.lineWidth }), this.grid.axisLineExtra.animate({ d: i4 })) : this.grid.axisLineExtra = this.grid.renderBorder(i4), this.axisLine[this.showAxis ? "show" : "hide"]();
              }
            }
            if ((i3 && i3.columns || []).forEach((t4) => t4.render()), !this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar) && this.tickPositions.length) {
              let t4, i4;
              let e4 = this.tickmarkOffset, s2 = this.tickPositions[this.tickPositions.length - 1], n3 = this.tickPositions[0];
              for (; (t4 = this.hiddenLabels.pop()) && t4.element; ) t4.show();
              for (; (i4 = this.hiddenMarks.pop()) && i4.element; ) i4.show();
              (t4 = this.ticks[n3].label) && (r2 - n3 > e4 ? this.hiddenLabels.push(t4.hide()) : t4.show()), (t4 = this.ticks[s2].label) && (s2 - o2 > e4 ? this.hiddenLabels.push(t4.hide()) : t4.show());
              let h2 = this.ticks[s2].mark;
              h2 && s2 - o2 < e4 && s2 - o2 > 0 && this.ticks[s2].isLast && this.hiddenMarks.push(h2.hide());
            }
          }
        }
        function w() {
          let t3 = this.tickPositions && this.tickPositions.info, i3 = this.options, e3 = i3.grid || {}, s2 = this.userOptions.labels || {};
          e3.enabled && (this.horiz ? (this.series.forEach((t4) => {
            t4.options.pointRange = 0;
          }), t3 && i3.dateTimeLabelFormats && i3.labels && !h(s2.align) && (false === i3.dateTimeLabelFormats[t3.unitName].range || t3.count > 1) && (i3.labels.align = "left", h(s2.x) || (i3.labels.x = 3))) : "treegrid" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));
        }
        function L(t3) {
          let i3;
          let e3 = this.options, s2 = t3.userOptions, r2 = e3 && m(e3.grid) ? e3.grid : {};
          true === r2.enabled && (i3 = g(true, { className: "highcharts-grid-axis " + (s2.className || ""), dateTimeLabelFormats: { hour: { list: ["%H:%M", "%H"] }, day: { list: ["%A, %e. %B", "%a, %e. %b", "%E"] }, week: { list: ["Week %W", "W%W"] }, month: { list: ["%B", "%b", "%o"] } }, grid: { borderWidth: 1 }, labels: { padding: 2, style: { fontSize: "0.9em" } }, margin: 0, title: { text: null, reserveSpace: false, rotation: 0, style: { textOverflow: "ellipsis" } }, units: [["millisecond", [1, 10, 100]], ["second", [1, 10]], ["minute", [1, 5, 15]], ["hour", [1, 6]], ["day", [1]], ["week", [1]], ["month", [1]], ["year", null]] }, s2), "xAxis" !== this.coll || (h(s2.linkedTo) && !h(s2.tickPixelInterval) && (i3.tickPixelInterval = 350), !(!h(s2.tickPixelInterval) && h(s2.linkedTo)) || h(s2.tickPositioner) || h(s2.tickInterval) || h(s2.units) || (i3.tickPositioner = function(t4, e4) {
            let s3 = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;
            if (s3) {
              let r3 = i3.units || [], o2, n2 = 1, h2 = "year";
              for (let t5 = 0; t5 < r3.length; t5++) {
                let i4 = r3[t5];
                if (i4 && i4[0] === s3.unitName) {
                  o2 = t5;
                  break;
                }
              }
              let l2 = c(o2) && r3[o2 + 1];
              if (l2) {
                h2 = l2[0] || "year";
                let t5 = l2[1];
                n2 = t5 && t5[0] || 1;
              } else "year" === s3.unitName && (n2 = 10 * s3.count);
              let a2 = u[h2];
              return this.tickInterval = a2 * n2, this.chart.time.getTimeTicks({ unitRange: a2, count: n2, unitName: h2 }, t4, e4, this.options.startOfWeek);
            }
          })), g(true, this.options, i3), this.horiz && (e3.minPadding = f(s2.minPadding, 0), e3.maxPadding = f(s2.maxPadding, 0)), c(e3.grid.borderWidth) && (e3.tickWidth = e3.lineWidth = r2.borderWidth));
        }
        function B(t3) {
          let i3 = t3.userOptions, e3 = i3 && i3.grid || {}, s2 = e3.columns;
          e3.enabled && s2 && g(true, this.options, s2[0]);
        }
        function v() {
          (this.grid.columns || []).forEach((t3) => t3.setScale());
        }
        function M(t3) {
          let { horiz: i3, maxLabelDimensions: e3, options: { grid: s2 = {} } } = this;
          if (s2.enabled && e3) {
            let r2 = 2 * this.options.labels.distance, o2 = i3 ? s2.cellHeight || r2 + e3.height : r2 + e3.width;
            d(t3.tickSize) ? t3.tickSize[0] = o2 : t3.tickSize = [o2, 0];
          }
        }
        function O() {
          this.axes.forEach((t3) => {
            (t3.grid && t3.grid.columns || []).forEach((t4) => {
              t4.setAxisSize(), t4.setAxisTranslation();
            });
          });
        }
        function W(t3) {
          let { grid: i3 } = this;
          (i3.columns || []).forEach((i4) => i4.destroy(t3.keepEvents)), i3.columns = void 0;
        }
        function C(t3) {
          let i3 = t3.userOptions || {}, e3 = i3.grid || {};
          e3.enabled && h(e3.borderColor) && (i3.tickColor = i3.lineColor = e3.borderColor), this.grid || (this.grid = new z(this)), this.hiddenLabels = [], this.hiddenMarks = [];
        }
        function S(t3) {
          let i3 = this.label, e3 = this.axis, r2 = e3.reversed, o2 = e3.chart, n2 = e3.options.grid || {}, h2 = e3.options.labels, l2 = h2.align, a2 = s[e3.side], d2 = t3.tickmarkOffset, g2 = e3.tickPositions, f2 = this.pos - d2, u2 = c(g2[t3.index + 1]) ? g2[t3.index + 1] - d2 : (e3.max || 0) + d2, p2 = e3.tickSize("tick"), m2 = p2 ? p2[0] : 0, k2 = p2 ? p2[1] / 2 : 0;
          if (true === n2.enabled) {
            let s2, n3, d3, c2;
            if ("top" === a2 ? n3 = (s2 = e3.top + e3.offset) - m2 : "bottom" === a2 ? s2 = (n3 = o2.chartHeight - e3.bottom + e3.offset) + m2 : (s2 = e3.top + e3.len - (e3.translate(r2 ? u2 : f2) || 0), n3 = e3.top + e3.len - (e3.translate(r2 ? f2 : u2) || 0)), "right" === a2 ? c2 = (d3 = o2.chartWidth - e3.right + e3.offset) + m2 : "left" === a2 ? d3 = (c2 = e3.left + e3.offset) - m2 : (d3 = Math.round(e3.left + (e3.translate(r2 ? u2 : f2) || 0)) - k2, c2 = Math.min(Math.round(e3.left + (e3.translate(r2 ? f2 : u2) || 0)) - k2, e3.left + e3.len)), this.slotWidth = c2 - d3, t3.pos.x = "left" === l2 ? d3 : "right" === l2 ? c2 : d3 + (c2 - d3) / 2, t3.pos.y = n3 + (s2 - n3) / 2, i3) {
              let e4 = o2.renderer.fontMetrics(i3), s3 = i3.getBBox().height;
              if (h2.useHTML) t3.pos.y += e4.b + -(s3 / 2);
              else {
                let i4 = Math.round(s3 / e4.h);
                t3.pos.y += (e4.b - (e4.h - e4.f)) / 2 + -((i4 - 1) * e4.h / 2);
              }
            }
            t3.pos.x += e3.horiz && h2.x || 0;
          }
        }
        function A(t3) {
          let { axis: e3, value: s2 } = t3;
          if (e3.options.grid && e3.options.grid.enabled) {
            let r2;
            let o2 = e3.tickPositions, n2 = (e3.linkedParent || e3).series[0], h2 = s2 === o2[0], l2 = s2 === o2[o2.length - 1], d2 = n2 && a(n2.options.data, function(t4) {
              return t4[e3.isXAxis ? "x" : "y"] === s2;
            });
            d2 && n2.is("gantt") && (r2 = g(d2), i2.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(r2)), t3.isFirst = h2, t3.isLast = l2, t3.point = r2;
          }
        }
        function T() {
          let t3 = this.options, i3 = t3.grid || {}, e3 = this.categories, s2 = this.tickPositions, r2 = s2[0], o2 = s2[1], n2 = s2[s2.length - 1], h2 = s2[s2.length - 2], l2 = this.linkedParent && this.linkedParent.min, a2 = this.linkedParent && this.linkedParent.max, d2 = l2 || this.min, g2 = a2 || this.max, f2 = this.tickInterval, u2 = c(d2) && d2 >= r2 + f2 && d2 < o2, p2 = c(d2) && r2 < d2 && r2 + f2 > d2, m2 = c(g2) && n2 > g2 && n2 - f2 < g2, k2 = c(g2) && g2 <= n2 - f2 && g2 > h2;
          true === i3.enabled && !e3 && (this.isXAxis || this.isLinked) && ((p2 || u2) && !t3.startOnTick && (s2[0] = d2), (m2 || k2) && !t3.endOnTick && (s2[s2.length - 1] = g2));
        }
        function E(t3) {
          var i3;
          let { options: { grid: e3 = {} } } = this;
          return true === e3.enabled && this.categories ? this.tickInterval : t3.apply(this, (i3 = arguments, Array.prototype.slice.call(i3, 1)));
        }
        (r = s || (s = {}))[r.top = 0] = "top", r[r.right = 1] = "right", r[r.bottom = 2] = "bottom", r[r.left = 3] = "left";
        class z {
          constructor(t3) {
            this.axis = t3;
          }
          isOuterAxis() {
            var _a;
            let t3 = this.axis, i3 = t3.chart, e3 = t3.grid.columnIndex, s2 = ((_a = t3.linkedParent) == null ? void 0 : _a.grid.columns) || t3.grid.columns || [], r2 = e3 ? t3.linkedParent : t3, o2 = -1, n2 = 0;
            return 3 === t3.side && !i3.inverted && s2.length ? !t3.linkedParent : ((i3[t3.coll] || []).forEach((i4, e4) => {
              i4.side !== t3.side || i4.options.isInternal || (n2 = e4, i4 !== r2 || (o2 = e4));
            }), n2 === o2 && (!c(e3) || s2.length === e3));
          }
          renderBorder(t3) {
            let i3 = this.axis, e3 = i3.chart.renderer, s2 = i3.options, r2 = e3.path(t3).addClass("highcharts-axis-line").add(i3.axisGroup);
            return e3.styledMode || r2.attr({ stroke: s2.lineColor, "stroke-width": s2.lineWidth, zIndex: 7 }), r2;
          }
        }
        return o.E = function(t3) {
          return this.dateFormat("%a", t3, true).charAt(0);
        }, o.W = function(t3) {
          let i3 = this, e3 = new this.Date(t3);
          ["Hours", "Milliseconds", "Minutes", "Seconds"].forEach(function(t4) {
            i3.set(t4, e3, 0);
          });
          let s2 = (this.get("Day", e3) + 6) % 7, r2 = new this.Date(e3.valueOf());
          this.set("Date", r2, this.get("Date", e3) - s2 + 3);
          let o2 = new this.Date(this.get("FullYear", r2), 0, 1);
          return 4 !== this.get("Day", o2) && (this.set("Month", e3, 0), this.set("Date", e3, 1 + (11 - this.get("Day", o2)) % 7)), (1 + Math.floor((r2.valueOf() - o2.valueOf()) / 6048e5)).toString();
        }, { compose: function(t3, i3, e3) {
          return t3.keepProps.includes("grid") || (t3.keepProps.push("grid"), t3.prototype.getMaxLabelDimensions = k, p(t3.prototype, "unsquish", E), p(t3.prototype, "getOffset", x), n(t3, "init", C), n(t3, "afterGetTitlePosition", b), n(t3, "afterInit", P), n(t3, "afterRender", y), n(t3, "afterSetAxisTranslation", w), n(t3, "afterSetOptions", L), n(t3, "afterSetOptions", B), n(t3, "afterSetScale", v), n(t3, "afterTickSize", M), n(t3, "trimTicks", T), n(t3, "destroy", W), n(i3, "afterSetChartSize", O), n(e3, "afterGetLabelPosition", S), n(e3, "labelFormat", A)), t3;
        } };
      }), e(i, "masters/modules/grid-axis.src.js", [i["Core/Globals.js"], i["Core/Axis/GridAxis.js"]], function(t2, i2) {
        return i2.compose(t2.Axis, t2.Chart, t2.Tick), t2;
      });
    });
  }
});
export default require_grid_axis();
//# sourceMappingURL=highcharts_modules_grid-axis__js.js.map
