import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/draggable-points.js
var require_draggable_points = __commonJS({
  "node_modules/highcharts/modules/draggable-points.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/draggable-points", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function r(t2, r2, o, a) {
        t2.hasOwnProperty(r2) || (t2[r2] = a.apply(null, o), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: r2, module: t2[r2] } })));
      }
      r(t, "Extensions/DraggablePoints/DragDropUtilities.js", [t["Core/Utilities.js"]], function(e2) {
        let { addEvent: t2 } = e2;
        return { addEvents: function(e3, r2, o, a) {
          let i = r2.map((r3) => t2(e3, r3, o, a));
          return function() {
            for (let e4 of i) e4();
          };
        }, countProps: function(e3) {
          return Object.keys(e3).length;
        }, getFirstProp: function(e3) {
          for (let t3 in e3) if (Object.hasOwnProperty.call(e3, t3)) return e3[t3];
        }, getNormalizedEvent: function(e3, t3) {
          var _a;
          return (void 0 === e3.chartX || void 0 === e3.chartY) && ((_a = t3.pointer) == null ? void 0 : _a.normalize(e3)) || e3;
        } };
      }), r(t, "Extensions/DraggablePoints/DragDropDefaults.js", [], function() {
        return { dragSensitivity: 2, dragHandle: { className: "highcharts-drag-handle", color: "#fff", lineColor: "rgba(0, 0, 0, 0.6)", lineWidth: 1, zIndex: 901 }, guideBox: { default: { className: "highcharts-drag-box-default", lineWidth: 1, lineColor: "#888", color: "rgba(0, 0, 0, 0.1)", cursor: "move", zIndex: 900 } } };
      }), r(t, "Extensions/DraggablePoints/DraggableChart.js", [t["Core/Animation/AnimationUtilities.js"], t["Extensions/DraggablePoints/DragDropUtilities.js"], t["Extensions/DraggablePoints/DragDropDefaults.js"], t["Core/Globals.js"], t["Core/Utilities.js"]], function(e2, t2, r2, o, a) {
        let { animObject: i } = e2, { addEvents: s, countProps: n, getFirstProp: d, getNormalizedEvent: l } = t2, { doc: g } = o, { addEvent: p, merge: h, pick: u } = a;
        function x() {
          let e3 = this.dragHandles || {};
          if (e3) {
            for (let t3 of Object.keys(e3)) e3[t3].destroy && e3[t3].destroy();
            delete this.dragHandles;
          }
        }
        function c(e3, t3) {
          let o2 = this.dragGuideBox, a2 = h(r2.guideBox, t3), i2 = h(a2.default, a2[e3]);
          return o2.attr({ class: i2.className, stroke: i2.lineColor, strokeWidth: i2.lineWidth, fill: i2.color, cursor: i2.cursor, zIndex: i2.zIndex }).css({ pointerEvents: "none" });
        }
        function m(e3) {
          let t3 = this.options.chart || {}, r3 = t3.panKey && t3.panKey + "Key";
          return e3[this.zooming.key && this.zooming.key + "Key"] || e3[r3];
        }
        function f(e3) {
          return { left: "right", right: "left", top: "bottom", bottom: "top" }[e3];
        }
        function D(e3, t3) {
          let r3;
          let o2 = function(e4) {
            let t4 = e4.series, r4 = t4.options.data || [], o3 = t4.options.dragDrop.groupBy, a3 = [];
            if (t4.boosted) for (let e5 = 0, o4 = r4.length; e5 < o4; ++e5) a3.push(new t4.pointClass(t4, r4[e5])), a3[a3.length - 1].index = e5;
            else a3 = t4.points;
            return e4.options[o3] ? a3.filter((t5) => t5.options[o3] === e4.options[o3]) : [e4];
          }(t3), a2 = t3.series, i2 = a2.chart;
          u(a2.options.dragDrop && a2.options.dragDrop.liveRedraw, true) || (i2.dragGuideBox = r3 = a2.getGuideBox(o2), i2.setGuideBoxState("default", a2.options.dragDrop.guideBox).add(a2.group)), i2.dragDropData = { origin: function(e4, t4, r4) {
            let o3 = { chartX: e4.chartX, chartY: e4.chartY, guideBox: r4 && { x: r4.attr("x"), y: r4.attr("y"), width: r4.attr("width"), height: r4.attr("height") }, points: {} };
            for (let r5 of t4) {
              let t5 = r5.series.dragDropProps || {}, a3 = {};
              for (let o4 of Object.keys(t5)) {
                let i3 = t5[o4], s2 = r5.series[i3.axis + "Axis"];
                a3[o4] = r5[o4], r5.series.chart.mapView && r5.plotX && r5.plotY ? a3[o4 + "Offset"] = "x" === o4 ? r5.plotX : r5.plotY : a3[o4 + "Offset"] = s2.toPixels(r5[o4]) - (s2.horiz ? e4.chartX : e4.chartY);
              }
              a3.point = r5, o3.points[r5.id] = a3;
            }
            return o3;
          }(e3, o2, r3), point: t3, groupedPoints: o2, isDragging: true };
        }
        function y(e3, t3) {
          let r3 = t3.dragDropData;
          if (r3 && r3.isDragging && r3.draggedPastSensitivity && r3.point.series) {
            let o2 = r3.point, a2 = r3.newPoints, i2 = n(a2), s2 = 1 === i2 ? d(a2) : null;
            t3.dragHandles && t3.hideDragHandles(), e3.preventDefault(), t3.cancelClick = true, o2.firePointEvent("drop", { origin: r3.origin, chartX: e3.chartX, chartY: e3.chartY, newPoints: a2, numNewPoints: i2, newPoint: s2 && s2.newValues, newPointId: s2 && s2.point.id }, function() {
              v(t3);
            });
          }
          delete t3.dragDropData, t3.dragGuideBox && (t3.dragGuideBox.destroy(), delete t3.dragGuideBox);
        }
        function P() {
          this.hasAddedDragDropEvents || function(e3) {
            let t3 = e3.container;
            (function(e4) {
              let t4 = e4.series ? e4.series.length : 0;
              if (e4.hasCartesianSeries && !e4.polar || e4.mapView) {
                for (; t4--; ) if (e4.series[t4].options.dragDrop && function(e5) {
                  let t5;
                  let r3 = ["draggableX", "draggableY"], o2 = e5.dragDropProps || {};
                  for (let e6 of Object.keys(o2)) (t5 = o2[e6]).optionName && r3.push(t5.optionName);
                  let a2 = r3.length;
                  for (; a2--; ) if (e5.options.dragDrop[r3[a2]]) return true;
                }(e4.series[t4])) return true;
              }
              return false;
            })(e3) && (s(t3, ["mousedown", "touchstart"], (t4) => {
              (function(e4, t5) {
                let r3 = t5.hoverPoint, o2 = h(r3 && r3.series.options.dragDrop, r3 && r3.options.dragDrop), a2 = o2.draggableX || false, i2 = o2.draggableY || false;
                if (t5.cancelClick = false, !(!(a2 || i2) || t5.zoomOrPanKeyPressed(e4)) && !t5.hasDraggedAnnotation) {
                  if (t5.dragDropData && t5.dragDropData.isDragging) {
                    y(e4, t5);
                    return;
                  }
                  r3 && function(e5) {
                    let t6, r4, o3;
                    let a3 = e5.series, i3 = a3.chart, s2 = a3.options.dragDrop || {}, n2 = e5.options && e5.options.dragDrop, d2 = a3.dragDropProps;
                    for (let e6 in d2) "x" === (t6 = d2[e6]).axis && t6.move ? r4 = true : "y" === t6.axis && t6.move && (o3 = true);
                    return (s2.draggableX && r4 || s2.draggableY && o3) && !(n2 && false === n2.draggableX && false === n2.draggableY) && (!!(a3.yAxis && a3.xAxis) || i3.mapView);
                  }(r3) && (t5.mouseIsDown = false, D(e4, r3), r3.firePointEvent("dragStart", e4));
                }
              })(l(t4, e3), e3);
            }), s(t3, ["mousemove", "touchmove"], (t4) => {
              (function(e4, t5) {
                if (t5.zoomOrPanKeyPressed(e4)) return;
                let o2 = t5.dragDropData, a2, i2, s2, l2 = 0, g2;
                o2 && o2.isDragging && o2.point.series && (i2 = (a2 = o2.point).series.options.dragDrop, e4.preventDefault(), o2.draggedPastSensitivity || (o2.draggedPastSensitivity = function(e5, t6, r3) {
                  let o3 = t6.dragDropData.origin, a3 = o3.chartX, i3 = o3.chartY, s3 = e5.chartX, n2 = e5.chartY;
                  return Math.sqrt((s3 - a3) * (s3 - a3) + (n2 - i3) * (n2 - i3)) > r3;
                }(e4, t5, u(a2.options.dragDrop && a2.options.dragDrop.dragSensitivity, i2 && i2.dragSensitivity, r2.dragSensitivity))), o2.draggedPastSensitivity && (o2.newPoints = function(e5, t6) {
                  let r3 = e5.point, o3 = r3.series, a3 = o3.chart, i3 = h(o3.options.dragDrop, r3.options.dragDrop), s3 = {}, n2 = e5.updateProp, d2 = {}, l3 = r3.series.dragDropProps;
                  for (let e6 in l3) {
                    let t7 = l3[e6];
                    (!n2 || n2 === e6 && t7.resize && (!t7.optionName || false !== i3[t7.optionName])) && (n2 || t7.move && ("x" === t7.axis && i3.draggableX || "y" === t7.axis && i3.draggableY)) && (a3.mapView ? s3["x" === e6 ? "lon" : "lat"] = t7 : s3[e6] = t7);
                  }
                  for (let o4 of n2 ? [r3] : e5.groupedPoints) d2[o4.id] = { point: o4, newValues: o4.getDropValues(e5.origin, t6, s3) };
                  return d2;
                }(o2, e4), g2 = 1 === (l2 = n(s2 = o2.newPoints)) ? d(s2) : null, a2.firePointEvent("drag", { origin: o2.origin, newPoints: o2.newPoints, newPoint: g2 && g2.newValues, newPointId: g2 && g2.point.id, numNewPoints: l2, chartX: e4.chartX, chartY: e4.chartY }, function() {
                  !function(e5, t6) {
                    let r3 = t6.series, o3 = r3.chart, a3 = o3.dragDropData, i3 = h(r3.options.dragDrop, t6.options.dragDrop), s3 = i3.draggableX, n2 = i3.draggableY, d2 = a3.origin, l3 = a3.updateProp, g3 = e5.chartX - d2.chartX, p2 = e5.chartY - d2.chartY, x2 = g3;
                    o3.inverted && (g3 = -p2, p2 = -x2), u(i3.liveRedraw, true) ? (v(o3, false), t6.showDragHandles()) : l3 ? function(e6, t7, r4) {
                      let o4 = e6.series, a4 = o4.chart, i4 = a4.dragDropData, s4 = o4.dragDropProps[i4.updateProp], n3 = i4.newPoints[e6.id].newValues, d3 = "function" == typeof s4.resizeSide ? s4.resizeSide(n3, e6) : s4.resizeSide;
                      s4.beforeResize && s4.beforeResize(a4.dragGuideBox, n3, e6), function(e7, t8, r5) {
                        let o5;
                        switch (t8) {
                          case "left":
                            o5 = { x: e7.attr("x") + r5.x, width: Math.max(1, e7.attr("width") - r5.x) };
                            break;
                          case "right":
                            o5 = { width: Math.max(1, e7.attr("width") + r5.x) };
                            break;
                          case "top":
                            o5 = { y: e7.attr("y") + r5.y, height: Math.max(1, e7.attr("height") - r5.y) };
                            break;
                          case "bottom":
                            o5 = { height: Math.max(1, e7.attr("height") + r5.y) };
                        }
                        e7.attr(o5);
                      }(a4.dragGuideBox, "x" === s4.axis && o4.xAxis.reversed || "y" === s4.axis && o4.yAxis.reversed ? f(d3) : d3, { x: "x" === s4.axis ? t7 - (i4.origin.prevdX || 0) : 0, y: "y" === s4.axis ? r4 - (i4.origin.prevdY || 0) : 0 });
                    }(t6, g3, p2) : o3.dragGuideBox.translate(s3 ? g3 : 0, n2 ? p2 : 0), d2.prevdX = g3, d2.prevdY = p2;
                  }(e4, a2);
                })));
              })(l(t4, e3), e3);
            }, { passive: false }), p(t3, "mouseleave", (t4) => {
              y(l(t4, e3), e3);
            }), e3.unbindDragDropMouseUp = s(g, ["mouseup", "touchend"], (t4) => {
              y(l(t4, e3), e3);
            }, { passive: false }), e3.hasAddedDragDropEvents = true, p(e3, "destroy", () => {
              e3.unbindDragDropMouseUp && e3.unbindDragDropMouseUp();
            }));
          }(this);
        }
        function v(e3, t3) {
          let r3;
          let o2 = e3.dragDropData.newPoints, a2 = i(t3);
          for (let t4 of (e3.isDragDropAnimating = true, Object.keys(o2))) (r3 = o2[t4]).point.update(r3.newValues, false);
          e3.redraw(a2), setTimeout(() => {
            delete e3.isDragDropAnimating, e3.hoverPoint && !e3.dragHandles && e3.hoverPoint.showDragHandles();
          }, a2.duration);
        }
        return { compose: function(e3) {
          let t3 = e3.prototype;
          t3.hideDragHandles || (t3.hideDragHandles = x, t3.setGuideBoxState = c, t3.zoomOrPanKeyPressed = m, p(e3, "render", P));
        }, flipResizeSide: f, initDragDrop: D };
      }), r(t, "Extensions/DraggablePoints/DragDropProps.js", [t["Extensions/DraggablePoints/DraggableChart.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { flipResizeSide: r2 } = e2, { isNumber: o, merge: a, pick: i } = t2, s = { x: { axis: "x", move: true }, y: { axis: "y", move: true } }, n = { x: { axis: "x", move: true }, y: { axis: "y", move: false, resize: true, beforeResize: (e3, t3, r3) => {
          let a2, s2;
          let n2 = i(r3.yBottom, r3.series.translatedThreshold), d2 = e3.attr("y"), l2 = o(r3.stackY) ? r3.stackY - (r3.y || 0) : r3.series.options.threshold || 0, g2 = l2 + t3.y;
          (r3.series.yAxis.reversed ? g2 < l2 : g2 >= l2) ? (a2 = e3.attr("height"), s2 = n2 ? n2 - d2 - a2 : 0, e3.attr({ height: Math.max(0, Math.round(a2 + s2)) })) : e3.attr({ y: Math.round(d2 + (n2 ? n2 - d2 : 0)) });
        }, resizeSide: (e3, t3) => {
          let o2 = t3.series.chart.dragHandles, a2 = e3.y >= (t3.series.options.threshold || 0) ? "top" : "bottom", i2 = r2(a2);
          return o2 && o2[i2] && (o2[i2].destroy(), delete o2[i2]), a2;
        }, handlePositioner: (e3) => {
          let t3 = e3.shapeArgs || e3.graphic && e3.graphic.getBBox() || {}, r3 = e3.series.yAxis.reversed, o2 = e3.series.options.threshold || 0, a2 = e3.y || 0;
          return { x: t3.x || 0, y: !r3 && a2 >= o2 || r3 && a2 < o2 ? t3.y || 0 : (t3.y || 0) + (t3.height || 0) };
        }, handleFormatter: (e3) => {
          let t3 = e3.shapeArgs || {}, r3 = t3.r || 0, o2 = t3.width || 0, a2 = o2 / 2;
          return [["M", r3, 0], ["L", a2 - 5, 0], ["A", 1, 1, 0, 0, 0, a2 + 5, 0], ["A", 1, 1, 0, 0, 0, a2 - 5, 0], ["M", a2 + 5, 0], ["L", o2 - r3, 0]];
        } } }, d = { x: n.x, low: { optionName: "draggableLow", axis: "y", move: true, resize: true, resizeSide: "bottom", handlePositioner: (e3) => ({ x: e3.shapeArgs.x || 0, y: e3.lowPlot }), handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 <= t3.q1 }, q1: { optionName: "draggableQ1", axis: "y", move: true, resize: true, resizeSide: "bottom", handlePositioner: (e3) => ({ x: e3.shapeArgs.x || 0, y: e3.q1Plot }), handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 <= t3.median && e3 >= t3.low }, median: { axis: "y", move: true }, q3: { optionName: "draggableQ3", axis: "y", move: true, resize: true, resizeSide: "top", handlePositioner: (e3) => ({ x: e3.shapeArgs.x || 0, y: e3.q3Plot }), handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 <= t3.high && e3 >= t3.median }, high: { optionName: "draggableHigh", axis: "y", move: true, resize: true, resizeSide: "top", handlePositioner: (e3) => ({ x: e3.shapeArgs.x || 0, y: e3.highPlot }), handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 >= t3.q3 } }, l = { x: n.x, low: { ...d.low, propValidate: (e3, t3) => e3 <= t3.high }, high: { ...d.high, propValidate: (e3, t3) => e3 >= t3.low } }, g = { x: n.x, y: n.y, target: { optionName: "draggableTarget", axis: "y", move: true, resize: true, resizeSide: "top", handlePositioner: (e3) => {
          let t3 = e3.targetGraphic.getBBox();
          return { x: e3.barX, y: t3.y + t3.height / 2 };
        }, handleFormatter: n.y.handleFormatter } }, p = { x: n.x, low: { optionName: "draggableLow", axis: "y", move: true, resize: true, resizeSide: "bottom", handlePositioner: (e3) => ({ x: e3.shapeArgs.x, y: e3.plotLow }), handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 <= t3.open && e3 <= t3.close }, high: { optionName: "draggableHigh", axis: "y", move: true, resize: true, resizeSide: "top", handlePositioner: (e3) => ({ x: e3.shapeArgs.x, y: e3.plotHigh }), handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 >= t3.open && e3 >= t3.close }, open: { optionName: "draggableOpen", axis: "y", move: true, resize: true, resizeSide: (e3) => e3.open >= e3.close ? "top" : "bottom", handlePositioner: (e3) => ({ x: e3.shapeArgs.x, y: e3.plotOpen }), handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 <= t3.high && e3 >= t3.low }, close: { optionName: "draggableClose", axis: "y", move: true, resize: true, resizeSide: (e3) => e3.open >= e3.close ? "bottom" : "top", handlePositioner: (e3) => ({ x: e3.shapeArgs.x, y: e3.plotClose }), handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 <= t3.high && e3 >= t3.low } }, h = { x: n.x, y: a(n.y, { handleFormatter: (e3) => e3.isSum || e3.isIntermediateSum ? null : n.y.handleFormatter(e3) }) }, u = { x: { axis: "x", move: true }, low: { optionName: "draggableLow", axis: "y", move: true, resize: true, resizeSide: "bottom", handlePositioner: (e3) => {
          let t3 = e3.shapeArgs || e3.graphic.getBBox();
          return { x: t3.x || 0, y: (t3.y || 0) + (t3.height || 0) };
        }, handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 <= t3.high }, high: { optionName: "draggableHigh", axis: "y", move: true, resize: true, resizeSide: "top", handlePositioner: (e3) => {
          let t3 = e3.shapeArgs || e3.graphic.getBBox();
          return { x: t3.x || 0, y: t3.y || 0 };
        }, handleFormatter: n.y.handleFormatter, propValidate: (e3, t3) => e3 >= t3.low } }, x = { x: u.x, low: { optionName: "draggableLow", axis: "y", move: true, resize: true, resizeSide: "bottom", handlePositioner: (e3) => {
          let t3 = e3.graphics && e3.graphics[0] && e3.graphics[0].getBBox();
          return t3 ? { x: t3.x + t3.width / 2, y: t3.y + t3.height / 2 } : { x: -999, y: -999 };
        }, handleFormatter: m, propValidate: u.low.propValidate }, high: { optionName: "draggableHigh", axis: "y", move: true, resize: true, resizeSide: "top", handlePositioner: (e3) => {
          let t3 = e3.graphics && e3.graphics[1] && e3.graphics[1].getBBox();
          return t3 ? { x: t3.x + t3.width / 2, y: t3.y + t3.height / 2 } : { x: -999, y: -999 };
        }, handleFormatter: m, propValidate: u.high.propValidate } }, c = { y: { axis: "y", move: true }, x: { optionName: "draggableX1", axis: "x", move: true, resize: true, resizeSide: "left", handlePositioner: (e3) => D(e3, "x"), handleFormatter: f, propValidate: (e3, t3) => e3 <= t3.x2 }, x2: { optionName: "draggableX2", axis: "x", move: true, resize: true, resizeSide: "right", handlePositioner: (e3) => D(e3, "x2"), handleFormatter: f, propValidate: (e3, t3) => e3 >= t3.x } };
        function m(e3) {
          let t3 = e3.graphic ? e3.graphic.getBBox().width / 2 + 1 : 4;
          return [["M", 0 - t3, 0], ["a", t3, t3, 0, 1, 0, 2 * t3, 0], ["a", t3, t3, 0, 1, 0, -2 * t3, 0]];
        }
        function f(e3) {
          let t3 = e3.shapeArgs || e3.graphic.getBBox(), r3 = t3.r || 0, o2 = t3.height - r3, a2 = t3.height / 2;
          return [["M", 0, r3], ["L", 0, a2 - 5], ["A", 1, 1, 0, 0, 0, 0, a2 + 5], ["A", 1, 1, 0, 0, 0, 0, a2 - 5], ["M", 0, a2 + 5], ["L", 0, o2]];
        }
        function D(e3, t3) {
          let r3 = e3.series, o2 = r3.xAxis, a2 = r3.yAxis, i2 = r3.chart.inverted, s2 = r3.columnMetrics ? r3.columnMetrics.offset : -e3.shapeArgs.height / 2, n2 = o2.toPixels(e3[t3], true), d2 = a2.toPixels(e3.y, true);
          return i2 && (n2 = o2.len - n2, d2 = a2.len - d2), { x: Math.round(n2), y: Math.round(d2 += s2) };
        }
        return { arearange: x, boxplot: d, bullet: g, column: n, columnrange: u, errorbar: l, flags: s, gantt: { y: c.y, start: a(c.x, { optionName: "draggableStart", validateIndividualDrag: (e3) => !e3.milestone }), end: a(c.x2, { optionName: "draggableEnd", validateIndividualDrag: (e3) => !e3.milestone }) }, line: s, ohlc: p, waterfall: h, xrange: c };
      }), r(t, "Extensions/DraggablePoints/DraggablePoints.js", [t["Extensions/DraggablePoints/DragDropUtilities.js"], t["Extensions/DraggablePoints/DraggableChart.js"], t["Extensions/DraggablePoints/DragDropDefaults.js"], t["Extensions/DraggablePoints/DragDropProps.js"], t["Core/Utilities.js"]], function(e2, t2, r2, o, a) {
        let { addEvents: i, getNormalizedEvent: s } = e2, { initDragDrop: n } = t2, { addEvent: d, clamp: l, isNumber: g, merge: p, pick: h } = a;
        function u(e3) {
          let t3 = e3.series && e3.series.chart, r3 = t3 && t3.dragDropData;
          t3 && t3.dragHandles && !(r3 && (r3.isDragging && r3.draggedPastSensitivity || r3.isHoveringHandle === e3.id)) && t3.hideDragHandles();
        }
        function x() {
          let e3 = this;
          setTimeout(() => {
            e3.series && u(e3);
          }, 10);
        }
        function c() {
          let e3 = this;
          setTimeout(() => function(e4) {
            let t3 = e4.series, r3 = t3 && t3.chart, o2 = r3 && r3.dragDropData, a2 = r3 && r3.is3d && r3.is3d();
            !r3 || o2 && o2.isDragging && o2.draggedPastSensitivity || r3.isDragDropAnimating || !t3.options.dragDrop || a2 || (r3.dragHandles && r3.hideDragHandles(), e4.showDragHandles());
          }(e3), 12);
        }
        function m() {
          let e3 = this.series.chart, t3 = e3.dragHandles;
          t3 && t3.point === this.id && e3.hideDragHandles();
        }
        function f(e3, t3, r3) {
          let o2 = this.series, a2 = o2.chart, i2 = a2.mapView, s2 = p(o2.options.dragDrop, this.options.dragDrop), n2 = {}, d2 = e3.points[this.id], u2 = 1 === Object.keys(r3).length, x2 = (e4, t4) => {
            let r4 = o2[t4.toLowerCase() + "Axis"].categories ? 1 : 0, a3 = h(s2["dragPrecision" + t4], r4), i3 = h(s2["dragMin" + t4], -1 / 0), n3 = h(s2["dragMax" + t4], 1 / 0), d3 = e4;
            return a3 && (d3 = Math.round(d3 / a3) * a3), l(d3, i3, n3);
          }, c2 = (e4, t4, r4) => {
            if (i2) {
              let o3 = h(s2["dragPrecision" + t4], 0), n3 = i2.pixelsToLonLat({ x: 0, y: 0 }), d3 = i2.pixelsToLonLat({ x: a2.plotBox.width, y: a2.plotBox.height }), g2 = h(s2["dragMin" + t4], n3 && n3[r4], -1 / 0), p2 = h(s2["dragMax" + t4], d3 && d3[r4], 1 / 0), u3 = e4[r4];
              if ("Orthographic" === i2.projection.options.name) return u3;
              if ("lat" === r4) {
                (isNaN(g2) || g2 > i2.projection.maxLatitude) && (g2 = i2.projection.maxLatitude), (isNaN(p2) || p2 < -1 * i2.projection.maxLatitude) && (p2 = -1 * i2.projection.maxLatitude);
                let e5 = p2;
                p2 = g2, g2 = e5;
              }
              if (!i2.projection.hasCoordinates) {
                let t5 = i2.pixelsToLonLat({ x: e4.chartX - a2.plotLeft, y: a2.plotHeight - e4.chartY + a2.plotTop });
                t5 && (u3 = t5[r4]);
              }
              return o3 && (u3 = Math.round(u3 / o3) * o3), l(u3, g2, p2);
            }
          };
          for (let e4 of Object.keys(r3)) {
            let a3 = r3[e4], s3 = d2.point[e4], l2 = o2[a3.axis + "Axis"], p2 = i2 ? c2(t3, a3.axis.toUpperCase(), e4) : x2(l2.toValue((l2.horiz ? t3.chartX : t3.chartY) + d2[e4 + "Offset"]), a3.axis.toUpperCase());
            g(p2) && !(u2 && a3.propValidate && !a3.propValidate(p2, this)) && void 0 !== s3 && (n2[e4] = p2);
          }
          return n2;
        }
        function D() {
          let e3 = this, t3 = e3.series, o2 = t3.chart, { inverted: a2, renderer: l2 } = o2, g2 = p(t3.options.dragDrop, e3.options.dragDrop), h2 = t3.dragDropProps || {}, x2 = o2.dragHandles;
          for (let c2 of Object.keys(h2)) {
            let m2, f2, D2;
            let y2 = h2[c2], P = p(r2.dragHandle, y2.handleOptions, g2.dragHandle), v = { class: P.className, "stroke-width": P.lineWidth, fill: P.color, stroke: P.lineColor }, b = P.pathFormatter || y2.handleFormatter, w = y2.handlePositioner, z = !y2.validateIndividualDrag || y2.validateIndividualDrag(e3);
            if (y2.resize && z && y2.resizeSide && b && (g2["draggable" + y2.axis.toUpperCase()] || g2[y2.optionName]) && false !== g2[y2.optionName]) {
              x2 ? x2.point = e3.id : x2 = o2.dragHandles = { group: l2.g("drag-drop-handles").add(t3.markerGroup || t3.group), point: e3.id }, m2 = w(e3), v.d = D2 = b(e3);
              let r3 = e3.series.xAxis.categories ? -0.5 : 0;
              if (!D2 || m2.x < r3 || m2.y < 0) return;
              v.cursor = P.cursor || ("x" === y2.axis != !!a2 ? "ew-resize" : "ns-resize"), (f2 = x2[y2.optionName]) || (f2 = x2[y2.optionName] = l2.path().add(x2.group)), v.translateX = a2 ? t3.yAxis.len - m2.y : m2.x, v.translateY = a2 ? t3.xAxis.len - m2.x : m2.y, a2 && (v.rotation = -90), f2.attr(v), i(f2.element, ["touchstart", "mousedown"], (t4) => {
                !function(e4, t5, r4) {
                  let o3 = t5.series.chart;
                  o3.zoomOrPanKeyPressed(e4) || (o3.mouseIsDown = false, n(e4, t5), o3.dragDropData.updateProp = e4.updateProp = r4, t5.firePointEvent("dragStart", e4), e4.stopPropagation(), e4.preventDefault());
                }(s(t4, o2), e3, c2);
              }, { passive: false }), d(x2.group.element, "mouseover", () => {
                o2.dragDropData = o2.dragDropData || {}, o2.dragDropData.isHoveringHandle = e3.id;
              }), i(x2.group.element, ["touchend", "mouseout"], () => {
                !function(e4) {
                  let t4 = e4.series.chart;
                  t4.dragDropData && e4.id === t4.dragDropData.isHoveringHandle && delete t4.dragDropData.isHoveringHandle, t4.hoverPoint || u(e4);
                }(e3);
              });
            }
          }
        }
        function y(e3) {
          let t3 = this.chart, r3 = 1 / 0, o2 = -1 / 0, a2 = 1 / 0, i2 = -1 / 0, s2;
          for (let t4 of e3) {
            let e4 = t4.graphic && t4.graphic.getBBox() || t4.shapeArgs;
            if (e4) {
              let n2;
              let d2 = t4.x2;
              g(d2) && (n2 = t4.series.xAxis.translate(d2, false, false, false, true));
              let l2 = !(e4.width || e4.height || e4.x || e4.y);
              s2 = true, r3 = Math.min(t4.plotX || 0, n2 || 0, l2 ? 1 / 0 : e4.x || 0, r3), o2 = Math.max(t4.plotX || 0, n2 || 0, (e4.x || 0) + (e4.width || 0), o2), a2 = Math.min(t4.plotY || 0, l2 ? 1 / 0 : e4.y || 0, a2), i2 = Math.max((e4.y || 0) + (e4.height || 0), i2);
            }
          }
          return s2 ? t3.renderer.rect(r3, a2, o2 - r3, i2 - a2) : t3.renderer.g();
        }
        return { compose: function(e3, r3) {
          t2.compose(e3);
          let a2 = r3.prototype;
          if (!a2.dragDropProps) {
            let e4 = r3.prototype.pointClass, t3 = r3.types, i2 = e4.prototype;
            for (let r4 of (i2.getDropValues = f, i2.showDragHandles = D, d(e4, "mouseOut", x), d(e4, "mouseOver", c), d(e4, "remove", m), a2.dragDropProps = o.line, a2.getGuideBox = y, ["arearange", "boxplot", "bullet", "column", "columnrange", "errorbar", "flags", "gantt", "ohlc", "waterfall", "xrange"])) t3[r4] && (t3[r4].prototype.dragDropProps = o[r4]);
            for (let e5 of ["bellcurve", "gauge", "histogram", "map", "mapline", "pareto", "pie", "sankey", "sma", "sunburst", "treemap", "vector", "windbarb", "wordcloud"]) t3[e5] && (t3[e5].prototype.dragDropProps = null);
          }
        } };
      }), r(t, "masters/modules/draggable-points.src.js", [t["Core/Globals.js"], t["Extensions/DraggablePoints/DraggablePoints.js"]], function(e2, t2) {
        return t2.compose(e2.Chart, e2.Series), e2;
      });
    });
  }
});
export default require_draggable_points();
//# sourceMappingURL=highcharts_modules_draggable-points__js.js.map
