import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/geoheatmap.js
var require_geoheatmap = __commonJS({
  "node_modules/highcharts/modules/geoheatmap.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2009-2024
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/geoheatmap", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, o, a) {
        e2.hasOwnProperty(i2) || (e2[i2] = a.apply(null, o), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Series/GeoHeatmap/GeoHeatmapPoint.js", [e["Core/Utilities.js"], e["Core/Series/SeriesRegistry.js"]], function(t2, e2) {
        let { map: { prototype: { pointClass: i2 } } } = e2.seriesTypes, { isNumber: o } = t2;
        return class extends i2 {
          applyOptions(t3, e3) {
            let i3 = super.applyOptions.call(this, t3, e3), { lat: a, lon: s } = i3.options;
            if (o(s) && o(a)) {
              let { colsize: t4 = 1, rowsize: e4 = 1 } = this.series.options, o2 = s - t4 / 2, n = a - e4 / 2;
              i3.geometry = i3.options.geometry = { type: "Polygon", coordinates: [[[o2, n], [o2 + t4, n], [o2 + t4, n + e4], [o2, n + e4], [o2, n]]] };
            }
            return i3;
          }
        };
      }), i(e, "Series/InterpolationUtilities.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { doc: i2 } = t2, { defined: o, pick: a } = e2;
        return { colorFromPoint: function(t3, e3) {
          let i3 = e3.series.colorAxis;
          if (i3) {
            let s = i3.toColor(t3 || 0, e3).split(")")[0].split("(")[1].split(",").map((t4) => a(parseFloat(t4), parseInt(t4, 10)));
            return s[3] = 255 * a(s[3], 1), o(t3) && e3.visible || (s[3] = 0), s;
          }
          return [0, 0, 0, 0];
        }, getContext: function(t3) {
          let { canvas: e3, context: o2 } = t3;
          return e3 && o2 ? (o2.clearRect(0, 0, e3.width, e3.height), o2) : (t3.canvas = i2.createElement("canvas"), t3.context = t3.canvas.getContext("2d", { willReadFrequently: true }) || void 0, t3.context);
        } };
      }), i(e, "Series/GeoHeatmap/GeoHeatmapSeries.js", [e["Core/Animation/AnimationUtilities.js"], e["Series/GeoHeatmap/GeoHeatmapPoint.js"], e["Core/Globals.js"], e["Series/InterpolationUtilities.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, i2, o, a, s) {
        let { animObject: n, stop: r } = t2, { noop: l } = i2, { colorFromPoint: h, getContext: p } = o, { seriesTypes: { map: d } } = a, { addEvent: u, extend: g, isNumber: c, isObject: m, merge: y, pick: f } = s;
        function x(t3) {
          return t3 - 360 * Math.floor((t3 + 180) / 360);
        }
        class b extends d {
          constructor() {
            super(...arguments), this.isDirtyCanvas = true;
          }
          update() {
            this.options = y(this.options, arguments[0]), this.getInterpolation().enabled && (this.isDirtyCanvas = true, this.points.forEach((t3) => {
              t3.graphic && (t3.graphic.destroy(), delete t3.graphic);
            })), super.update.apply(this, arguments);
          }
          translate() {
            (!this.getInterpolation().enabled || !this.image || this.isDirty || this.isDirtyData) && super.translate.apply(this, arguments);
          }
          getInterpolation() {
            return m(this.options.interpolation) ? this.options.interpolation : { blur: 1, enabled: this.options.interpolation };
          }
          drawPoints() {
            let t3 = this.chart.mapView, e3 = this.options;
            if (this.getInterpolation().enabled && t3 && this.bounds) {
              let i3 = this.context || p(this), { canvas: o2, colorAxis: a2, image: s2, chart: l2, points: d2 } = this, [u2, g2] = [f(e3.colsize, 1), f(e3.rowsize, 1)], m2 = t3.projectedUnitsToPixels({ x: this.bounds.x1, y: this.bounds.y2 }), x2 = t3.projectedUnitsToPixels({ x: this.bounds.x2, y: this.bounds.y1 });
              if (o2 && i3 && a2 && m2 && x2) {
                let e4 = { x: m2.x, y: m2.y, width: x2.x - m2.x, height: x2.y - m2.y };
                if (this.isDirtyCanvas || this.isDirtyData || "Orthographic" === t3.projection.options.name) {
                  this.isDirtyCanvas = true;
                  let a3 = o2.width = ~~(360 / u2) + 1, s3 = o2.height = ~~(180 / g2) + 1, n2 = new Uint8ClampedArray(a3 * s3 * 4);
                  this.directTouch = false;
                  for (let t4 = 0; t4 < d2.length; t4++) {
                    let e5 = d2[t4], i4 = new Uint8ClampedArray(h(e5.value, e5)), { lon: o3, lat: r3 } = e5.options;
                    c(o3) && c(r3) && n2.set(i4, 4 * Math.ceil(a3 * (s3 - 1 - (r3 + 90) / g2) + (o3 + 180) / u2));
                  }
                  let r2 = this.getInterpolation().blur, l3 = 0 === r2 ? 1 : 11 * r2, p2 = ~~e4.width, m3 = ~~e4.height, y2 = new ImageData(n2, a3, s3);
                  o2.width = ~~(a3 * l3), o2.height = ~~(s3 * l3), i3.putImageData(y2, 0, 0), i3.globalCompositeOperation = "copy", i3.drawImage(o2, 0, 0, y2.width, y2.height, 0, 0, o2.width, o2.height);
                  let f2 = i3.getImageData(0, 0, o2.width, o2.height), x3 = new ImageData(this.getProjectedImageData(t3, p2, m3, f2, o2, e4.x, e4.y), p2, m3);
                  i3.globalCompositeOperation = "copy", o2.width = p2, o2.height = m3, i3.putImageData(x3, 0, 0);
                }
                if (s2) {
                  if (l2.renderer.globalAnimation && l2.hasRendered) {
                    let t4 = Number(s2.attr("x")), i4 = Number(s2.attr("y")), a3 = Number(s2.attr("width")), r2 = Number(s2.attr("height")), h2 = (o3, n2) => {
                      s2.attr({ x: t4 + (e4.x - t4) * n2.pos, y: i4 + (e4.y - i4) * n2.pos, width: a3 + (e4.width - a3) * n2.pos, height: r2 + (e4.height - r2) * n2.pos });
                    }, p2 = y(n(l2.renderer.globalAnimation)), d3 = p2.step;
                    p2.step = function() {
                      d3 && d3.apply(this, arguments), h2.apply(this, arguments);
                    }, s2.attr(y({ animator: 0 }, this.isDirtyCanvas ? { href: o2.toDataURL("image/png", 1) } : void 0)).animate({ animator: 1 }, p2);
                  } else r(s2), s2.attr(y(e4, this.isDirtyCanvas ? { href: o2.toDataURL("image/png", 1) } : void 0));
                } else this.image = l2.renderer.image(o2.toDataURL("image/png", 1)).attr(e4).add(this.group);
                this.isDirtyCanvas = false;
              }
            } else super.drawPoints.apply(this, arguments);
          }
          getProjectedImageData(t3, e3, i3, o2, a2, s2, n2) {
            var _a;
            let r2 = new Uint8ClampedArray(e3 * i3 * 4), l2 = f((_a = t3.projection.options.rotation) == null ? void 0 : _a[0], 0), h2 = a2.width / 360, p2 = -1 * a2.height / 180, d2 = -1;
            for (let i4 = 0; i4 < r2.length; i4 += 4) {
              let u2 = i4 / 4 % e3;
              0 === u2 && d2++;
              let g2 = t3.pixelsToLonLat({ x: s2 + u2, y: n2 + d2 });
              if (g2) {
                g2.lon > -180 - l2 && g2.lon < 180 - l2 && (g2.lon = x(g2.lon));
                let t4 = [g2.lon, g2.lat], e4 = t4[0] * h2 + a2.width / 2, s3 = t4[1] * p2 + a2.height / 2;
                if (e4 >= 0 && e4 <= a2.width && s3 >= 0 && s3 <= a2.height) {
                  let t5 = Math.floor(s3) * a2.width * 4 + 4 * Math.round(e4);
                  r2[i4] = o2.data[t5], r2[i4 + 1] = o2.data[t5 + 1], r2[i4 + 2] = o2.data[t5 + 2], r2[i4 + 3] = o2.data[t5 + 3];
                }
              }
            }
            return r2;
          }
          searchPoint(t3, e3) {
            let i3 = this.chart, o2 = i3.mapView;
            if (o2 && this.bounds && this.image && i3.tooltip && i3.tooltip.options.enabled) {
              if (!i3.pointer.hasDragged && (0.01 >= +this.image.attr("animator") || +this.image.attr("animator") >= 0.99)) {
                let a2 = o2.projectedUnitsToPixels({ x: this.bounds.x1, y: this.bounds.y2 }), s2 = o2.projectedUnitsToPixels({ x: this.bounds.x2, y: this.bounds.y1 });
                if (i3.pointer.normalize(t3), t3.lon && t3.lat && a2 && s2 && t3.chartX - i3.plotLeft > a2.x && t3.chartX - i3.plotLeft < s2.x && t3.chartY - i3.plotTop > a2.y && t3.chartY - i3.plotTop < s2.y) return this.searchKDTree({ clientX: t3.chartX, lon: x(t3.lon), lat: t3.lat }, e3, t3);
              } else i3.tooltip.destroy();
            }
          }
        }
        return b.defaultOptions = y(d.defaultOptions, { nullColor: "transparent", tooltip: { pointFormat: "Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>" }, borderWidth: 0, colsize: 1, rowsize: 1, stickyTracking: true, interpolation: { enabled: false, blur: 1 } }), u(b, "afterDataClassLegendClick", function() {
          this.isDirtyCanvas = true, this.drawPoints();
        }), g(b.prototype, { type: "geoheatmap", applyJitter: l, pointClass: e2, pointArrayMap: ["lon", "lat", "value"], kdAxisArray: ["lon", "lat"] }), a.registerSeriesType("geoheatmap", b), b;
      }), i(e, "masters/modules/geoheatmap.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_geoheatmap();
//# sourceMappingURL=highcharts_modules_geoheatmap__js.js.map
