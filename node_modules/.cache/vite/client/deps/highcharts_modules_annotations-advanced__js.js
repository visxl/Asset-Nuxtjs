import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/annotations-advanced.js
var require_annotations_advanced = __commonJS({
  "node_modules/highcharts/modules/annotations-advanced.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Annotations module
    *
    * (c) 2009-2024 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/annotations-advanced", ["highcharts"], function(i) {
        return t(i), t.Highcharts = i, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var i = t ? t._modules : {};
      function s(i2, s2, n, e) {
        i2.hasOwnProperty(s2) || (i2[s2] = e.apply(null, n), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s2, module: i2[s2] } })));
      }
      s(i, "Extensions/Annotations/AnnotationChart.js", [i["Core/Utilities.js"]], function(t2) {
        var i2;
        let { addEvent: s2, erase: n, find: e, fireEvent: o, pick: a, wrap: r } = t2;
        function l(t3, i3) {
          let s3 = this.initAnnotation(t3);
          return this.options.annotations.push(s3.options), a(i3, true) && (s3.redraw(), s3.graphic.attr({ opacity: 1 })), s3;
        }
        function h() {
          let t3 = this;
          t3.plotBoxClip = this.renderer.clipRect(this.plotBox), t3.controlPointsGroup = t3.renderer.g("control-points").attr({ zIndex: 99 }).clip(t3.plotBoxClip).add(), t3.options.annotations.forEach((i3, s3) => {
            if (!t3.annotations.some((t4) => t4.options === i3)) {
              let n2 = t3.initAnnotation(i3);
              t3.options.annotations[s3] = n2.options;
            }
          }), t3.drawAnnotations(), s2(t3, "redraw", t3.drawAnnotations), s2(t3, "destroy", function() {
            t3.plotBoxClip.destroy(), t3.controlPointsGroup.destroy();
          }), s2(t3, "exportData", function(i3) {
            let s3 = t3.annotations, n2 = (this.options.exporting && this.options.exporting.csv || {}).columnHeaderFormatter, e2 = !i3.dataRows[1].xValues, o2 = t3.options.lang && t3.options.lang.exportData && t3.options.lang.exportData.annotationHeader, a2 = i3.dataRows[0].length, r2 = t3.options.exporting && t3.options.exporting.csv && t3.options.exporting.csv.annotations && t3.options.exporting.csv.annotations.itemDelimiter, l2 = t3.options.exporting && t3.options.exporting.csv && t3.options.exporting.csv.annotations && t3.options.exporting.csv.annotations.join;
            s3.forEach((t4) => {
              t4.options.labelOptions && t4.options.labelOptions.includeInDataExport && t4.labels.forEach((t5) => {
                if (t5.options.text) {
                  let s4 = t5.options.text;
                  t5.points.forEach((t6) => {
                    let n3 = t6.x, e3 = t6.series.xAxis ? t6.series.xAxis.index : -1, o3 = false;
                    if (-1 === e3) {
                      let t7 = i3.dataRows[0].length, a3 = Array(t7);
                      for (let i4 = 0; i4 < t7; ++i4) a3[i4] = "";
                      a3.push(s4), a3.xValues = [], a3.xValues[e3] = n3, i3.dataRows.push(a3), o3 = true;
                    }
                    if (o3 || i3.dataRows.forEach((t7) => {
                      !o3 && t7.xValues && void 0 !== e3 && n3 === t7.xValues[e3] && (l2 && t7.length > a2 ? t7[t7.length - 1] += r2 + s4 : t7.push(s4), o3 = true);
                    }), !o3) {
                      let t7 = i3.dataRows[0].length, o4 = Array(t7);
                      for (let i4 = 0; i4 < t7; ++i4) o4[i4] = "";
                      o4[0] = n3, o4.push(s4), o4.xValues = [], void 0 !== e3 && (o4.xValues[e3] = n3), i3.dataRows.push(o4);
                    }
                  });
                }
              });
            });
            let h2 = 0;
            i3.dataRows.forEach((t4) => {
              h2 = Math.max(h2, t4.length);
            });
            let p2 = h2 - i3.dataRows[0].length;
            for (let t4 = 0; t4 < p2; t4++) {
              let s4 = function(t5) {
                let i4;
                return n2 && false !== (i4 = n2(t5)) ? i4 : (i4 = o2 + " " + t5, e2) ? { columnTitle: i4, topLevelColumnTitle: i4 } : i4;
              }(t4 + 1);
              e2 ? (i3.dataRows[0].push(s4.topLevelColumnTitle), i3.dataRows[1].push(s4.columnTitle)) : i3.dataRows[0].push(s4);
            }
          });
        }
        function p() {
          this.plotBoxClip.attr(this.plotBox), this.annotations.forEach((t3) => {
            t3.redraw(), t3.graphic.animate({ opacity: 1 }, t3.animationConfig);
          });
        }
        function c(t3) {
          let i3 = this.annotations, s3 = "annotations" === t3.coll ? t3 : e(i3, function(i4) {
            return i4.options.id === t3;
          });
          s3 && (o(s3, "remove"), n(this.options.annotations, s3.options), n(i3, s3), s3.destroy());
        }
        function d() {
          this.annotations = [], this.options.annotations || (this.options.annotations = []);
        }
        function u(t3) {
          this.chart.hasDraggedAnnotation || t3.apply(this, Array.prototype.slice.call(arguments, 1));
        }
        return (i2 || (i2 = {})).compose = function(t3, i3, n2) {
          let e2 = i3.prototype;
          if (!e2.addAnnotation) {
            let o2 = n2.prototype;
            s2(i3, "afterInit", d), e2.addAnnotation = l, e2.callbacks.push(h), e2.collectionsWithInit.annotations = [l], e2.collectionsWithUpdate.push("annotations"), e2.drawAnnotations = p, e2.removeAnnotation = c, e2.initAnnotation = function(i4) {
              let s3 = new (t3.types[i4.type] || t3)(this, i4);
              return this.annotations.push(s3), s3;
            }, r(o2, "onContainerMouseDown", u);
          }
        }, i2;
      }), s(i, "Extensions/Annotations/AnnotationDefaults.js", [i["Core/Utilities.js"]], function(t2) {
        let { defined: i2 } = t2;
        return { visible: true, animation: {}, crop: true, draggable: "xy", labelOptions: { align: "center", allowOverlap: false, backgroundColor: "rgba(0, 0, 0, 0.75)", borderColor: "#000000", borderRadius: 3, borderWidth: 1, className: "highcharts-no-tooltip", crop: false, formatter: function() {
          return i2(this.y) ? "" + this.y : "Annotation label";
        }, includeInDataExport: true, overflow: "justify", padding: 5, shadow: false, shape: "callout", style: { fontSize: "0.7em", fontWeight: "normal", color: "contrast" }, useHTML: false, verticalAlign: "bottom", x: 0, y: -16 }, shapeOptions: { stroke: "rgba(0, 0, 0, 0.75)", strokeWidth: 1, fill: "rgba(0, 0, 0, 0.75)", r: 0, snap: 2 }, controlPointOptions: { events: {}, style: { cursor: "pointer", fill: "#ffffff", stroke: "#000000", "stroke-width": 2 }, height: 10, symbol: "circle", visible: false, width: 10 }, events: {}, zIndex: 6 };
      }), s(i, "Extensions/Annotations/EventEmitter.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { doc: s2, isTouchDevice: n } = t2, { addEvent: e, fireEvent: o, objectEach: a, pick: r, removeEvent: l } = i2;
        return class {
          addEvents() {
            let t3 = this, i3 = function(i4) {
              e(i4, n ? "touchstart" : "mousedown", (i5) => {
                t3.onMouseDown(i5);
              }, { passive: false });
            };
            if (i3(this.graphic.element), (t3.labels || []).forEach((t4) => {
              t4.options.useHTML && t4.graphic.text && i3(t4.graphic.text.element);
            }), a(t3.options.events, (i4, s3) => {
              let n2 = function(n3) {
                var _a;
                "click" === s3 && t3.cancelClick || i4.call(t3, (_a = t3.chart.pointer) == null ? void 0 : _a.normalize(n3), t3.target);
              };
              -1 === (t3.nonDOMEvents || []).indexOf(s3) ? (e(t3.graphic.element, s3, n2, { passive: false }), t3.graphic.div && e(t3.graphic.div, s3, n2, { passive: false })) : e(t3, s3, n2, { passive: false });
            }), t3.options.draggable && (e(t3, "drag", t3.onDrag), !t3.graphic.renderer.styledMode)) {
              let i4 = { cursor: { x: "ew-resize", y: "ns-resize", xy: "move" }[t3.options.draggable] };
              t3.graphic.css(i4), (t3.labels || []).forEach((t4) => {
                t4.options.useHTML && t4.graphic.text && t4.graphic.text.css(i4);
              });
            }
            t3.isUpdating || o(t3, "add");
          }
          destroy() {
            this.removeDocEvents(), l(this), this.hcEvents = null;
          }
          mouseMoveToRadians(t3, i3, s3) {
            let n2 = t3.prevChartY - s3, e2 = t3.prevChartX - i3, o2 = t3.chartY - s3, a2 = t3.chartX - i3, r2;
            return this.chart.inverted && (r2 = e2, e2 = n2, n2 = r2, r2 = a2, a2 = o2, o2 = r2), Math.atan2(o2, a2) - Math.atan2(n2, e2);
          }
          mouseMoveToScale(t3, i3, s3) {
            let n2 = t3.prevChartX - i3, e2 = t3.prevChartY - s3, o2 = t3.chartX - i3, a2 = t3.chartY - s3, r2 = (o2 || 1) / (n2 || 1), l2 = (a2 || 1) / (e2 || 1);
            if (this.chart.inverted) {
              let t4 = l2;
              l2 = r2, r2 = t4;
            }
            return { x: r2, y: l2 };
          }
          mouseMoveToTranslation(t3) {
            let i3 = t3.chartX - t3.prevChartX, s3 = t3.chartY - t3.prevChartY, n2;
            return this.chart.inverted && (n2 = s3, s3 = i3, i3 = n2), { x: i3, y: s3 };
          }
          onDrag(t3) {
            if (this.chart.isInsidePlot(t3.chartX - this.chart.plotLeft, t3.chartY - this.chart.plotTop, { visiblePlotOnly: true })) {
              let i3 = this.mouseMoveToTranslation(t3);
              "x" === this.options.draggable && (i3.y = 0), "y" === this.options.draggable && (i3.x = 0), this.points.length ? this.translate(i3.x, i3.y) : (this.shapes.forEach((t4) => t4.translate(i3.x, i3.y)), this.labels.forEach((t4) => t4.translate(i3.x, i3.y))), this.redraw(false);
            }
          }
          onMouseDown(t3) {
            var _a;
            if (t3.preventDefault && t3.preventDefault(), 2 === t3.button) return;
            let i3 = this, a2 = i3.chart.pointer, l2 = ((_a = t3 == null ? void 0 : t3.sourceCapabilities) == null ? void 0 : _a.firesTouchEvents) || false, h = (t3 = (a2 == null ? void 0 : a2.normalize(t3)) || t3).chartX, p = t3.chartY;
            i3.cancelClick = false, i3.chart.hasDraggedAnnotation = true, i3.removeDrag = e(s2, n || l2 ? "touchmove" : "mousemove", function(t4) {
              i3.hasDragged = true, (t4 = (a2 == null ? void 0 : a2.normalize(t4)) || t4).prevChartX = h, t4.prevChartY = p, o(i3, "drag", t4), h = t4.chartX, p = t4.chartY;
            }, n || l2 ? { passive: false } : void 0), i3.removeMouseUp = e(s2, n || l2 ? "touchend" : "mouseup", function() {
              let t4 = r(i3.target && i3.target.annotation, i3.target);
              t4 && (t4.cancelClick = i3.hasDragged), i3.cancelClick = i3.hasDragged, i3.chart.hasDraggedAnnotation = false, i3.hasDragged && o(r(t4, i3), "afterUpdate"), i3.hasDragged = false, i3.onMouseUp();
            }, n || l2 ? { passive: false } : void 0);
          }
          onMouseUp() {
            this.removeDocEvents();
          }
          removeDocEvents() {
            this.removeDrag && (this.removeDrag = this.removeDrag()), this.removeMouseUp && (this.removeMouseUp = this.removeMouseUp());
          }
        };
      }), s(i, "Extensions/Annotations/ControlPoint.js", [i["Extensions/Annotations/EventEmitter.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { merge: s2, pick: n } = i2;
        return class extends t2 {
          constructor(t3, i3, s3, e) {
            super(), this.nonDOMEvents = ["drag"], this.chart = t3, this.target = i3, this.options = s3, this.index = n(s3.index, e);
          }
          destroy() {
            super.destroy(), this.graphic && (this.graphic = this.graphic.destroy()), this.chart = null, this.target = null, this.options = null;
          }
          redraw(t3) {
            this.graphic[t3 ? "animate" : "attr"](this.options.positioner.call(this, this.target));
          }
          render() {
            let t3 = this.chart, i3 = this.options;
            this.graphic = t3.renderer.symbol(i3.symbol, 0, 0, i3.width, i3.height).add(t3.controlPointsGroup).css(i3.style), this.setVisibility(i3.visible), this.addEvents();
          }
          setVisibility(t3) {
            this.graphic[t3 ? "show" : "hide"](), this.options.visible = t3;
          }
          update(t3) {
            let i3 = this.chart, n2 = this.target, e = this.index, o = s2(true, this.options, t3);
            this.destroy(), this.constructor(i3, n2, o, e), this.render(i3.controlPointsGroup), this.redraw();
          }
        };
      }), s(i, "Extensions/Annotations/MockPoint.js", [i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { series: { prototype: s2 } } = t2, { defined: n, fireEvent: e } = i2;
        class o {
          static fromPoint(t3) {
            return new o(t3.series.chart, null, { x: t3.x, y: t3.y, xAxis: t3.series.xAxis, yAxis: t3.series.yAxis });
          }
          static pointToPixels(t3, i3) {
            let s3 = t3.series, n2 = s3.chart, e2 = t3.plotX || 0, o2 = t3.plotY || 0, a;
            return n2.inverted && (t3.mock ? (e2 = t3.plotY, o2 = t3.plotX) : (e2 = n2.plotWidth - (t3.plotY || 0), o2 = n2.plotHeight - (t3.plotX || 0))), s3 && !i3 && (e2 += (a = s3.getPlotBox()).translateX, o2 += a.translateY), { x: e2, y: o2 };
          }
          static pointToOptions(t3) {
            return { x: t3.x, y: t3.y, xAxis: t3.series.xAxis, yAxis: t3.series.yAxis };
          }
          constructor(t3, i3, n2) {
            this.mock = true, this.series = { visible: true, chart: t3, getPlotBox: s2.getPlotBox }, this.target = i3 || null, this.options = n2, this.applyOptions(this.getOptions());
          }
          applyOptions(t3) {
            this.command = t3.command, this.setAxis(t3, "x"), this.setAxis(t3, "y"), this.refresh();
          }
          getLabelConfig() {
            return { x: this.x, y: this.y, point: this };
          }
          getOptions() {
            return this.hasDynamicOptions() ? this.options(this.target) : this.options;
          }
          hasDynamicOptions() {
            return "function" == typeof this.options;
          }
          isInsidePlot() {
            let t3 = this.plotX, i3 = this.plotY, s3 = this.series.xAxis, o2 = this.series.yAxis, a = { x: t3, y: i3, isInsidePlot: true, options: {} };
            return s3 && (a.isInsidePlot = n(t3) && t3 >= 0 && t3 <= s3.len), o2 && (a.isInsidePlot = a.isInsidePlot && n(i3) && i3 >= 0 && i3 <= o2.len), e(this.series.chart, "afterIsInsidePlot", a), a.isInsidePlot;
          }
          refresh() {
            let t3 = this.series, i3 = t3.xAxis, s3 = t3.yAxis, n2 = this.getOptions();
            i3 ? (this.x = n2.x, this.plotX = i3.toPixels(n2.x, true)) : (this.x = void 0, this.plotX = n2.x), s3 ? (this.y = n2.y, this.plotY = s3.toPixels(n2.y, true)) : (this.y = null, this.plotY = n2.y), this.isInside = this.isInsidePlot();
          }
          refreshOptions() {
            let t3 = this.series, i3 = t3.xAxis, s3 = t3.yAxis;
            this.x = this.options.x = i3 ? this.options.x = i3.toValue(this.plotX, true) : this.plotX, this.y = this.options.y = s3 ? s3.toValue(this.plotY, true) : this.plotY;
          }
          rotate(t3, i3, s3) {
            if (!this.hasDynamicOptions()) {
              let n2 = Math.cos(s3), e2 = Math.sin(s3), o2 = this.plotX - t3, a = this.plotY - i3;
              this.plotX = o2 * n2 - a * e2 + t3, this.plotY = o2 * e2 + a * n2 + i3, this.refreshOptions();
            }
          }
          scale(t3, i3, s3, n2) {
            if (!this.hasDynamicOptions()) {
              let e2 = this.plotX * s3, o2 = this.plotY * n2;
              this.plotX = (1 - s3) * t3 + e2, this.plotY = (1 - n2) * i3 + o2, this.refreshOptions();
            }
          }
          setAxis(t3, i3) {
            let s3 = i3 + "Axis", e2 = t3[s3], o2 = this.series.chart;
            this.series[s3] = "object" == typeof e2 ? e2 : n(e2) ? o2[s3][e2] || o2.get(e2) : null;
          }
          toAnchor() {
            let t3 = [this.plotX, this.plotY, 0, 0];
            return this.series.chart.inverted && (t3[0] = this.plotY, t3[1] = this.plotX), t3;
          }
          translate(t3, i3, s3, n2) {
            this.hasDynamicOptions() || (this.plotX += s3, this.plotY += n2, this.refreshOptions());
          }
        }
        return o;
      }), s(i, "Extensions/Annotations/ControlTarget.js", [i["Extensions/Annotations/ControlPoint.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        var n;
        return function(n2) {
          function e() {
            let i3 = this.controlPoints, n3 = this.options.controlPoints || [];
            n3.forEach((e2, o2) => {
              let a2 = s2.merge(this.options.controlPointOptions, e2);
              a2.index || (a2.index = o2), n3[o2] = a2, i3.push(new t2(this.chart, this, a2));
            });
          }
          function o(t3) {
            let i3 = t3.series.getPlotBox(), n3 = t3.series.chart, e2 = t3.mock ? t3.toAnchor() : n3.tooltip && n3.tooltip.getAnchor.call({ chart: t3.series.chart }, t3) || [0, 0, 0, 0], o2 = { x: e2[0] + (this.options.x || 0), y: e2[1] + (this.options.y || 0), height: e2[2] || 0, width: e2[3] || 0 };
            return { relativePosition: o2, absolutePosition: s2.merge(o2, { x: o2.x + (t3.mock ? i3.translateX : n3.plotLeft), y: o2.y + (t3.mock ? i3.translateY : n3.plotTop) }) };
          }
          function a() {
            this.controlPoints.forEach((t3) => t3.destroy()), this.chart = null, this.controlPoints = null, this.points = null, this.options = null, this.annotation && (this.annotation = null);
          }
          function r() {
            let t3 = this.options;
            return t3.points || t3.point && s2.splat(t3.point);
          }
          function l() {
            let t3, i3;
            let s3 = this.getPointsOptions(), n3 = this.points, e2 = s3 && s3.length || 0;
            for (t3 = 0; t3 < e2; t3++) {
              if (!(i3 = this.point(s3[t3], n3[t3]))) {
                n3.length = 0;
                return;
              }
              i3.mock && i3.refresh(), n3[t3] = i3;
            }
            return n3;
          }
          function h(t3, n3) {
            if (t3 && t3.series) return t3;
            if (!n3 || null === n3.series) {
              if (s2.isObject(t3)) n3 = new i2(this.chart, this, t3);
              else if (s2.isString(t3)) n3 = this.chart.get(t3) || null;
              else if ("function" == typeof t3) {
                let s3 = t3.call(n3, this);
                n3 = s3.series ? s3 : new i2(this.chart, this, t3);
              }
            }
            return n3;
          }
          function p(t3) {
            this.controlPoints.forEach((i3) => i3.redraw(t3));
          }
          function c() {
            this.controlPoints.forEach((t3) => t3.render());
          }
          function d(t3, i3, s3, n3, e2) {
            if (this.chart.inverted) {
              let t4 = i3;
              i3 = s3, s3 = t4;
            }
            this.points.forEach((o2, a2) => this.transformPoint(t3, i3, s3, n3, e2, a2), this);
          }
          function u(t3, s3, n3, e2, o2, a2) {
            let r2 = this.points[a2];
            r2.mock || (r2 = this.points[a2] = i2.fromPoint(r2)), r2[t3](s3, n3, e2, o2);
          }
          function x(t3, i3) {
            this.transform("translate", null, null, t3, i3);
          }
          function g(t3, i3, s3) {
            this.transformPoint("translate", null, null, t3, i3, s3);
          }
          n2.compose = function(t3) {
            let i3 = t3.prototype;
            i3.addControlPoints || s2.merge(true, i3, { addControlPoints: e, anchor: o, destroyControlTarget: a, getPointsOptions: r, linkPoints: l, point: h, redrawControlPoints: p, renderControlPoints: c, transform: d, transformPoint: u, translate: x, translatePoint: g });
          };
        }(n || (n = {})), n;
      }), s(i, "Extensions/Annotations/Controllables/Controllable.js", [i["Extensions/Annotations/ControlTarget.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { merge: s2 } = i2;
        class n {
          constructor(t3, i3, s3, n2) {
            this.annotation = t3, this.chart = t3.chart, this.collection = "label" === n2 ? "labels" : "shapes", this.controlPoints = [], this.options = i3, this.points = [], this.index = s3, this.itemType = n2, this.init(t3, i3, s3);
          }
          attr(...t3) {
            this.graphic.attr.apply(this.graphic, arguments);
          }
          attrsFromOptions(t3) {
            let i3, s3;
            let n2 = this.constructor.attrsMap, e = {}, o = this.chart.styledMode;
            for (i3 in t3) s3 = n2[i3], void 0 === n2[i3] || o && -1 !== ["fill", "stroke", "stroke-width"].indexOf(s3) || (e[s3] = t3[i3]);
            return e;
          }
          destroy() {
            this.graphic && (this.graphic = this.graphic.destroy()), this.tracker && (this.tracker = this.tracker.destroy()), this.destroyControlTarget();
          }
          init(t3, i3, s3) {
            this.annotation = t3, this.chart = t3.chart, this.options = i3, this.points = [], this.controlPoints = [], this.index = s3, this.linkPoints(), this.addControlPoints();
          }
          redraw(t3) {
            this.redrawControlPoints(t3);
          }
          render(t3) {
            this.options.className && this.graphic && this.graphic.addClass(this.options.className), this.renderControlPoints();
          }
          rotate(t3, i3, s3) {
            this.transform("rotate", t3, i3, s3);
          }
          scale(t3, i3, s3, n2) {
            this.transform("scale", t3, i3, s3, n2);
          }
          setControlPointsVisibility(t3) {
            this.controlPoints.forEach((i3) => {
              i3.setVisibility(t3);
            });
          }
          shouldBeDrawn() {
            return !!this.points.length;
          }
          translateShape(t3, i3, s3) {
            let n2 = this.annotation.chart, e = this.annotation.userOptions, o = n2.annotations.indexOf(this.annotation), a = n2.options.annotations[o];
            this.translatePoint(t3, i3, 0), s3 && this.translatePoint(t3, i3, 1), a[this.collection][this.index].point = this.options.point, e[this.collection][this.index].point = this.options.point;
          }
          update(t3) {
            let i3 = this.annotation, n2 = s2(true, this.options, t3), e = this.graphic.parentGroup, o = this.constructor;
            this.destroy(), s2(true, this, new o(i3, n2, this.index, this.itemType)), this.render(e), this.redraw();
          }
        }
        return t2.compose(n), n;
      }), s(i, "Extensions/Annotations/Controllables/ControllableDefaults.js", [], function() {
        return { defaultMarkers: { arrow: { tagName: "marker", attributes: { id: "arrow", refY: 5, refX: 9, markerWidth: 10, markerHeight: 10 }, children: [{ tagName: "path", attributes: { d: "M 0 0 L 10 5 L 0 10 Z", "stroke-width": 0 } }] }, "reverse-arrow": { tagName: "marker", attributes: { id: "reverse-arrow", refY: 5, refX: 1, markerWidth: 10, markerHeight: 10 }, children: [{ tagName: "path", attributes: { d: "M 0 5 L 10 0 L 10 10 Z", "stroke-width": 0 } }] } } };
      }), s(i, "Extensions/Annotations/Controllables/ControllablePath.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllableDefaults.js"], i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n) {
        let { defaultMarkers: e } = i2, { addEvent: o, defined: a, extend: r, merge: l, uniqueKey: h } = n, p = u("marker-end"), c = u("marker-start"), d = "rgba(192,192,192," + (s2.svg ? 1e-4 : 2e-3) + ")";
        function u(t3) {
          return function(i3) {
            this.attr(t3, "url(#" + i3 + ")");
          };
        }
        function x() {
          this.options.defs = l(e, this.options.defs || {});
        }
        function g(t3, i3) {
          let s3 = { attributes: { id: t3 } }, n2 = { stroke: i3.color || "none", fill: i3.color || "rgba(0, 0, 0, 0.75)" };
          s3.children = i3.children && i3.children.map(function(t4) {
            return l(n2, t4);
          });
          let e2 = l(true, { attributes: { markerWidth: 20, markerHeight: 20, refX: 0, refY: 0, orient: "auto" } }, i3, s3), o2 = this.definition(e2);
          return o2.id = t3, o2;
        }
        class y extends t2 {
          static compose(t3, i3) {
            let s3 = i3.prototype;
            s3.addMarker || (o(t3, "afterGetContainer", x), s3.addMarker = g);
          }
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "path";
          }
          toD() {
            let t3 = this.options.d;
            if (t3) return "function" == typeof t3 ? t3.call(this) : t3;
            let i3 = this.points, s3 = i3.length, n2 = [], e2 = s3, o2 = i3[0], a2 = e2 && this.anchor(o2).absolutePosition, r2 = 0, l2;
            if (a2) for (n2.push(["M", a2.x, a2.y]); ++r2 < s3 && e2; ) l2 = (o2 = i3[r2]).command || "L", a2 = this.anchor(o2).absolutePosition, "M" === l2 ? n2.push([l2, a2.x, a2.y]) : "L" === l2 ? n2.push([l2, a2.x, a2.y]) : "Z" === l2 && n2.push([l2]), e2 = o2.series.visible;
            return e2 && this.graphic ? this.chart.renderer.crispLine(n2, this.graphic.strokeWidth()) : null;
          }
          shouldBeDrawn() {
            return super.shouldBeDrawn() || !!this.options.d;
          }
          render(t3) {
            let i3 = this.options, s3 = this.attrsFromOptions(i3);
            this.graphic = this.annotation.chart.renderer.path([["M", 0, 0]]).attr(s3).add(t3), this.tracker = this.annotation.chart.renderer.path([["M", 0, 0]]).addClass("highcharts-tracker-line").attr({ zIndex: 2 }).add(t3), this.annotation.chart.styledMode || this.tracker.attr({ "stroke-linejoin": "round", stroke: d, fill: d, "stroke-width": this.graphic.strokeWidth() + 2 * i3.snap }), super.render(), r(this.graphic, { markerStartSetter: c, markerEndSetter: p }), this.setMarkers(this);
          }
          redraw(t3) {
            if (this.graphic) {
              let i3 = this.toD(), s3 = t3 ? "animate" : "attr";
              i3 ? (this.graphic[s3]({ d: i3 }), this.tracker[s3]({ d: i3 })) : (this.graphic.attr({ d: "M 0 -9000000000" }), this.tracker.attr({ d: "M 0 -9000000000" })), this.graphic.placed = this.tracker.placed = !!i3;
            }
            super.redraw(t3);
          }
          setMarkers(t3) {
            let i3 = t3.options, s3 = t3.chart, n2 = s3.options.defs, e2 = i3.fill, o2 = a(e2) && "none" !== e2 ? e2 : i3.stroke;
            ["markerStart", "markerEnd"].forEach(function(e3) {
              let a2, r2, p2, c2;
              let d2 = i3[e3];
              if (d2) {
                for (p2 in n2) if ((d2 === ((a2 = n2[p2]).attributes && a2.attributes.id) || d2 === a2.id) && "marker" === a2.tagName) {
                  r2 = a2;
                  break;
                }
                r2 && (c2 = t3[e3] = s3.renderer.addMarker((i3.id || h()) + "-" + d2, l(r2, { color: o2 })), t3.attr(e3, c2.getAttribute("id")));
              }
            });
          }
        }
        return y.attrsMap = { dashStyle: "dashstyle", strokeWidth: "stroke-width", stroke: "stroke", fill: "fill", zIndex: "zIndex" }, y;
      }), s(i, "Extensions/Annotations/Controllables/ControllableRect.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllablePath.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: n } = s2;
        class e extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "rect", this.translate = super.translateShape;
          }
          render(t3) {
            let i3 = this.attrsFromOptions(this.options);
            this.graphic = this.annotation.chart.renderer.rect(0, -9e9, 0, 0).attr(i3).add(t3), super.render();
          }
          redraw(t3) {
            if (this.graphic) {
              let i3 = this.anchor(this.points[0]).absolutePosition;
              i3 ? this.graphic[t3 ? "animate" : "attr"]({ x: i3.x, y: i3.y, width: this.options.width, height: this.options.height }) : this.attr({ x: 0, y: -9e9 }), this.graphic.placed = !!i3;
            }
            super.redraw(t3);
          }
        }
        return e.attrsMap = n(i2.attrsMap, { width: "width", height: "height" }), e;
      }), s(i, "Extensions/Annotations/Controllables/ControllableCircle.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllablePath.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: n } = s2;
        class e extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "circle", this.translate = super.translateShape;
          }
          redraw(t3) {
            if (this.graphic) {
              let i3 = this.anchor(this.points[0]).absolutePosition;
              i3 ? this.graphic[t3 ? "animate" : "attr"]({ x: i3.x, y: i3.y, r: this.options.r }) : this.graphic.attr({ x: 0, y: -9e9 }), this.graphic.placed = !!i3;
            }
            super.redraw.call(this, t3);
          }
          render(t3) {
            let i3 = this.attrsFromOptions(this.options);
            this.graphic = this.annotation.chart.renderer.circle(0, -9e9, 0).attr(i3).add(t3), super.render();
          }
          setRadius(t3) {
            this.options.r = t3;
          }
        }
        return e.attrsMap = n(i2.attrsMap, { r: "r" }), e;
      }), s(i, "Extensions/Annotations/Controllables/ControllableEllipse.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllablePath.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: n, defined: e } = s2;
        class o extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "ellipse";
          }
          init(t3, i3, s3) {
            e(i3.yAxis) && i3.points.forEach((t4) => {
              t4.yAxis = i3.yAxis;
            }), e(i3.xAxis) && i3.points.forEach((t4) => {
              t4.xAxis = i3.xAxis;
            }), super.init(t3, i3, s3);
          }
          render(t3) {
            this.graphic = this.annotation.chart.renderer.createElement("ellipse").attr(this.attrsFromOptions(this.options)).add(t3), super.render();
          }
          translate(t3, i3) {
            super.translateShape(t3, i3, true);
          }
          getDistanceFromLine(t3, i3, s3, n2) {
            return Math.abs((i3.y - t3.y) * s3 - (i3.x - t3.x) * n2 + i3.x * t3.y - i3.y * t3.x) / Math.sqrt((i3.y - t3.y) * (i3.y - t3.y) + (i3.x - t3.x) * (i3.x - t3.x));
          }
          getAttrs(t3, i3) {
            let s3 = t3.x, n2 = t3.y, e2 = i3.x, o2 = i3.y, a = (s3 + e2) / 2, r = Math.sqrt((s3 - e2) * (s3 - e2) / 4 + (n2 - o2) * (n2 - o2) / 4), l = 180 * Math.atan((o2 - n2) / (e2 - s3)) / Math.PI;
            return a < s3 && (l += 180), { cx: a, cy: (n2 + o2) / 2, rx: r, ry: this.getRY(), angle: l };
          }
          getRY() {
            let t3 = this.getYAxis();
            return e(t3) ? Math.abs(t3.toPixels(this.options.ry) - t3.toPixels(0)) : this.options.ry;
          }
          getYAxis() {
            let t3 = this.options.yAxis;
            return this.chart.yAxis[t3];
          }
          getAbsolutePosition(t3) {
            return this.anchor(t3).absolutePosition;
          }
          redraw(t3) {
            if (this.graphic) {
              let i3 = this.getAbsolutePosition(this.points[0]), s3 = this.getAbsolutePosition(this.points[1]), n2 = this.getAttrs(i3, s3);
              i3 ? this.graphic[t3 ? "animate" : "attr"]({ cx: n2.cx, cy: n2.cy, rx: n2.rx, ry: n2.ry, rotation: n2.angle, rotationOriginX: n2.cx, rotationOriginY: n2.cy }) : this.graphic.attr({ x: 0, y: -9e9 }), this.graphic.placed = !!i3;
            }
            super.redraw(t3);
          }
          setYRadius(t3) {
            let i3 = this.annotation.userOptions.shapes;
            this.options.ry = t3, i3 && i3[0] && (i3[0].ry = t3, i3[0].ry = t3);
          }
        }
        return o.attrsMap = n(i2.attrsMap, { ry: "ry" }), o;
      }), s(i, "Extensions/Annotations/Controllables/ControllableLabel.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Core/Templating.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n) {
        let { format: e } = i2, { extend: o, isNumber: a, pick: r } = n;
        function l(t3, i3, s3, n2, e2) {
          let o2 = e2 && e2.anchorX, r2 = e2 && e2.anchorY, l2, h2, p = s3 / 2;
          return a(o2) && a(r2) && (l2 = [["M", o2, r2]], (h2 = i3 - r2) < 0 && (h2 = -n2 - h2), h2 < s3 && (p = o2 < t3 + s3 / 2 ? h2 : s3 - h2), r2 > i3 + n2 ? l2.push(["L", t3 + p, i3 + n2]) : r2 < i3 ? l2.push(["L", t3 + p, i3]) : o2 < t3 ? l2.push(["L", t3, i3 + n2 / 2]) : o2 > t3 + s3 && l2.push(["L", t3 + s3, i3 + n2 / 2])), l2 || [];
        }
        class h extends t2 {
          static alignedPosition(t3, i3) {
            let s3 = t3.align, n2 = t3.verticalAlign, e2 = (i3.x || 0) + (t3.x || 0), o2 = (i3.y || 0) + (t3.y || 0), a2, r2;
            return "right" === s3 ? a2 = 1 : "center" === s3 && (a2 = 2), a2 && (e2 += (i3.width - (t3.width || 0)) / a2), "bottom" === n2 ? r2 = 1 : "middle" === n2 && (r2 = 2), r2 && (o2 += (i3.height - (t3.height || 0)) / r2), { x: Math.round(e2), y: Math.round(o2) };
          }
          static compose(t3) {
            t3.prototype.symbols.connector = l;
          }
          static justifiedOptions(t3, i3, s3, n2) {
            let e2;
            let o2 = s3.align, a2 = s3.verticalAlign, r2 = i3.box ? 0 : i3.padding || 0, l2 = i3.getBBox(), h2 = { align: o2, verticalAlign: a2, x: s3.x, y: s3.y, width: i3.width, height: i3.height }, p = (n2.x || 0) - t3.plotLeft, c = (n2.y || 0) - t3.plotTop;
            return (e2 = p + r2) < 0 && ("right" === o2 ? h2.align = "left" : h2.x = (h2.x || 0) - e2), (e2 = p + l2.width - r2) > t3.plotWidth && ("left" === o2 ? h2.align = "right" : h2.x = (h2.x || 0) + t3.plotWidth - e2), (e2 = c + r2) < 0 && ("bottom" === a2 ? h2.verticalAlign = "top" : h2.y = (h2.y || 0) - e2), (e2 = c + l2.height - r2) > t3.plotHeight && ("top" === a2 ? h2.verticalAlign = "bottom" : h2.y = (h2.y || 0) + t3.plotHeight - e2), h2;
          }
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "label");
          }
          translatePoint(t3, i3) {
            super.translatePoint(t3, i3, 0);
          }
          translate(t3, i3) {
            let s3 = this.annotation.chart, n2 = this.annotation.userOptions, e2 = s3.annotations.indexOf(this.annotation), o2 = s3.options.annotations[e2];
            if (s3.inverted) {
              let s4 = t3;
              t3 = i3, i3 = s4;
            }
            this.options.x += t3, this.options.y += i3, o2[this.collection][this.index].x = this.options.x, o2[this.collection][this.index].y = this.options.y, n2[this.collection][this.index].x = this.options.x, n2[this.collection][this.index].y = this.options.y;
          }
          render(t3) {
            let i3 = this.options, s3 = this.attrsFromOptions(i3), n2 = i3.style;
            this.graphic = this.annotation.chart.renderer.label("", 0, -9999, i3.shape, null, null, i3.useHTML, null, "annotation-label").attr(s3).add(t3), this.annotation.chart.styledMode || ("contrast" === n2.color && (n2.color = this.annotation.chart.renderer.getContrast(h.shapesWithoutBackground.indexOf(i3.shape) > -1 ? "#FFFFFF" : i3.backgroundColor)), this.graphic.css(i3.style).shadow(i3.shadow)), this.graphic.labelrank = i3.labelrank, super.render();
          }
          redraw(t3) {
            let i3 = this.options, s3 = this.text || i3.format || i3.text, n2 = this.graphic, o2 = this.points[0];
            if (!n2) {
              this.redraw(t3);
              return;
            }
            n2.attr({ text: s3 ? e(String(s3), o2.getLabelConfig(), this.annotation.chart) : i3.formatter.call(o2, this) });
            let a2 = this.anchor(o2), r2 = this.position(a2);
            r2 ? (n2.alignAttr = r2, r2.anchorX = a2.absolutePosition.x, r2.anchorY = a2.absolutePosition.y, n2[t3 ? "animate" : "attr"](r2)) : n2.attr({ x: 0, y: -9999 }), n2.placed = !!r2, super.redraw(t3);
          }
          anchor(t3) {
            let i3 = super.anchor.apply(this, arguments), s3 = this.options.x || 0, n2 = this.options.y || 0;
            return i3.absolutePosition.x -= s3, i3.absolutePosition.y -= n2, i3.relativePosition.x -= s3, i3.relativePosition.y -= n2, i3;
          }
          position(t3) {
            let i3 = this.graphic, n2 = this.annotation.chart, e2 = n2.tooltip, a2 = this.points[0], l2 = this.options, p = t3.absolutePosition, c = t3.relativePosition, d, u, x, g, y = a2.series.visible && s2.prototype.isInsidePlot.call(a2);
            if (i3 && y) {
              let { width: t4 = 0, height: s3 = 0 } = i3;
              l2.distance && e2 ? d = e2.getPosition.call({ chart: n2, distance: r(l2.distance, 16), getPlayingField: e2.getPlayingField, pointer: e2.pointer }, t4, s3, { plotX: c.x, plotY: c.y, negative: a2.negative, ttBelow: a2.ttBelow, h: c.height || c.width }) : l2.positioner ? d = l2.positioner.call(this) : (u = { x: p.x, y: p.y, width: 0, height: 0 }, d = h.alignedPosition(o(l2, { width: t4, height: s3 }), u), "justify" === this.options.overflow && (d = h.alignedPosition(h.justifiedOptions(n2, i3, l2, d), u))), l2.crop && (x = d.x - n2.plotLeft, g = d.y - n2.plotTop, y = n2.isInsidePlot(x, g) && n2.isInsidePlot(x + t4, g + s3));
            }
            return y ? d : null;
          }
        }
        return h.attrsMap = { backgroundColor: "fill", borderColor: "stroke", borderWidth: "stroke-width", zIndex: "zIndex", borderRadius: "r", padding: "padding" }, h.shapesWithoutBackground = ["connector"], h;
      }), s(i, "Extensions/Annotations/Controllables/ControllableImage.js", [i["Extensions/Annotations/Controllables/Controllable.js"], i["Extensions/Annotations/Controllables/ControllableLabel.js"]], function(t2, i2) {
        class s2 extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3, s3, "shape"), this.type = "image", this.translate = super.translateShape;
          }
          render(t3) {
            let i3 = this.attrsFromOptions(this.options), s3 = this.options;
            this.graphic = this.annotation.chart.renderer.image(s3.src, 0, -9e9, s3.width, s3.height).attr(i3).add(t3), this.graphic.width = s3.width, this.graphic.height = s3.height, super.render();
          }
          redraw(t3) {
            if (this.graphic) {
              let s3 = this.anchor(this.points[0]), n = i2.prototype.position.call(this, s3);
              n ? this.graphic[t3 ? "animate" : "attr"]({ x: n.x, y: n.y }) : this.graphic.attr({ x: 0, y: -9e9 }), this.graphic.placed = !!n;
            }
            super.redraw(t3);
          }
        }
        return s2.attrsMap = { width: "width", height: "height", zIndex: "zIndex" }, s2;
      }), s(i, "Shared/BaseForm.js", [i["Core/Renderer/HTML/AST.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { addEvent: s2, createElement: n } = i2;
        return class {
          constructor(t3, i3) {
            this.iconsURL = i3, this.container = this.createPopupContainer(t3), this.closeButton = this.addCloseButton();
          }
          createPopupContainer(t3, i3 = "highcharts-popup highcharts-no-tooltip") {
            return n("div", { className: i3 }, void 0, t3);
          }
          addCloseButton(t3 = "highcharts-popup-close") {
            let i3 = this, e = this.iconsURL, o = n("button", { className: t3 }, void 0, this.container);
            return o.style["background-image"] = "url(" + (e.match(/png|svg|jpeg|jpg|gif/ig) ? e : e + "close.svg") + ")", ["click", "touchstart"].forEach((t4) => {
              s2(o, t4, i3.closeButtonEvents.bind(i3));
            }), s2(document, "keydown", function(t4) {
              "Escape" === t4.code && i3.closeButtonEvents();
            }), o;
          }
          closeButtonEvents() {
            this.closePopup();
          }
          showPopup(i3 = "highcharts-annotation-toolbar") {
            let s3 = this.container, n2 = this.closeButton;
            this.type = void 0, s3.innerHTML = t2.emptyHTML, s3.className.indexOf(i3) >= 0 && (s3.classList.remove(i3), s3.removeAttribute("style")), s3.appendChild(n2), s3.style.display = "block", s3.style.height = "";
          }
          closePopup() {
            this.container.style.display = "none";
          }
        };
      }), s(i, "Extensions/Annotations/Popup/PopupAnnotations.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { doc: s2, isFirefox: n } = t2, { createElement: e, isArray: o, isObject: a, objectEach: r, pick: l, stableSort: h } = i2;
        function p(t3, i3, l2, c, d, u) {
          let x, g;
          if (!i3) return;
          let y = this.addInput, f = this.lang;
          r(c, (s3, n2) => {
            x = "" !== l2 ? l2 + "." + n2 : n2, a(s3) && (!o(s3) || o(s3) && a(s3[0]) ? ((g = f[n2] || n2).match(/\d/g) || d.push([true, g, t3]), p.call(this, t3, i3, x, s3, d, false)) : d.push([this, x, "annotation", t3, s3]));
          }), u && (h(d, (t4) => t4[1].match(/format/g) ? -1 : 1), n && d.reverse(), d.forEach((t4) => {
            true === t4[0] ? e("span", { className: "highcharts-annotation-title" }, void 0, t4[2]).appendChild(s2.createTextNode(t4[1])) : (t4[4] = { value: t4[4][0], type: t4[4][1] }, y.apply(t4[0], t4.splice(1)));
          }));
        }
        return { addForm: function(t3, i3, n2, o2) {
          if (!t3) return;
          let a2 = this.container, r2 = this.lang, l2 = e("h2", { className: "highcharts-popup-main-title" }, void 0, a2);
          l2.appendChild(s2.createTextNode(r2[i3.langKey] || i3.langKey || "")), l2 = e("div", { className: "highcharts-popup-lhs-col highcharts-popup-lhs-full" }, void 0, a2);
          let h2 = e("div", { className: "highcharts-popup-bottom-row" }, void 0, a2);
          p.call(this, l2, t3, "", i3, [], true), this.addButton(h2, o2 ? r2.addButton || "Add" : r2.saveButton || "Save", o2 ? "add" : "save", a2, n2);
        }, addToolbar: function(t3, i3, n2) {
          let o2 = this.lang, a2 = this.container, r2 = this.showForm, h2 = "highcharts-annotation-toolbar";
          -1 === a2.className.indexOf(h2) && (a2.className += " " + h2 + " highcharts-no-mousewheel"), t3 && (a2.style.top = t3.plotTop + 10 + "px");
          let p2 = e("p", { className: "highcharts-annotation-label" }, void 0, a2);
          p2.setAttribute("aria-label", "Annotation type"), p2.appendChild(s2.createTextNode(l(o2[i3.langKey] || i3.langKey, i3.shapes && i3.shapes[0].type, "")));
          let c = this.addButton(a2, o2.editButton || "Edit", "edit", a2, () => {
            r2.call(this, "annotation-edit", t3, i3, n2);
          });
          c.className += " highcharts-annotation-edit-button", c.style["background-image"] = "url(" + this.iconsURL + "edit.svg)", c = this.addButton(a2, o2.removeButton || "Remove", "remove", a2, n2), c.className += " highcharts-annotation-remove-button", c.style["background-image"] = "url(" + this.iconsURL + "destroy.svg)";
        } };
      }), s(i, "Extensions/Annotations/Popup/PopupIndicators.js", [i["Core/Renderer/HTML/AST.js"], i["Core/Globals.js"], i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n) {
        var e, o;
        let { doc: a } = i2, { seriesTypes: r } = s2, { addEvent: l, createElement: h, defined: p, isArray: c, isObject: d, objectEach: u, stableSort: x } = n;
        (o = e || (e = {}))[o["params.algorithm"] = 0] = "params.algorithm", o[o["params.average"] = 1] = "params.average";
        let g = { "algorithm-pivotpoints": ["standard", "fibonacci", "camarilla"], "average-disparityindex": ["sma", "ema", "dema", "tema", "wma"] };
        function y(t3) {
          let i3 = h("div", { className: "highcharts-popup-lhs-col" }, void 0, t3), s3 = h("div", { className: "highcharts-popup-rhs-col" }, void 0, t3);
          return h("div", { className: "highcharts-popup-rhs-col-wrapper" }, void 0, s3), { lhsCol: i3, rhsCol: s3 };
        }
        function f(i3, s3, n2, e2) {
          let o2 = s3.params || s3.options.params;
          e2.innerHTML = t2.emptyHTML, h("h3", { className: "highcharts-indicator-title" }, void 0, e2).appendChild(a.createTextNode(M(s3, n2).indicatorFullName)), h("input", { type: "hidden", name: "highcharts-type-" + n2, value: n2 }, void 0, e2), O.call(this, n2, "series", i3, e2, s3, s3.linkedParent && s3.linkedParent.options.id), o2.volumeSeriesID && O.call(this, n2, "volume", i3, e2, s3, s3.linkedParent && o2.volumeSeriesID), A.call(this, i3, "params", o2, n2, e2);
        }
        function m(i3, s3, n2, e2) {
          function o2(t3, s4) {
            let n3 = b2.parentNode.children[1];
            f.call(a2, i3, t3, s4, b2), n3 && (n3.style.display = "block"), u2 && t3.options && h("input", { type: "hidden", name: "highcharts-id-" + s4, value: t3.options.id }, void 0, b2).setAttribute("highcharts-data-series-id", t3.options.id);
          }
          let a2 = this, r2 = a2.lang, p2 = s3.querySelectorAll(".highcharts-popup-lhs-col")[0], d2 = s3.querySelectorAll(".highcharts-popup-rhs-col")[0], u2 = "edit" === n2, g2 = u2 ? i3.series : i3.options.plotOptions || {};
          if (!i3 && g2) return;
          let y2, m2 = [];
          u2 || c(g2) ? c(g2) && (m2 = E.call(this, g2)) : m2 = C.call(this, g2, e2), x(m2, (t3, i4) => {
            let s4 = t3.indicatorFullName.toLowerCase(), n3 = i4.indicatorFullName.toLowerCase();
            return s4 < n3 ? -1 : s4 > n3 ? 1 : 0;
          }), p2.children[1] && p2.children[1].remove();
          let A2 = h("ul", { className: "highcharts-indicator-list" }, void 0, p2), b2 = d2.querySelectorAll(".highcharts-popup-rhs-col-wrapper")[0];
          if (m2.forEach((t3) => {
            let { indicatorFullName: i4, indicatorType: s4, series: n3 } = t3;
            y2 = h("li", { className: "highcharts-indicator-list" }, void 0, A2);
            let e3 = h("button", { className: "highcharts-indicator-list-item", textContent: i4 }, void 0, y2);
            ["click", "touchstart"].forEach((t4) => {
              l(e3, t4, function() {
                o2(n3, s4);
              });
            });
          }), m2.length > 0) {
            let { series: t3, indicatorType: i4 } = m2[0];
            o2(t3, i4);
          } else u2 || (t2.setElementHTML(b2.parentNode.children[0], r2.noFilterMatch || ""), b2.parentNode.children[1].style.display = "none");
        }
        function A(t3, i3, s3, n2, o2) {
          if (!t3) return;
          let a2 = this.addInput;
          u(s3, (s4, r2) => {
            let l2 = i3 + "." + r2;
            if (p(s4) && l2) {
              if (d(s4) && (a2.call(this, l2, n2, o2, {}), A.call(this, t3, l2, s4, n2, o2)), l2 in e) {
                let e2 = v.call(this, n2, l2, o2);
                P.call(this, t3, i3, e2, n2, r2, s4);
              } else "params.volumeSeriesID" === l2 || c(s4) || a2.call(this, l2, n2, o2, { value: s4, type: "number" });
            }
          });
        }
        function b(t3, i3) {
          let s3 = this, n2 = i3.querySelectorAll(".highcharts-popup-lhs-col")[0], e2 = this.lang.clearFilter, o2 = h("div", { className: "highcharts-input-wrapper" }, void 0, n2), a2 = function(i4) {
            m.call(s3, t3, s3.container, "add", i4);
          }, r2 = this.addInput("searchIndicators", "input", o2, { value: "", type: "text", htmlFor: "search-indicators", labelClassName: "highcharts-input-search-indicators-label" }), p2 = h("a", { textContent: e2 }, void 0, o2);
          r2.classList.add("highcharts-input-search-indicators"), p2.classList.add("clear-filter-button"), l(r2, "input", function() {
            a2(this.value), this.value.length ? p2.style.display = "inline-block" : p2.style.display = "none";
          }), ["click", "touchstart"].forEach((t4) => {
            l(p2, t4, function() {
              r2.value = "", a2(""), p2.style.display = "none";
            });
          });
        }
        function v(t3, i3, s3) {
          let n2 = i3.split("."), e2 = n2[n2.length - 1], o2 = "highcharts-" + i3 + "-type-" + t3, r2 = this.lang;
          h("label", { htmlFor: o2 }, null, s3).appendChild(a.createTextNode(r2[e2] || i3));
          let l2 = h("select", { name: o2, className: "highcharts-popup-field", id: "highcharts-select-" + i3 }, null, s3);
          return l2.setAttribute("id", "highcharts-select-" + i3), l2;
        }
        function P(t3, i3, s3, n2, e2, o2, r2) {
          "series" === i3 || "volume" === i3 ? t3.series.forEach((t4) => {
            let n3 = t4.options, e3 = n3.name || n3.params ? t4.name : n3.id || "";
            "highcharts-navigator-series" !== n3.id && n3.id !== (r2 && r2.options && r2.options.id) && (p(o2) || "volume" !== i3 || "column" !== t4.type || (o2 = n3.id), h("option", { value: n3.id }, void 0, s3).appendChild(a.createTextNode(e3)));
          }) : n2 && e2 && g[e2 + "-" + n2].forEach((t4) => {
            h("option", { value: t4 }, void 0, s3).appendChild(a.createTextNode(t4));
          }), p(o2) && (s3.value = o2);
        }
        function C(t3, i3) {
          let s3;
          let n2 = this.chart && this.chart.options.lang, e2 = n2 && n2.navigation && n2.navigation.popup && n2.navigation.popup.indicatorAliases, o2 = [];
          return u(t3, (t4, n3) => {
            let a2 = t4 && t4.options;
            if (t4.params || a2 && a2.params) {
              let { indicatorFullName: a3, indicatorType: r2 } = M(t4, n3);
              if (i3) {
                let n4 = RegExp(i3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i"), l2 = e2 && e2[r2] && e2[r2].join(" ") || "";
                (a3.match(n4) || l2.match(n4)) && (s3 = { indicatorFullName: a3, indicatorType: r2, series: t4 }, o2.push(s3));
              } else s3 = { indicatorFullName: a3, indicatorType: r2, series: t4 }, o2.push(s3);
            }
          }), o2;
        }
        function E(t3) {
          let i3 = [];
          return t3.forEach((t4) => {
            t4.is("sma") && i3.push({ indicatorFullName: t4.name, indicatorType: t4.type, series: t4 });
          }), i3;
        }
        function M(t3, i3) {
          let s3 = t3.options, n2 = r[i3] && r[i3].prototype.nameBase || i3.toUpperCase(), e2 = i3;
          return s3 && s3.type && (e2 = t3.options.type, n2 = t3.name), { indicatorFullName: n2, indicatorType: e2 };
        }
        function O(t3, i3, s3, n2, e2, o2) {
          if (!s3) return;
          let a2 = v.call(this, t3, i3, n2);
          P.call(this, s3, i3, a2, void 0, void 0, void 0, e2), p(o2) && (a2.value = o2);
        }
        return { addForm: function(t3, i3, s3) {
          let n2;
          let e2 = this.lang;
          if (!t3) return;
          this.tabs.init.call(this, t3);
          let o2 = this.container.querySelectorAll(".highcharts-tab-item-content");
          y(o2[0]), b.call(this, t3, o2[0]), m.call(this, t3, o2[0], "add"), n2 = o2[0].querySelectorAll(".highcharts-popup-rhs-col")[0], this.addButton(n2, e2.addButton || "add", "add", n2, s3), y(o2[1]), m.call(this, t3, o2[1], "edit"), n2 = o2[1].querySelectorAll(".highcharts-popup-rhs-col")[0], this.addButton(n2, e2.saveButton || "save", "edit", n2, s3), this.addButton(n2, e2.removeButton || "remove", "remove", n2, s3);
        }, getAmount: function() {
          let t3 = 0;
          return this.series.forEach((i3) => {
            (i3.params || i3.options.params) && t3++;
          }), t3;
        } };
      }), s(i, "Extensions/Annotations/Popup/PopupTabs.js", [i["Core/Globals.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { doc: s2 } = t2, { addEvent: n, createElement: e } = i2;
        function o() {
          return e("div", { className: "highcharts-tab-item-content highcharts-no-mousewheel" }, void 0, this.container);
        }
        function a(t3, i3) {
          let n2 = this.container, o2 = this.lang, a2 = "highcharts-tab-item";
          0 === i3 && (a2 += " highcharts-tab-disabled");
          let r2 = e("button", { className: a2 }, void 0, n2);
          return r2.appendChild(s2.createTextNode(o2[t3 + "Button"] || t3)), r2.setAttribute("highcharts-data-tab-type", t3), r2;
        }
        function r() {
          let t3 = this.container, i3 = t3.querySelectorAll(".highcharts-tab-item"), s3 = t3.querySelectorAll(".highcharts-tab-item-content");
          for (let t4 = 0; t4 < i3.length; t4++) i3[t4].classList.remove("highcharts-tab-item-active"), s3[t4].classList.remove("highcharts-tab-item-show");
        }
        function l(t3, i3) {
          let s3 = this.container.querySelectorAll(".highcharts-tab-item-content");
          t3.className += " highcharts-tab-item-active", s3[i3].className += " highcharts-tab-item-show";
        }
        function h(t3) {
          let i3 = this;
          this.container.querySelectorAll(".highcharts-tab-item").forEach((s3, e2) => {
            (0 !== t3 || "edit" !== s3.getAttribute("highcharts-data-tab-type")) && ["click", "touchstart"].forEach((t4) => {
              n(s3, t4, function() {
                r.call(i3), l.call(i3, this, e2);
              });
            });
          });
        }
        return { init: function(t3) {
          if (!t3) return;
          let i3 = this.indicators.getAmount.call(t3), s3 = a.call(this, "add");
          a.call(this, "edit", i3), o.call(this), o.call(this), h.call(this, i3), l.call(this, s3, 0);
        } };
      }), s(i, "Extensions/Annotations/Popup/Popup.js", [i["Shared/BaseForm.js"], i["Core/Globals.js"], i["Core/Defaults.js"], i["Extensions/Annotations/Popup/PopupAnnotations.js"], i["Extensions/Annotations/Popup/PopupIndicators.js"], i["Extensions/Annotations/Popup/PopupTabs.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n, e, o, a) {
        let { doc: r } = i2, { getOptions: l } = s2, { addEvent: h, createElement: p, extend: c, fireEvent: d, pick: u } = a;
        class x extends t2 {
          constructor(t3, i3, s3) {
            super(t3, i3), this.chart = s3, this.lang = (l().lang.navigation || {}).popup || {}, h(this.container, "mousedown", () => {
              let t4 = s3 && s3.navigationBindings && s3.navigationBindings.activeAnnotation;
              if (t4) {
                t4.cancelClick = true;
                let i4 = h(r, "click", () => {
                  setTimeout(() => {
                    t4.cancelClick = false;
                  }, 0), i4();
                });
              }
            });
          }
          addInput(t3, i3, s3, n2) {
            let e2 = t3.split("."), o2 = e2[e2.length - 1], a2 = this.lang, l2 = "highcharts-" + i3 + "-" + u(n2.htmlFor, o2);
            o2.match(/^\d+$/) || p("label", { htmlFor: l2, className: n2.labelClassName }, void 0, s3).appendChild(r.createTextNode(a2[o2] || o2));
            let h2 = p("input", { name: l2, value: n2.value, type: n2.type, className: "highcharts-popup-field" }, void 0, s3);
            return h2.setAttribute("highcharts-data-name", t3), h2;
          }
          closeButtonEvents() {
            if (this.chart) {
              let t3 = this.chart.navigationBindings;
              d(t3, "closePopup"), t3 && t3.selectedButtonElement && d(t3, "deselectButton", { button: t3.selectedButtonElement });
            } else super.closeButtonEvents();
          }
          addButton(t3, i3, s3, n2, e2) {
            let o2 = p("button", void 0, void 0, t3);
            return o2.appendChild(r.createTextNode(i3)), e2 && ["click", "touchstart"].forEach((t4) => {
              h(o2, t4, () => (this.closePopup(), e2(function(t5, i4) {
                let s4 = Array.prototype.slice.call(t5.querySelectorAll("input")), n3 = Array.prototype.slice.call(t5.querySelectorAll("select")), e3 = t5.querySelectorAll("#highcharts-select-series > option:checked")[0], o3 = t5.querySelectorAll("#highcharts-select-volume > option:checked")[0], a2 = { actionType: i4, linkedTo: e3 && e3.getAttribute("value") || "", fields: {} };
                return s4.forEach((t6) => {
                  let i5 = t6.getAttribute("highcharts-data-name");
                  t6.getAttribute("highcharts-data-series-id") ? a2.seriesId = t6.value : i5 ? a2.fields[i5] = t6.value : a2.type = t6.value;
                }), n3.forEach((t6) => {
                  let i5 = t6.id;
                  if ("highcharts-select-series" !== i5 && "highcharts-select-volume" !== i5) {
                    let s5 = i5.split("highcharts-select-")[1];
                    a2.fields[s5] = t6.value;
                  }
                }), o3 && (a2.fields["params.volumeSeriesID"] = o3.getAttribute("value") || ""), a2;
              }(n2, s3))));
            }), o2;
          }
          showForm(t3, i3, s3, n2) {
            i3 && (this.showPopup(), "indicators" === t3 && this.indicators.addForm.call(this, i3, s3, n2), "annotation-toolbar" === t3 && this.annotations.addToolbar.call(this, i3, s3, n2), "annotation-edit" === t3 && this.annotations.addForm.call(this, i3, s3, n2), "flag" === t3 && this.annotations.addForm.call(this, i3, s3, n2, true), this.type = t3, this.container.style.height = this.container.offsetHeight + "px");
          }
        }
        return c(x.prototype, { annotations: n, indicators: e, tabs: o }), x;
      }), s(i, "Extensions/Annotations/Popup/PopupComposition.js", [i["Core/Globals.js"], i["Extensions/Annotations/Popup/Popup.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { composed: n } = t2, { addEvent: e, pushUnique: o, wrap: a } = s2;
        function r() {
          this.popup && this.popup.closePopup();
        }
        function l(t3) {
          this.popup || (this.popup = new i2(this.chart.container, this.chart.options.navigation.iconsURL || this.chart.options.stockTools && this.chart.options.stockTools.gui.iconsURL || "https://code.highcharts.com/11.4.7/gfx/stock-icons/", this.chart)), this.popup.showForm(t3.formType, this.chart, t3.options, t3.onSubmit);
        }
        function h(t3, i3) {
          this.inClass(i3.target, "highcharts-popup") || t3.apply(this, Array.prototype.slice.call(arguments, 1));
        }
        return { compose: function(t3, i3) {
          o(n, "Popup") && (e(t3, "closePopup", r), e(t3, "showPopup", l), a(i3.prototype, "onContainerMouseDown", h));
        } };
      }), s(i, "Extensions/Annotations/Annotation.js", [i["Core/Animation/AnimationUtilities.js"], i["Extensions/Annotations/AnnotationChart.js"], i["Extensions/Annotations/AnnotationDefaults.js"], i["Extensions/Annotations/Controllables/ControllableRect.js"], i["Extensions/Annotations/Controllables/ControllableCircle.js"], i["Extensions/Annotations/Controllables/ControllableEllipse.js"], i["Extensions/Annotations/Controllables/ControllablePath.js"], i["Extensions/Annotations/Controllables/ControllableImage.js"], i["Extensions/Annotations/Controllables/ControllableLabel.js"], i["Extensions/Annotations/ControlPoint.js"], i["Extensions/Annotations/ControlTarget.js"], i["Extensions/Annotations/EventEmitter.js"], i["Extensions/Annotations/MockPoint.js"], i["Extensions/Annotations/Popup/PopupComposition.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n, e, o, a, r, l, h, p, c, d, u, x) {
        let { getDeferredAnimation: g } = t2, { destroyObjectProperties: y, erase: f, fireEvent: m, merge: A, pick: b, splat: v } = x;
        function P(t3, i3) {
          let s3 = {};
          return ["labels", "shapes"].forEach((n2) => {
            let e2 = t3[n2];
            e2 && (i3[n2] ? s3[n2] = v(i3[n2]).map(function(t4, i4) {
              return A(e2[i4], t4);
            }) : s3[n2] = t3[n2]);
          }), s3;
        }
        class C extends c {
          static compose(t3, s3, n2, e2) {
            i2.compose(C, t3, n2), l.compose(e2), a.compose(t3, e2), s3.compose(C, t3), u.compose(s3, n2);
          }
          constructor(t3, i3) {
            super(), this.coll = "annotations", this.chart = t3, this.points = [], this.controlPoints = [], this.coll = "annotations", this.index = -1, this.labels = [], this.shapes = [], this.options = A(this.defaultOptions, i3), this.userOptions = i3;
            let s3 = P(this.options, i3);
            this.options.labels = s3.labels, this.options.shapes = s3.shapes, this.init(t3, this.options);
          }
          addClipPaths() {
            this.setClipAxes(), this.clipXAxis && this.clipYAxis && this.options.crop && (this.clipRect = this.chart.renderer.clipRect(this.getClipBox()));
          }
          addLabels() {
            let t3 = this.options.labels || [];
            t3.forEach((i3, s3) => {
              let n2 = this.initLabel(i3, s3);
              A(true, t3[s3], n2.options);
            });
          }
          addShapes() {
            let t3 = this.options.shapes || [];
            t3.forEach((i3, s3) => {
              let n2 = this.initShape(i3, s3);
              A(true, t3[s3], n2.options);
            });
          }
          destroy() {
            let t3 = this.chart, i3 = function(t4) {
              t4.destroy();
            };
            this.labels.forEach(i3), this.shapes.forEach(i3), this.clipXAxis = null, this.clipYAxis = null, f(t3.labelCollectors, this.labelCollector), super.destroy(), this.destroyControlTarget(), y(this, t3);
          }
          destroyItem(t3) {
            f(this[t3.itemType + "s"], t3), t3.destroy();
          }
          getClipBox() {
            if (this.clipXAxis && this.clipYAxis) return { x: this.clipXAxis.left, y: this.clipYAxis.top, width: this.clipXAxis.width, height: this.clipYAxis.height };
          }
          initProperties(t3, i3) {
            this.setOptions(i3);
            let s3 = P(this.options, i3);
            this.options.labels = s3.labels, this.options.shapes = s3.shapes, this.chart = t3, this.points = [], this.controlPoints = [], this.coll = "annotations", this.userOptions = i3, this.labels = [], this.shapes = [];
          }
          init(t3, i3, s3 = this.index) {
            let n2 = this.chart, e2 = this.options.animation;
            this.index = s3, this.linkPoints(), this.addControlPoints(), this.addShapes(), this.addLabels(), this.setLabelCollector(), this.animationConfig = g(n2, e2);
          }
          initLabel(t3, i3) {
            let s3 = new l(this, A(this.options.labelOptions, { controlPointOptions: this.options.controlPointOptions }, t3), i3);
            return s3.itemType = "label", this.labels.push(s3), s3;
          }
          initShape(t3, i3) {
            let s3 = A(this.options.shapeOptions, { controlPointOptions: this.options.controlPointOptions }, t3), n2 = new C.shapesMap[s3.type](this, s3, i3);
            return n2.itemType = "shape", this.shapes.push(n2), n2;
          }
          redraw(t3) {
            this.linkPoints(), this.graphic || this.render(), this.clipRect && this.clipRect.animate(this.getClipBox()), this.redrawItems(this.shapes, t3), this.redrawItems(this.labels, t3), this.redrawControlPoints(t3);
          }
          redrawItem(t3, i3) {
            t3.linkPoints(), t3.shouldBeDrawn() ? (t3.graphic || this.renderItem(t3), t3.redraw(b(i3, true) && t3.graphic.placed), t3.points.length && function(t4) {
              let i4 = t4.graphic, s3 = t4.points.some((t5) => false !== t5.series.visible && false !== t5.visible);
              i4 && (s3 ? "hidden" === i4.visibility && i4.show() : i4.hide());
            }(t3)) : this.destroyItem(t3);
          }
          redrawItems(t3, i3) {
            let s3 = t3.length;
            for (; s3--; ) this.redrawItem(t3[s3], i3);
          }
          remove() {
            return this.chart.removeAnnotation(this);
          }
          render() {
            let t3 = this.chart.renderer;
            this.graphic = t3.g("annotation").attr({ opacity: 0, zIndex: this.options.zIndex, visibility: this.options.visible ? "inherit" : "hidden" }).add(), this.shapesGroup = t3.g("annotation-shapes").add(this.graphic), this.options.crop && this.shapesGroup.clip(this.chart.plotBoxClip), this.labelsGroup = t3.g("annotation-labels").attr({ translateX: 0, translateY: 0 }).add(this.graphic), this.addClipPaths(), this.clipRect && this.graphic.clip(this.clipRect), this.renderItems(this.shapes), this.renderItems(this.labels), this.addEvents(), this.renderControlPoints();
          }
          renderItem(t3) {
            t3.render("label" === t3.itemType ? this.labelsGroup : this.shapesGroup);
          }
          renderItems(t3) {
            let i3 = t3.length;
            for (; i3--; ) this.renderItem(t3[i3]);
          }
          setClipAxes() {
            let t3 = this.chart.xAxis, i3 = this.chart.yAxis, s3 = (this.options.labels || []).concat(this.options.shapes || []).reduce((s4, n2) => {
              let e2 = n2 && (n2.point || n2.points && n2.points[0]);
              return [t3[e2 && e2.xAxis] || s4[0], i3[e2 && e2.yAxis] || s4[1]];
            }, []);
            this.clipXAxis = s3[0], this.clipYAxis = s3[1];
          }
          setControlPointsVisibility(t3) {
            let i3 = function(i4) {
              i4.setControlPointsVisibility(t3);
            };
            this.controlPoints.forEach((i4) => {
              i4.setVisibility(t3);
            }), this.shapes.forEach(i3), this.labels.forEach(i3);
          }
          setLabelCollector() {
            let t3 = this;
            t3.labelCollector = function() {
              return t3.labels.reduce(function(t4, i3) {
                return i3.options.allowOverlap || t4.push(i3.graphic), t4;
              }, []);
            }, t3.chart.labelCollectors.push(t3.labelCollector);
          }
          setOptions(t3) {
            this.options = A(this.defaultOptions, t3);
          }
          setVisibility(t3) {
            let i3 = this.options, s3 = this.chart.navigationBindings, n2 = b(t3, !i3.visible);
            if (this.graphic.attr("visibility", n2 ? "inherit" : "hidden"), !n2) {
              let t4 = function(t5) {
                t5.setControlPointsVisibility(n2);
              };
              this.shapes.forEach(t4), this.labels.forEach(t4), s3.activeAnnotation === this && s3.popup && "annotation-toolbar" === s3.popup.type && m(s3, "closePopup");
            }
            i3.visible = n2;
          }
          update(t3, i3) {
            let s3 = this.chart, n2 = P(this.userOptions, t3), e2 = s3.annotations.indexOf(this), o2 = A(true, this.userOptions, t3);
            o2.labels = n2.labels, o2.shapes = n2.shapes, this.destroy(), this.initProperties(s3, o2), this.init(s3, o2), s3.options.annotations[e2] = this.options, this.isUpdating = true, b(i3, true) && s3.drawAnnotations(), m(this, "afterUpdate"), this.isUpdating = false;
          }
        }
        return C.ControlPoint = h, C.MockPoint = d, C.shapesMap = { rect: n, circle: e, ellipse: o, path: a, image: r }, C.types = {}, C.prototype.defaultOptions = s2, C.prototype.nonDOMEvents = ["add", "afterUpdate", "drag", "remove"], p.compose(C), C;
      }), s(i, "Core/Chart/ChartNavigationComposition.js", [], function() {
        var t2;
        return function(t3) {
          t3.compose = function(t4) {
            return t4.navigation || (t4.navigation = new i2(t4)), t4;
          };
          class i2 {
            constructor(t4) {
              this.updates = [], this.chart = t4;
            }
            addUpdate(t4) {
              this.chart.navigation.updates.push(t4);
            }
            update(t4, i3) {
              this.updates.forEach((s2) => {
                s2.call(this.chart, t4, i3);
              });
            }
          }
          t3.Additions = i2;
        }(t2 || (t2 = {})), t2;
      }), s(i, "Extensions/Annotations/NavigationBindingsUtilities.js", [i["Core/Utilities.js"]], function(t2) {
        let { defined: i2, isNumber: s2, pick: n } = t2, e = { backgroundColor: "string", borderColor: "string", borderRadius: "string", color: "string", fill: "string", fontSize: "string", labels: "string", name: "string", stroke: "string", title: "string" };
        return { annotationsFieldsTypes: e, getAssignedAxis: function(t3) {
          return t3.filter((t4) => {
            let i3 = t4.axis.getExtremes(), e2 = i3.min, o = i3.max, a = n(t4.axis.minPointOffset, 0);
            return s2(e2) && s2(o) && t4.value >= e2 - a && t4.value <= o + a && !t4.axis.options.isInternal;
          })[0];
        }, getFieldType: function(t3, s3) {
          let n2 = e[t3], o = typeof s3;
          return i2(n2) && (o = n2), { string: "text", number: "number", boolean: "checkbox" }[o];
        } };
      }), s(i, "Extensions/Annotations/NavigationBindingsDefaults.js", [i["Extensions/Annotations/NavigationBindingsUtilities.js"], i["Core/Utilities.js"]], function(t2, i2) {
        let { getAssignedAxis: s2 } = t2, { isNumber: n, merge: e } = i2;
        return { lang: { navigation: { popup: { simpleShapes: "Simple shapes", lines: "Lines", circle: "Circle", ellipse: "Ellipse", rectangle: "Rectangle", label: "Label", shapeOptions: "Shape options", typeOptions: "Details", fill: "Fill", format: "Text", strokeWidth: "Line width", stroke: "Line color", title: "Title", name: "Name", labelOptions: "Label options", labels: "Labels", backgroundColor: "Background color", backgroundColors: "Background colors", borderColor: "Border color", borderRadius: "Border radius", borderWidth: "Border width", style: "Style", padding: "Padding", fontSize: "Font size", color: "Color", height: "Height", shapes: "Shape options" } } }, navigation: { bindingsClassName: "highcharts-bindings-container", bindings: { circleAnnotation: { className: "highcharts-circle-annotation", start: function(t3) {
          var _a;
          let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), n2 = i3 && s2(i3.xAxis), o = i3 && s2(i3.yAxis), a = this.chart.options.navigation;
          if (n2 && o) return this.chart.addAnnotation(e({ langKey: "circle", type: "basicAnnotation", shapes: [{ type: "circle", point: { x: n2.value, y: o.value, xAxis: n2.axis.index, yAxis: o.axis.index }, r: 5 }] }, a.annotationsOptions, a.bindings.circleAnnotation.annotationsOptions));
        }, steps: [function(t3, i3) {
          let s3;
          let e2 = i3.options.shapes, o = e2 && e2[0] && e2[0].point || {};
          if (n(o.xAxis) && n(o.yAxis)) {
            let i4 = this.chart.inverted, n2 = this.chart.xAxis[o.xAxis].toPixels(o.x), e3 = this.chart.yAxis[o.yAxis].toPixels(o.y);
            s3 = Math.max(Math.sqrt(Math.pow(i4 ? e3 - t3.chartX : n2 - t3.chartX, 2) + Math.pow(i4 ? n2 - t3.chartY : e3 - t3.chartY, 2)), 5);
          }
          i3.update({ shapes: [{ r: s3 }] });
        }] }, ellipseAnnotation: { className: "highcharts-ellipse-annotation", start: function(t3) {
          var _a;
          let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), n2 = i3 && s2(i3.xAxis), o = i3 && s2(i3.yAxis), a = this.chart.options.navigation;
          if (n2 && o) return this.chart.addAnnotation(e({ langKey: "ellipse", type: "basicAnnotation", shapes: [{ type: "ellipse", xAxis: n2.axis.index, yAxis: o.axis.index, points: [{ x: n2.value, y: o.value }, { x: n2.value, y: o.value }], ry: 1 }] }, a.annotationsOptions, a.bindings.ellipseAnnotation.annotationOptions));
        }, steps: [function(t3, i3) {
          let s3 = i3.shapes[0], n2 = s3.getAbsolutePosition(s3.points[1]);
          s3.translatePoint(t3.chartX - n2.x, t3.chartY - n2.y, 1), s3.redraw(false);
        }, function(t3, i3) {
          let s3 = i3.shapes[0], n2 = s3.getAbsolutePosition(s3.points[0]), e2 = s3.getAbsolutePosition(s3.points[1]), o = s3.getDistanceFromLine(n2, e2, t3.chartX, t3.chartY), a = s3.getYAxis(), r = Math.abs(a.toValue(0) - a.toValue(o));
          s3.setYRadius(r), s3.redraw(false);
        }] }, rectangleAnnotation: { className: "highcharts-rectangle-annotation", start: function(t3) {
          var _a;
          let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), n2 = i3 && s2(i3.xAxis), o = i3 && s2(i3.yAxis);
          if (!n2 || !o) return;
          let a = n2.value, r = o.value, l = n2.axis.index, h = o.axis.index, p = this.chart.options.navigation;
          return this.chart.addAnnotation(e({ langKey: "rectangle", type: "basicAnnotation", shapes: [{ type: "path", points: [{ xAxis: l, yAxis: h, x: a, y: r }, { xAxis: l, yAxis: h, x: a, y: r }, { xAxis: l, yAxis: h, x: a, y: r }, { xAxis: l, yAxis: h, x: a, y: r }, { command: "Z" }] }] }, p.annotationsOptions, p.bindings.rectangleAnnotation.annotationsOptions));
        }, steps: [function(t3, i3) {
          var _a;
          let n2 = i3.options.shapes, e2 = n2 && n2[0] && n2[0].points || [], o = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), a = o && s2(o.xAxis), r = o && s2(o.yAxis);
          if (a && r) {
            let t4 = a.value, s3 = r.value;
            e2[1].x = t4, e2[2].x = t4, e2[2].y = s3, e2[3].y = s3, i3.update({ shapes: [{ points: e2 }] });
          }
        }] }, labelAnnotation: { className: "highcharts-label-annotation", start: function(t3) {
          var _a;
          let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), n2 = i3 && s2(i3.xAxis), o = i3 && s2(i3.yAxis), a = this.chart.options.navigation;
          if (n2 && o) return this.chart.addAnnotation(e({ langKey: "label", type: "basicAnnotation", labelOptions: { format: "{y:.2f}", overflow: "none", crop: true }, labels: [{ point: { xAxis: n2.axis.index, yAxis: o.axis.index, x: n2.value, y: o.value } }] }, a.annotationsOptions, a.bindings.labelAnnotation.annotationsOptions));
        } } }, events: {}, annotationsOptions: { animation: { defer: 0 } } } };
      }), s(i, "Extensions/Annotations/NavigationBindings.js", [i["Core/Chart/ChartNavigationComposition.js"], i["Core/Defaults.js"], i["Core/Templating.js"], i["Core/Globals.js"], i["Extensions/Annotations/NavigationBindingsDefaults.js"], i["Extensions/Annotations/NavigationBindingsUtilities.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n, e, o, a) {
        let { setOptions: r } = i2, { format: l } = s2, { composed: h, doc: p, win: c } = n, { getAssignedAxis: d, getFieldType: u } = o, { addEvent: x, attr: g, defined: y, fireEvent: f, isArray: m, isFunction: A, isNumber: b, isObject: v, merge: P, objectEach: C, pick: E, pushUnique: M } = a;
        function O() {
          this.chart.navigationBindings && this.chart.navigationBindings.deselectAnnotation();
        }
        function k() {
          this.navigationBindings && this.navigationBindings.destroy();
        }
        function w() {
          let t3 = this.options;
          t3 && t3.navigation && t3.navigation.bindings && (this.navigationBindings = new N(this, t3.navigation), this.navigationBindings.initEvents(), this.navigationBindings.initUpdate());
        }
        function j() {
          let t3 = this.navigationBindings, i3 = "highcharts-disabled-btn";
          if (this && t3) {
            let s3 = false;
            if (this.series.forEach((t4) => {
              !t4.options.isInternal && t4.visible && (s3 = true);
            }), this.navigationBindings && this.navigationBindings.container && this.navigationBindings.container[0]) {
              let n2 = this.navigationBindings.container[0];
              C(t3.boundClassNames, (t4, e2) => {
                let o2 = n2.querySelectorAll("." + e2);
                if (o2) for (let n3 = 0; n3 < o2.length; n3++) {
                  let e3 = o2[n3], a2 = e3.className;
                  "normal" === t4.noDataState ? -1 !== a2.indexOf(i3) && e3.classList.remove(i3) : s3 ? -1 !== a2.indexOf(i3) && e3.classList.remove(i3) : -1 === a2.indexOf(i3) && (e3.className += " " + i3);
                }
              });
            }
          }
        }
        function T() {
          this.deselectAnnotation();
        }
        function B() {
          this.selectedButtonElement = null;
        }
        function L(t3) {
          let i3, s3;
          let n2 = t3.prototype.defaultOptions.events && t3.prototype.defaultOptions.events.click;
          function e2(t4) {
            let i4 = this, s4 = i4.chart.navigationBindings, e3 = s4.activeAnnotation;
            n2 && n2.call(i4, t4), e3 !== i4 ? (s4.deselectAnnotation(), s4.activeAnnotation = i4, i4.setControlPointsVisibility(true), f(s4, "showPopup", { annotation: i4, formType: "annotation-toolbar", options: s4.annotationToFields(i4), onSubmit: function(t5) {
              if ("remove" === t5.actionType) s4.activeAnnotation = false, s4.chart.removeAnnotation(i4);
              else {
                let n3 = {};
                s4.fieldsToOptions(t5.fields, n3), s4.deselectAnnotation();
                let e4 = n3.typeOptions;
                "measure" === i4.options.type && (e4.crosshairY.enabled = 0 !== e4.crosshairY.strokeWidth, e4.crosshairX.enabled = 0 !== e4.crosshairX.strokeWidth), i4.update(n3);
              }
            } })) : f(s4, "closePopup"), t4.activeAnnotation = true;
          }
          P(true, t3.prototype.defaultOptions.events, { click: e2, touchstart: function(t4) {
            i3 = t4.touches[0].clientX, s3 = t4.touches[0].clientY;
          }, touchend: function(t4) {
            i3 && Math.sqrt(Math.pow(i3 - t4.changedTouches[0].clientX, 2) + Math.pow(s3 - t4.changedTouches[0].clientY, 2)) >= 4 || e2.call(this, t4);
          } });
        }
        class N {
          static compose(t3, i3) {
            M(h, "NavigationBindings") && (x(t3, "remove", O), L(t3), C(t3.types, (t4) => {
              L(t4);
            }), x(i3, "destroy", k), x(i3, "load", w), x(i3, "render", j), x(N, "closePopup", T), x(N, "deselectButton", B), r(e));
          }
          constructor(t3, i3) {
            this.boundClassNames = void 0, this.chart = t3, this.options = i3, this.eventsToUnbind = [], this.container = this.chart.container.getElementsByClassName(this.options.bindingsClassName || ""), this.container.length || (this.container = p.getElementsByClassName(this.options.bindingsClassName || ""));
          }
          getCoords(t3) {
            var _a;
            let i3 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3);
            return [i3 && d(i3.xAxis), i3 && d(i3.yAxis)];
          }
          initEvents() {
            let t3 = this, i3 = t3.chart, s3 = t3.container, e2 = t3.options;
            t3.boundClassNames = {}, C(e2.bindings || {}, (i4) => {
              t3.boundClassNames[i4.className] = i4;
            }), [].forEach.call(s3, (i4) => {
              t3.eventsToUnbind.push(x(i4, "click", (s4) => {
                let n2 = t3.getButtonEvents(i4, s4);
                n2 && !n2.button.classList.contains("highcharts-disabled-btn") && t3.bindingsButtonClick(n2.button, n2.events, s4);
              }));
            }), C(e2.events || {}, (i4, s4) => {
              A(i4) && t3.eventsToUnbind.push(x(t3, s4, i4, { passive: false }));
            }), t3.eventsToUnbind.push(x(i3.container, "click", function(s4) {
              !i3.cancelClick && i3.isInsidePlot(s4.chartX - i3.plotLeft, s4.chartY - i3.plotTop, { visiblePlotOnly: true }) && t3.bindingsChartClick(this, s4);
            })), t3.eventsToUnbind.push(x(i3.container, n.isTouchDevice ? "touchmove" : "mousemove", function(i4) {
              t3.bindingsContainerMouseMove(this, i4);
            }, n.isTouchDevice ? { passive: false } : void 0));
          }
          initUpdate() {
            let i3 = this;
            t2.compose(this.chart).navigation.addUpdate((t3) => {
              i3.update(t3);
            });
          }
          bindingsButtonClick(t3, i3, s3) {
            let n2 = this.chart, e2 = n2.renderer.boxWrapper, o2 = true;
            this.selectedButtonElement && (this.selectedButtonElement.classList === t3.classList && (o2 = false), f(this, "deselectButton", { button: this.selectedButtonElement }), this.nextEvent && (this.currentUserDetails && "annotations" === this.currentUserDetails.coll && n2.removeAnnotation(this.currentUserDetails), this.mouseMoveEvent = this.nextEvent = false)), o2 ? (this.selectedButton = i3, this.selectedButtonElement = t3, f(this, "selectButton", { button: t3 }), i3.init && i3.init.call(this, t3, s3), (i3.start || i3.steps) && n2.renderer.boxWrapper.addClass("highcharts-draw-mode")) : (n2.stockTools && t3.classList.remove("highcharts-active"), e2.removeClass("highcharts-draw-mode"), this.nextEvent = false, this.mouseMoveEvent = false, this.selectedButton = null);
          }
          bindingsChartClick(t3, i3) {
            t3 = this.chart;
            let s3 = this.activeAnnotation, n2 = this.selectedButton, e2 = t3.renderer.boxWrapper;
            s3 && (s3.cancelClick || i3.activeAnnotation || !i3.target.parentNode || function(t4, i4) {
              let s4 = c.Element.prototype, n3 = s4.matches || s4.msMatchesSelector || s4.webkitMatchesSelector, e3 = null;
              if (s4.closest) e3 = s4.closest.call(t4, i4);
              else do {
                if (n3.call(t4, i4)) return t4;
                t4 = t4.parentElement || t4.parentNode;
              } while (null !== t4 && 1 === t4.nodeType);
              return e3;
            }(i3.target, ".highcharts-popup") ? s3.cancelClick && setTimeout(() => {
              s3.cancelClick = false;
            }, 0) : f(this, "closePopup")), n2 && n2.start && (this.nextEvent ? (this.nextEvent(i3, this.currentUserDetails), this.steps && (this.stepIndex++, n2.steps[this.stepIndex] ? this.mouseMoveEvent = this.nextEvent = n2.steps[this.stepIndex] : (f(this, "deselectButton", { button: this.selectedButtonElement }), e2.removeClass("highcharts-draw-mode"), n2.end && n2.end.call(this, i3, this.currentUserDetails), this.nextEvent = false, this.mouseMoveEvent = false, this.selectedButton = null))) : (this.currentUserDetails = n2.start.call(this, i3), this.currentUserDetails && n2.steps ? (this.stepIndex = 0, this.steps = true, this.mouseMoveEvent = this.nextEvent = n2.steps[this.stepIndex]) : (f(this, "deselectButton", { button: this.selectedButtonElement }), e2.removeClass("highcharts-draw-mode"), this.steps = false, this.selectedButton = null, n2.end && n2.end.call(this, i3, this.currentUserDetails))));
          }
          bindingsContainerMouseMove(t3, i3) {
            this.mouseMoveEvent && this.mouseMoveEvent(i3, this.currentUserDetails);
          }
          fieldsToOptions(t3, i3) {
            return C(t3, (t4, s3) => {
              let n2 = parseFloat(t4), e2 = s3.split("."), o2 = e2.length - 1;
              if (!b(n2) || t4.match(/px|em/g) || s3.match(/format/g) || (t4 = n2), "undefined" !== t4) {
                let s4 = i3;
                e2.forEach((i4, n3) => {
                  if ("__proto__" !== i4 && "constructor" !== i4) {
                    let a2 = E(e2[n3 + 1], "");
                    o2 === n3 ? s4[i4] = t4 : (s4[i4] || (s4[i4] = a2.match(/\d/g) ? [] : {}), s4 = s4[i4]);
                  }
                });
              }
            }), i3;
          }
          deselectAnnotation() {
            this.activeAnnotation && (this.activeAnnotation.setControlPointsVisibility(false), this.activeAnnotation = false);
          }
          annotationToFields(t3) {
            let i3 = t3.options, s3 = N.annotationsEditable, n2 = s3.nestedOptions, e2 = E(i3.type, i3.shapes && i3.shapes[0] && i3.shapes[0].type, i3.labels && i3.labels[0] && i3.labels[0].type, "label"), o2 = N.annotationsNonEditable[i3.langKey] || [], a2 = { langKey: i3.langKey, type: e2 };
            function r2(i4, s4, e3, a3, h2) {
              let p2;
              e3 && y(i4) && -1 === o2.indexOf(s4) && ((e3.indexOf && e3.indexOf(s4)) >= 0 || e3[s4] || true === e3) && (m(i4) ? (a3[s4] = [], i4.forEach((t4, i5) => {
                v(t4) ? (a3[s4][i5] = {}, C(t4, (t5, e4) => {
                  r2(t5, e4, n2[s4], a3[s4][i5], s4);
                })) : r2(t4, 0, n2[s4], a3[s4], s4);
              })) : v(i4) ? (p2 = {}, m(a3) ? (a3.push(p2), p2[s4] = {}, p2 = p2[s4]) : a3[s4] = p2, C(i4, (t4, i5) => {
                r2(t4, i5, 0 === s4 ? e3 : n2[s4], p2, s4);
              })) : "format" === s4 ? a3[s4] = [l(i4, t3.labels[0].points[0]).toString(), "text"] : m(a3) ? a3.push([i4, u(h2, i4)]) : a3[s4] = [i4, u(s4, i4)]);
            }
            return C(i3, (t4, o3) => {
              "typeOptions" === o3 ? (a2[o3] = {}, C(i3[o3], (t5, i4) => {
                r2(t5, i4, n2, a2[o3], i4);
              })) : r2(t4, o3, s3[e2], a2, o3);
            }), a2;
          }
          getClickedClassNames(t3, i3) {
            let s3 = i3.target, n2 = [], e2;
            for (; s3 && s3.tagName && ((e2 = g(s3, "class")) && (n2 = n2.concat(e2.split(" ").map((t4) => [t4, s3]))), (s3 = s3.parentNode) !== t3); ) ;
            return n2;
          }
          getButtonEvents(t3, i3) {
            let s3;
            let n2 = this;
            return this.getClickedClassNames(t3, i3).forEach((t4) => {
              n2.boundClassNames[t4[0]] && !s3 && (s3 = { events: n2.boundClassNames[t4[0]], button: t4[1] });
            }), s3;
          }
          update(t3) {
            this.options = P(true, this.options, t3), this.removeEvents(), this.initEvents();
          }
          removeEvents() {
            this.eventsToUnbind.forEach((t3) => t3());
          }
          destroy() {
            this.removeEvents();
          }
        }
        return N.annotationsEditable = { nestedOptions: { labelOptions: ["style", "format", "backgroundColor"], labels: ["style"], label: ["style"], style: ["fontSize", "color"], background: ["fill", "strokeWidth", "stroke"], innerBackground: ["fill", "strokeWidth", "stroke"], outerBackground: ["fill", "strokeWidth", "stroke"], shapeOptions: ["fill", "strokeWidth", "stroke"], shapes: ["fill", "strokeWidth", "stroke"], line: ["strokeWidth", "stroke"], backgroundColors: [true], connector: ["fill", "strokeWidth", "stroke"], crosshairX: ["strokeWidth", "stroke"], crosshairY: ["strokeWidth", "stroke"] }, circle: ["shapes"], ellipse: ["shapes"], verticalLine: [], label: ["labelOptions"], measure: ["background", "crosshairY", "crosshairX"], fibonacci: [], tunnel: ["background", "line", "height"], pitchfork: ["innerBackground", "outerBackground"], rect: ["shapes"], crookedLine: [], basicAnnotation: ["shapes", "labelOptions"] }, N.annotationsNonEditable = { rectangle: ["crosshairX", "crosshairY", "labelOptions"], ellipse: ["labelOptions"], circle: ["labelOptions"] }, N;
      }), s(i, "masters/modules/annotations.src.js", [i["Core/Globals.js"], i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/NavigationBindings.js"]], function(t2, i2, s2) {
        return t2.Annotation = t2.Annotation || i2, t2.NavigationBindings = t2.NavigationBindings || s2, t2.Annotation.compose(t2.Chart, t2.NavigationBindings, t2.Pointer, t2.SVGRenderer), t2;
      }), s(i, "Extensions/Annotations/Types/BasicAnnotation.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: n } = s2;
        class e extends t2 {
          addControlPoints() {
            let t3 = this.options, i3 = e.basicControlPoints, s3 = this.basicType;
            (t3.labels || t3.shapes || []).forEach((t4) => {
              t4.controlPoints = i3[s3];
            });
          }
          init() {
            let t3 = this.options;
            if (t3.shapes) {
              delete t3.labelOptions;
              let i3 = t3.shapes[0].type;
              t3.shapes[0].className = (t3.shapes[0].className || "") + " highcharts-basic-shape", i3 && "path" !== i3 ? this.basicType = i3 : this.basicType = "rectangle";
            } else delete t3.shapes, this.basicType = "label";
            super.init.apply(this, arguments);
          }
        }
        return e.basicControlPoints = { label: [{ symbol: "triangle-down", positioner: function(t3) {
          if (!t3.graphic.placed) return { x: 0, y: -9e7 };
          let s3 = i2.pointToPixels(t3.points[0]);
          return { x: s3.x - (this.graphic.width || 0) / 2, y: s3.y - (this.graphic.height || 0) / 2 };
        }, events: { drag: function(t3, i3) {
          let s3 = this.mouseMoveToTranslation(t3);
          i3.translatePoint(s3.x, s3.y), i3.annotation.userOptions.labels[0].point = i3.options.point, i3.redraw(false);
        } } }, { symbol: "square", positioner: function(t3) {
          return t3.graphic.placed ? { x: t3.graphic.alignAttr.x - (this.graphic.width || 0) / 2, y: t3.graphic.alignAttr.y - (this.graphic.height || 0) / 2 } : { x: 0, y: -9e7 };
        }, events: { drag: function(t3, i3) {
          let s3 = this.mouseMoveToTranslation(t3);
          i3.translate(s3.x, s3.y), i3.annotation.userOptions.labels[0].point = i3.options.point, i3.redraw(false);
        } } }], rectangle: [{ positioner: function(t3) {
          let s3 = i2.pointToPixels(t3.points[2]);
          return { x: s3.x - 4, y: s3.y - 4 };
        }, events: { drag: function(t3, i3) {
          var _a, _b, _c;
          let s3 = i3.annotation, n2 = (_a = this.chart.pointer) == null ? void 0 : _a.getCoordinates(t3), e2 = i3.options.points, o = s3.userOptions.shapes, a = ((_b = s3.clipXAxis) == null ? void 0 : _b.index) || 0, r = ((_c = s3.clipYAxis) == null ? void 0 : _c.index) || 0;
          if (n2) {
            let t4 = n2.xAxis[a].value, s4 = n2.yAxis[r].value;
            e2[1].x = t4, e2[2].x = t4, e2[2].y = s4, e2[3].y = s4, o && o[0] && (o[0].points = i3.options.points);
          }
          s3.redraw(false);
        } } }], circle: [{ positioner: function(t3) {
          let s3 = i2.pointToPixels(t3.points[0]), n2 = t3.options.r;
          return { x: s3.x + n2 * Math.cos(Math.PI / 4) - (this.graphic.width || 0) / 2, y: s3.y + n2 * Math.sin(Math.PI / 4) - (this.graphic.height || 0) / 2 };
        }, events: { drag: function(t3, i3) {
          let s3 = i3.annotation, n2 = this.mouseMoveToTranslation(t3), e2 = s3.userOptions.shapes;
          i3.setRadius(Math.max(i3.options.r + n2.y / Math.sin(Math.PI / 4), 5)), e2 && e2[0] && (e2[0].r = i3.options.r, e2[0].point = i3.options.point), i3.redraw(false);
        } } }], ellipse: [{ positioner: function(t3) {
          let i3 = t3.getAbsolutePosition(t3.points[0]);
          return { x: i3.x - (this.graphic.width || 0) / 2, y: i3.y - (this.graphic.height || 0) / 2 };
        }, events: { drag: function(t3, i3) {
          let s3 = i3.getAbsolutePosition(i3.points[0]);
          i3.translatePoint(t3.chartX - s3.x, t3.chartY - s3.y, 0), i3.redraw(false);
        } } }, { positioner: function(t3) {
          let i3 = t3.getAbsolutePosition(t3.points[1]);
          return { x: i3.x - (this.graphic.width || 0) / 2, y: i3.y - (this.graphic.height || 0) / 2 };
        }, events: { drag: function(t3, i3) {
          let s3 = i3.getAbsolutePosition(i3.points[1]);
          i3.translatePoint(t3.chartX - s3.x, t3.chartY - s3.y, 1), i3.redraw(false);
        } } }, { positioner: function(t3) {
          let i3 = t3.getAbsolutePosition(t3.points[0]), s3 = t3.getAbsolutePosition(t3.points[1]), n2 = t3.getAttrs(i3, s3);
          return { x: n2.cx - (this.graphic.width || 0) / 2 + n2.ry * Math.sin(n2.angle * Math.PI / 180), y: n2.cy - (this.graphic.height || 0) / 2 - n2.ry * Math.cos(n2.angle * Math.PI / 180) };
        }, events: { drag: function(t3, i3) {
          let s3 = i3.getAbsolutePosition(i3.points[0]), n2 = i3.getAbsolutePosition(i3.points[1]), e2 = i3.getDistanceFromLine(s3, n2, t3.chartX, t3.chartY), o = i3.getYAxis(), a = Math.abs(o.toValue(0) - o.toValue(e2));
          i3.setYRadius(a), i3.redraw(false);
        } } }] }, e.prototype.defaultOptions = n(t2.prototype.defaultOptions, {}), t2.types.basicAnnotation = e, e;
      }), s(i, "Extensions/Annotations/Types/CrookedLine.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/ControlPoint.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n) {
        let { merge: e } = n;
        class o extends t2 {
          setClipAxes() {
            this.clipXAxis = this.chart.xAxis[this.options.typeOptions.xAxis], this.clipYAxis = this.chart.yAxis[this.options.typeOptions.yAxis];
          }
          getPointsOptions() {
            let t3 = this.options.typeOptions;
            return (t3.points || []).map((i3) => (i3.xAxis = t3.xAxis, i3.yAxis = t3.yAxis, i3));
          }
          getControlPointsOptions() {
            return this.getPointsOptions();
          }
          addControlPoints() {
            this.getControlPointsOptions().forEach(function(t3, s3) {
              let n2 = new i2(this.chart, this, e(this.options.controlPointOptions, t3.controlPoint), s3);
              this.controlPoints.push(n2), t3.controlPoint = n2.options;
            }, this);
          }
          addShapes() {
            let t3 = this.options.typeOptions, i3 = this.initShape(e(t3.line, { type: "path", className: "highcharts-crooked-lines", points: this.points.map((t4, i4) => function(t5) {
              return t5.annotation.points[i4];
            }) }), 0);
            t3.line = i3.options;
          }
        }
        return o.prototype.defaultOptions = e(t2.prototype.defaultOptions, { typeOptions: { xAxis: 0, yAxis: 0, line: { fill: "none" } }, controlPointOptions: { positioner: function(t3) {
          let i3 = this.graphic, n2 = s2.pointToPixels(t3.points[this.index]);
          return { x: n2.x - (i3.width || 0) / 2, y: n2.y - (i3.height || 0) / 2 };
        }, events: { drag: function(t3, i3) {
          if (i3.chart.isInsidePlot(t3.chartX - i3.chart.plotLeft, t3.chartY - i3.chart.plotTop, { visiblePlotOnly: true })) {
            let s3 = this.mouseMoveToTranslation(t3), n2 = i3.options.typeOptions;
            i3.translatePoint(s3.x, s3.y, this.index), n2.points[this.index].x = i3.points[this.index].x, n2.points[this.index].y = i3.points[this.index].y, i3.redraw(false);
          }
        } } } }), t2.types.crookedLine = o, o;
      }), s(i, "Extensions/Annotations/Types/ElliottWave.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/Types/CrookedLine.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: n } = s2;
        class e extends i2 {
          addLabels() {
            this.getPointsOptions().forEach((t3, i3) => {
              let s3 = this.options.typeOptions, e2 = this.initLabel(n(t3.label, { text: s3.labels[i3], point: function(t4) {
                return t4.annotation.points[i3];
              } }), false);
              t3.label = e2.options;
            });
          }
        }
        return e.prototype.defaultOptions = n(i2.prototype.defaultOptions, { typeOptions: { labels: ["(0)", "(A)", "(B)", "(C)", "(D)", "(E)"], line: { strokeWidth: 1 } }, labelOptions: { align: "center", allowOverlap: true, crop: true, overflow: "none", type: "rect", backgroundColor: "none", borderWidth: 0, y: -5 } }), t2.types.elliottWave = e, e;
      }), s(i, "Extensions/Annotations/Types/Tunnel.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/ControlPoint.js"], i["Extensions/Annotations/Types/CrookedLine.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n, e) {
        let { merge: o } = e;
        class a extends s2 {
          getPointsOptions() {
            let t3 = s2.prototype.getPointsOptions.call(this), i3 = this.options.typeOptions.yAxis || 0, n2 = this.chart.yAxis[i3];
            if (t3[2] = this.heightPointOptions(t3[1]), t3[3] = this.heightPointOptions(t3[0]), n2 && n2.logarithmic) {
              let i4 = n2.toPixels(t3[2].y) - n2.toPixels(t3[1].y), s3 = n2.toPixels(t3[0].y) + i4;
              t3[3].y = n2.toValue(s3);
            }
            return t3;
          }
          getControlPointsOptions() {
            return this.getPointsOptions().slice(0, 2);
          }
          heightPointOptions(t3) {
            let i3 = o(t3), s3 = this.options.typeOptions;
            return i3.y += s3.height, i3;
          }
          addControlPoints() {
            s2.prototype.addControlPoints.call(this);
            let t3 = this.options, n2 = t3.typeOptions, e2 = new i2(this.chart, this, o(t3.controlPointOptions, n2.heightControlPoint), 2);
            this.controlPoints.push(e2), n2.heightControlPoint = e2.options;
          }
          addShapes() {
            this.addLine(), this.addBackground();
          }
          addLine() {
            let t3 = this.initShape(o(this.options.typeOptions.line, { type: "path", points: [this.points[0], this.points[1], function(t4) {
              let i3 = n.pointToOptions(t4.annotation.points[2]);
              return i3.command = "M", i3;
            }, this.points[3]], className: "highcharts-tunnel-lines" }), 0);
            this.options.typeOptions.line = t3.options;
          }
          addBackground() {
            let t3 = this.initShape(o(this.options.typeOptions.background, { type: "path", points: this.points.slice(), className: "highcharts-tunnel-background" }), 1);
            this.options.typeOptions.background = t3.options;
          }
          translateSide(t3, i3, s3) {
            let n2 = Number(s3);
            this.translatePoint(t3, i3, n2), this.translatePoint(t3, i3, 0 === n2 ? 3 : 2);
          }
          translateHeight(t3) {
            this.translatePoint(0, t3, 2), this.translatePoint(0, t3, 3), this.options.typeOptions.height = this.points[3].y - this.points[0].y, this.userOptions.typeOptions.height = this.options.typeOptions.height;
          }
        }
        return a.prototype.defaultOptions = o(s2.prototype.defaultOptions, { typeOptions: { background: { fill: "rgba(130, 170, 255, 0.4)", strokeWidth: 0 }, line: { strokeWidth: 1 }, height: -2, heightControlPoint: { positioner: function(t3) {
          let i3 = n.pointToPixels(t3.points[2]), s3 = n.pointToPixels(t3.points[3]), e2 = (i3.x + s3.x) / 2;
          return { x: e2 - (this.graphic.width || 0) / 2, y: (s3.y - i3.y) / (s3.x - i3.x) * (e2 - i3.x) + i3.y - (this.graphic.height || 0) / 2 };
        }, events: { drag: function(t3, i3) {
          i3.chart.isInsidePlot(t3.chartX - i3.chart.plotLeft, t3.chartY - i3.chart.plotTop, { visiblePlotOnly: true }) && (i3.translateHeight(this.mouseMoveToTranslation(t3).y), i3.redraw(false));
        } } } }, controlPointOptions: { events: { drag: function(t3, i3) {
          if (i3.chart.isInsidePlot(t3.chartX - i3.chart.plotLeft, t3.chartY - i3.chart.plotTop, { visiblePlotOnly: true })) {
            let s3 = this.mouseMoveToTranslation(t3);
            i3.translateSide(s3.x, s3.y, !!this.index), i3.redraw(false);
          }
        } } } }), t2.types.tunnel = a, a;
      }), s(i, "Extensions/Annotations/Types/InfinityLine.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/Types/CrookedLine.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n) {
        let { merge: e } = n;
        class o extends i2 {
          static edgePoint(t3, i3) {
            return function(n2) {
              let e2 = n2.annotation, a = e2.options.typeOptions.type, r = e2.points;
              return ("horizontalLine" === a || "verticalLine" === a) && (r = [r[0], new s2(e2.chart, r[0].target, { x: r[0].x + +("horizontalLine" === a), y: r[0].y + +("verticalLine" === a), xAxis: r[0].options.xAxis, yAxis: r[0].options.yAxis })]), o.findEdgePoint(r[t3], r[i3]);
            };
          }
          static findEdgeCoordinate(t3, i3, s3, n2) {
            let e2 = "x" === s3 ? "y" : "x";
            return (i3[s3] - t3[s3]) * (n2 - t3[e2]) / (i3[e2] - t3[e2]) + t3[s3];
          }
          static findEdgePoint(t3, i3) {
            let n2, e2, a;
            let r = t3.series.chart, l = t3.series.xAxis, h = i3.series.yAxis, p = s2.pointToPixels(t3), c = s2.pointToPixels(i3), d = c.x - p.x, u = c.y - p.y, x = l.left, g = x + l.width, y = h.top, f = y + h.height, m = d < 0 ? x : g, A = u < 0 ? y : f, b = { x: 0 === d ? p.x : m, y: 0 === u ? p.y : A };
            return 0 !== d && 0 !== u && (e2 = o.findEdgeCoordinate(p, c, "y", m), n2 = o.findEdgeCoordinate(p, c, "x", A), e2 >= y && e2 <= f ? (b.x = m, b.y = e2) : (b.x = n2, b.y = A)), b.x -= r.plotLeft, b.y -= r.plotTop, t3.series.chart.inverted && (a = b.x, b.x = b.y, b.y = a), b;
          }
          addShapes() {
            let t3 = this.options.typeOptions, i3 = [this.points[0], o.endEdgePoint];
            t3.type.match(/line/gi) && (i3[0] = o.startEdgePoint);
            let s3 = this.initShape(e(t3.line, { type: "path", points: i3, className: "highcharts-infinity-lines" }), 0);
            t3.line = s3.options;
          }
        }
        return o.endEdgePoint = o.edgePoint(0, 1), o.startEdgePoint = o.edgePoint(1, 0), o.prototype.defaultOptions = e(i2.prototype.defaultOptions, {}), t2.types.infinityLine = o, o;
      }), s(i, "Extensions/Annotations/Types/TimeCycles.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/Types/CrookedLine.js"], i["Extensions/Annotations/ControlPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n) {
        let { merge: e, isNumber: o, defined: a } = n;
        class r extends i2 {
          init(t3, i3, s3) {
            a(i3.yAxis) && i3.points.forEach((t4) => {
              t4.yAxis = i3.yAxis;
            }), a(i3.xAxis) && i3.points.forEach((t4) => {
              t4.xAxis = i3.xAxis;
            }), super.init(t3, i3, s3);
          }
          setPath() {
            this.shapes[0].options.d = this.getPath();
          }
          getPath() {
            return [["M", this.startX, this.y]].concat(function(t3, i3, s3, n2) {
              let e2 = [];
              for (let o2 = 1; o2 <= i3; o2++) e2.push(["A", t3 / 2, t3 / 2, 0, 1, 1, s3 + o2 * t3, n2]);
              return e2;
            }(this.pixelInterval, this.numberOfCircles, this.startX, this.y));
          }
          addShapes() {
            let t3 = this.options.typeOptions;
            this.setPathProperties();
            let i3 = this.initShape(e(t3.line, { type: "path", d: this.getPath(), points: this.options.points, className: "highcharts-timecycles-lines" }), 0);
            t3.line = i3.options;
          }
          addControlPoints() {
            let t3 = this.options, i3 = t3.typeOptions;
            t3.controlPointOptions.style.cursor = this.chart.inverted ? "ns-resize" : "ew-resize", i3.controlPointOptions.forEach((i4) => {
              let n2 = e(t3.controlPointOptions, i4), o2 = new s2(this.chart, this, n2, 0);
              this.controlPoints.push(o2);
            });
          }
          setPathProperties() {
            let t3 = this.options.typeOptions, i3 = t3.points;
            if (!i3) return;
            let s3 = i3[0], n2 = i3[1], e2 = t3.xAxis || 0, a2 = t3.yAxis || 0, r2 = this.chart.xAxis[e2], l = this.chart.yAxis[a2], h = s3.x, p = s3.y, c = n2.x;
            if (!h || !c) return;
            let d = o(p) ? l.toPixels(p) : l.top + l.height, u = o(h) ? r2.toPixels(h) : r2.left, x = o(c) ? r2.toPixels(c) : r2.left + 30, g = r2.len, y = Math.round(Math.max(Math.abs(x - u), 2)), f = Math.floor(g / y) + 2, m = (Math.floor((u - r2.left) / y) + 1) * y;
            this.startX = u - m, this.y = d, this.pixelInterval = y, this.numberOfCircles = f;
          }
          redraw(t3) {
            this.setPathProperties(), this.setPath(), super.redraw(t3);
          }
        }
        return r.prototype.defaultOptions = e(i2.prototype.defaultOptions, { typeOptions: { controlPointOptions: [{ positioner: function(t3) {
          let i3 = t3.points[0];
          return { x: t3.anchor(i3).absolutePosition.x - (this.graphic.width || 0) / 2, y: t3.y - (this.graphic.height || 0) };
        }, events: { drag: function(t3, i3) {
          let s3 = i3.anchor(i3.points[0]).absolutePosition;
          i3.translatePoint(t3.chartX - s3.x, 0, 0), i3.redraw(false);
        } } }, { positioner: function(t3) {
          let i3 = t3.points[1];
          return { x: t3.anchor(i3).absolutePosition.x - (this.graphic.width || 0) / 2, y: t3.y - (this.graphic.height || 0) };
        }, events: { drag: function(t3, i3) {
          let s3 = i3.anchor(i3.points[1]).absolutePosition;
          i3.translatePoint(t3.chartX - s3.x, 0, 1), i3.redraw(false);
        } } }] } }), t2.types.timeCycles = r, r;
      }), s(i, "Extensions/Annotations/Types/Fibonacci.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/MockPoint.js"], i["Extensions/Annotations/Types/Tunnel.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n) {
        let { merge: e } = n;
        function o(t3, i3) {
          return function() {
            let s3 = this.annotation;
            if (!s3.startRetracements || !s3.endRetracements) return [];
            let n2 = this.anchor(s3.startRetracements[t3]).absolutePosition, e2 = this.anchor(s3.endRetracements[t3]).absolutePosition, o2 = [["M", Math.round(n2.x), Math.round(n2.y)], ["L", Math.round(e2.x), Math.round(e2.y)]];
            if (i3) {
              let i4 = this.anchor(s3.endRetracements[t3 - 1]).absolutePosition, n3 = this.anchor(s3.startRetracements[t3 - 1]).absolutePosition;
              o2.push(["L", Math.round(i4.x), Math.round(i4.y)], ["L", Math.round(n3.x), Math.round(n3.y)]);
            }
            return o2;
          };
        }
        class a extends s2 {
          linkPoints() {
            super.linkPoints(), this.linkRetracementsPoints();
          }
          linkRetracementsPoints() {
            let t3 = this.points, i3 = t3[0].y - t3[3].y, s3 = t3[1].y - t3[2].y, n2 = t3[0].x, e2 = t3[1].x;
            a.levels.forEach((o2, r) => {
              let l = t3[0].y - i3 * o2, h = t3[1].y - s3 * o2, p = this.options.typeOptions.reversed ? a.levels.length - r - 1 : r;
              this.startRetracements = this.startRetracements || [], this.endRetracements = this.endRetracements || [], this.linkRetracementPoint(p, n2, l, this.startRetracements), this.linkRetracementPoint(p, e2, h, this.endRetracements);
            });
          }
          linkRetracementPoint(t3, s3, n2, e2) {
            let o2 = e2[t3], a2 = this.options.typeOptions;
            o2 ? (o2.options.x = s3, o2.options.y = n2, o2.refresh()) : e2[t3] = new i2(this.chart, this, { x: s3, y: n2, xAxis: a2.xAxis, yAxis: a2.yAxis });
          }
          addShapes() {
            a.levels.forEach(function(t3, i3) {
              let { backgroundColors: s3, lineColor: n2, lineColors: e2 } = this.options.typeOptions;
              this.initShape({ type: "path", d: o(i3), stroke: e2[i3] || n2, className: "highcharts-fibonacci-line" }, i3), i3 > 0 && this.initShape({ type: "path", fill: s3[i3 - 1], strokeWidth: 0, d: o(i3, true), className: "highcharts-fibonacci-background-" + (i3 - 1) });
            }, this);
          }
          addLabels() {
            a.levels.forEach(function(t3, s3) {
              let n2 = this.options.typeOptions, o2 = this.initLabel(e(n2.labels[s3], { point: function(t4) {
                return i2.pointToOptions(t4.annotation.startRetracements[s3]);
              }, text: t3.toString() }));
              n2.labels[s3] = o2.options;
            }, this);
          }
        }
        return a.levels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1], a.prototype.defaultOptions = e(s2.prototype.defaultOptions, { typeOptions: { reversed: false, height: 2, backgroundColors: ["rgba(130, 170, 255, 0.4)", "rgba(139, 191, 216, 0.4)", "rgba(150, 216, 192, 0.4)", "rgba(156, 229, 161, 0.4)", "rgba(162, 241, 130, 0.4)", "rgba(169, 255, 101, 0.4)"], lineColor: "#999999", lineColors: [], labels: [] }, labelOptions: { allowOverlap: true, align: "right", backgroundColor: "none", borderWidth: 0, crop: false, overflow: "none", shape: "rect", style: { color: "grey" }, verticalAlign: "middle", y: 0 } }), t2.types.fibonacci = a, a;
      }), s(i, "Extensions/Annotations/Types/FibonacciTimeZones.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/ControlPoint.js"], i["Extensions/Annotations/Types/CrookedLine.js"], i["Extensions/Annotations/Types/InfinityLine.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n, e, o) {
        let { merge: a } = o;
        function r(t3, i3, s3) {
          return function(o2) {
            let a2 = o2.annotation.chart, r2 = a2.inverted ? a2.plotTop : a2.plotLeft, l2 = o2.annotation.points, h = l2[0].series.xAxis, p = l2.length > 1 ? l2[1].plotX - l2[0].plotX : 0, c = h.toValue(l2[0].plotX + r2 + s3 * p);
            return l2 = [new e(a2, l2[0].target, { x: c, y: 0, xAxis: l2[0].options.xAxis, yAxis: l2[0].options.yAxis }), new e(a2, l2[0].target, { x: c, y: 1, xAxis: l2[0].options.xAxis, yAxis: l2[0].options.yAxis })], n.findEdgePoint(l2[t3], l2[i3]);
          };
        }
        class l extends s2 {
          addShapes() {
            let t3 = 1, i3 = 1;
            for (let s3 = 0; s3 < 11; s3++) {
              let n2 = s3 ? t3 : 0, e2 = [r(1, 0, n2), r(0, 1, n2)];
              t3 = (i3 = t3 + i3) - t3, 1 === s3 && (this.secondLineEdgePoints = [e2[0], e2[1]]), this.initShape(a(this.options.typeOptions.line, { type: "path", points: e2, className: "highcharts-fibonacci-timezones-lines" }), s3);
            }
          }
          addControlPoints() {
            let t3 = this.options, s3 = t3.typeOptions, n2 = new i2(this.chart, this, a(t3.controlPointOptions, s3.controlPointOptions), 0);
            this.controlPoints.push(n2), s3.controlPointOptions = n2.options;
          }
        }
        return l.prototype.defaultOptions = a(s2.prototype.defaultOptions, { typeOptions: { line: { stroke: "rgba(0, 0, 0, 0.75)", strokeWidth: 1, fill: void 0 }, controlPointOptions: { positioner: function() {
          let t3 = this.target, i3 = this.graphic, s3 = t3.secondLineEdgePoints, n2 = { annotation: t3 }, e2 = s3[0](n2).y, o2 = s3[1](n2).y, a2 = this.chart.plotLeft, r2 = this.chart.plotTop, l2 = s3[0](n2).x, h = (e2 + o2) / 2;
          return this.chart.inverted && ([l2, h] = [h, l2]), { x: a2 + l2 - (i3.width || 0) / 2, y: r2 + h - (i3.height || 0) / 2 };
        }, events: { drag: function(t3, i3) {
          if (i3.chart.isInsidePlot(t3.chartX - i3.chart.plotLeft, t3.chartY - i3.chart.plotTop, { visiblePlotOnly: true })) {
            let s3 = this.mouseMoveToTranslation(t3);
            i3.translatePoint(s3.x, 0, 1), i3.redraw(false);
          }
        } } } } }), t2.types.fibonacciTimeZones = l, l;
      }), s(i, "Extensions/Annotations/Types/Pitchfork.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/Types/InfinityLine.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2, n) {
        let { merge: e } = n;
        class o extends i2 {
          static outerLineEdgePoint(t3) {
            return function(i3) {
              let n2 = i3.annotation, e2 = n2.points;
              return o.findEdgePoint(e2[t3], e2[0], new s2(n2.chart, i3, n2.midPointOptions()));
            };
          }
          static findEdgePoint(t3, i3, s3) {
            let n2 = Math.atan2(s3.plotY - i3.plotY, s3.plotX - i3.plotX);
            return { x: t3.plotX + 1e7 * Math.cos(n2), y: t3.plotY + 1e7 * Math.sin(n2) };
          }
          static middleLineEdgePoint(t3) {
            let n2 = t3.annotation, e2 = n2.points;
            return i2.findEdgePoint(e2[0], new s2(n2.chart, t3, n2.midPointOptions()));
          }
          midPointOptions() {
            let t3 = this.points;
            return { x: (t3[1].x + t3[2].x) / 2, y: (t3[1].y + t3[2].y) / 2, xAxis: t3[0].series.xAxis, yAxis: t3[0].series.yAxis };
          }
          addShapes() {
            this.addLines(), this.addBackgrounds();
          }
          addLines() {
            let t3 = "highcharts-pitchfork-lines";
            this.initShape({ type: "path", points: [this.points[0], o.middleLineEdgePoint], className: t3 }, 0), this.initShape({ type: "path", points: [this.points[1], o.topLineEdgePoint], className: t3 }, 1), this.initShape({ type: "path", points: [this.points[2], o.bottomLineEdgePoint], className: t3 }, 2);
          }
          addBackgrounds() {
            let t3 = this.shapes, i3 = this.options.typeOptions, s3 = this.initShape(e(i3.innerBackground, { type: "path", points: [function(t4) {
              let i4 = t4.annotation, s4 = i4.points, n3 = i4.midPointOptions();
              return { x: (s4[1].x + n3.x) / 2, y: (s4[1].y + n3.y) / 2, xAxis: n3.xAxis, yAxis: n3.yAxis };
            }, t3[1].points[1], t3[2].points[1], function(t4) {
              let i4 = t4.annotation, s4 = i4.points, n3 = i4.midPointOptions();
              return { x: (n3.x + s4[2].x) / 2, y: (n3.y + s4[2].y) / 2, xAxis: n3.xAxis, yAxis: n3.yAxis };
            }], className: "highcharts-pitchfork-inner-background" }), 3), n2 = this.initShape(e(i3.outerBackground, { type: "path", points: [this.points[1], t3[1].points[1], t3[2].points[1], this.points[2]], className: "highcharts-pitchfork-outer-background" }), 4);
            i3.innerBackground = s3.options, i3.outerBackground = n2.options;
          }
        }
        return o.topLineEdgePoint = o.outerLineEdgePoint(1), o.bottomLineEdgePoint = o.outerLineEdgePoint(0), o.prototype.defaultOptions = e(i2.prototype.defaultOptions, { typeOptions: { innerBackground: { fill: "rgba(130, 170, 255, 0.4)", strokeWidth: 0 }, outerBackground: { fill: "rgba(156, 229, 161, 0.4)", strokeWidth: 0 } } }), t2.types.pitchfork = o, o;
      }), s(i, "Extensions/Annotations/Types/VerticalLine.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/MockPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { merge: n, pick: e } = s2;
        class o extends t2 {
          static connectorFirstPoint(t3) {
            let s3 = t3.annotation, n2 = s3.chart, o2 = n2.inverted, a = s3.points[0], r = e(a.series.yAxis && a.series.yAxis.left, 0), l = e(a.series.yAxis && a.series.yAxis.top, 0), h = s3.options.typeOptions.label.offset, p = i2.pointToPixels(a, true)[o2 ? "x" : "y"];
            return { x: a.x, xAxis: a.series.xAxis, y: p + h + (o2 ? r - n2.plotLeft : l - n2.plotTop) };
          }
          static connectorSecondPoint(t3) {
            let s3 = t3.annotation, n2 = s3.chart, o2 = n2.inverted, a = s3.options.typeOptions, r = s3.points[0], l = e(r.series.yAxis && r.series.yAxis.left, 0), h = e(r.series.yAxis && r.series.yAxis.top, 0), p = i2.pointToPixels(r, true)[o2 ? "x" : "y"], c = a.yOffset;
            return a.label.offset < 0 && (c *= -1), { x: r.x, xAxis: r.series.xAxis, y: p + c + (o2 ? l - n2.plotLeft : h - n2.plotTop) };
          }
          getPointsOptions() {
            return [this.options.typeOptions.point];
          }
          addShapes() {
            let t3 = this.options.typeOptions, i3 = this.initShape(n(t3.connector, { type: "path", points: [o.connectorFirstPoint, o.connectorSecondPoint], className: "highcharts-vertical-line" }), 0);
            t3.connector = i3.options, this.userOptions.typeOptions.point = t3.point;
          }
          addLabels() {
            let t3 = this.options.typeOptions, i3 = t3.label, s3 = 0, e2 = i3.offset, o2 = i3.offset < 0 ? "bottom" : "top", a = "center";
            this.chart.inverted && (s3 = i3.offset, e2 = 0, o2 = "middle", a = i3.offset < 0 ? "right" : "left");
            let r = this.initLabel(n(i3, { verticalAlign: o2, align: a, x: s3, y: e2 }));
            t3.label = r.options;
          }
        }
        return o.prototype.defaultOptions = n(t2.prototype.defaultOptions, { typeOptions: { yOffset: 10, label: { offset: -40, point: function(t3) {
          return t3.annotation.points[0];
        }, allowOverlap: true, backgroundColor: "none", borderWidth: 0, crop: true, overflow: "none", shape: "rect", text: "{y:.2f}" }, connector: { strokeWidth: 1, markerEnd: "arrow" } } }), t2.types.verticalLine = o, o;
      }), s(i, "Extensions/Annotations/Types/Measure.js", [i["Extensions/Annotations/Annotation.js"], i["Extensions/Annotations/ControlPoint.js"], i["Core/Utilities.js"]], function(t2, i2, s2) {
        let { defined: n, extend: e, isNumber: o, merge: a, pick: r } = s2;
        function l() {
          let t3 = "";
          return "" !== this.max && "" !== this.min && (t3 = (this.max + this.min) / 2), t3;
        }
        function h() {
          let t3 = this.chart.series, i3 = c(this.xAxisMin, this.xAxisMax, this.yAxisMin, this.yAxisMax), s3 = 0, n2 = false;
          return t3.forEach((t4) => {
            t4.visible && "highcharts-navigator-series" !== t4.options.id && t4.points.forEach((t5) => {
              !t5.isNull && t5.x > i3.xAxisMin && t5.x <= i3.xAxisMax && t5.y > i3.yAxisMin && t5.y <= i3.yAxisMax && (s3++, n2 = true);
            });
          }), n2 || (s3 = ""), s3;
        }
        function p() {
          return "Min: " + this.min + "<br>Max: " + this.max + "<br>Average: " + this.average + "<br>Bins: " + this.bins;
        }
        function c(t3, i3, s3, n2) {
          return { xAxisMin: Math.min(i3, t3), xAxisMax: Math.max(i3, t3), yAxisMin: Math.min(n2, s3), yAxisMax: Math.max(n2, s3) };
        }
        function d(t3, i3, s3) {
          return t3.toValue(t3.toPixels(i3) + s3);
        }
        function u() {
          let t3 = this.options.typeOptions, i3 = this.chart, s3 = i3.inverted, n2 = i3.xAxis[t3.xAxis], e2 = i3.yAxis[t3.yAxis], a2 = t3.background, r2 = s3 ? a2.height : a2.width, l2 = s3 ? a2.width : a2.height, h2 = t3.selectType, p2 = s3 ? n2.left : e2.top, c2 = s3 ? e2.top : n2.left;
          this.startXMin = t3.point.x, this.startYMin = t3.point.y, o(r2) ? this.startXMax = this.startXMin + r2 : this.startXMax = d(n2, this.startXMin, parseFloat(r2)), o(l2) ? this.startYMax = this.startYMin - l2 : this.startYMax = d(e2, this.startYMin, parseFloat(l2)), "x" === h2 ? (this.startYMin = e2.toValue(p2), this.startYMax = e2.toValue(p2 + e2.len)) : "y" === h2 && (this.startXMin = n2.toValue(c2), this.startXMax = n2.toValue(c2 + n2.len));
        }
        function x() {
          let t3 = this.chart.series, i3 = c(this.xAxisMin, this.xAxisMax, this.yAxisMin, this.yAxisMax), s3 = -1 / 0, n2 = false;
          return t3.forEach((t4) => {
            t4.visible && "highcharts-navigator-series" !== t4.options.id && t4.points.forEach((t5) => {
              !t5.isNull && t5.y > s3 && t5.x > i3.xAxisMin && t5.x <= i3.xAxisMax && t5.y > i3.yAxisMin && t5.y <= i3.yAxisMax && (s3 = t5.y, n2 = true);
            });
          }), n2 || (s3 = ""), s3;
        }
        function g() {
          let t3 = this.chart.series, i3 = c(this.xAxisMin, this.xAxisMax, this.yAxisMin, this.yAxisMax), s3 = 1 / 0, n2 = false;
          return t3.forEach((t4) => {
            t4.visible && "highcharts-navigator-series" !== t4.options.id && t4.points.forEach((t5) => {
              !t5.isNull && t5.y < s3 && t5.x > i3.xAxisMin && t5.x <= i3.xAxisMax && t5.y > i3.yAxisMin && t5.y <= i3.yAxisMax && (s3 = t5.y, n2 = true);
            });
          }), n2 || (s3 = ""), s3;
        }
        function y(t3) {
          let i3 = this.options.typeOptions, s3 = this.chart.xAxis[i3.xAxis], n2 = this.chart.yAxis[i3.yAxis], e2 = this.offsetX, o2 = this.offsetY;
          this.xAxisMin = d(s3, this.startXMin, e2), this.xAxisMax = d(s3, this.startXMax, e2), this.yAxisMin = d(n2, this.startYMin, o2), this.yAxisMax = d(n2, this.startYMax, o2), this.min = g.call(this), this.max = x.call(this), this.average = l.call(this), this.bins = h.call(this), t3 && this.resize(0, 0);
        }
        function f(t3, i3, s3, n2, e2) {
          let o2 = this.options.typeOptions, a2 = o2.selectType, r2 = this.chart.xAxis[o2.xAxis], l2 = this.chart.yAxis[o2.yAxis], h2 = this.startXMin, p2 = this.startXMax, c2 = this.startYMin, u2 = this.startYMax, x2 = this.offsetX, g2 = this.offsetY;
          i3 && ("x" === a2 ? 0 === s3 ? this.startXMin = d(r2, h2, n2) : this.startXMax = d(r2, p2, n2) : "y" === a2 ? 0 === s3 ? this.startYMin = d(l2, c2, e2) : this.startYMax = d(l2, u2, e2) : (this.startXMax = d(r2, p2, n2), this.startYMax = d(l2, u2, e2))), t3 && (this.startXMin = d(r2, h2, x2), this.startXMax = d(r2, p2, x2), this.startYMin = d(l2, c2, g2), this.startYMax = d(l2, u2, g2), this.offsetX = 0, this.offsetY = 0), this.options.typeOptions.point = { x: this.startXMin, y: this.startYMin }, this.userOptions.typeOptions.point = { x: this.startXMin, y: this.startYMin };
        }
        class m extends t2 {
          init(t3, i3, s3) {
            super.init(t3, i3, s3), this.offsetX = 0, this.offsetY = 0, this.resizeX = 0, this.resizeY = 0, u.call(this), this.addValues(), this.addShapes();
          }
          setClipAxes() {
            this.clipXAxis = this.chart.xAxis[this.options.typeOptions.xAxis], this.clipYAxis = this.chart.yAxis[this.options.typeOptions.yAxis];
          }
          pointsOptions() {
            return this.options.points;
          }
          shapePointsOptions() {
            let t3 = this.options.typeOptions, i3 = t3.xAxis, s3 = t3.yAxis;
            return [{ x: this.xAxisMin, y: this.yAxisMin, xAxis: i3, yAxis: s3 }, { x: this.xAxisMax, y: this.yAxisMin, xAxis: i3, yAxis: s3 }, { x: this.xAxisMax, y: this.yAxisMax, xAxis: i3, yAxis: s3 }, { x: this.xAxisMin, y: this.yAxisMax, xAxis: i3, yAxis: s3 }];
          }
          addControlPoints() {
            let t3 = this.chart.inverted, s3 = this.options.controlPointOptions, e2 = this.options.typeOptions.selectType;
            n(this.userOptions.controlPointOptions && this.userOptions.controlPointOptions.style.cursor) || ("x" === e2 ? s3.style.cursor = t3 ? "ns-resize" : "ew-resize" : "y" !== e2 || (s3.style.cursor = t3 ? "ew-resize" : "ns-resize"));
            let o2 = new i2(this.chart, this, this.options.controlPointOptions, 0);
            this.controlPoints.push(o2), "xy" !== e2 && (o2 = new i2(this.chart, this, this.options.controlPointOptions, 1), this.controlPoints.push(o2));
          }
          addValues(t3) {
            let i3 = this.options.typeOptions, s3 = i3.label.formatter;
            y.call(this, t3), i3.label.enabled && (this.labels.length > 0 ? this.labels[0].text = s3 && s3.call(this) || p.call(this) : this.initLabel(e({ shape: "rect", backgroundColor: "none", color: "black", borderWidth: 0, dashStyle: "Dash", overflow: "allow", align: "left", y: 0, x: 0, verticalAlign: "top", crop: true, xAxis: 0, yAxis: 0, point: function(t4) {
              let s4 = t4.annotation, n2 = t4.options;
              return { x: s4.xAxisMin, y: s4.yAxisMin, xAxis: r(i3.xAxis, n2.xAxis), yAxis: r(i3.yAxis, n2.yAxis) };
            }, text: s3 && s3.call(this) || p.call(this) }, i3.label), void 0));
          }
          addShapes() {
            this.addCrosshairs(), this.addBackground();
          }
          addBackground() {
            void 0 !== this.shapePointsOptions()[0].x && this.initShape(e({ type: "path", points: this.shapePointsOptions(), className: "highcharts-measure-background" }, this.options.typeOptions.background), 2);
          }
          addCrosshairs() {
            let t3 = this.chart, i3 = this.options.typeOptions, s3 = this.options.typeOptions.point, n2 = t3.xAxis[i3.xAxis], o2 = t3.yAxis[i3.yAxis], r2 = t3.inverted, l2 = { point: s3, type: "path" }, h2 = n2.toPixels(this.xAxisMin), p2 = n2.toPixels(this.xAxisMax), c2 = o2.toPixels(this.yAxisMin), d2 = o2.toPixels(this.yAxisMax), u2 = [], x2 = [], g2, y2, f2;
            r2 && (f2 = h2, h2 = c2, c2 = f2, f2 = p2, p2 = d2, d2 = f2), i3.crosshairX.enabled && (u2 = [["M", h2, c2 + (d2 - c2) / 2], ["L", p2, c2 + (d2 - c2) / 2]]), i3.crosshairY.enabled && (x2 = [["M", h2 + (p2 - h2) / 2, c2], ["L", h2 + (p2 - h2) / 2, d2]]), this.shapes.length > 0 ? (this.shapes[0].options.d = u2, this.shapes[1].options.d = x2) : (g2 = a(l2, { className: "highcharts-measure-crosshair-x" }, i3.crosshairX), y2 = a(l2, { className: "highcharts-measure-crosshair-y" }, i3.crosshairY), this.initShape(e({ d: u2 }, g2), 0), this.initShape(e({ d: x2 }, y2), 1));
          }
          onDrag(t3) {
            let i3 = this.mouseMoveToTranslation(t3), s3 = this.options.typeOptions.selectType, n2 = "y" === s3 ? 0 : i3.x, e2 = "x" === s3 ? 0 : i3.y;
            this.translate(n2, e2), this.offsetX += n2, this.offsetY += e2, this.redraw(false, false, true);
          }
          resize(t3, i3, s3, n2) {
            let e2 = this.shapes[2];
            "x" === n2 ? 0 === s3 ? (e2.translatePoint(t3, 0, 0), e2.translatePoint(t3, i3, 3)) : (e2.translatePoint(t3, 0, 1), e2.translatePoint(t3, i3, 2)) : "y" === n2 ? 0 === s3 ? (e2.translatePoint(0, i3, 0), e2.translatePoint(0, i3, 1)) : (e2.translatePoint(0, i3, 2), e2.translatePoint(0, i3, 3)) : (e2.translatePoint(t3, 0, 1), e2.translatePoint(t3, i3, 2), e2.translatePoint(0, i3, 3)), f.call(this, false, true, s3, t3, i3), this.options.typeOptions.background.height = Math.abs(this.startYMax - this.startYMin), this.options.typeOptions.background.width = Math.abs(this.startXMax - this.startXMin);
          }
          redraw(t3, i3, s3) {
            this.linkPoints(), this.graphic || this.render(), s3 && f.call(this, true, false), this.clipRect && this.clipRect.animate(this.getClipBox()), this.addValues(i3), this.addCrosshairs(), this.redrawItems(this.shapes, t3), this.redrawItems(this.labels, t3), this.controlPoints.forEach((t4) => t4.redraw());
          }
          translate(t3, i3) {
            this.shapes.forEach((s3) => s3.translate(t3, i3));
          }
        }
        return m.prototype.defaultOptions = a(t2.prototype.defaultOptions, { typeOptions: { selectType: "xy", xAxis: 0, yAxis: 0, background: { fill: "rgba(130, 170, 255, 0.4)", strokeWidth: 0, stroke: void 0 }, crosshairX: { enabled: true, zIndex: 6, dashStyle: "Dash", markerEnd: "arrow" }, crosshairY: { enabled: true, zIndex: 6, dashStyle: "Dash", markerEnd: "arrow" }, label: { enabled: true, style: { fontSize: "0.7em", color: "#666666" }, formatter: void 0 } }, controlPointOptions: { positioner: function(t3) {
          let i3 = this.index, s3 = t3.chart, n2 = t3.options, e2 = n2.typeOptions, o2 = e2.selectType, a2 = n2.controlPointOptions, r2 = s3.inverted, l2 = s3.xAxis[e2.xAxis], h2 = s3.yAxis[e2.yAxis], p2 = c(t3.xAxisMin, t3.xAxisMax, t3.yAxisMin, t3.yAxisMax), d2 = t3.xAxisMax, u2 = t3.yAxisMax, x2, g2;
          return "x" === o2 && (u2 = (p2.yAxisMax + p2.yAxisMin) / 2, 0 === i3 && (d2 = t3.xAxisMin)), "y" === o2 && (d2 = p2.xAxisMin + (p2.xAxisMax - p2.xAxisMin) / 2, 0 === i3 && (u2 = t3.yAxisMin)), r2 ? (x2 = h2.toPixels(u2), g2 = l2.toPixels(d2)) : (x2 = l2.toPixels(d2), g2 = h2.toPixels(u2)), { x: x2 - a2.width / 2, y: g2 - a2.height / 2 };
        }, events: { drag: function(t3, i3) {
          let s3 = this.mouseMoveToTranslation(t3), n2 = i3.options.typeOptions.selectType, e2 = this.index, o2 = "y" === n2 ? 0 : s3.x, a2 = "x" === n2 ? 0 : s3.y;
          i3.resize(o2, a2, e2, n2), i3.resizeX += o2, i3.resizeY += a2, i3.redraw(false, true);
        } } } }), t2.types.measure = m, m;
      }), s(i, "masters/modules/annotations-advanced.src.js", [i["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_annotations_advanced();
//# sourceMappingURL=highcharts_modules_annotations-advanced__js.js.map
