import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/timeline.js
var require_timeline = __commonJS({
  "node_modules/highcharts/modules/timeline.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Timeline series
    *
    * (c) 2010-2024 Highsoft AS
    * Author: Daniel Studencki
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/timeline", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, s, n) {
        e2.hasOwnProperty(i2) || (e2[i2] = n.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Series/Timeline/TimelinePoint.js", [e["Core/Series/Point.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { line: { prototype: { pointClass: s } }, pie: { prototype: { pointClass: n } } } = e2.seriesTypes, { defined: o, isNumber: r, merge: a, objectEach: l, pick: h } = i2;
        return class extends s {
          alignConnector() {
            let t3 = this.series, e3 = this.dataLabel, i3 = e3.connector, s2 = e3.options || {}, n2 = s2.connectorWidth || 0, r2 = this.series.chart, a2 = i3.getBBox(), l2 = { x: a2.x + (e3.translateX || 0), y: a2.y + (e3.translateY || 0) };
            r2.inverted ? l2.y -= n2 / 2 : l2.x += n2 / 2, i3[r2.isInsidePlot(l2.x, l2.y) ? "animate" : "attr"]({ d: this.getConnectorPath() }), i3.addClass("highcharts-color-" + this.colorIndex), t3.chart.styledMode || i3.attr({ stroke: s2.connectorColor || this.color, "stroke-width": s2.connectorWidth, opacity: e3[o(e3.newOpacity) ? "newOpacity" : "opacity"] });
          }
          drawConnector() {
            let { dataLabel: t3, series: e3 } = this;
            t3 && (t3.connector || (t3.connector = e3.chart.renderer.path(this.getConnectorPath()).attr({ zIndex: -1 }).add(t3)), this.series.chart.isInsidePlot(t3.x || 0, t3.y || 0) && this.alignConnector());
          }
          getConnectorPath() {
            var _a;
            let { plotX: t3 = 0, plotY: e3 = 0, series: i3, dataLabel: s2 } = this, n2 = i3.chart, o2 = i3.xAxis.len, a2 = n2.inverted, h2 = a2 ? "x2" : "y2";
            if (s2) {
              let d = s2.targetPosition, p = (s2.alignAttr || s2)[h2[0]] < i3.yAxis.len / 2, c = { x1: t3, y1: e3, x2: t3, y2: r(d.y) ? d.y : s2.y };
              return a2 && (c = { x1: e3, y1: o2 - t3, x2: d.x || s2.x, y2: o2 - t3 }), p && (c[h2] += s2[a2 ? "width" : "height"] || 0), l(c, (t4, e4) => {
                c[e4] -= (s2.alignAttr || s2)[e4[0]];
              }), n2.renderer.crispLine([["M", c.x1, c.y1], ["L", c.x2, c.y2]], ((_a = s2.options) == null ? void 0 : _a.connectorWidth) || 0);
            }
            return [];
          }
          constructor(t3, e3) {
            super(t3, e3), this.name ?? (this.name = "Event"), this.y = 1;
          }
          isValid() {
            return null !== this.options.y;
          }
          setState() {
            let t3 = super.setState;
            this.isNull || t3.apply(this, arguments);
          }
          setVisible(t3, e3) {
            let i3 = this.series;
            e3 = h(e3, i3.options.ignoreHiddenPoint), n.prototype.setVisible.call(this, t3, false), i3.processData(), e3 && i3.chart.redraw();
          }
          applyOptions(e3, i3) {
            return e3 = t2.prototype.optionsToObject.call(this, e3), this.userDLOptions = a(this.userDLOptions, e3.dataLabels), super.applyOptions(e3, i3);
          }
        };
      }), i(e, "Series/Timeline/TimelineSeriesDefaults.js", [], function() {
        return { colorByPoint: true, stickyTracking: false, ignoreHiddenPoint: true, legendType: "point", lineWidth: 4, tooltip: { headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {point.key}</span><br/>', pointFormat: "{point.description}" }, states: { hover: { lineWidthPlus: 0 } }, dataLabels: { enabled: true, allowOverlap: true, alternate: true, backgroundColor: "#ffffff", borderWidth: 1, borderColor: "#999999", borderRadius: 3, color: "#333333", connectorWidth: 1, distance: void 0, formatter: function() {
          return (this.series.chart.styledMode ? '<span class="highcharts-color-' + this.point.colorIndex + '">● </span>' : '<span style="color:' + this.point.color + '">● </span>') + ('<span class="highcharts-strong">' + (this.key || "")) + "</span><br/>" + (this.point.label || "");
        }, style: { textOutline: "none", fontWeight: "normal", fontSize: "0.8em" }, shadow: false, verticalAlign: "middle" }, marker: { enabledThreshold: 0, symbol: "square", radius: 6, lineWidth: 2, height: 15 }, showInLegend: false, colorKey: "x", legendSymbol: "rectangle" };
      }), i(e, "Series/Timeline/TimelineSeries.js", [e["Core/Series/SeriesRegistry.js"], e["Series/Timeline/TimelinePoint.js"], e["Series/Timeline/TimelineSeriesDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s) {
        let { column: n, line: o } = t2.seriesTypes, { addEvent: r, arrayMax: a, arrayMin: l, defined: h, extend: d, merge: p, pick: c } = s;
        class u extends o {
          alignDataLabel(t3, e3, i3, s2) {
            var _a;
            let n2, o2, r2;
            let a2 = this.chart.inverted, l2 = this.visibilityMap.filter((t4) => !!t4), h2 = this.visiblePointsCount || 0, d2 = l2.indexOf(t3), p2 = this.options.dataLabels, u2 = t3.userDLOptions || {}, y = p2.alternate ? d2 && d2 !== h2 - 1 ? 2 : 1.5 : 1, f = Math.floor(this.xAxis.len / h2), g = e3.padding;
            t3.visible && (n2 = Math.abs(u2.x || t3.options.dataLabels.x), a2 ? (o2 = (n2 - g) * 2 - (t3.itemHeight || 0) / 2, r2 = { width: c((_a = p2.style) == null ? void 0 : _a.width, `${0.4 * this.yAxis.len}px`), textOverflow: (e3.width || 0) / o2 * (e3.height || 0) / 2 > f * y ? "ellipsis" : "none" }) : r2 = { width: (u2.width || p2.width || f * y - 2 * g) + "px" }, e3.css(r2), this.chart.styledMode || e3.shadow(p2.shadow)), super.alignDataLabel.apply(this, arguments);
          }
          bindAxes() {
            super.bindAxes(), this.xAxis.userOptions.type || (this.xAxis.categories = this.xAxis.hasNames = true);
          }
          distributeDL() {
            let t3 = this.options.dataLabels, e3 = this.chart.inverted, i3 = 1;
            if (t3) {
              let s2 = c(t3.distance, e3 ? 20 : 100);
              for (let n2 of this.points) {
                let o2 = { [e3 ? "x" : "y"]: t3.alternate && i3 % 2 ? -s2 : s2 };
                e3 && (o2.align = t3.alternate && i3 % 2 ? "right" : "left"), n2.options.dataLabels = p(o2, n2.userDLOptions), i3++;
              }
            }
          }
          generatePoints() {
            super.generatePoints();
            let t3 = this.points;
            for (let e3 = 0, i3 = t3.length; e3 < i3; ++e3) t3[e3].applyOptions({ x: this.xData[e3] }, this.xData[e3]);
          }
          getVisibilityMap() {
            return (this.data.length ? this.data : this.userOptions.data || []).map((t3) => !!t3 && false !== t3.visible && !t3.isNull && t3);
          }
          getXExtremes(t3) {
            let e3 = this, i3 = t3.filter((t4, i4) => e3.points[i4].isValid() && e3.points[i4].visible);
            return { min: l(i3), max: a(i3) };
          }
          init() {
            let t3 = this;
            super.init.apply(t3, arguments), t3.eventsToUnbind.push(r(t3, "afterTranslate", function() {
              let e3, i3 = Number.MAX_VALUE;
              for (let s2 of t3.points) s2.isInside = s2.isInside && s2.visible, s2.visible && !s2.isNull && (h(e3) && (i3 = Math.min(i3, Math.abs(s2.plotX - e3))), e3 = s2.plotX);
              t3.closestPointRangePx = i3;
            })), t3.eventsToUnbind.push(r(t3, "drawDataLabels", function() {
              t3.distributeDL();
            })), t3.eventsToUnbind.push(r(t3, "afterDrawDataLabels", function() {
              let e3;
              for (let i3 of t3.points) (e3 = i3.dataLabel) && (e3.animate = function(t4) {
                return this.targetPosition && (this.targetPosition = t4), this.renderer.Element.prototype.animate.apply(this, arguments);
              }, e3.targetPosition || (e3.targetPosition = {}), i3.drawConnector());
            })), t3.eventsToUnbind.push(r(t3.chart, "afterHideOverlappingLabel", function() {
              for (let e3 of t3.points) e3.dataLabel && e3.dataLabel.connector && e3.dataLabel.oldOpacity !== e3.dataLabel.newOpacity && e3.alignConnector();
            }));
          }
          markerAttribs(t3, e3) {
            let i3 = this.options.marker, s2 = t3.marker || {}, n2 = s2.symbol || i3.symbol, o2 = c(s2.width, i3.width, this.closestPointRangePx), r2 = c(s2.height, i3.height), a2, l2 = 0;
            if (this.xAxis.dateTime) return super.markerAttribs(t3, e3);
            e3 && (a2 = i3.states[e3] || {}, l2 = c((s2.states && s2.states[e3] || {}).radius, a2.radius, l2 + (a2.radiusPlus || 0))), t3.hasImage = n2 && 0 === n2.indexOf("url");
            let h2 = { x: Math.floor(t3.plotX) - o2 / 2 - l2 / 2, y: t3.plotY - r2 / 2 - l2 / 2, width: o2 + l2, height: r2 + l2 };
            return this.chart.inverted ? { y: h2.x && h2.width && this.xAxis.len - h2.x - h2.width, x: h2.y && h2.y, width: h2.height, height: h2.width } : h2;
          }
          processData() {
            let t3 = 0, e3;
            for (let e4 of (this.visibilityMap = this.getVisibilityMap(), this.visibilityMap)) e4 && t3++;
            for (e3 = 0, this.visiblePointsCount = t3; e3 < this.xData.length; e3++) this.yData[e3] = 1;
            super.processData.call(this, arguments);
          }
        }
        return u.defaultOptions = p(o.defaultOptions, i2), d(u.prototype, { drawTracker: n.prototype.drawTracker, pointClass: e2, trackerGroups: ["markerGroup", "dataLabelsGroup"] }), t2.registerSeriesType("timeline", u), u;
      }), i(e, "masters/modules/timeline.src.js", [e["Core/Globals.js"]], function(t2) {
        return t2;
      });
    });
  }
});
export default require_timeline();
//# sourceMappingURL=highcharts_modules_timeline__js.js.map
