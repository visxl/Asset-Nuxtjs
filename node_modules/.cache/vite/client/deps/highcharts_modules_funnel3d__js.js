import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/funnel3d.js
var require_funnel3d = __commonJS({
  "node_modules/highcharts/modules/funnel3d.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Highcharts funnel module
    *
    * (c) 2010-2024 Kacper Madej
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/funnel3d", ["highcharts", "highcharts/highcharts-3d", "highcharts/modules/cylinder"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, r, n) {
        e2.hasOwnProperty(i2) || (e2[i2] = n.apply(null, r), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Series/Funnel3D/SVGElement3DFunnel.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, i2, r) {
        let { parse: n } = t2, { charts: o } = e2, { Element3D: s } = i2.getRendererType().prototype, { merge: d } = r;
        return class extends s {
          constructor() {
            super(...arguments), this.mainParts = ["top", "bottom"], this.parts = ["top", "bottom", "frontUpper", "backUpper", "frontLower", "backLower", "rightUpper", "rightLower"], this.sideGroups = ["upperGroup", "lowerGroup"], this.sideParts = { upperGroup: ["frontUpper", "backUpper", "rightUpper"], lowerGroup: ["frontLower", "backLower", "rightLower"] }, this.pathType = "funnel3d";
          }
          opacitySetter(t3) {
            let e3 = parseFloat(t3), i3 = this.parts, r2 = o[this.renderer.chartIndex], n2 = "group-opacity-" + e3 + "-" + r2.index;
            if (this.parts = this.mainParts, this.singleSetterForParts("opacity", e3), this.parts = i3, !r2.renderer.filterId) {
              for (let t4 of (r2.renderer.definition({ tagName: "filter", attributes: { id: n2 }, children: [{ tagName: "feComponentTransfer", children: [{ tagName: "feFuncA", attributes: { type: "table", tableValues: "0 " + e3 } }] }] }), this.sideGroups)) this[t4].attr({ filter: "url(#" + n2 + ")" });
              if (this.renderer.styledMode) for (let t4 of (r2.renderer.definition({ tagName: "style", textContent: ".highcharts-" + n2 + " {filter:url(#" + n2 + ")}" }), this.sideGroups)) this[t4].addClass("highcharts-" + n2);
            }
            return this;
          }
          fillSetter(t3) {
            let e3 = n(t3), i3 = e3.rgba[3], r2 = { top: n(t3).brighten(0.1).get(), bottom: n(t3).brighten(-0.2).get() };
            if (i3 < 1 ? (e3.rgba[3] = 1, e3 = e3.get("rgb"), this.attr({ opacity: i3 })) : e3 = t3, e3.linearGradient || e3.radialGradient || !this.gradientForSides || (e3 = { linearGradient: { x1: 0, x2: 1, y1: 1, y2: 1 }, stops: [[0, n(t3).brighten(-0.2).get()], [0.5, t3], [1, n(t3).brighten(-0.2).get()]] }), e3.linearGradient) for (let t4 of this.sideGroups) {
              let i4 = this[t4].gradientBox, n2 = e3.linearGradient, o2 = d(e3, { linearGradient: { x1: i4.x + n2.x1 * i4.width, y1: i4.y + n2.y1 * i4.height, x2: i4.x + n2.x2 * i4.width, y2: i4.y + n2.y2 * i4.height } });
              for (let e4 of this.sideParts[t4]) r2[e4] = o2;
            }
            else if (d(true, r2, { frontUpper: e3, backUpper: e3, rightUpper: e3, frontLower: e3, backLower: e3, rightLower: e3 }), e3.radialGradient) for (let t4 of this.sideGroups) {
              let e4 = this[t4].gradientBox, i4 = e4.x + e4.width / 2, r3 = e4.y + e4.height / 2, n2 = Math.min(e4.width, e4.height);
              for (let e5 of this.sideParts[t4]) this[e5].setRadialReference([i4, r3, n2]);
            }
            if (this.singleSetterForParts("fill", null, r2), this.color = this.fill = t3, e3.linearGradient) for (let t4 of [this.frontLower, this.frontUpper]) {
              let e4 = t4.element, i4 = e4 && this.renderer.gradients[e4.gradient];
              i4 && "userSpaceOnUse" !== i4.attr("gradientUnits") && i4.attr({ gradientUnits: "userSpaceOnUse" });
            }
            return this;
          }
          adjustForGradient() {
            let t3;
            for (let e3 of this.sideGroups) {
              let i3 = { x: Number.MAX_VALUE, y: Number.MAX_VALUE }, r2 = { x: -Number.MAX_VALUE, y: -Number.MAX_VALUE };
              for (let n2 of this.sideParts[e3]) t3 = this[n2].getBBox(true), i3 = { x: Math.min(i3.x, t3.x), y: Math.min(i3.y, t3.y) }, r2 = { x: Math.max(r2.x, t3.x + t3.width), y: Math.max(r2.y, t3.y + t3.height) };
              this[e3].gradientBox = { x: i3.x, width: r2.x - i3.x, y: i3.y, height: r2.y - i3.y };
            }
          }
          zIndexSetter() {
            return this.finishedOnAdd && this.adjustForGradient(), this.renderer.Element.prototype.zIndexSetter.apply(this, arguments);
          }
          onAdd() {
            this.adjustForGradient(), this.finishedOnAdd = true;
          }
        };
      }), i(e, "Series/Funnel3D/Funnel3DComposition.js", [e["Series/Funnel3D/SVGElement3DFunnel.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { charts: r } = e2, { error: n, extend: o, merge: s } = i2;
        function d(t3) {
          let e3 = this.element3d("funnel3d", t3), i3 = this.styledMode, r2 = { "stroke-width": 1, stroke: "none" };
          for (let t4 of (e3.upperGroup = this.g("funnel3d-upper-group").attr({ zIndex: e3.frontUpper.zIndex }).add(e3), [e3.frontUpper, e3.backUpper, e3.rightUpper])) i3 || t4.attr(r2), t4.add(e3.upperGroup);
          for (let t4 of (e3.lowerGroup = this.g("funnel3d-lower-group").attr({ zIndex: e3.frontLower.zIndex }).add(e3), [e3.frontLower, e3.backLower, e3.rightLower])) i3 || t4.attr(r2), t4.add(e3.lowerGroup);
          return e3.gradientForSides = t3.gradientForSides, e3;
        }
        function h(t3) {
          this.getCylinderEnd || n("A required Highcharts module is missing: cylinder.js", true, r[this.chartIndex]);
          let e3 = r[this.chartIndex], i3 = t3.alphaCorrection = 90 - Math.abs(e3.options.chart.options3d.alpha % 180 - 90), o2 = this.cuboidPath.call(this, s(t3, { depth: t3.width, width: (t3.width + t3.bottom.width) / 2 })), d2 = o2.isTop, h2 = !o2.isFront, l = !!t3.middle, a = this.getCylinderEnd(e3, s(t3, { x: t3.x - t3.width / 2, z: t3.z - t3.width / 2, alphaCorrection: i3 })), p = t3.bottom.width, g = s(t3, { width: p, x: t3.x - p / 2, z: t3.z - p / 2, alphaCorrection: i3 }), u = this.getCylinderEnd(e3, g, true), f = p, c = g, y = u, x = u, m;
          l && (f = t3.middle.width, c = s(t3, { y: t3.y + t3.middle.fraction * t3.height, width: f, x: t3.x - f / 2, z: t3.z - f / 2 }), y = this.getCylinderEnd(e3, c, false), x = this.getCylinderEnd(e3, c, false));
          let w = { top: a, bottom: u, frontUpper: this.getCylinderFront(a, y), zIndexes: { group: o2.zIndexes.group, top: 0 !== d2 ? 0 : 3, bottom: 1 !== d2 ? 0 : 3, frontUpper: h2 ? 2 : 1, backUpper: h2 ? 1 : 2, rightUpper: h2 ? 2 : 1 } };
          return w.backUpper = this.getCylinderBack(a, y), m = Math.min(f, t3.width) / Math.max(f, t3.width) != 1, w.rightUpper = this.getCylinderFront(this.getCylinderEnd(e3, s(t3, { x: t3.x - t3.width / 2, z: t3.z - t3.width / 2, alphaCorrection: m ? -i3 : 0 }), false), this.getCylinderEnd(e3, s(c, { alphaCorrection: m ? -i3 : 0 }), !l)), l && (m = Math.min(f, p) / Math.max(f, p) != 1, s(true, w, { frontLower: this.getCylinderFront(x, u), backLower: this.getCylinderBack(x, u), rightLower: this.getCylinderFront(this.getCylinderEnd(e3, s(g, { alphaCorrection: m ? -i3 : 0 }), true), this.getCylinderEnd(e3, s(c, { alphaCorrection: m ? -i3 : 0 }), false)), zIndexes: { frontLower: h2 ? 2 : 1, backLower: h2 ? 1 : 2, rightLower: h2 ? 1 : 2 } })), w;
        }
        return { compose: function(e3) {
          let i3 = e3.prototype;
          i3.funnel3d || (i3.Element3D.types.funnel3d = t2, o(i3, { funnel3d: d, funnel3dPath: h }));
        } };
      }), i(e, "Series/Funnel3D/Funnel3DSeriesDefaults.js", [], function() {
        return { center: ["50%", "50%"], width: "90%", neckWidth: "30%", height: "100%", neckHeight: "25%", reversed: false, gradientForSides: true, animation: false, edgeWidth: 0, colorByPoint: true, showInLegend: false, dataLabels: { align: "right", crop: false, inside: false, overflow: "allow" } };
      }), i(e, "Series/Funnel3D/Funnel3DPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { seriesTypes: { column: i2 } } = t2, { extend: r } = e2;
        class n extends i2.prototype.pointClass {
        }
        return r(n.prototype, { shapeType: "funnel3d" }), n;
      }), i(e, "Series/Funnel3D/Funnel3DSeries.js", [e["Series/Funnel3D/Funnel3DComposition.js"], e["Series/Funnel3D/Funnel3DSeriesDefaults.js"], e["Series/Funnel3D/Funnel3DPoint.js"], e["Core/Globals.js"], e["Core/Math3D.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, i2, r, n, o, s) {
        let { noop: d } = r, { perspective: h } = n, { series: l, seriesTypes: { column: a } } = o, { extend: p, merge: g, pick: u, relativeLength: f } = s;
        class c extends a {
          alignDataLabel(t3, e3, i3) {
            let r2 = t3.dlBoxRaw, n2 = this.chart.inverted, o2 = t3.plotY > u(this.translatedThreshold, this.yAxis.len), s2 = u(i3.inside, !!this.options.stacking), d2 = { x: r2.x, y: r2.y, height: 0 };
            i3.align = u(i3.align, !n2 || s2 ? "center" : o2 ? "right" : "left"), i3.verticalAlign = u(i3.verticalAlign, n2 || s2 ? "middle" : o2 ? "top" : "bottom"), "top" !== i3.verticalAlign && (d2.y += r2.bottom / ("bottom" === i3.verticalAlign ? 1 : 2)), d2.width = this.getWidthAt(d2.y), this.options.reversed && (d2.width = r2.fullWidth - d2.width), s2 ? d2.x -= d2.width / 2 : "left" === i3.align ? (i3.align = "right", d2.x -= 1.5 * d2.width) : "right" === i3.align ? (i3.align = "left", d2.x += d2.width / 2) : d2.x -= d2.width / 2, t3.dlBox = d2, a.prototype.alignDataLabel.apply(this, arguments);
          }
          bindAxes() {
            l.prototype.bindAxes.apply(this, arguments), p(this.xAxis.options, { gridLineWidth: 0, lineWidth: 0, title: void 0, tickPositions: [] }), g(true, this.yAxis.options, { gridLineWidth: 0, title: void 0, labels: { enabled: false } });
          }
          translate() {
            l.prototype.translate.apply(this, arguments);
            let t3 = this.chart, e3 = this.options, i3 = e3.reversed, r2 = e3.ignoreHiddenPoint, n2 = t3.plotWidth, o2 = t3.plotHeight, s2 = e3.center, d2 = f(s2[0], n2), a2 = f(s2[1], o2), g2 = f(e3.width, n2), c2 = f(e3.height, o2), y = f(e3.neckWidth, n2), x = f(e3.neckHeight, o2), m = a2 - c2 / 2 + c2 - x, w = this.points, b = 0, C = 0, F, S, U, G, L, j, D, A, k;
            for (let t4 of (this.getWidthAt = S = function(t5) {
              return t5 > m || c2 === x ? y : y + (g2 - y) * (1 - (t5 - (a2 - c2 / 2)) / (c2 - x));
            }, this.center = [d2, a2, c2], this.centerX = d2, w)) r2 && false === t4.visible || (b += t4.y);
            for (let n3 of w) D = null, U = b ? n3.y / b : 0, j = (L = a2 - c2 / 2 + C * c2) + U * c2, F = S(L), A = j - L, k = { gradientForSides: u(n3.options.gradientForSides, e3.gradientForSides), x: d2, y: L, height: A, width: F, z: 1, top: { width: F } }, F = S(j), k.bottom = { fraction: U, width: F }, L >= m ? k.isCylinder = true : j > m && (D = j, F = S(m), j = m, k.bottom.width = F, k.middle = { fraction: A ? (m - L) / A : 0, width: F }), i3 && (k.y = L = a2 + c2 / 2 - (C + U) * c2, k.middle && (k.middle.fraction = 1 - (A ? k.middle.fraction : 0)), F = k.width, k.width = k.bottom.width, k.bottom.width = F), n3.shapeArgs = p(n3.shapeArgs, k), n3.percentage = 100 * U, n3.plotX = d2, i3 ? n3.plotY = a2 + c2 / 2 - (C + U / 2) * c2 : n3.plotY = (L + (D || j)) / 2, G = h([{ x: d2, y: n3.plotY, z: i3 ? -(g2 - S(n3.plotY)) / 2 : -S(n3.plotY) / 2 }], t3, true)[0], n3.tooltipPos = [G.x, G.y], n3.dlBoxRaw = { x: d2, width: S(n3.plotY), y: L, bottom: k.height || 0, fullWidth: g2 }, r2 && false === n3.visible || (C += U);
          }
        }
        return c.compose = t2.compose, c.defaultOptions = g(a.defaultOptions, e2), p(c.prototype, { pointClass: i2, translate3dShapes: d }), o.registerSeriesType("funnel3d", c), c;
      }), i(e, "masters/modules/funnel3d.src.js", [e["Core/Globals.js"], e["Series/Funnel3D/Funnel3DSeries.js"], e["Core/Renderer/RendererRegistry.js"]], function(t2, e2, i2) {
        return e2.compose(i2.getRendererType()), t2;
      });
    });
  }
});
export default require_funnel3d();
//# sourceMappingURL=highcharts_modules_funnel3d__js.js.map
