import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/sunburst.js
var require_sunburst = __commonJS({
  "node_modules/highcharts/modules/sunburst.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * (c) 2016-2024 Highsoft AS
    * Authors: Jon Arild Nygard
    *
    * License: www.highcharts.com/license
    */
    function(t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = t) : "function" == typeof define && define.amd ? define("highcharts/modules/sunburst", ["highcharts"], function(e) {
        return t(e), t.Highcharts = e, t;
      }) : t("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(t) {
      "use strict";
      var e = t ? t._modules : {};
      function i(e2, i2, s, r) {
        e2.hasOwnProperty(i2) || (e2[i2] = r.apply(null, s), "function" == typeof CustomEvent && t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: e2[i2] } })));
      }
      i(e, "Extensions/Breadcrumbs/BreadcrumbsDefaults.js", [], function() {
        return { lang: { mainBreadcrumb: "Main" }, options: { buttonTheme: { fill: "none", height: 18, padding: 2, "stroke-width": 0, zIndex: 7, states: { select: { fill: "none" } }, style: { color: "#334eff" } }, buttonSpacing: 5, floating: false, format: void 0, relativeTo: "plotBox", rtl: false, position: { align: "left", verticalAlign: "top", x: 0, y: void 0 }, separator: { text: "/", style: { color: "#666666", fontSize: "0.8em" } }, showFullPath: true, style: {}, useHTML: false, zIndex: 7 } };
      }), i(e, "Extensions/Breadcrumbs/Breadcrumbs.js", [e["Extensions/Breadcrumbs/BreadcrumbsDefaults.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s) {
        let { format: r } = e2, { composed: o } = i2, { addEvent: l, defined: a, extend: n, fireEvent: h, isString: d, merge: p, objectEach: u, pick: c, pushUnique: g } = s;
        function b() {
          if (this.breadcrumbs) {
            let t3 = this.resetZoomButton && this.resetZoomButton.getBBox(), e3 = this.breadcrumbs.options;
            t3 && "right" === e3.position.align && "plotBox" === e3.relativeTo && this.breadcrumbs.alignBreadcrumbsGroup(-t3.width - e3.buttonSpacing);
          }
        }
        function f() {
          this.breadcrumbs && (this.breadcrumbs.destroy(), this.breadcrumbs = void 0);
        }
        function v() {
          let t3 = this.breadcrumbs;
          if (t3 && !t3.options.floating && t3.level) {
            let e3 = t3.options, i3 = e3.buttonTheme, s2 = (i3.height || 0) + 2 * (i3.padding || 0) + e3.buttonSpacing, r2 = e3.position.verticalAlign;
            "bottom" === r2 ? (this.marginBottom = (this.marginBottom || 0) + s2, t3.yOffset = s2) : "middle" !== r2 ? (this.plotTop += s2, t3.yOffset = -s2) : t3.yOffset = void 0;
          }
        }
        function m() {
          this.breadcrumbs && this.breadcrumbs.redraw();
        }
        function y(t3) {
          true === t3.resetSelection && this.breadcrumbs && this.breadcrumbs.alignBreadcrumbsGroup();
        }
        class x {
          static compose(e3, i3) {
            g(o, "Breadcrumbs") && (l(e3, "destroy", f), l(e3, "afterShowResetZoom", b), l(e3, "getMargins", v), l(e3, "redraw", m), l(e3, "selection", y), n(i3.lang, t2.lang));
          }
          constructor(t3, e3) {
            this.elementList = {}, this.isDirty = true, this.level = 0, this.list = [];
            let i3 = p(t3.options.drilldown && t3.options.drilldown.drillUpButton, x.defaultOptions, t3.options.navigation && t3.options.navigation.breadcrumbs, e3);
            this.chart = t3, this.options = i3 || {};
          }
          updateProperties(t3) {
            this.setList(t3), this.setLevel(), this.isDirty = true;
          }
          setList(t3) {
            this.list = t3;
          }
          setLevel() {
            this.level = this.list.length && this.list.length - 1;
          }
          getLevel() {
            return this.level;
          }
          getButtonText(t3) {
            let e3 = this.chart, i3 = this.options, s2 = e3.options.lang, o2 = c(i3.format, i3.showFullPath ? "{level.name}" : "← {level.name}"), l2 = s2 && c(s2.drillUpText, s2.mainBreadcrumb), n2 = i3.formatter && i3.formatter(t3) || r(o2, { level: t3.levelOptions }, e3) || "";
            return (d(n2) && !n2.length || "← " === n2) && a(l2) && (n2 = i3.showFullPath ? l2 : "← " + l2), n2;
          }
          redraw() {
            this.isDirty && this.render(), this.group && this.group.align(), this.isDirty = false;
          }
          render() {
            let t3 = this.chart, e3 = this.options;
            !this.group && e3 && (this.group = t3.renderer.g("breadcrumbs-group").addClass("highcharts-no-tooltip highcharts-breadcrumbs").attr({ zIndex: e3.zIndex }).add()), e3.showFullPath ? this.renderFullPathButtons() : this.renderSingleButton(), this.alignBreadcrumbsGroup();
          }
          renderFullPathButtons() {
            this.destroySingleButton(), this.resetElementListState(), this.updateListElements(), this.destroyListElements();
          }
          renderSingleButton() {
            let t3 = this.chart, e3 = this.list, i3 = this.options.buttonSpacing;
            this.destroyListElements();
            let s2 = this.group ? this.group.getBBox().width : i3, r2 = e3[e3.length - 2];
            !t3.drillUpButton && this.level > 0 ? t3.drillUpButton = this.renderButton(r2, s2, i3) : t3.drillUpButton && (this.level > 0 ? this.updateSingleButton() : this.destroySingleButton());
          }
          alignBreadcrumbsGroup(t3) {
            if (this.group) {
              let e3 = this.options, i3 = e3.buttonTheme, s2 = e3.position, r2 = "chart" === e3.relativeTo || "spacingBox" === e3.relativeTo ? void 0 : "plotBox", o2 = this.group.getBBox(), l2 = 2 * (i3.padding || 0) + e3.buttonSpacing;
              s2.width = o2.width + l2, s2.height = o2.height + l2;
              let a2 = p(s2);
              t3 && (a2.x += t3), this.options.rtl && (a2.x += s2.width), a2.y = c(a2.y, this.yOffset, 0), this.group.align(a2, true, r2);
            }
          }
          renderButton(t3, e3, i3) {
            let s2 = this, r2 = this.chart, o2 = s2.options, l2 = p(o2.buttonTheme), a2 = r2.renderer.button(s2.getButtonText(t3), e3, i3, function(e4) {
              let i4;
              let r3 = o2.events && o2.events.click;
              r3 && (i4 = r3.call(s2, e4, t3)), false !== i4 && (o2.showFullPath ? e4.newLevel = t3.level : e4.newLevel = s2.level - 1, h(s2, "up", e4));
            }, l2).addClass("highcharts-breadcrumbs-button").add(s2.group);
            return r2.styledMode || a2.attr(o2.style), a2;
          }
          renderSeparator(t3, e3) {
            let i3 = this.chart, s2 = this.options.separator, r2 = i3.renderer.label(s2.text, t3, e3, void 0, void 0, void 0, false).addClass("highcharts-breadcrumbs-separator").add(this.group);
            return i3.styledMode || r2.css(s2.style), r2;
          }
          update(t3) {
            p(true, this.options, t3), this.destroy(), this.isDirty = true;
          }
          updateSingleButton() {
            let t3 = this.chart, e3 = this.list[this.level - 1];
            t3.drillUpButton && t3.drillUpButton.attr({ text: this.getButtonText(e3) });
          }
          destroy() {
            this.destroySingleButton(), this.destroyListElements(true), this.group && this.group.destroy(), this.group = void 0;
          }
          destroyListElements(t3) {
            let e3 = this.elementList;
            u(e3, (i3, s2) => {
              (t3 || !e3[s2].updated) && ((i3 = e3[s2]).button && i3.button.destroy(), i3.separator && i3.separator.destroy(), delete i3.button, delete i3.separator, delete e3[s2]);
            }), t3 && (this.elementList = {});
          }
          destroySingleButton() {
            this.chart.drillUpButton && (this.chart.drillUpButton.destroy(), this.chart.drillUpButton = void 0);
          }
          resetElementListState() {
            u(this.elementList, (t3) => {
              t3.updated = false;
            });
          }
          updateListElements() {
            let t3 = this.elementList, e3 = this.options.buttonSpacing, i3 = this.list, s2 = this.options.rtl, r2 = s2 ? -1 : 1, o2 = function(t4, e4) {
              return r2 * t4.getBBox().width + r2 * e4;
            }, l2 = function(t4, e4, i4) {
              t4.translate(e4 - t4.getBBox().width, i4);
            }, a2 = this.group ? o2(this.group, e3) : e3, n2, h2;
            for (let d2 = 0, p2 = i3.length; d2 < p2; ++d2) {
              let u2, c2;
              let g2 = d2 === p2 - 1;
              t3[(h2 = i3[d2]).level] ? (u2 = (n2 = t3[h2.level]).button, n2.separator || g2 ? n2.separator && g2 && (n2.separator.destroy(), delete n2.separator) : (a2 += r2 * e3, n2.separator = this.renderSeparator(a2, e3), s2 && l2(n2.separator, a2, e3), a2 += o2(n2.separator, e3)), t3[h2.level].updated = true) : (u2 = this.renderButton(h2, a2, e3), s2 && l2(u2, a2, e3), a2 += o2(u2, e3), g2 || (c2 = this.renderSeparator(a2, e3), s2 && l2(c2, a2, e3), a2 += o2(c2, e3)), t3[h2.level] = { button: u2, separator: c2, updated: true }), u2 && u2.setState(g2 ? 2 : 0);
            }
          }
        }
        return x.defaultOptions = t2.options, x;
      }), i(e, "Series/ColorMapComposition.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        var s;
        let { column: { prototype: r } } = t2.seriesTypes, { addEvent: o, defined: l } = i2;
        return function(t3) {
          function i3(t4) {
            let i4 = this.series, s2 = i4.chart.renderer;
            this.moveToTopOnHover && this.graphic && (i4.stateMarkerGraphic || (i4.stateMarkerGraphic = new e2(s2, "use").css({ pointerEvents: "none" }).add(this.graphic.parentGroup)), (t4 == null ? void 0 : t4.state) === "hover" ? (this.graphic.attr({ id: this.id }), i4.stateMarkerGraphic.attr({ href: `${s2.url}#${this.id}`, visibility: "visible" })) : i4.stateMarkerGraphic.attr({ href: "" }));
          }
          t3.pointMembers = { dataLabelOnNull: true, moveToTopOnHover: true, isValid: function() {
            return null !== this.value && this.value !== 1 / 0 && this.value !== -1 / 0 && (void 0 === this.value || !isNaN(this.value));
          } }, t3.seriesMembers = { colorKey: "value", axisTypes: ["xAxis", "yAxis", "colorAxis"], parallelArrays: ["x", "y", "value"], pointArrayMap: ["value"], trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], colorAttribs: function(t4) {
            let e3 = {};
            return l(t4.color) && (!t4.state || "normal" === t4.state) && (e3[this.colorProp || "fill"] = t4.color), e3;
          }, pointAttribs: r.pointAttribs }, t3.compose = function(t4) {
            return o(t4.prototype.pointClass, "afterSetState", i3), t4;
          };
        }(s || (s = {})), s;
      }), i(e, "Series/Treemap/TreemapAlgorithmGroup.js", [], function() {
        return class {
          constructor(t2, e2, i2, s) {
            this.height = t2, this.width = e2, this.plot = s, this.direction = i2, this.startDirection = i2, this.total = 0, this.nW = 0, this.lW = 0, this.nH = 0, this.lH = 0, this.elArr = [], this.lP = { total: 0, lH: 0, nH: 0, lW: 0, nW: 0, nR: 0, lR: 0, aspectRatio: function(t3, e3) {
              return Math.max(t3 / e3, e3 / t3);
            } };
          }
          addElement(t2) {
            this.lP.total = this.elArr[this.elArr.length - 1], this.total = this.total + t2, 0 === this.direction ? (this.lW = this.nW, this.lP.lH = this.lP.total / this.lW, this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH), this.nW = this.total / this.height, this.lP.nH = this.lP.total / this.nW, this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH)) : (this.lH = this.nH, this.lP.lW = this.lP.total / this.lH, this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH), this.nH = this.total / this.width, this.lP.nW = this.lP.total / this.nH, this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH)), this.elArr.push(t2);
          }
          reset() {
            this.nW = 0, this.lW = 0, this.elArr = [], this.total = 0;
          }
        };
      }), i(e, "Series/Treemap/TreemapNode.js", [], function() {
        return class {
          constructor() {
            this.childrenTotal = 0, this.visible = false;
          }
          init(t2, e2, i2, s, r, o, l) {
            return this.id = t2, this.i = e2, this.children = i2, this.height = s, this.level = r, this.series = o, this.parent = l, this;
          }
        };
      }), i(e, "Series/DrawPointUtilities.js", [], function() {
        return { draw: function(t2, e2) {
          let { animatableAttribs: i2, onComplete: s, css: r, renderer: o } = e2, l = t2.series && t2.series.chart.hasRendered ? void 0 : t2.series && t2.series.options.animation, a = t2.graphic;
          if (e2.attribs = { ...e2.attribs, class: t2.getClassName() }, t2.shouldDraw()) a || (a = "text" === e2.shapeType ? o.text() : "image" === e2.shapeType ? o.image(e2.imageUrl || "").attr(e2.shapeArgs || {}) : o[e2.shapeType](e2.shapeArgs || {}), t2.graphic = a, a.add(e2.group)), r && a.css(r), a.attr(e2.attribs).animate(i2, !e2.isNew && l, s);
          else if (a) {
            let e3 = () => {
              t2.graphic = a = a && a.destroy(), "function" == typeof s && s();
            };
            Object.keys(i2).length ? a.animate(i2, void 0, () => e3()) : e3();
          }
        } };
      }), i(e, "Series/Treemap/TreemapPoint.js", [e["Series/DrawPointUtilities.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2, i2) {
        let { pie: { prototype: { pointClass: s } }, scatter: { prototype: { pointClass: r } } } = e2.seriesTypes, { extend: o, isNumber: l, pick: a } = i2;
        class n extends r {
          constructor() {
            super(...arguments), this.shapeType = "rect";
          }
          draw(e3) {
            t2.draw(this, e3);
          }
          getClassName() {
            let t3 = this.series, e3 = t3.options, i3 = super.getClassName();
            return this.node.level <= t3.nodeMap[t3.rootNode].level && this.node.children.length ? i3 += " highcharts-above-level" : this.node.isLeaf || a(e3.interactByLeaf, !e3.allowTraversingTree) ? this.node.isLeaf || (i3 += " highcharts-internal-node") : i3 += " highcharts-internal-node-interactive", i3;
          }
          isValid() {
            return !!(this.id || l(this.value));
          }
          setState(t3) {
            super.setState.apply(this, arguments), this.graphic && this.graphic.attr({ zIndex: "hover" === t3 ? 1 : 0 });
          }
          shouldDraw() {
            return l(this.plotY) && null !== this.y;
          }
        }
        return o(n.prototype, { setVisible: s.prototype.setVisible }), n;
      }), i(e, "Series/Treemap/TreemapSeriesDefaults.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { isString: i2 } = e2;
        return { allowTraversingTree: false, animationLimit: 250, borderRadius: 0, showInLegend: false, marker: void 0, colorByPoint: false, dataLabels: { defer: false, enabled: true, formatter: function() {
          let t3 = this && this.point ? this.point : {};
          return i2(t3.name) ? t3.name : "";
        }, inside: true, verticalAlign: "middle" }, tooltip: { headerFormat: "", pointFormat: "<b>{point.name}</b>: {point.value}<br/>" }, ignoreHiddenPoint: true, layoutAlgorithm: "sliceAndDice", layoutStartingDirection: "vertical", alternateStartingDirection: false, levelIsConstant: true, traverseUpButton: { position: { align: "right", x: -10, y: 10 } }, borderColor: "#e6e6e6", borderWidth: 1, colorKey: "colorValue", opacity: 0.15, states: { hover: { borderColor: "#999999", brightness: t2.seriesTypes.heatmap ? 0 : 0.1, halo: false, opacity: 0.75, shadow: false } }, legendSymbol: "rectangle", traverseToLeaf: false };
      }), i(e, "Series/Treemap/TreemapUtilities.js", [], function() {
        var t2;
        return (t2 || (t2 = {})).recursive = function t3(e2, i2, s) {
          let r = i2.call(s || this, e2);
          false !== r && t3(r, i2, s);
        }, t2;
      }), i(e, "Series/TreeUtilities.js", [e["Core/Color/Color.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { extend: i2, isArray: s, isNumber: r, isObject: o, merge: l, pick: a, relativeLength: n } = e2;
        return { getColor: function(e3, i3) {
          let s2, r2, o2, l2, n2, h;
          let d = i3.index, p = i3.mapOptionsToLevel, u = i3.parentColor, c = i3.parentColorIndex, g = i3.series, b = i3.colors, f = i3.siblings, v = g.points, m = g.chart.options.chart;
          return e3 && (s2 = v[e3.i], r2 = p[e3.level] || {}, s2 && r2.colorByPoint && (l2 = s2.index % (b ? b.length : m.colorCount), o2 = b && b[l2]), g.chart.styledMode || (n2 = a(s2 && s2.options.color, r2 && r2.color, o2, u && ((e4) => {
            let i4 = r2 && r2.colorVariation;
            return i4 && "brightness" === i4.key && d && f ? t2.parse(e4).brighten(i4.to * (d / f)).get() : e4;
          })(u), g.color)), h = a(s2 && s2.options.colorIndex, r2 && r2.colorIndex, l2, c, i3.colorIndex)), { color: n2, colorIndex: h };
        }, getLevelOptions: function(t3) {
          let e3, i3, n2, h, d, p;
          let u = {};
          if (o(t3)) for (h = r(t3.from) ? t3.from : 1, p = t3.levels, i3 = {}, e3 = o(t3.defaults) ? t3.defaults : {}, s(p) && (i3 = p.reduce((t4, i4) => {
            let s2, n3, d2;
            return o(i4) && r(i4.level) && (n3 = a((d2 = l({}, i4)).levelIsConstant, e3.levelIsConstant), delete d2.levelIsConstant, delete d2.level, o(t4[s2 = i4.level + (n3 ? 0 : h - 1)]) ? l(true, t4[s2], d2) : t4[s2] = d2), t4;
          }, {})), d = r(t3.to) ? t3.to : 1, n2 = 0; n2 <= d; n2++) u[n2] = l({}, e3, o(i3[n2]) ? i3[n2] : {});
          return u;
        }, getNodeWidth: function(t3, e3) {
          let { chart: i3, options: s2 } = t3, { nodeDistance: r2 = 0, nodeWidth: o2 = 0 } = s2, { plotSizeX: l2 = 1 } = i3;
          if ("auto" === o2) {
            if ("string" == typeof r2 && /%$/.test(r2)) return l2 / (e3 + parseFloat(r2) / 100 * (e3 - 1));
            let t4 = Number(r2);
            return (l2 + t4) / (e3 || 1) - t4;
          }
          return n(o2, l2);
        }, setTreeValues: function t3(e3, s2) {
          let r2 = s2.before, o2 = s2.idRoot, l2 = s2.mapIdToNode[o2], n2 = false !== s2.levelIsConstant, h = s2.points[e3.i], d = h && h.options || {}, p = [], u = 0;
          e3.levelDynamic = e3.level - (n2 ? 0 : l2.level), e3.name = a(h && h.name, ""), e3.visible = o2 === e3.id || true === s2.visible, "function" == typeof r2 && (e3 = r2(e3, s2)), e3.children.forEach((r3, o3) => {
            let l3 = i2({}, s2);
            i2(l3, { index: o3, siblings: e3.children.length, visible: e3.visible }), r3 = t3(r3, l3), p.push(r3), r3.visible && (u += r3.val);
          });
          let c = a(d.value, u);
          return e3.visible = c >= 0 && (u > 0 || e3.visible), e3.children = p, e3.childrenTotal = u, e3.isLeaf = e3.visible && !u, e3.val = c, e3;
        }, updateRootId: function(t3) {
          let e3, i3;
          return o(t3) && (i3 = o(t3.options) ? t3.options : {}, e3 = a(t3.rootNode, i3.rootId, ""), o(t3.userOptions) && (t3.userOptions.rootId = e3), t3.rootNode = e3), e3;
        } };
      }), i(e, "Series/Treemap/TreemapSeries.js", [e["Extensions/Breadcrumbs/Breadcrumbs.js"], e["Core/Color/Color.js"], e["Series/ColorMapComposition.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Series/Treemap/TreemapAlgorithmGroup.js"], e["Series/Treemap/TreemapNode.js"], e["Series/Treemap/TreemapPoint.js"], e["Series/Treemap/TreemapSeriesDefaults.js"], e["Series/Treemap/TreemapUtilities.js"], e["Series/TreeUtilities.js"], e["Core/Utilities.js"]], function(t2, e2, i2, s, r, o, l, a, n, h, d, p) {
        let { parse: u } = e2, { composed: c, noop: g } = s, { column: b, scatter: f } = r.seriesTypes, { getColor: v, getLevelOptions: m, updateRootId: y } = d, { addEvent: x, correctFloat: T, crisp: S, defined: P, error: L, extend: w, fireEvent: C, isArray: A, isObject: R, isString: B, merge: M, pick: O, pushUnique: I, stableSort: j } = p, D = false;
        function N() {
          let t3;
          let e3 = this.xAxis, i3 = this.yAxis;
          e3 && i3 && (this.is("treemap") ? (t3 = { endOnTick: false, gridLineWidth: 0, lineWidth: 0, min: 0, minPadding: 0, max: 100, maxPadding: 0, startOnTick: false, title: void 0, tickPositions: [] }, w(i3.options, t3), w(e3.options, t3), D = true) : D && (i3.setOptions(i3.userOptions), e3.setOptions(e3.userOptions), D = false));
        }
        class U extends f {
          static compose(t3) {
            I(c, "TreemapSeries") && x(t3, "afterBindAxes", N);
          }
          algorithmCalcPoints(t3, e3, i3, s2) {
            let r2 = i3.plot, o2 = i3.elArr.length - 1, l2, a2, n2, h2, d2 = i3.lW, p2 = i3.lH, u2, c2 = 0;
            for (let t4 of (e3 ? (d2 = i3.nW, p2 = i3.nH) : u2 = i3.elArr[o2], i3.elArr)) (e3 || c2 < o2) && (0 === i3.direction ? (l2 = r2.x, a2 = r2.y, h2 = t4 / (n2 = d2)) : (l2 = r2.x, a2 = r2.y, n2 = t4 / (h2 = p2)), s2.push({ x: l2, y: a2, width: n2, height: T(h2) }), 0 === i3.direction ? r2.y = r2.y + h2 : r2.x = r2.x + n2), c2 += 1;
            i3.reset(), 0 === i3.direction ? i3.width = i3.width - d2 : i3.height = i3.height - p2, r2.y = r2.parent.y + (r2.parent.height - i3.height), r2.x = r2.parent.x + (r2.parent.width - i3.width), t3 && (i3.direction = 1 - i3.direction), e3 || i3.addElement(u2);
          }
          algorithmFill(t3, e3, i3) {
            let s2 = [], r2, o2 = e3.direction, l2 = e3.x, a2 = e3.y, n2 = e3.width, h2 = e3.height, d2, p2, u2, c2;
            for (let g2 of i3) r2 = e3.width * e3.height * (g2.val / e3.val), d2 = l2, p2 = a2, 0 === o2 ? (n2 -= u2 = r2 / (c2 = h2), l2 += u2) : (h2 -= c2 = r2 / (u2 = n2), a2 += c2), s2.push({ x: d2, y: p2, width: u2, height: c2 }), t3 && (o2 = 1 - o2);
            return s2;
          }
          algorithmLowAspectRatio(t3, e3, i3) {
            let s2 = [], r2 = { x: e3.x, y: e3.y, parent: e3 }, l2 = e3.direction, a2 = i3.length - 1, n2 = new o(e3.height, e3.width, l2, r2), h2, d2 = 0;
            for (let o2 of i3) h2 = e3.width * e3.height * (o2.val / e3.val), n2.addElement(h2), n2.lP.nR > n2.lP.lR && this.algorithmCalcPoints(t3, false, n2, s2, r2), d2 === a2 && this.algorithmCalcPoints(t3, true, n2, s2, r2), ++d2;
            return s2;
          }
          alignDataLabel(t3, e3, i3) {
            let s2 = i3.style;
            s2 && !P(s2.textOverflow) && e3.text && e3.getBBox().width > (e3.text.textWidth || 0) && e3.css({ textOverflow: "ellipsis", width: s2.width += "px" }), b.prototype.alignDataLabel.apply(this, arguments), t3.dataLabel && t3.dataLabel.attr({ zIndex: (t3.node.zIndex || 0) + 1 });
          }
          calculateChildrenAreas(t3, e3) {
            let i3 = this.options, s2 = this.mapOptionsToLevel[t3.level + 1], r2 = O(this[s2 && s2.layoutAlgorithm] && s2.layoutAlgorithm, i3.layoutAlgorithm), o2 = i3.alternateStartingDirection, l2 = t3.children.filter((t4) => !t4.ignore), a2 = [];
            s2 && s2.layoutStartingDirection && (e3.direction = "vertical" === s2.layoutStartingDirection ? 0 : 1), a2 = this[r2](e3, l2);
            let n2 = -1;
            for (let t4 of l2) {
              let i4 = a2[++n2];
              t4.values = M(i4, { val: t4.childrenTotal, direction: o2 ? 1 - e3.direction : e3.direction }), t4.pointValues = M(i4, { x: i4.x / this.axisRatio, y: 100 - i4.y - i4.height, width: i4.width / this.axisRatio }), t4.children.length && this.calculateChildrenAreas(t4, t4.values);
            }
          }
          createList(t3) {
            let e3 = this.chart, i3 = e3.breadcrumbs, s2 = [];
            if (i3) {
              let i4 = 0;
              s2.push({ level: i4, levelOptions: e3.series[0] });
              let r2 = t3.target.nodeMap[t3.newRootId], o2 = [];
              for (; r2.parent || "" === r2.parent; ) o2.push(r2), r2 = t3.target.nodeMap[r2.parent];
              for (let t4 of o2.reverse()) s2.push({ level: ++i4, levelOptions: t4 });
              s2.length <= 1 && (s2.length = 0);
            }
            return s2;
          }
          drawDataLabels() {
            let t3, e3;
            let i3 = this.mapOptionsToLevel;
            for (let s2 of this.points.filter(function(t4) {
              return t4.node.visible;
            })) e3 = i3[s2.node.level], t3 = { style: {} }, s2.node.isLeaf || (t3.enabled = false), e3 && e3.dataLabels && (t3 = M(t3, e3.dataLabels), this.hasDataLabels = () => true), s2.shapeArgs && (t3.style.width = s2.shapeArgs.width, s2.dataLabel && s2.dataLabel.css({ width: s2.shapeArgs.width + "px" })), s2.dlOptions = M(t3, s2.options.dataLabels);
            super.drawDataLabels();
          }
          drawPoints(t3 = this.points) {
            let e3 = this.chart, i3 = e3.renderer, s2 = e3.styledMode, r2 = this.options, o2 = s2 ? {} : r2.shadow, l2 = r2.borderRadius, a2 = e3.pointCount < r2.animationLimit, n2 = r2.allowTraversingTree;
            for (let e4 of t3) {
              let t4 = e4.node.levelDynamic, h2 = {}, d2 = {}, p2 = {}, u2 = "level-group-" + e4.node.level, c2 = !!e4.graphic, g2 = a2 && c2, b2 = e4.shapeArgs;
              e4.shouldDraw() && (e4.isInside = true, l2 && (d2.r = l2), M(true, g2 ? h2 : d2, c2 ? b2 : {}, s2 ? {} : this.pointAttribs(e4, e4.selected ? "select" : void 0)), this.colorAttribs && s2 && w(p2, this.colorAttribs(e4)), this[u2] || (this[u2] = i3.g(u2).attr({ zIndex: 1e3 - (t4 || 0) }).add(this.group), this[u2].survive = true)), e4.draw({ animatableAttribs: h2, attribs: d2, css: p2, group: this[u2], imageUrl: e4.imageUrl, renderer: i3, shadow: o2, shapeArgs: b2, shapeType: e4.shapeType }), n2 && e4.graphic && (e4.drillId = r2.interactByLeaf ? this.drillToByLeaf(e4) : this.drillToByGroup(e4));
            }
          }
          drillToByGroup(t3) {
            let e3 = false;
            return t3.node.isLeaf || t3.node.level - this.nodeMap[this.rootNode].level != 1 || (e3 = t3.id), e3;
          }
          drillToByLeaf(t3) {
            let { traverseToLeaf: e3 } = t3.series.options, i3 = false, s2;
            if (t3.node.parent !== this.rootNode && t3.node.isLeaf) {
              if (e3) i3 = t3.id;
              else for (s2 = t3.node; !i3; ) void 0 !== s2.parent && (s2 = this.nodeMap[s2.parent]), s2.parent === this.rootNode && (i3 = s2.id);
            }
            return i3;
          }
          drillToNode(t3, e3) {
            L(32, false, void 0, { "treemap.drillToNode": "use treemap.setRootNode" }), this.setRootNode(t3, e3);
          }
          drillUp() {
            let t3 = this.nodeMap[this.rootNode];
            t3 && B(t3.parent) && this.setRootNode(t3.parent, true, { trigger: "traverseUpButton" });
          }
          getExtremes() {
            let { dataMin: t3, dataMax: e3 } = super.getExtremes(this.colorValueData);
            return this.valueMin = t3, this.valueMax = e3, super.getExtremes();
          }
          getListOfParents(t3, e3) {
            let i3 = A(t3) ? t3 : [], s2 = A(e3) ? e3 : [], r2 = i3.reduce(function(t4, e4, i4) {
              let s3 = O(e4.parent, "");
              return void 0 === t4[s3] && (t4[s3] = []), t4[s3].push(i4), t4;
            }, { "": [] });
            for (let t4 of Object.keys(r2)) {
              let e4 = r2[t4];
              if ("" !== t4 && -1 === s2.indexOf(t4)) {
                for (let t5 of e4) r2[""].push(t5);
                delete r2[t4];
              }
            }
            return r2;
          }
          getTree() {
            let t3 = this.data.map(function(t4) {
              return t4.id;
            }), e3 = this.getListOfParents(this.data, t3);
            return this.nodeMap = {}, this.nodeList = [], this.buildTree("", -1, 0, e3);
          }
          buildTree(t3, e3, i3, s2, r2) {
            let o2 = [], l2 = this.points[e3], a2 = 0, n2;
            for (let e4 of s2[t3] || []) a2 = Math.max((n2 = this.buildTree(this.points[e4].id, e4, i3 + 1, s2, t3)).height + 1, a2), o2.push(n2);
            let h2 = new this.NodeClass().init(t3, e3, o2, a2, i3, this, r2);
            for (let t4 of o2) t4.parentNode = h2;
            return this.nodeMap[h2.id] = h2, this.nodeList.push(h2), l2 && (l2.node = h2, h2.point = l2), h2;
          }
          hasData() {
            return !!this.processedXData.length;
          }
          init(e3, i3) {
            let s2 = this, r2 = M(i3.drillUpButton, i3.breadcrumbs), o2 = x(s2, "setOptions", (t3) => {
              let e4 = t3.userOptions;
              P(e4.allowDrillToNode) && !P(e4.allowTraversingTree) && (e4.allowTraversingTree = e4.allowDrillToNode, delete e4.allowDrillToNode), P(e4.drillUpButton) && !P(e4.traverseUpButton) && (e4.traverseUpButton = e4.drillUpButton, delete e4.drillUpButton);
            });
            super.init(e3, i3), delete s2.opacity, s2.eventsToUnbind.push(o2), s2.options.allowTraversingTree && (s2.eventsToUnbind.push(x(s2, "click", s2.onClickDrillToNode)), s2.eventsToUnbind.push(x(s2, "setRootNode", function(t3) {
              let e4 = s2.chart;
              e4.breadcrumbs && e4.breadcrumbs.updateProperties(s2.createList(t3));
            })), s2.eventsToUnbind.push(x(s2, "update", function(t3, e4) {
              let i4 = this.chart.breadcrumbs;
              i4 && t3.options.breadcrumbs && i4.update(t3.options.breadcrumbs);
            })), s2.eventsToUnbind.push(x(s2, "destroy", function(t3) {
              let e4 = this.chart;
              e4.breadcrumbs && !t3.keepEventsForUpdate && (e4.breadcrumbs.destroy(), e4.breadcrumbs = void 0);
            }))), e3.breadcrumbs || (e3.breadcrumbs = new t2(e3, r2)), s2.eventsToUnbind.push(x(e3.breadcrumbs, "up", function(t3) {
              let e4 = this.level - t3.newLevel;
              for (let t4 = 0; t4 < e4; t4++) s2.drillUp();
            }));
          }
          onClickDrillToNode(t3) {
            let e3 = t3.point, i3 = e3 && e3.drillId;
            B(i3) && (e3.setState(""), this.setRootNode(i3, true, { trigger: "click" }));
          }
          pointAttribs(t3, e3) {
            let i3;
            let s2 = R(this.mapOptionsToLevel) ? this.mapOptionsToLevel : {}, r2 = t3 && s2[t3.node.level] || {}, o2 = this.options, l2 = e3 && o2.states && o2.states[e3] || {}, a2 = t3 && t3.getClassName() || "", n2 = { stroke: t3 && t3.borderColor || r2.borderColor || l2.borderColor || o2.borderColor, "stroke-width": O(t3 && t3.borderWidth, r2.borderWidth, l2.borderWidth, o2.borderWidth), dashstyle: t3 && t3.borderDashStyle || r2.borderDashStyle || l2.borderDashStyle || o2.borderDashStyle, fill: t3 && t3.color || this.color };
            return -1 !== a2.indexOf("highcharts-above-level") ? (n2.fill = "none", n2["stroke-width"] = 0) : -1 !== a2.indexOf("highcharts-internal-node-interactive") ? (i3 = O(l2.opacity, o2.opacity), n2.fill = u(n2.fill).setOpacity(i3).get(), n2.cursor = "pointer") : -1 !== a2.indexOf("highcharts-internal-node") ? n2.fill = "none" : e3 && (n2.fill = u(n2.fill).brighten(l2.brightness).get()), n2;
          }
          setColorRecursive(t3, e3, i3, s2, r2) {
            let o2 = this && this.chart, l2 = o2 && o2.options && o2.options.colors;
            if (t3) {
              let o3 = v(t3, { colors: l2, index: s2, mapOptionsToLevel: this.mapOptionsToLevel, parentColor: e3, parentColorIndex: i3, series: this, siblings: r2 }), a2 = this.points[t3.i];
              a2 && (a2.color = o3.color, a2.colorIndex = o3.colorIndex);
              let n2 = -1;
              for (let e4 of t3.children || []) this.setColorRecursive(e4, o3.color, o3.colorIndex, ++n2, t3.children.length);
            }
          }
          setPointValues() {
            let t3 = this, { points: e3, xAxis: i3, yAxis: s2 } = t3, r2 = t3.chart.styledMode, o2 = (e4) => r2 ? 0 : t3.pointAttribs(e4)["stroke-width"] || 0;
            for (let t4 of e3) {
              let { pointValues: e4, visible: r3 } = t4.node;
              if (e4 && r3) {
                let { height: r4, width: l2, x: a2, y: n2 } = e4, h2 = o2(t4), d2 = S(i3.toPixels(a2, true), h2, true), p2 = S(i3.toPixels(a2 + l2, true), h2, true), u2 = S(s2.toPixels(n2, true), h2, true), c2 = S(s2.toPixels(n2 + r4, true), h2, true), g2 = { x: Math.min(d2, p2), y: Math.min(u2, c2), width: Math.abs(p2 - d2), height: Math.abs(c2 - u2) };
                t4.plotX = g2.x + g2.width / 2, t4.plotY = g2.y + g2.height / 2, t4.shapeArgs = g2;
              } else delete t4.plotX, delete t4.plotY;
            }
          }
          setRootNode(t3, e3, i3) {
            C(this, "setRootNode", w({ newRootId: t3, previousRootId: this.rootNode, redraw: O(e3, true), series: this }, i3), function(t4) {
              let e4 = t4.series;
              e4.idPreviousRoot = t4.previousRootId, e4.rootNode = t4.newRootId, e4.isDirty = true, t4.redraw && e4.chart.redraw();
            });
          }
          setState(t3) {
            this.options.inactiveOtherPoints = true, super.setState(t3, false), this.options.inactiveOtherPoints = false;
          }
          setTreeValues(t3) {
            let e3 = this.options, i3 = this.rootNode, s2 = this.nodeMap[i3], r2 = "boolean" != typeof e3.levelIsConstant || e3.levelIsConstant, o2 = [], l2 = this.points[t3.i], a2 = 0;
            for (let e4 of t3.children) e4 = this.setTreeValues(e4), o2.push(e4), e4.ignore || (a2 += e4.val);
            j(o2, (t4, e4) => (t4.sortIndex || 0) - (e4.sortIndex || 0));
            let n2 = O(l2 && l2.options.value, a2);
            return l2 && (l2.value = n2), w(t3, { children: o2, childrenTotal: a2, ignore: !(O(l2 && l2.visible, true) && n2 > 0), isLeaf: t3.visible && !a2, levelDynamic: t3.level - (r2 ? 0 : s2.level), name: O(l2 && l2.name, ""), sortIndex: O(l2 && l2.sortIndex, -n2), val: n2 }), t3;
          }
          sliceAndDice(t3, e3) {
            return this.algorithmFill(true, t3, e3);
          }
          squarified(t3, e3) {
            return this.algorithmLowAspectRatio(true, t3, e3);
          }
          strip(t3, e3) {
            return this.algorithmLowAspectRatio(false, t3, e3);
          }
          stripes(t3, e3) {
            return this.algorithmFill(false, t3, e3);
          }
          translate() {
            let t3 = this, e3 = t3.options, i3 = y(t3), s2, r2, o2, l2;
            super.translate();
            let a2 = t3.tree = t3.getTree();
            s2 = t3.nodeMap[i3], "" === i3 || s2 || (t3.setRootNode("", false), i3 = t3.rootNode, s2 = t3.nodeMap[i3]), t3.mapOptionsToLevel = m({ from: s2.level + 1, levels: e3.levels, to: a2.height, defaults: { levelIsConstant: t3.options.levelIsConstant, colorByPoint: e3.colorByPoint } }), h.recursive(t3.nodeMap[t3.rootNode], (e4) => {
              let i4 = e4.parent, s3 = false;
              return e4.visible = true, (i4 || "" === i4) && (s3 = t3.nodeMap[i4]), s3;
            }), h.recursive(t3.nodeMap[t3.rootNode].children, (t4) => {
              let e4 = false;
              for (let i4 of t4) i4.visible = true, i4.children.length && (e4 = (e4 || []).concat(i4.children));
              return e4;
            }), t3.setTreeValues(a2), t3.axisRatio = t3.xAxis.len / t3.yAxis.len, t3.nodeMap[""].pointValues = r2 = { x: 0, y: 0, width: 100, height: 100 }, t3.nodeMap[""].values = o2 = M(r2, { width: r2.width * t3.axisRatio, direction: "vertical" === e3.layoutStartingDirection ? 0 : 1, val: a2.val }), t3.calculateChildrenAreas(a2, o2), t3.colorAxis || e3.colorByPoint || t3.setColorRecursive(t3.tree), e3.allowTraversingTree && (l2 = s2.pointValues, t3.xAxis.setExtremes(l2.x, l2.x + l2.width, false), t3.yAxis.setExtremes(l2.y, l2.y + l2.height, false), t3.xAxis.setScale(), t3.yAxis.setScale()), t3.setPointValues();
          }
        }
        return U.defaultOptions = M(f.defaultOptions, n), w(U.prototype, { buildKDTree: g, colorAttribs: i2.seriesMembers.colorAttribs, colorKey: "colorValue", directTouch: true, getExtremesFromAll: true, getSymbol: g, optionalAxis: "colorAxis", parallelArrays: ["x", "y", "value", "colorValue"], pointArrayMap: ["value"], pointClass: a, NodeClass: l, trackerGroups: ["group", "dataLabelsGroup"], utils: h }), i2.compose(U), r.registerSeriesType("treemap", U), U;
      }), i(e, "Series/Sunburst/SunburstPoint.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { series: { prototype: { pointClass: i2 } }, seriesTypes: { treemap: { prototype: { pointClass: s } } } } = t2, { correctFloat: r, extend: o, pInt: l } = e2;
        class a extends s {
          getDataLabelPath(t3) {
            var _a2;
            let e3 = this.series.chart.renderer, i3 = this.shapeExisting, s2 = i3.r + l(((_a2 = t3.options) == null ? void 0 : _a2.distance) || 0), o2 = i3.start, a2 = i3.end, n = o2 + (a2 - o2) / 2, h = n < 0 && n > -Math.PI || n > Math.PI, d;
            return o2 === -Math.PI / 2 && r(a2) === r(1.5 * Math.PI) && (o2 = -Math.PI + Math.PI / 360, a2 = -Math.PI / 360, h = true), a2 - o2 > Math.PI && (h = false, d = true, a2 - o2 > 2 * Math.PI - 0.01 && (o2 += 0.01, a2 -= 0.01)), this.dataLabelPath && (this.dataLabelPath = this.dataLabelPath.destroy()), this.dataLabelPath = e3.arc({ open: true, longArc: d ? 1 : 0 }).attr({ start: h ? o2 : a2, end: h ? a2 : o2, clockwise: +h, x: i3.x, y: i3.y, r: (s2 + i3.innerR) / 2 }).add(e3.defs), this.dataLabelPath;
          }
          isValid() {
            return true;
          }
        }
        return o(a.prototype, { getClassName: i2.prototype.getClassName, haloPath: i2.prototype.haloPath, setState: i2.prototype.setState }), a;
      }), i(e, "Series/Sunburst/SunburstUtilities.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { seriesTypes: { treemap: i2 } } = t2, { isNumber: s, isObject: r, merge: o } = e2;
        function l(t3, e3) {
          let i3 = [];
          if (s(t3) && s(e3) && t3 <= e3) for (let s2 = t3; s2 <= e3; s2++) i3.push(s2);
          return i3;
        }
        return { calculateLevelSizes: function(t3, e3) {
          let i3 = r(e3) ? e3 : {}, a, n = 0, h, d, p, u;
          if (r(t3)) {
            for (let e4 of (a = o({}, t3), d = l(s(i3.from) ? i3.from : 0, s(i3.to) ? i3.to : 0), p = Object.keys(a).filter((t4) => -1 === d.indexOf(+t4)), h = u = s(i3.diffRadius) ? i3.diffRadius : 0, d)) {
              let t4 = a[e4], i4 = t4.levelSize.unit, s2 = t4.levelSize.value;
              "weight" === i4 ? n += s2 : "percentage" === i4 ? (t4.levelSize = { unit: "pixels", value: s2 / 100 * h }, u -= t4.levelSize.value) : "pixels" === i4 && (u -= s2);
            }
            for (let t4 of d) {
              let e4 = a[t4];
              if ("weight" === e4.levelSize.unit) {
                let i4 = e4.levelSize.value;
                a[t4].levelSize = { unit: "pixels", value: i4 / n * u };
              }
            }
            for (let t4 of p) a[t4].levelSize = { value: 0, unit: "pixels" };
          }
          return a;
        }, getLevelFromAndTo: function({ level: t3, height: e3 }) {
          return { from: t3 > 0 ? t3 : 1, to: t3 + e3 };
        }, range: l, recursive: i2.prototype.utils.recursive };
      }), i(e, "Series/Sunburst/SunburstNode.js", [e["Series/Treemap/TreemapNode.js"]], function(t2) {
        return class extends t2 {
        };
      }), i(e, "Series/Sunburst/SunburstSeriesDefaults.js", [], function() {
        return { center: ["50%", "50%"], clip: false, colorByPoint: false, opacity: 1, dataLabels: { allowOverlap: true, defer: true, rotationMode: "circular", style: { textOverflow: "ellipsis" } }, rootId: void 0, levelIsConstant: true, levelSize: { value: 1, unit: "weight" }, slicedOffset: 10 };
      }), i(e, "Extensions/TextPath.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { deg2rad: i2 } = t2, { addEvent: s, merge: r, uniqueKey: o, defined: l, extend: a } = e2;
        function n(t3, e3) {
          e3 = r(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, e3);
          let i3 = this.renderer.url, n2 = this.text || this, h2 = n2.textPath, { attributes: d2, enabled: p } = e3;
          if (t3 = t3 || h2 && h2.path, h2 && h2.undo(), t3 && p) {
            let e4 = s(n2, "afterModifyTree", (e5) => {
              if (t3 && p) {
                let s2 = t3.attr("id");
                s2 || t3.attr("id", s2 = o());
                let r2 = { x: 0, y: 0 };
                l(d2.dx) && (r2.dx = d2.dx, delete d2.dx), l(d2.dy) && (r2.dy = d2.dy, delete d2.dy), n2.attr(r2), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy());
                let h3 = e5.nodes.slice(0);
                e5.nodes.length = 0, e5.nodes[0] = { tagName: "textPath", attributes: a(d2, { "text-anchor": d2.textAnchor, href: `${i3}#${s2}` }), children: h3 };
              }
            });
            n2.textPath = { path: t3, undo: e4 };
          } else n2.attr({ dx: 0, dy: 0 }), delete n2.textPath;
          return this.added && (n2.textCache = "", this.renderer.buildText(n2)), this;
        }
        function h(t3) {
          var _a;
          let e3 = t3.bBox, s2 = (_a = this.element) == null ? void 0 : _a.querySelector("textPath");
          if (s2) {
            let t4 = [], { b: r2, h: o2 } = this.renderer.fontMetrics(this.element), l2 = o2 - r2, a2 = RegExp('(<tspan>|<tspan(?!\\sclass="highcharts-br")[^>]*>|<\\/tspan>)', "g"), n2 = s2.innerHTML.replace(a2, "").split(/<tspan class="highcharts-br"[^>]*>/), h2 = n2.length, d2 = (t5, e4) => {
              let { x: o3, y: a3 } = e4, n3 = (s2.getRotationOfChar(t5) - 90) * i2, h3 = Math.cos(n3), d3 = Math.sin(n3);
              return [[o3 - l2 * h3, a3 - l2 * d3], [o3 + r2 * h3, a3 + r2 * d3]];
            };
            for (let e4 = 0, i3 = 0; i3 < h2; i3++) {
              let r3 = n2[i3].length;
              for (let o3 = 0; o3 < r3; o3 += 5) try {
                let r4 = e4 + o3 + i3, [l3, a3] = d2(r4, s2.getStartPositionOfChar(r4));
                0 === o3 ? (t4.push(a3), t4.push(l3)) : (0 === i3 && t4.unshift(a3), i3 === h2 - 1 && t4.push(l3));
              } catch (t5) {
                break;
              }
              e4 += r3 - 1;
              try {
                let r4 = e4 + i3, o3 = s2.getEndPositionOfChar(r4), [l3, a3] = d2(r4, o3);
                t4.unshift(a3), t4.unshift(l3);
              } catch (t5) {
                break;
              }
            }
            t4.length && t4.push(t4[0].slice()), e3.polygon = t4;
          }
          return e3;
        }
        function d(t3) {
          var _a;
          let e3 = t3.labelOptions, i3 = t3.point, s2 = e3[i3.formatPrefix + "TextPath"] || e3.textPath;
          s2 && !e3.useHTML && (this.setTextPath(((_a = i3.getDataLabelPath) == null ? void 0 : _a.call(i3, this)) || i3.graphic, s2), i3.dataLabelPath && !s2.enabled && (i3.dataLabelPath = i3.dataLabelPath.destroy()));
        }
        return { compose: function(t3) {
          s(t3, "afterGetBBox", h), s(t3, "beforeAddingDataLabel", d);
          let e3 = t3.prototype;
          e3.setTextPath || (e3.setTextPath = n);
        } };
      }), i(e, "Series/Sunburst/SunburstSeries.js", [e["Series/CenteredUtilities.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Series/Sunburst/SunburstPoint.js"], e["Series/Sunburst/SunburstUtilities.js"], e["Series/TreeUtilities.js"], e["Core/Utilities.js"], e["Series/Sunburst/SunburstNode.js"], e["Series/Sunburst/SunburstSeriesDefaults.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Extensions/TextPath.js"]], function(t2, e2, i2, s, r, o, l, a, n, h, d) {
        let { getCenter: p, getStartAndEndRadians: u } = t2, { noop: c } = e2, { column: g, treemap: b } = i2.seriesTypes, { getColor: f, getLevelOptions: v, setTreeValues: m, updateRootId: y } = o, { defined: x, error: T, extend: S, fireEvent: P, isNumber: L, isObject: w, isString: C, merge: A, splat: R } = l;
        d.compose(h);
        let B = 180 / Math.PI, M = function(t3, e3, i3, s2) {
          return { x: t3 + Math.cos(i3) * s2, y: e3 + Math.sin(i3) * s2 };
        };
        function O(t3, e3) {
          let i3 = e3.mapIdToNode, s2 = t3.parent, r2 = s2 ? i3[s2] : void 0, o2 = e3.series, l2 = o2.chart, a2 = o2.points[t3.i], n2 = f(t3, { colors: o2.options.colors || l2 && l2.options.colors, colorIndex: o2.colorIndex, index: e3.index, mapOptionsToLevel: e3.mapOptionsToLevel, parentColor: r2 && r2.color, parentColorIndex: r2 && r2.colorIndex, series: e3.series, siblings: e3.siblings });
          return t3.color = n2.color, t3.colorIndex = n2.colorIndex, a2 && (a2.color = t3.color, a2.colorIndex = t3.colorIndex, t3.sliced = t3.id !== e3.idRoot && a2.sliced), t3;
        }
        class I extends b {
          alignDataLabel(t3, e3, i3) {
            if (!i3.textPath || !i3.textPath.enabled) return super.alignDataLabel.apply(this, arguments);
          }
          animate(t3) {
            let e3;
            let i3 = this.chart, s2 = [i3.plotWidth / 2, i3.plotHeight / 2], r2 = i3.plotLeft, o2 = i3.plotTop, l2 = this.group;
            t3 ? (e3 = { translateX: s2[0] + r2, translateY: s2[1] + o2, scaleX: 1e-3, scaleY: 1e-3, rotation: 10, opacity: 0.01 }, l2.attr(e3)) : (e3 = { translateX: r2, translateY: o2, scaleX: 1, scaleY: 1, rotation: 0, opacity: 1 }, l2.animate(e3, this.options.animation));
          }
          drawPoints() {
            let t3 = this, e3 = t3.mapOptionsToLevel, i3 = t3.shapeRoot, s2 = t3.group, r2 = t3.hasRendered, o2 = t3.rootNode, l2 = t3.idPreviousRoot, a2 = t3.nodeMap, n2 = a2[l2], h2 = n2 && n2.shapeArgs, d2 = t3.points, p2 = t3.startAndEndRadians, u2 = t3.chart, c2 = u2 && u2.options && u2.options.chart || {}, b2 = "boolean" != typeof c2.animation || c2.animation, f2 = t3.center, v2 = { x: f2[0], y: f2[1] }, m2 = f2[3] / 2, y2 = t3.chart.renderer, T2 = !!(b2 && r2 && o2 !== l2 && t3.dataLabelsGroup), P2, C2 = false, M2 = false;
            for (let n3 of (T2 && (t3.dataLabelsGroup.attr({ opacity: 0 }), P2 = function() {
              C2 = true, t3.dataLabelsGroup && t3.dataLabelsGroup.animate({ opacity: 1, visibility: "inherit" });
            }), d2)) {
              let d3, c3;
              let g2 = n3.node, f3 = e3[g2.level], T3 = n3.shapeExisting || {}, C3 = g2.shapeArgs || {}, O2 = !!(g2.visible && g2.shapeArgs);
              C3.borderRadius = t3.options.borderRadius, d3 = r2 && b2 ? function(t4, e4) {
                let i4 = e4.point, s3 = e4.radians, r3 = e4.innerR, o3 = e4.idRoot, l3 = e4.idPreviousRoot, a3 = e4.shapeExisting, n4 = e4.shapeRoot, h3 = e4.shapePreviousRoot, d4 = e4.visible, p3 = {}, u3 = { end: t4.end, start: t4.start, innerR: t4.innerR, r: t4.r, x: t4.x, y: t4.y };
                return d4 ? !i4.graphic && h3 && ((p3 = o3 === i4.id ? { start: s3.start, end: s3.end } : h3.end <= t4.start ? { start: s3.end, end: s3.end } : { start: s3.start, end: s3.start }).innerR = p3.r = r3) : i4.graphic && (l3 === i4.id ? u3 = { innerR: r3, r: r3 } : n4 && (u3 = n4.end <= a3.start ? { innerR: r3, r: r3, start: s3.end, end: s3.end } : { innerR: r3, r: r3, start: s3.start, end: s3.start })), { from: p3, to: u3 };
              }(C3, { center: v2, point: n3, radians: p2, innerR: m2, idRoot: o2, idPreviousRoot: l2, shapeExisting: T3, shapeRoot: i3, shapePreviousRoot: h2, visible: O2 }) : { to: C3, from: {} }, S(n3, { shapeExisting: C3, tooltipPos: [C3.plotX, C3.plotY], drillId: function(t4, e4, i4) {
                let s3;
                return t4.node.isLeaf || (s3 = e4 === t4.id ? i4[e4].parent : t4.id), s3;
              }(n3, o2, a2), name: "" + (n3.name || n3.id || n3.index), plotX: C3.plotX, plotY: C3.plotY, value: g2.val, isInside: O2, isNull: !O2 }), n3.dlOptions = function(t4) {
                let e4 = t4.point, i4 = w(t4.shapeArgs) ? t4.shapeArgs : {}, s3 = w(t4.optionsPoint) ? t4.optionsPoint.dataLabels : {}, r3 = A({ style: {} }, R(w(t4.level) ? t4.level.dataLabels : {})[0], s3), o3, l3, a3 = r3.rotationMode;
                return L(r3.rotation) || (("auto" === a3 || "circular" === a3) && (r3.useHTML && "circular" === a3 && (a3 = "auto"), e4.innerArcLength < 1 && e4.outerArcLength > i4.radius ? (o3 = 0, e4.dataLabelPath && "circular" === a3 && (r3.textPath = { enabled: true })) : e4.innerArcLength > 1 && e4.outerArcLength > 1.5 * i4.radius ? "circular" === a3 ? r3.textPath = { enabled: true, attributes: { dy: 5 } } : a3 = "parallel" : (e4.dataLabel && e4.dataLabel.textPath && "circular" === a3 && (r3.textPath = { enabled: false }), a3 = "perpendicular")), "auto" !== a3 && "circular" !== a3 && (e4.dataLabel && e4.dataLabel.textPath && (r3.textPath = { enabled: false }), o3 = i4.end - (i4.end - i4.start) / 2), "parallel" === a3 ? r3.style.width = Math.min(2.5 * i4.radius, (e4.outerArcLength + e4.innerArcLength) / 2) : !x(r3.style.width) && i4.radius && (r3.style.width = 1 === e4.node.level ? 2 * i4.radius : i4.radius), "perpendicular" === a3 && e4.outerArcLength < 16 && (r3.style.width = 1), r3.style.width = Math.max(r3.style.width - 2 * (r3.padding || 0), 1), l3 = o3 * B % 180, "parallel" === a3 && (l3 -= 90), l3 > 90 ? l3 -= 180 : l3 < -90 && (l3 += 180), r3.rotation = l3), r3.textPath && (0 === e4.shapeExisting.innerR && r3.textPath.enabled ? (r3.rotation = 0, r3.textPath.enabled = false, r3.style.width = Math.max(2 * e4.shapeExisting.r - 2 * (r3.padding || 0), 1)) : e4.dlOptions && e4.dlOptions.textPath && !e4.dlOptions.textPath.enabled && "circular" === a3 && (r3.textPath.enabled = true), r3.textPath.enabled && (r3.rotation = 0, r3.style.width = Math.max((e4.outerArcLength + e4.innerArcLength) / 2 - 2 * (r3.padding || 0), 1))), r3;
              }({ point: n3, level: f3, optionsPoint: n3.options, shapeArgs: C3 }), !M2 && O2 && (M2 = true, c3 = P2), n3.draw({ animatableAttribs: d3.to, attribs: S(d3.from, !u2.styledMode && t3.pointAttribs(n3, n3.selected && "select")), onComplete: c3, group: s2, renderer: y2, shapeType: "arc", shapeArgs: C3 });
            }
            T2 && M2 ? (t3.hasRendered = false, t3.options.dataLabels.defer = true, g.prototype.drawDataLabels.call(t3), t3.hasRendered = true, C2 && P2()) : g.prototype.drawDataLabels.call(t3), t3.idPreviousRoot = o2;
          }
          layoutAlgorithm(t3, e3, i3) {
            let s2 = t3.start, r2 = t3.end - s2, o2 = t3.val, l2 = t3.x, a2 = t3.y, n2 = i3 && w(i3.levelSize) && L(i3.levelSize.value) ? i3.levelSize.value : 0, h2 = t3.r, d2 = h2 + n2, p2 = i3 && L(i3.slicedOffset) ? i3.slicedOffset : 0;
            return (e3 || []).reduce((t4, e4) => {
              let i4 = 1 / o2 * e4.val * r2, u2 = M(l2, a2, s2 + i4 / 2, p2), c2 = { x: e4.sliced ? u2.x : l2, y: e4.sliced ? u2.y : a2, innerR: h2, r: d2, radius: n2, start: s2, end: s2 + i4 };
              return t4.push(c2), s2 = c2.end, t4;
            }, []);
          }
          setRootNode(t3, e3, i3) {
            if (1 === this.nodeMap[t3].level && 1 === this.nodeList.filter((t4) => 1 === t4.level).length) {
              if ("" === this.idPreviousRoot) return;
              t3 = "";
            }
            super.setRootNode(t3, e3, i3);
          }
          setShapeArgs(t3, e3, i3) {
            let s2 = i3[t3.level + 1], r2 = t3.children.filter(function(t4) {
              return t4.visible;
            }), o2 = [];
            o2 = this.layoutAlgorithm(e3, r2, s2);
            let l2 = -1;
            for (let t4 of r2) {
              let e4 = o2[++l2], s3 = e4.start + (e4.end - e4.start) / 2, r3 = e4.innerR + (e4.r - e4.innerR) / 2, a2 = e4.end - e4.start, n2 = 0 === e4.innerR && a2 > 6.28 ? { x: e4.x, y: e4.y } : M(e4.x, e4.y, s3, r3), h2 = t4.val ? t4.childrenTotal > t4.val ? t4.childrenTotal : t4.val : t4.childrenTotal;
              this.points[t4.i] && (this.points[t4.i].innerArcLength = a2 * e4.innerR, this.points[t4.i].outerArcLength = a2 * e4.r), t4.shapeArgs = A(e4, { plotX: n2.x, plotY: n2.y }), t4.values = A(e4, { val: h2 }), t4.children.length && this.setShapeArgs(t4, t4.values, i3);
            }
          }
          translate() {
            let t3 = this.options, e3 = this.center = this.getCenter(), i3 = this.startAndEndRadians = u(t3.startAngle, t3.endAngle), s2 = e3[3] / 2, o2 = e3[2] / 2, l2 = y(this), a2 = this.nodeMap, n2, h2 = a2 && a2[l2], d2 = {};
            this.shapeRoot = h2 && h2.shapeArgs, this.processedXData || this.processData(), this.generatePoints(), P(this, "afterTranslate");
            let p2 = this.tree = this.getTree(), c2 = C((h2 = (a2 = this.nodeMap)[l2]).parent) ? h2.parent : "", g2 = a2[c2], { from: b2, to: f2 } = r.getLevelFromAndTo(h2);
            n2 = v({ from: b2, levels: this.options.levels, to: f2, defaults: { colorByPoint: t3.colorByPoint, dataLabels: t3.dataLabels, levelIsConstant: t3.levelIsConstant, levelSize: t3.levelSize, slicedOffset: t3.slicedOffset } }), n2 = r.calculateLevelSizes(n2, { diffRadius: o2 - s2, from: b2, to: f2 }), m(p2, { before: O, idRoot: l2, levelIsConstant: t3.levelIsConstant, mapOptionsToLevel: n2, mapIdToNode: a2, points: this.points, series: this });
            let x2 = a2[""].shapeArgs = { end: i3.end, r: s2, start: i3.start, val: h2.val, x: e3[0], y: e3[1] };
            for (let t4 of (this.setShapeArgs(g2, x2, n2), this.mapOptionsToLevel = n2, this.points)) d2[t4.id] && T(31, false, this.chart), d2[t4.id] = true;
          }
        }
        return I.defaultOptions = A(b.defaultOptions, n), S(I.prototype, { axisTypes: [], drawDataLabels: c, getCenter: p, isCartesian: false, onPointSupported: true, pointAttribs: g.prototype.pointAttribs, pointClass: s, NodeClass: a, utils: r }), i2.registerSeriesType("sunburst", I), I;
      }), i(e, "masters/modules/sunburst.src.js", [e["Core/Globals.js"], e["Extensions/Breadcrumbs/Breadcrumbs.js"]], function(t2, e2) {
        return t2.Breadcrumbs = t2.Breadcrumbs || e2, t2.Breadcrumbs.compose(t2.Chart, t2.defaultOptions), t2;
      });
    });
  }
});
export default require_sunburst();
//# sourceMappingURL=highcharts_modules_sunburst__js.js.map
