import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/sonification.js
var require_sonification = __commonJS({
  "node_modules/highcharts/modules/sonification.js"(exports, module) {
    !/**
    * Highcharts JS v11.4.7 (2024-08-14)
    *
    * Sonification module
    *
    * (c) 2010-2024 Highsoft AS
    * Author: Ã˜ystein Moseng
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/sonification", ["highcharts"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function i(t2, i2, n, s) {
        t2.hasOwnProperty(i2) || (t2[i2] = s.apply(null, n), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: i2, module: t2[i2] } })));
      }
      i(t, "Extensions/Sonification/Options.js", [], function() {
        return { sonification: { enabled: true, duration: 6e3, afterSeriesWait: 700, updateInterval: 200, masterVolume: 0.7, order: "sequential", showTooltip: true, showCrosshair: true, pointGrouping: { enabled: true, groupTimespan: 15, algorithm: "minmax", prop: "y" }, defaultInstrumentOptions: { roundToMusicalNotes: true, instrument: "piano", mapping: { time: "x", pan: "x", noteDuration: 200, pitch: { mapTo: "y", min: "c2", max: "c6", within: "yAxis" }, gapBetweenNotes: 100 } }, defaultSpeechOptions: { language: "en-US", mapping: { time: "x", rate: 1.3, volume: 0.4 }, pointGrouping: { algorithm: "last" } } }, exporting: { menuItemDefinitions: { downloadMIDI: { textKey: "downloadMIDI", onclick: function() {
          this.sonification && this.sonification.downloadMIDI();
        } }, playAsSound: { textKey: "playAsSound", onclick: function() {
          let e2 = this.sonification;
          e2 && e2.isPlaying() ? e2.cancel() : this.sonify();
        } } } }, lang: { downloadMIDI: "Download MIDI", playAsSound: "Play as sound" } };
      }), i(t, "Extensions/Sonification/SynthPatch.js", [t["Core/Utilities.js"]], function(e2) {
        let { clamp: t2, defined: i2, pick: n } = e2;
        function s(e3, t3) {
          return (0.2414 * e3 - 0.2414) * Math.log(t3) + (3.5 - 1.7 * e3) / 1.8;
        }
        function o(e3, t3, i3) {
          e3.gain.cancelScheduledValues(t3), e3.gain.setTargetAtTime(i3, t3, h.stopRampTime / 4), e3.gain.setValueAtTime(i3, t3 + h.stopRampTime);
        }
        function a(e3, t3, i3, n2, s2 = 1) {
          let l2 = "attack" === t3, r2 = n2.gain;
          if (r2.cancelScheduledValues(i3), !e3.length) {
            o(n2, i3, l2 ? s2 : 0);
            return;
          }
          e3[0].t > 1 && e3.unshift({ t: 0, vol: l2 ? 0 : 1 }), e3.forEach((t4, n3) => {
            let o2 = e3[n3 - 1], a2 = o2 ? (t4.t - o2.t) / 1e3 : 0, l3 = i3 + (o2 ? o2.t / 1e3 + h.stopRampTime : 0);
            r2.setTargetAtTime(t4.vol * s2, l3, Math.max(a2, h.stopRampTime) / 2);
          });
        }
        class l {
          constructor(e3, t3) {
            this.pulseWidth = Math.min(Math.max(0, t3.pulseWidth || 0.5));
            let i3 = () => new OscillatorNode(e3, { type: "sawtooth", detune: t3.detune, frequency: Math.max(1, t3.frequency || 350) });
            this.sawOscA = i3(), this.sawOscB = i3(), this.phaseInverter = new GainNode(e3, { gain: -1 }), this.masterGain = new GainNode(e3), this.delayNode = new DelayNode(e3, { delayTime: this.pulseWidth / this.sawOscA.frequency.value }), this.sawOscA.connect(this.masterGain), this.sawOscB.connect(this.phaseInverter), this.phaseInverter.connect(this.delayNode), this.delayNode.connect(this.masterGain);
          }
          connect(e3) {
            this.masterGain.connect(e3);
          }
          getFrequencyFacade() {
            let e3 = this;
            return { cancelScheduledValues: (t3) => (e3.sawOscA.frequency.cancelScheduledValues(t3), e3.sawOscB.frequency.cancelScheduledValues(t3), e3.delayNode.delayTime.cancelScheduledValues(t3), e3.sawOscA.frequency), setValueAtTime(t3, i3) {
              return this.cancelScheduledValues(i3), e3.sawOscA.frequency.setValueAtTime(t3, i3), e3.sawOscB.frequency.setValueAtTime(t3, i3), e3.delayNode.delayTime.setValueAtTime(Math.round(1e4 * e3.pulseWidth / t3) / 1e4, i3), e3.sawOscA.frequency;
            }, setTargetAtTime(t3, i3, n2) {
              return this.cancelScheduledValues(i3), e3.sawOscA.frequency.setTargetAtTime(t3, i3, n2), e3.sawOscB.frequency.setTargetAtTime(t3, i3, n2), e3.delayNode.delayTime.setTargetAtTime(Math.round(1e4 * e3.pulseWidth / t3) / 1e4, i3, n2), e3.sawOscA.frequency;
            } };
          }
          getPWMTarget() {
            return this.delayNode.delayTime;
          }
          start() {
            this.sawOscA.start(), this.sawOscB.start();
          }
          stop(e3) {
            this.sawOscA.stop(e3), this.sawOscB.stop(e3);
          }
        }
        class r {
          constructor(e3, t3, i3) {
            this.audioContext = e3, this.options = t3, this.fmOscillatorIx = t3.fmOscillator, this.vmOscillatorIx = t3.vmOscillator, this.createSoundSource(), this.createGain(), this.createFilters(), this.createVolTracking(), i3 && this.connect(i3);
          }
          connect(e3) {
            [this.lowpassNode, this.highpassNode, this.volTrackingNode, this.vmNode, this.gainNode, this.whiteNoise, this.pulseNode, this.oscNode].reduce((e4, t3) => t3 ? (t3.connect(e4), t3) : e4, e3);
          }
          start() {
            this.oscNode && this.oscNode.start(), this.whiteNoise && this.whiteNoise.start(), this.pulseNode && this.pulseNode.start();
          }
          stopAtTime(e3) {
            this.oscNode && this.oscNode.stop(e3), this.whiteNoise && this.whiteNoise.stop(e3), this.pulseNode && this.pulseNode.stop(e3);
          }
          setFreqAtTime(e3, i3, s2 = 0) {
            let o2 = this.options, a2 = t2(n(o2.fixedFrequency, i3) * (o2.freqMultiplier || 1), 0, 21e3), l2 = this.getOscTarget(), r2 = s2 / 5e3;
            l2 && (l2.cancelScheduledValues(e3), s2 && e3 - (this.lastUpdateTime || -1) > 0.01 ? (l2.setTargetAtTime(a2, e3, r2), l2.setValueAtTime(a2, e3 + r2)) : l2.setValueAtTime(a2, e3)), this.scheduleVolTrackingChange(a2, e3, s2), this.scheduleFilterTrackingChange(a2, e3, s2), this.lastUpdateTime = e3;
          }
          getFMTarget() {
            return this.oscNode && this.oscNode.detune || this.whiteNoise && this.whiteNoise.detune || this.pulseNode && this.pulseNode.getPWMTarget();
          }
          getVMTarget() {
            return this.vmNode && this.vmNode.gain;
          }
          runEnvelopeAtTime(e3, t3) {
            this.gainNode && a(("attack" === e3 ? this.options.attackEnvelope : this.options.releaseEnvelope) || [], e3, t3, this.gainNode, this.options.volume);
          }
          cancelScheduled() {
            this.gainNode && this.gainNode.gain.cancelScheduledValues(this.audioContext.currentTime);
            let e3 = this.getOscTarget();
            e3 && e3.cancelScheduledValues(0), this.lowpassNode && this.lowpassNode.frequency.cancelScheduledValues(0), this.highpassNode && this.highpassNode.frequency.cancelScheduledValues(0), this.volTrackingNode && this.volTrackingNode.gain.cancelScheduledValues(0);
          }
          scheduleVolTrackingChange(e3, t3, i3) {
            if (this.volTrackingNode) {
              let n2 = s(this.options.volumePitchTrackingMultiplier || 1, e3), o2 = i3 ? i3 / 1e3 : h.stopRampTime;
              this.volTrackingNode.gain.cancelScheduledValues(t3), this.volTrackingNode.gain.setTargetAtTime(n2, t3, o2 / 5), this.volTrackingNode.gain.setValueAtTime(n2, t3 + o2);
            }
          }
          scheduleFilterTrackingChange(e3, i3, n2) {
            let o2 = this.options, a2 = n2 ? n2 / 1e3 : h.stopRampTime, l2 = (n3, o3) => {
              let l3 = s(o3.frequencyPitchTrackingMultiplier || 1, e3), r2 = t2((o3.frequency || 1e3) * l3, 0, 21e3);
              n3.frequency.cancelScheduledValues(i3), n3.frequency.setTargetAtTime(r2, i3, a2 / 5), n3.frequency.setValueAtTime(r2, i3 + a2);
            };
            this.lowpassNode && o2.lowpass && l2(this.lowpassNode, o2.lowpass), this.highpassNode && o2.highpass && l2(this.highpassNode, o2.highpass);
          }
          createGain() {
            let e3 = this.options;
            (i2(e3.volume) || e3.attackEnvelope && e3.attackEnvelope.length || e3.releaseEnvelope && e3.releaseEnvelope.length) && (this.gainNode = new GainNode(this.audioContext, { gain: n(e3.volume, 1) })), this.vmNode = new GainNode(this.audioContext);
          }
          createSoundSource() {
            let e3 = this.options, t3 = this.audioContext, i3 = (e3.fixedFrequency || 0) * (e3.freqMultiplier || 1);
            if ("whitenoise" === e3.type) {
              let e4 = 2 * t3.sampleRate, i4 = t3.createBuffer(1, e4, t3.sampleRate), n2 = i4.getChannelData(0);
              for (let t4 = 0; t4 < e4; ++t4) n2[t4] = 1.2 * Math.random() - 0.6;
              let s2 = this.whiteNoise = t3.createBufferSource();
              s2.buffer = i4, s2.loop = true;
            } else "pulse" === e3.type ? this.pulseNode = new l(t3, { detune: e3.detune, pulseWidth: e3.pulseWidth, frequency: i3 }) : this.oscNode = new OscillatorNode(t3, { type: e3.type || "sine", detune: e3.detune, frequency: i3 });
          }
          createFilters() {
            let e3 = this.options;
            e3.lowpass && e3.lowpass.frequency && (this.lowpassNode = new BiquadFilterNode(this.audioContext, { type: "lowpass", Q: e3.lowpass.Q || 1, frequency: e3.lowpass.frequency })), e3.highpass && e3.highpass.frequency && (this.highpassNode = new BiquadFilterNode(this.audioContext, { type: "highpass", Q: e3.highpass.Q || 1, frequency: e3.highpass.frequency }));
          }
          createVolTracking() {
            let e3 = this.options;
            e3.volumePitchTrackingMultiplier && 1 !== e3.volumePitchTrackingMultiplier && (this.volTrackingNode = new GainNode(this.audioContext, { gain: 1 }));
          }
          getOscTarget() {
            return this.oscNode ? this.oscNode.frequency : this.pulseNode && this.pulseNode.getFrequencyFacade();
          }
        }
        class h {
          constructor(e3, t3) {
            this.audioContext = e3, this.options = t3, this.eqNodes = [], this.midiInstrument = t3.midiInstrument || 1, this.outputNode = new GainNode(e3, { gain: 0 }), this.createEqChain(this.outputNode);
            let n2 = this.eqNodes.length ? this.eqNodes[0] : this.outputNode;
            this.oscillators = (this.options.oscillators || []).map((t4) => new r(e3, t4, i2(t4.fmOscillator) || i2(t4.vmOscillator) ? void 0 : n2)), this.oscillators.forEach((e4) => {
              let t4 = (t5, i3) => {
                if (i3) {
                  let n3 = i3[t5]();
                  n3 && e4.connect(n3);
                }
              };
              i2(e4.fmOscillatorIx) && t4("getFMTarget", this.oscillators[e4.fmOscillatorIx]), i2(e4.vmOscillatorIx) && t4("getVMTarget", this.oscillators[e4.vmOscillatorIx]);
            });
          }
          startSilently() {
            this.outputNode.gain.value = 0, this.oscillators.forEach((e3) => e3.start());
          }
          stop() {
            let e3 = this.audioContext.currentTime, t3 = e3 + h.stopRampTime;
            o(this.outputNode, e3, 0), this.oscillators.forEach((e4) => e4.stopAtTime(t3)), this.outputNode.disconnect();
          }
          silenceAtTime(e3) {
            if (!e3 && this.outputNode.gain.value < 0.01) {
              this.outputNode.gain.value = 0;
              return;
            }
            this.releaseAtTime((e3 || 0) + this.audioContext.currentTime);
          }
          mute() {
            this.cancelScheduled(), o(this.outputNode, this.audioContext.currentTime, 0);
          }
          playFreqAtTime(e3, t3, i3) {
            let n2 = (e3 || 0) + this.audioContext.currentTime, s2 = this.options;
            this.oscillators.forEach((e4) => {
              e4.setFreqAtTime(n2, t3, s2.noteGlideDuration), e4.runEnvelopeAtTime("attack", n2);
            }), a(s2.masterAttackEnvelope || [], "attack", n2, this.outputNode, s2.masterVolume), i3 && this.releaseAtTime(n2 + i3 / 1e3);
          }
          cancelScheduled() {
            this.outputNode.gain.cancelScheduledValues(this.audioContext.currentTime), this.oscillators.forEach((e3) => e3.cancelScheduled());
          }
          connect(e3) {
            return this.outputNode.connect(e3);
          }
          createEqChain(e3) {
            this.eqNodes = (this.options.eq || []).map((e4) => new BiquadFilterNode(this.audioContext, { type: "peaking", ...e4 })), this.eqNodes.reduceRight((e4, t3) => (t3.connect(e4), t3), e3);
          }
          releaseAtTime(e3) {
            let t3 = 0;
            this.oscillators.forEach((i4) => {
              let n2 = i4.options.releaseEnvelope;
              n2 && n2.length && (t3 = Math.max(t3, n2[n2.length - 1].t), i4.runEnvelopeAtTime("release", e3));
            });
            let i3 = this.options.masterReleaseEnvelope || [];
            i3.length && (a(i3, "release", e3, this.outputNode, this.options.masterVolume), t3 = Math.max(t3, i3[i3.length - 1].t)), o(this.outputNode, e3 + t3 / 1e3, 0);
          }
        }
        return h.stopRampTime = 0.012, h;
      }), i(t, "Extensions/Sonification/InstrumentPresets.js", [], function() {
        return { piano: { masterVolume: 0.45, masterAttackEnvelope: [{ t: 1, vol: 0.71 }, { t: 40, vol: 0.79 }, { t: 82, vol: 0.64 }, { t: 147, vol: 0.29 }, { t: 260, vol: 0.15 }, { t: 417, vol: 0.05 }, { t: 589, vol: 0 }], eq: [{ frequency: 200, Q: 0.7, gain: 6 }, { frequency: 450, gain: 6 }, { frequency: 1300, gain: 2 }, { frequency: 2600, Q: 0.8, gain: 8 }, { frequency: 3500, Q: 0.8, gain: 6 }, { frequency: 6200, Q: 0.8, gain: 10 }, { frequency: 8e3, gain: -23 }, { frequency: 1e4, Q: 0.4, gain: -12 }], oscillators: [{ type: "pulse", volume: 0.5, pulseWidth: 0.55, volumePitchTrackingMultiplier: 0.1, lowpass: { frequency: 4.5, frequencyPitchTrackingMultiplier: 900, Q: -2 }, highpass: { frequency: 270 }, attackEnvelope: [{ t: 1, vol: 1 }], releaseEnvelope: [{ t: 1, vol: 1 }, { t: 282, vol: 0.64 }, { t: 597, vol: 0 }] }, { type: "whitenoise", volume: 0.8, lowpass: { frequency: 400 }, highpass: { frequency: 300 }, attackEnvelope: [{ t: 1, vol: 1 }, { t: 19, vol: 0 }] }] }, plucked: { masterVolume: 0.5, midiInstrument: 25, masterAttackEnvelope: [{ t: 1, vol: 0.71 }, { t: 4, vol: 0.71 }, { t: 31, vol: 0.4 }, { t: 109, vol: 0.12 }, { t: 234, vol: 0.04 }, { t: 442, vol: 0 }], eq: [{ frequency: 800, gain: -8 }, { frequency: 1400, Q: 4, gain: 4 }, { frequency: 1600, gain: -14 }, { frequency: 2200, gain: -8 }, { frequency: 3600, gain: -2 }, { frequency: 6400, Q: 2, gain: -6 }], oscillators: [{ type: "sawtooth", volume: 0.9, volumePitchTrackingMultiplier: 0.6, highpass: { frequency: 100 }, lowpass: { frequency: 8e3 }, releaseEnvelope: [{ t: 1, vol: 1 }, { t: 315, vol: 0.56 }, { t: 550, vol: 0 }] }] }, flute: { masterVolume: 1.1, midiInstrument: 74, noteGlideDuration: 30, masterAttackEnvelope: [{ t: 0, vol: 0 }, { t: 29, vol: 1 }, { t: 76, vol: 0.48 }, { t: 600, vol: 0.36 }], masterReleaseEnvelope: [{ t: 1, vol: 0.36 }, { t: 24, vol: 0.15 }, { t: 119, vol: 0 }], eq: [{ frequency: 150, Q: 0.6, gain: -10 }, { frequency: 500, gain: 4 }, { frequency: 1100, gain: -4 }, { frequency: 2200, gain: -14 }, { frequency: 5e3, gain: 8 }, { frequency: 6400, gain: 10 }, { frequency: 8e3, gain: 12 }, { frequency: 10800, gain: 8 }], oscillators: [{ type: "triangle", volume: 1, volumePitchTrackingMultiplier: 0.4, lowpass: { frequency: 12, frequencyPitchTrackingMultiplier: 100 }, highpass: { frequency: 200 } }, { type: "sine", fixedFrequency: 5, volume: 0.2, vmOscillator: 0, attackEnvelope: [{ t: 1, vol: 1 }, { t: 48, vol: 0 }, { t: 225, vol: 0.05 }, { t: 600, vol: 0.77 }] }, { type: "whitenoise", volume: 0.13, lowpass: { frequency: 9e3, Q: 3 }, highpass: { frequency: 6e3, Q: 3 }, vmOscillator: 0, attackEnvelope: [{ t: 0, vol: 0 }, { t: 26, vol: 1 }, { t: 93, vol: 0.8 }] }] }, lead: { masterVolume: 1, midiInstrument: 20, masterAttackEnvelope: [{ t: 1, vol: 0.81 }, { t: 98, vol: 0.5 }, { t: 201, vol: 0.18 }, { t: 377, vol: 0.04 }, { t: 586, vol: 0 }, { t: 586, vol: 0 }], eq: [{ frequency: 200, gain: -6 }, { frequency: 400, gain: -8 }, { frequency: 800, Q: 0.5, gain: -10 }, { frequency: 1200, gain: 4 }, { frequency: 3600, gain: -4 }, { frequency: 4200, gain: -12 }, { frequency: 7400, gain: -14 }, { frequency: 1e4, gain: 2 }], oscillators: [{ type: "triangle", volume: 1.1, volumePitchTrackingMultiplier: 0.6, lowpass: { frequency: 5e3 }, highpass: { frequency: 100 } }, { type: "sawtooth", volume: 0.4, lowpass: { frequency: 7e3 }, highpass: { frequency: 800, Q: 6 }, releaseEnvelope: [{ t: 0, vol: 0.99 }, { t: 200, vol: 0.83 }, { t: 495, vol: 0 }] }] }, vibraphone: { masterVolume: 1, midiInstrument: 12, masterAttackEnvelope: [{ t: 1, vol: 0 }, { t: 10, vol: 0.63 }, { t: 82, vol: 0.64 }, { t: 149, vol: 0.26 }, { t: 600, vol: 0 }], eq: [{ frequency: 200, Q: 0.8, gain: -12 }, { frequency: 400, gain: -4 }, { frequency: 1600, Q: 0.5, gain: 6 }, { frequency: 2200, Q: 0.5, gain: 6 }, { frequency: 6400, gain: 4 }, { frequency: 12800, gain: 4 }], oscillators: [{ type: "sine", volume: 1.5, volumePitchTrackingMultiplier: 1e-7, attackEnvelope: [{ t: 1, vol: 1 }], releaseEnvelope: [{ t: 1, vol: 1 }, { t: 146, vol: 0.39 }, { t: 597, vol: 0 }] }, { type: "whitenoise", volume: 0.03, volumePitchTrackingMultiplier: 1e-4, lowpass: { frequency: 900 }, highpass: { frequency: 800 }, attackEnvelope: [{ t: 1, vol: 1 }, { t: 9, vol: 0 }] }, { type: "sine", freqMultiplier: 4, volume: 0.15, volumePitchTrackingMultiplier: 1e-4 }, { type: "sine", fixedFrequency: 3, volume: 6, fmOscillator: 0, releaseEnvelope: [{ t: 1, vol: 1 }, { t: 190, vol: 0.41 }, { t: 600, vol: 0 }] }, { type: "sine", fixedFrequency: 6, volume: 3, fmOscillator: 2 }, { type: "sine", freqMultiplier: 9, volume: 5e-4, volumePitchTrackingMultiplier: 1e-4, releaseEnvelope: [{ t: 1, vol: 0.97 }, { t: 530, vol: 0 }] }] }, saxophone: { masterVolume: 1, midiInstrument: 67, noteGlideDuration: 10, masterAttackEnvelope: [{ t: 1, vol: 0.57 }, { t: 35, vol: 1 }, { t: 87, vol: 0.84 }, { t: 111, vol: 0.6 }, { t: 296, vol: 0.49 }, { t: 600, vol: 0.58 }], masterReleaseEnvelope: [{ t: 1, vol: 0.58 }, { t: 47, vol: 0.16 }, { t: 119, vol: 0 }], eq: [{ frequency: 200, gain: -2 }, { frequency: 600, gain: 2 }, { frequency: 800, gain: -10 }, { frequency: 1100, gain: -2 }, { frequency: 2200, gain: -2 }, { frequency: 3500, gain: 10 }, { frequency: 12800, gain: 4 }], oscillators: [{ type: "sawtooth", volume: 0.45, volumePitchTrackingMultiplier: 0.06, lowpass: { frequency: 18, frequencyPitchTrackingMultiplier: 200 }, highpass: { frequency: 300 } }, { type: "whitenoise", fixedFrequency: 1, volume: 0.4, highpass: { frequency: 7e3 }, vmOscillator: 0, attackEnvelope: [{ t: 1, vol: 1 }, { t: 51, vol: 1 }, { t: 86, vol: 0.84 }, { t: 500, vol: 0.78 }] }, { type: "sine", fixedFrequency: 4, volume: 2, fmOscillator: 0, attackEnvelope: [{ t: 0, vol: 0 }, { t: 15, vol: 0.94 }, { t: 79, vol: 1 }, { t: 172, vol: 0.47 }, { t: 500, vol: 0.26 }] }, { type: "sine", fixedFrequency: 7, volume: 6, fmOscillator: 0, attackEnvelope: [{ t: 0, vol: 0 }, { t: 25, vol: 0.99 }, { t: 85, vol: 0 }, { t: 85, vol: 0 }, { t: 387, vol: 0.02 }, { t: 511, vol: 0.43 }, { t: 600, vol: 0 }] }] }, trumpet: { masterVolume: 0.3, midiInstrument: 57, noteGlideDuration: 40, masterAttackEnvelope: [{ t: 1, vol: 0 }, { t: 17, vol: 1 }, { t: 42, vol: 0.85 }, { t: 76, vol: 1 }, { t: 202, vol: 0.65 }, { t: 226, vol: 0.86 }, { t: 282, vol: 0.63 }], masterReleaseEnvelope: [{ t: 1, vol: 0.62 }, { t: 34, vol: 0.14 }, { t: 63, vol: 0.21 }, { t: 96, vol: 0 }], eq: [{ frequency: 200, Q: 0.6, gain: 10 }, { frequency: 600, Q: 0.5, gain: 6 }, { frequency: 1500, Q: 0.7, gain: 14 }, { frequency: 3200, Q: 2, gain: 8 }, { frequency: 3800, Q: 0.8, gain: 10 }, { frequency: 6200, gain: 12 }, { frequency: 8400, gain: -20 }, { frequency: 12800, Q: 0.5, gain: -18 }], oscillators: [{ type: "sawtooth", volume: 0.15, pulseWidth: 0.5, volumePitchTrackingMultiplier: 0.5, lowpass: { frequency: 1900, Q: 3 } }, { type: "sine", fixedFrequency: 6, volume: 0.2, vmOscillator: 0, attackEnvelope: [{ t: 1, vol: 1 }, { t: 102, vol: 0.13 }, { t: 556, vol: 0.24 }] }, { type: "whitenoise", volume: 0.45, highpass: { frequency: 7e3, Q: 9 }, vmOscillator: 0, attackEnvelope: [{ t: 1, vol: 1 }, { t: 89, vol: 0.51 }, { t: 577, vol: 0.29 }] }, { type: "sine", fixedFrequency: 5.7, volume: 20, fmOscillator: 0, attackEnvelope: [{ t: 1, vol: 1 }, { t: 89, vol: 1 }, { t: 137, vol: 0.46 }, { t: 283, vol: 0.15 }, { t: 600, vol: 0.28 }] }] }, sawsynth: { masterVolume: 0.3, midiInstrument: 51, noteGlideDuration: 40, masterAttackEnvelope: [{ t: 0, vol: 0.6 }, { t: 9, vol: 1 }, { t: 102, vol: 0.48 }], eq: [{ frequency: 200, gain: -6 }], oscillators: [{ type: "sawtooth", volume: 0.4, volumePitchTrackingMultiplier: 0.3 }, { type: "sawtooth", volume: 0.4, detune: 11, volumePitchTrackingMultiplier: 0.3 }, { type: "sawtooth", volume: 0.4, detune: -11, volumePitchTrackingMultiplier: 0.3 }] }, basic1: { masterVolume: 1, noteGlideDuration: 0, masterReleaseEnvelope: [{ t: 1, vol: 0.36 }, { t: 24, vol: 0.15 }, { t: 119, vol: 0 }], eq: [{ frequency: 150, Q: 0.6, gain: -12 }, { frequency: 1100, gain: -2 }, { frequency: 2200, gain: -16 }, { frequency: 5e3, gain: 8 }, { frequency: 6400, gain: 10 }, { frequency: 8e3, gain: 12 }, { frequency: 10800, gain: 8 }], oscillators: [{ type: "triangle", volume: 1, volumePitchTrackingMultiplier: 0.05, lowpass: { frequency: 17, frequencyPitchTrackingMultiplier: 100 }, highpass: { frequency: 200 } }, { type: "whitenoise", volume: 0.04, lowpass: { frequency: 9e3, Q: 3 }, highpass: { frequency: 6e3, Q: 3 }, vmOscillator: 0, attackEnvelope: [{ t: 0, vol: 0 }, { t: 26, vol: 1 }, { t: 71, vol: 0.73 }] }] }, basic2: { masterVolume: 0.3, eq: [{ frequency: 200, Q: 0.7, gain: 6 }, { frequency: 450, gain: 2 }, { frequency: 1300, gain: -2 }, { frequency: 2600, Q: 0.8, gain: 6 }, { frequency: 3500, Q: 0.8, gain: 6 }, { frequency: 6200, Q: 0.8, gain: 10 }, { frequency: 8e3, gain: -18 }, { frequency: 1e4, Q: 0.4, gain: -12 }], oscillators: [{ type: "pulse", volume: 0.4, pulseWidth: 0.55, volumePitchTrackingMultiplier: 0.1, lowpass: { frequency: 4.5, frequencyPitchTrackingMultiplier: 900, Q: -2 }, highpass: { frequency: 270 } }] }, chord: { masterVolume: 1, masterAttackEnvelope: [{ t: 1, vol: 0.79 }, { t: 27, vol: 0.86 }, { t: 62, vol: 0.81 }, { t: 150, vol: 0.35 }, { t: 408, vol: 0.04 }, { t: 600, vol: 0 }], eq: [{ frequency: 200, gain: -8 }, { frequency: 600, Q: 2, gain: 4 }, { frequency: 800, gain: -10 }, { frequency: 1600, gain: -2 }, { frequency: 2200, gain: -6 }, { frequency: 3600, Q: 0.7, gain: -2 }, { frequency: 6400, gain: 6 }, { frequency: 12800, gain: 6 }], oscillators: [{ type: "triangle", volume: 1.1, volumePitchTrackingMultiplier: 0.05, lowpass: { frequency: 8e3 }, highpass: { frequency: 100 }, releaseEnvelope: [{ t: 1, vol: 1 }, { t: 315, vol: 0.56 }, { t: 540, vol: 0 }] }, { type: "triangle", freqMultiplier: 1.17, volume: 0.4, volumePitchTrackingMultiplier: 0.07, lowpass: { frequency: 5e3 }, highpass: { frequency: 100 }, releaseEnvelope: [{ t: 0, vol: 1 }, { t: 476, vol: 0 }] }, { type: "triangle", freqMultiplier: 1.58333, volume: 0.7, volumePitchTrackingMultiplier: 0.02, highpass: { frequency: 200 }, releaseEnvelope: [{ t: 0, vol: 1 }, { t: 422, vol: 0.56 }, { t: 577, vol: 0 }] }, { type: "sine", fixedFrequency: 10, volume: 4, fmOscillator: 0, attackEnvelope: [{ t: 1, vol: 1 }, { t: 157, vol: 0.65 }] }, { type: "sine", fixedFrequency: 5, volume: 0.3, vmOscillator: 2, attackEnvelope: [{ t: 1, vol: 1 }, { t: 155, vol: 0.91 }, { t: 289, vol: 0.78 }] }] }, wobble: { masterVolume: 0.9, masterReleaseEnvelope: [{ t: 1, vol: 0.36 }, { t: 24, vol: 0.15 }, { t: 119, vol: 0 }], eq: [{ frequency: 150, Q: 0.6, gain: -12 }, { frequency: 1100, gain: -2 }, { frequency: 2200, gain: -16 }, { frequency: 5e3, gain: 8 }, { frequency: 6400, gain: 10 }, { frequency: 8e3, gain: 12 }, { frequency: 10800, gain: 8 }], oscillators: [{ type: "triangle", volume: 0.9, volumePitchTrackingMultiplier: 0.1, lowpass: { frequency: 17, frequencyPitchTrackingMultiplier: 100 }, highpass: { frequency: 200 } }, { type: "whitenoise", volume: 0.04, lowpass: { frequency: 9e3, Q: 3 }, highpass: { frequency: 6e3, Q: 3 }, vmOscillator: 0, attackEnvelope: [{ t: 0, vol: 0 }, { t: 26, vol: 1 }, { t: 71, vol: 0.73 }] }, { type: "sine", freqMultiplier: 0.011, volume: 30, fmOscillator: 0 }] }, sine: { masterVolume: 1, oscillators: [{ type: "sine", volumePitchTrackingMultiplier: 0.07 }] }, sineGlide: { masterVolume: 1, noteGlideDuration: 100, oscillators: [{ type: "sine", volumePitchTrackingMultiplier: 0.07 }] }, triangle: { masterVolume: 0.5, oscillators: [{ type: "triangle", volume: 1, volumePitchTrackingMultiplier: 0.07 }] }, sawtooth: { masterVolume: 0.25, midiInstrument: 82, oscillators: [{ type: "sawtooth", volume: 0.3, volumePitchTrackingMultiplier: 0.07 }] }, square: { masterVolume: 0.3, midiInstrument: 81, oscillators: [{ type: "square", volume: 0.2, volumePitchTrackingMultiplier: 0.07 }] }, chop: { masterVolume: 1, midiInstrument: 116, masterAttackEnvelope: [{ t: 1, vol: 1 }, { t: 44, vol: 0 }], oscillators: [{ type: "whitenoise", volume: 1, lowpass: { frequency: 600 }, highpass: { frequency: 200 } }] }, shaker: { masterVolume: 0.4, midiInstrument: 116, masterAttackEnvelope: [{ t: 1, vol: 1 }, { t: 44, vol: 0 }], oscillators: [{ type: "whitenoise", volume: 1, lowpass: { frequency: 6500 }, highpass: { frequency: 5e3 } }] }, step: { masterVolume: 1, midiInstrument: 116, masterAttackEnvelope: [{ t: 1, vol: 1 }, { t: 44, vol: 0 }], eq: [{ frequency: 200, gain: -1 }, { frequency: 400, gain: -14 }, { frequency: 800, gain: 8 }, { frequency: 1e3, Q: 5, gain: -24 }, { frequency: 1600, gain: 8 }, { frequency: 2200, gain: -10 }, { frequency: 5400, gain: 4 }, { frequency: 12800, gain: -36 }], oscillators: [{ type: "whitenoise", volume: 1.5, lowpass: { frequency: 300 }, highpass: { frequency: 100, Q: 6 } }] }, kick: { masterVolume: 0.55, masterAttackEnvelope: [{ t: 1, vol: 0.8 }, { t: 15, vol: 1 }, { t: 45, vol: 0.35 }, { t: 121, vol: 0.11 }, { t: 242, vol: 0 }], eq: [{ frequency: 50, gain: 6 }, { frequency: 400, gain: -18 }, { frequency: 1600, gain: 18 }], oscillators: [{ type: "triangle", fixedFrequency: 90, volume: 1, lowpass: { frequency: 300 }, attackEnvelope: [{ t: 1, vol: 1 }, { t: 6, vol: 1 }, { t: 45, vol: 0.01 }] }, { type: "whitenoise", volume: 0.4, lowpass: { frequency: 200 }, attackEnvelope: [{ t: 1, vol: 1 }, { t: 30, vol: 0 }] }, { type: "triangle", freqMultiplier: 0.1, volume: 1, lowpass: { frequency: 200 } }] }, shortnote: { masterVolume: 0.8, midiInstrument: 116, masterAttackEnvelope: [{ t: 1, vol: 1 }, { t: 15, vol: 0 }], eq: [{ frequency: 400, gain: -4 }, { frequency: 800, gain: -12 }, { frequency: 2400, gain: 4 }, { frequency: 7200, gain: -20 }, { frequency: 1e3, Q: 5, gain: -12 }, { frequency: 5400, gain: -32 }, { frequency: 12800, gain: -14 }], oscillators: [{ type: "sawtooth", volume: 0.6, lowpass: { frequency: 1e3 } }, { type: "whitenoise", volume: 0.2, lowpass: { frequency: 1e4 }, highpass: { frequency: 7e3 }, attackEnvelope: [{ t: 1, vol: 1 }, { t: 10, vol: 0 }] }, { type: "whitenoise", volume: 1.3, lowpass: { frequency: 700, Q: 4 }, highpass: { frequency: 250 } }] }, noise: { masterVolume: 0.3, midiInstrument: 122, oscillators: [{ type: "whitenoise" }] }, filteredNoise: { masterVolume: 0.3, midiInstrument: 122, eq: [{ frequency: 1600, gain: -8 }, { frequency: 2200, gain: -4 }], oscillators: [{ type: "whitenoise", lowpass: { frequency: 5, frequencyPitchTrackingMultiplier: 1300, Q: 6 }, highpass: { frequency: 5, frequencyPitchTrackingMultiplier: 300, Q: 6 } }] }, wind: { masterVolume: 0.75, midiInstrument: 122, noteGlideDuration: 150, masterReleaseEnvelope: [{ t: 0, vol: 1 }, { t: 124, vol: 0.24 }, { t: 281, vol: 0 }], oscillators: [{ type: "whitenoise", volume: 1, lowpass: { frequency: 100, frequencyPitchTrackingMultiplier: 6, Q: 23 }, highpass: { frequency: 170, frequencyPitchTrackingMultiplier: 6 } }, { type: "sine", freqMultiplier: 0.016, volume: 1e3, fmOscillator: 0 }] } };
      }), i(t, "Extensions/Sonification/SonificationInstrument.js", [t["Extensions/Sonification/SynthPatch.js"], t["Extensions/Sonification/InstrumentPresets.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        let { defined: n, extend: s } = i2;
        class o {
          constructor(i3, n2, o2) {
            this.audioContext = i3, this.curParams = {}, this.midiTrackName = o2.midiTrackName, this.masterVolNode = new GainNode(i3), this.masterVolNode.connect(n2), this.volumeNode = new GainNode(i3), this.createNodesFromCapabilities(s({ pan: true }, o2.capabilities || {})), this.connectCapabilityNodes(this.volumeNode, this.masterVolNode), this.synthPatch = new e2(i3, "string" == typeof o2.synthPatch ? t2[o2.synthPatch] : o2.synthPatch), this.midiInstrument = this.synthPatch.midiInstrument || 1, this.synthPatch.startSilently(), this.synthPatch.connect(this.volumeNode);
          }
          setMasterVolume(e3) {
            this.masterVolNode.gain.setTargetAtTime(e3, 0, o.rampTime);
          }
          scheduleEventAtTime(e3, t3) {
            let i3 = s(this.curParams, t3), a = n(t3.frequency) ? t3.frequency : n(t3.note) ? o.musicalNoteToFrequency(t3.note) : 220;
            n(a) && this.synthPatch.playFreqAtTime(e3, a, i3.noteDuration), (n(i3.tremoloDepth) || n(i3.tremoloSpeed)) && this.setTremoloAtTime(e3, i3.tremoloDepth, i3.tremoloSpeed), n(i3.pan) && this.setPanAtTime(e3, i3.pan), n(i3.volume) && this.setVolumeAtTime(e3, i3.volume), (n(i3.lowpassFreq) || n(i3.lowpassResonance)) && this.setFilterAtTime("lowpass", e3, i3.lowpassFreq, i3.lowpassResonance), (n(i3.highpassFreq) || n(i3.highpassResonance)) && this.setFilterAtTime("highpass", e3, i3.highpassFreq, i3.highpassResonance);
          }
          silenceAtTime(e3) {
            this.synthPatch.silenceAtTime(e3);
          }
          cancel() {
            this.synthPatch.mute(), [this.tremoloDepth && this.tremoloDepth.gain, this.tremoloOsc && this.tremoloOsc.frequency, this.lowpassNode && this.lowpassNode.frequency, this.lowpassNode && this.lowpassNode.Q, this.highpassNode && this.highpassNode.frequency, this.highpassNode && this.highpassNode.Q, this.panNode && this.panNode.pan, this.volumeNode.gain].forEach((e3) => e3 && e3.cancelScheduledValues(0));
          }
          destroy() {
            this.cancel(), this.synthPatch.stop(), this.tremoloOsc && this.tremoloOsc.stop(), [this.tremoloDepth, this.tremoloOsc, this.lowpassNode, this.highpassNode, this.panNode, this.volumeNode, this.masterVolNode].forEach((e3) => e3 && e3.disconnect());
          }
          setPanAtTime(e3, t3) {
            this.panNode && this.panNode.pan.setTargetAtTime(t3, e3 + this.audioContext.currentTime, o.rampTime);
          }
          setFilterAtTime(e3, t3, i3, s2) {
            let a = this[e3 + "Node"], l = this.audioContext.currentTime + t3;
            a && (n(s2) && a.Q.setTargetAtTime(s2, l, o.rampTime), n(i3) && a.frequency.setTargetAtTime(i3, l, o.rampTime));
          }
          setVolumeAtTime(e3, t3) {
            this.volumeNode && this.volumeNode.gain.setTargetAtTime(t3, e3 + this.audioContext.currentTime, o.rampTime);
          }
          setTremoloAtTime(e3, t3, i3) {
            let s2 = this.audioContext.currentTime + e3;
            this.tremoloDepth && n(t3) && this.tremoloDepth.gain.setTargetAtTime(t3, s2, o.rampTime), this.tremoloOsc && n(i3) && this.tremoloOsc.frequency.setTargetAtTime(15 * i3, s2, o.rampTime);
          }
          createNodesFromCapabilities(e3) {
            let t3 = this.audioContext;
            e3.pan && (this.panNode = new StereoPannerNode(t3)), e3.tremolo && (this.tremoloOsc = new OscillatorNode(t3, { type: "sine", frequency: 3 }), this.tremoloDepth = new GainNode(t3), this.tremoloOsc.connect(this.tremoloDepth), this.tremoloDepth.connect(this.masterVolNode.gain), this.tremoloOsc.start()), e3.filters && (this.lowpassNode = new BiquadFilterNode(t3, { type: "lowpass", frequency: 2e4 }), this.highpassNode = new BiquadFilterNode(t3, { type: "highpass", frequency: 0 }));
          }
          connectCapabilityNodes(e3, t3) {
            [this.panNode, this.lowpassNode, this.highpassNode, e3].reduce((e4, t4) => t4 ? (t4.connect(e4), t4) : e4, t3);
          }
          static noteStringToC0Distance(e3) {
            let t3 = e3.match(/^([a-g][#b]?)([0-8])$/i), i3 = t3 ? t3[1] : "a", n2 = i3[0].toLowerCase(), s2 = i3[1];
            return ({ c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }[n2] || 0) + ("#" === s2 ? 1 : "b" === s2 ? -1 : 0) + 12 * (t3 ? parseInt(t3[2], 10) : 4);
          }
          static musicalNoteToFrequency(e3) {
            return 16.3516 * Math.pow(2, Math.min("string" == typeof e3 ? this.noteStringToC0Distance(e3) : e3, 107) / 12);
          }
        }
        return o.rampTime = e2.stopRampTime / 4, o;
      }), i(t, "Extensions/Sonification/SonificationSpeaker.js", [t["Core/Utilities.js"]], function(e2) {
        let { pick: t2 } = e2;
        return class {
          constructor(e3) {
            this.options = e3, this.masterVolume = 1, this.synthesis = window.speechSynthesis, void 0 !== speechSynthesis.onvoiceschanged && (speechSynthesis.onvoiceschanged = this.setVoice.bind(this)), this.setVoice(), this.scheduled = [];
          }
          say(e3, i2) {
            if (this.synthesis) {
              this.synthesis.cancel();
              let n = new SpeechSynthesisUtterance(e3);
              this.voice && (n.voice = this.voice), n.rate = i2 && i2.rate || this.options.rate || 1, n.pitch = i2 && i2.pitch || this.options.pitch || 1, n.volume = t2(i2 && i2.volume, this.options.volume, 1) * this.masterVolume, this.synthesis.speak(n);
            }
          }
          sayAtTime(e3, t3, i2) {
            this.scheduled.push(setTimeout(this.say.bind(this, t3, i2), e3));
          }
          cancel() {
            this.scheduled.forEach(clearTimeout), this.scheduled = [], this.synthesis.cancel();
          }
          destroy() {
            this.cancel();
          }
          setMasterVolume(e3) {
            this.masterVolume = e3;
          }
          setVoice() {
            if (this.synthesis) {
              let e3;
              let t3 = this.options.name, i2 = this.options.language || "en-US", n = this.synthesis.getVoices(), s = n.length;
              for (let o = 0; o < s; ++o) {
                if (t3 && n[o].name === t3) {
                  this.voice = n[o];
                  return;
                }
                if (!e3 && n[o].lang === i2 && (e3 = n[o], !t3)) break;
              }
              this.voice = e3;
            }
          }
        };
      }), i(t, "Extensions/Sonification/TimelineChannel.js", [], function() {
        return class {
          constructor(e2, t2, i2 = false, n, s) {
            this.type = e2, this.engine = t2, this.showPlayMarker = i2, this.muted = s, this.events = n || [];
          }
          addEvent(e2) {
            let t2 = this.events[this.events.length - 1];
            if (t2 && e2.time < t2.time) {
              let t3 = this.events.length;
              for (; t3-- && this.events[t3].time > e2.time; ) ;
              this.events.splice(t3 + 1, 0, e2);
            } else this.events.push(e2);
            return e2;
          }
          mute() {
            this.muted = true;
          }
          unmute() {
            this.muted = false;
          }
          cancel() {
            this.engine.cancel();
          }
          destroy() {
            this.engine.destroy();
          }
        };
      }), i(t, "Extensions/Sonification/MIDI.js", [t["Extensions/Sonification/SonificationInstrument.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { pick: i2 } = t2, n = (e3) => Math.round(12 * Math.log(e3) / Math.LN2 - 48.37632), s = (e3, t3) => t3 >>> 8 * e3 & 255, o = (e3) => [77, 84, 104, 100, 0, 0, 0, 6, 0, e3 > 1 ? 1 : 0, s(1, e3), s(0, e3), 1, 244], a = [0, 255, 81, 3, 7, 161, 32], l = (e3) => {
          let t3 = 127 & e3, i3 = [];
          for (; e3 >>= 7; ) t3 <<= 8, t3 |= 127 & e3 | 128;
          for (; ; ) if (i3.push(255 & t3), 128 & t3) t3 >>= 8;
          else break;
          return i3;
        }, r = (t3) => {
          let s2, o2;
          let a2 = [], l2 = (e3) => {
            let t4 = a2.length;
            for (; t4-- && a2[t4].timeMS > e3.timeMS; ) ;
            a2.splice(t4 + 1, 0, e3);
          };
          return t3.forEach((t4) => {
            let a3 = t4.instrumentEventOptions || {}, r2 = t4.time, h2 = o2 = i2(a3.noteDuration, o2), c2 = h2 && t4.time + h2, u = [{ valMap: (e3) => 64 + 63 * e3 & 127, data: { 10: a3.pan, 92: a3.tremoloDepth, 93: a3.tremoloSpeed } }, { valMap: (e3) => 127 * e3 / 2e4 & 127, data: { 74: a3.lowpassFreq, 75: a3.highpassFreq } }, { valMap: (e3) => 63 * Math.min(18, Math.max(-18, e3)) / 18 + 63 & 127, data: { 71: a3.lowpassResonance, 76: a3.highpassResonance } }], m = s2 = void 0 === a3.volume ? i2(s2, 127) : 127 * a3.volume & 127, p = a3.frequency, d = a3.note || 0, f = 12 + (p ? n(p) : "string" == typeof d ? e2.noteStringToC0Distance(d) : d) & 127;
            u.forEach((e3) => Object.keys(e3.data).forEach((t5) => {
              let i3 = e3.data[t5];
              void 0 !== i3 && l2({ timeMS: r2, type: "CTRL_CHG", data: [176, parseInt(t5, 10), e3.valMap(i3)] });
            })), c2 && (l2({ timeMS: r2, type: "NON", data: [144, f, m] }), l2({ timeMS: c2, type: "NOF", data: [128, f, m] }));
          }), a2;
        }, h = (e3, t3) => {
          let i3 = [];
          if (t3 && i3.push(0, 192, 127 & t3), e3) {
            let t4 = [];
            for (let i4 = 0; i4 < e3.length; ++i4) {
              let n2 = e3.charCodeAt(i4);
              n2 < 128 && t4.push(n2);
            }
            return i3.concat([0, 255, 3], l(t4.length), t4);
          }
          return i3;
        }, c = (e3, t3, i3, n2) => {
          let o2 = 0, c2 = h(i3, n2), u = r(e3).reduce((e4, t4) => {
            let i4 = l(t4.timeMS - o2);
            return o2 = t4.timeMS, e4.concat(i4, t4.data);
          }, []), m = [0, 255, 47, 0], p = (t3 ? a.length : 0) + c2.length + u.length + m.length;
          return [77, 84, 114, 107, s(3, p), s(2, p), s(1, p), s(0, p)].concat(t3 ? a : [], c2, u, m);
        };
        return function(e3) {
          let t3 = e3.filter((e4) => !!e4.events.length), i3 = t3.length, n2 = i3 > 1;
          return new Uint8Array(o(n2 ? i3 + 1 : i3).concat(n2 ? c([], true) : [], t3.reduce((e4, t4) => {
            let i4 = t4.engine;
            return e4.concat(c(t4.events, !n2, i4.midiTrackName, i4.midiInstrument));
          }, [])));
        };
      }), i(t, "Extensions/DownloadURL.js", [t["Core/Globals.js"]], function(e2) {
        let { isSafari: t2, win: i2, win: { document: n } } = e2, s = i2.URL || i2.webkitURL || i2;
        function o(e3) {
          let t3 = e3.replace(/filename=.*;/, "").match(/data:([^;]*)(;base64)?,([A-Z+\d\/]+)/i);
          if (t3 && t3.length > 3 && i2.atob && i2.ArrayBuffer && i2.Uint8Array && i2.Blob && s.createObjectURL) {
            let e4 = i2.atob(t3[3]), n2 = new i2.ArrayBuffer(e4.length), o2 = new i2.Uint8Array(n2);
            for (let t4 = 0; t4 < o2.length; ++t4) o2[t4] = e4.charCodeAt(t4);
            return s.createObjectURL(new i2.Blob([o2], { type: t3[1] }));
          }
        }
        return { dataURLtoBlob: o, downloadURL: function(e3, s2) {
          let a = i2.navigator, l = n.createElement("a");
          if ("string" != typeof e3 && !(e3 instanceof String) && a.msSaveOrOpenBlob) {
            a.msSaveOrOpenBlob(e3, s2);
            return;
          }
          if (e3 = "" + e3, a.userAgent.length > 1e3) throw Error("Input too long");
          let r = /Edge\/\d+/.test(a.userAgent);
          if ((t2 && "string" == typeof e3 && 0 === e3.indexOf("data:application/pdf") || r || e3.length > 2e6) && !(e3 = o(e3) || "")) throw Error("Failed to convert to blob");
          if (void 0 !== l.download) l.href = e3, l.download = s2, n.body.appendChild(l), l.click(), n.body.removeChild(l);
          else try {
            if (!i2.open(e3, "chart")) throw Error("Failed to open window");
          } catch {
            i2.location.href = e3;
          }
        } };
      }), i(t, "Extensions/Sonification/SonificationTimeline.js", [t["Extensions/Sonification/TimelineChannel.js"], t["Extensions/Sonification/MIDI.js"], t["Extensions/DownloadURL.js"], t["Core/Utilities.js"]], function(e2, t2, i2, n) {
        let { downloadURL: s } = i2, { defined: o, find: a, merge: l } = n;
        return class {
          constructor(e3, t3) {
            this.chart = t3, this.isPaused = false, this.isPlaying = false, this.channels = [], this.scheduledCallbacks = [], this.playTimestamp = 0, this.resumeFromTime = 0, this.options = e3 || {};
          }
          addChannel(t3, i3, n2 = false, s2) {
            if ("instrument" === t3 && !i3.scheduleEventAtTime || "speech" === t3 && !i3.sayAtTime) throw Error("Highcharts Sonification: Invalid channel engine.");
            let o2 = new e2(t3, i3, n2, s2);
            return this.channels.push(o2), o2;
          }
          play(t3, i3 = true, n2 = true, s2) {
            this.isPlaying ? this.cancel() : this.clearScheduledCallbacks(), this.onEndArgument = s2, this.playTimestamp = Date.now(), this.resumeFromTime = 0, this.isPaused = false, this.isPlaying = true;
            let o2 = this.options.skipThreshold || 2, r = this.options.onPlay, h = this.options.showTooltip, c = this.options.showCrosshair, u = t3 ? function(t4, i4) {
              let n3 = i4.map((e3) => (e3.cancel(), { channel: e3, filteredEvents: e3.muted ? [] : e3.events.filter(t4) })), s3 = n3.reduce((e3, t5) => Math.min(e3, t5.filteredEvents.length ? t5.filteredEvents[0].time : 1 / 0), 1 / 0);
              return n3.map((t5) => new e2(t5.channel.type, t5.channel.engine, t5.channel.showPlayMarker, t5.filteredEvents.map((e3) => l(e3, { time: e3.time - s3 })), t5.channel.muted));
            }(t3, this.playingChannels || this.channels) : this.channels, m = (e3) => Object.keys(e3.speechOptions || {}).concat(Object.keys(e3.instrumentEventOptions || {})).join(), p = [];
            i3 && (this.playingChannels = u), r && r({ chart: this.chart, timeline: this });
            let d = 0;
            u.forEach((e3) => {
              if (e3.muted) return;
              let t4 = e3.events.length, i4 = -1 / 0, n3 = -1 / 0, s3 = "";
              d = Math.max(e3.events[t4 - 1] && e3.events[t4 - 1].time || 0, d);
              for (let l2 = 0; l2 < t4; ++l2) {
                let r2 = e3.events[l2], u2 = m(r2);
                if (u2 === s3 && r2.time - n3 < o2) continue;
                s3 = u2, n3 = r2.time, "instrument" === e3.type ? e3.engine.scheduleEventAtTime(r2.time / 1e3, r2.instrumentEventOptions || {}) : e3.engine.sayAtTime(r2.time, r2.message || "", r2.speechOptions || {});
                let d2 = r2.relatedPoint, f2 = d2 && d2.series && d2.series.chart, y2 = r2.callback || d2 && (h || c) && false !== e3.showPlayMarker && (r2.time - i4 > 50 || l2 === t4 - 1);
                d2 && p.push(d2), y2 && (this.scheduledCallbacks.push(setTimeout(() => {
                  if (r2.callback && r2.callback(), d2) {
                    if (c) {
                      let e4 = d2.series;
                      e4 && e4.xAxis && e4.xAxis.crosshair && e4.xAxis.drawCrosshair(void 0, d2), e4 && e4.yAxis && e4.yAxis.crosshair && e4.yAxis.drawCrosshair(void 0, d2);
                    }
                    h && !(f2 && f2.hoverPoints && f2.hoverPoints.length > 1 && a(f2.hoverPoints, (e4) => e4 === d2) && d2.onMouseOver) && d2.onMouseOver();
                  }
                }, r2.time)), i4 = r2.time);
              }
            });
            let f = this.options.onEnd, y = this.options.onStop;
            this.scheduledCallbacks.push(setTimeout(() => {
              let e3 = this.chart, t4 = { chart: e3, timeline: this, pointsPlayed: p };
              this.isPlaying = false, n2 && this.resetPlayState(), y && y(t4), f && f(t4), s2 && s2(t4), e3 && (e3.tooltip && e3.tooltip.hide(0), e3.hoverSeries && e3.hoverSeries.onMouseOut(), e3.axes.forEach((e4) => e4.hideCrosshair()));
            }, d + 250)), this.resumeFromTime = i3 ? d : this.getLength();
          }
          pause() {
            return this.isPaused = true, this.cancel(), this.resumeFromTime = Date.now() - this.playTimestamp - 10, this.resumeFromTime;
          }
          getCurrentTime() {
            return this.isPlaying ? Date.now() - this.playTimestamp : this.resumeFromTime;
          }
          getLength() {
            return this.channels.reduce((e3, t3) => {
              let i3 = t3.events[t3.events.length - 1];
              return i3 ? Math.max(i3.time, e3) : e3;
            }, 0);
          }
          resume() {
            if (this.playingChannels) {
              let e3 = this.resumeFromTime - 50;
              this.play((t3) => t3.time > e3, false, false, this.onEndArgument), this.playTimestamp -= e3;
            } else this.play(void 0, false, false, this.onEndArgument);
          }
          anchorPlayMoment(e3, t3) {
            this.isPlaying && this.pause();
            let i3 = 0;
            this.play((t4, n2, s2) => {
              let o2 = e3(t4, n2, s2);
              return o2 && t4.time > i3 && (i3 = t4.time), o2;
            }, false, false, t3), this.playingChannels = this.playingChannels || this.channels, this.isPaused = true, this.isPlaying = false, this.resumeFromTime = i3;
          }
          playAdjacent(e3, t3, i3, n2) {
            this.isPlaying && this.pause();
            let s2 = this.resumeFromTime, o2 = this.channels.reduce((t4, i4) => {
              let o3 = n2 ? i4.events.filter(n2) : i4.events, a2 = 0, l2 = o3.length, r = t4;
              for (; a2 < l2; ) {
                let t5 = a2 + l2 >> 1, i5 = o3[t5].time, n3 = i5 - s2;
                n3 > 0 ? (e3 && i5 < r && (r = i5), l2 = t5) : n3 < 0 ? (!e3 && i5 > r && (r = i5), a2 = t5 + 1) : e3 ? a2 = t5 + 1 : l2 = t5;
              }
              return r;
            }, e3 ? 1 / 0 : -1 / 0);
            if (o2 === 1 / 0 || o2 === -1 / 0) {
              i3 && i3({ chart: this.chart, timeline: this, attemptedNext: e3 });
              return;
            }
            this.anchorPlayMoment((t4, i4, a2) => {
              let l2 = e3 ? t4.time > s2 && t4.time <= o2 + 0.02 : t4.time < s2 && t4.time >= o2 - 0.02;
              return n2 ? l2 && n2(t4, i4, a2) : l2;
            }, t3);
          }
          playClosestToPropValue(e3, t3, i3, n2, s2) {
            let a2 = (e4, t4, i4) => !!(s2 ? s2(e4, t4, i4) && e4.relatedPoint : e4.relatedPoint), l2 = 1 / 0, r = null;
            (this.playingChannels || this.channels).forEach((i4) => {
              let n3 = i4.events, s3 = n3.length;
              for (; s3--; ) {
                if (!a2(n3[s3], s3, n3)) continue;
                let i5 = n3[s3].relatedPoint[e3], h = o(i5) && Math.abs(t3 - i5);
                false !== h && h < l2 && (l2 = h, r = n3[s3]);
              }
            }), r ? (this.play((e4) => !!(r && e4.time < r.time + 1 && e4.time > r.time - 1 && e4.relatedPoint === r.relatedPoint), false, false, i3), this.playingChannels = this.playingChannels || this.channels, this.isPaused = true, this.isPlaying = false, this.resumeFromTime = r.time) : n2 && n2({ chart: this.chart, timeline: this });
          }
          getEventsForPoint(e3) {
            return this.channels.reduce((t3, i3) => {
              let n2 = i3.events.filter((t4) => t4.relatedPoint === e3);
              return t3.concat(n2);
            }, []);
          }
          playSegment(e3, t3) {
            let i3 = { first: 1 / 0, last: -1 / 0 };
            if (this.channels.forEach((e4) => {
              e4.events.length && (i3.first = Math.min(e4.events[0].time, i3.first), i3.last = Math.max(e4.events[e4.events.length - 1].time, i3.last));
            }), i3.first < 1 / 0) {
              let n2 = (i3.last - i3.first) / 100, s2 = i3.first + e3 * n2, o2 = s2 + n2;
              if (!this.channels.some((e4) => {
                let t4 = e4.events, i4 = 0, n3 = t4.length;
                for (; i4 < n3; ) {
                  let e5 = i4 + n3 >> 1, a2 = t4[e5].time;
                  if (a2 < s2) i4 = e5 + 1;
                  else {
                    if (!(a2 > o2)) return true;
                    n3 = e5;
                  }
                }
                return false;
              })) return;
              this.play((e4) => e4.time >= s2 && e4.time <= o2, false, false, t3), this.playingChannels = this.playingChannels || this.channels, this.isPaused = true, this.isPlaying = false, this.resumeFromTime = o2;
            }
          }
          getLastPlayedPoint(e3) {
            let t3 = this.getCurrentTime(), i3 = this.playingChannels || this.channels, n2 = 1 / 0, s2 = null;
            return i3.forEach((i4) => {
              let o2 = i4.events.filter((i5, n3, s3) => !!(i5.relatedPoint && i5.time <= t3 && (!e3 || e3(i5, n3, s3)))), a2 = o2[o2.length - 1];
              if (a2) {
                let e4 = Math.abs(a2.time - t3);
                e4 < n2 && (n2 = e4, s2 = a2.relatedPoint);
              }
            }), s2;
          }
          reset() {
            this.isPlaying && this.cancel(), this.resetPlayState();
          }
          cancel() {
            let e3 = this.options.onStop;
            e3 && e3({ chart: this.chart, timeline: this }), this.isPlaying = false, this.channels.forEach((e4) => e4.cancel()), this.playingChannels && this.playingChannels !== this.channels && this.playingChannels.forEach((e4) => e4.cancel()), this.clearScheduledCallbacks(), this.resumeFromTime = 0;
          }
          destroy() {
            this.cancel(), this.playingChannels && this.playingChannels !== this.channels && this.playingChannels.forEach((e3) => e3.destroy()), this.channels.forEach((e3) => e3.destroy());
          }
          setMasterVolume(e3) {
            this.channels.forEach((t3) => t3.engine.setMasterVolume(e3));
          }
          getMIDIData() {
            return t2(this.channels.filter((e3) => "instrument" === e3.type));
          }
          downloadMIDI(e3) {
            let t3 = this.getMIDIData(), i3 = (e3 || this.chart && this.chart.options.title && this.chart.options.title.text || "chart") + ".mid", n2 = new Blob([t3], { type: "application/octet-stream" }), o2 = window.URL.createObjectURL(n2);
            s(o2, i3), window.URL.revokeObjectURL(o2);
          }
          resetPlayState() {
            delete this.playingChannels, delete this.onEndArgument, this.playTimestamp = this.resumeFromTime = 0, this.isPaused = false;
          }
          clearScheduledCallbacks() {
            this.scheduledCallbacks.forEach(clearTimeout), this.scheduledCallbacks = [];
          }
        };
      }), i(t, "Extensions/Sonification/TimelineFromChart.js", [t["Extensions/Sonification/SonificationTimeline.js"], t["Extensions/Sonification/SonificationInstrument.js"], t["Extensions/Sonification/SonificationSpeaker.js"], t["Core/Utilities.js"], t["Core/Templating.js"]], function(e2, t2, i2, n, s) {
        let { clamp: o, defined: a, extend: l, getNestedProperty: r, merge: h, pick: c } = n, { format: u } = s, m = (e3) => /^([a-g][#b]?)[0-8]$/i.test(e3);
        function p(e3, t3) {
          let i3;
          if (t3) {
            if ("number" == typeof (i3 = e3[t3])) return i3;
            i3 = r(t3, e3);
          }
          return "number" == typeof i3 ? i3 : void 0;
        }
        function d(e3, t3, i3, n2, s2) {
          let a2 = t3.max - t3.min;
          if (a2 <= 0) return i3.min;
          let l2 = i3.max - i3.min, r2 = l2 * (e3 - t3.min) / a2;
          if (s2) {
            let i4 = t3.min > 0 ? (e4) => Math.log(e4) / Math.LOG10E : (e4) => {
              let t4 = Math.abs(e4);
              t4 < 10 && (t4 += (10 - t4) / 10);
              let i5 = Math.log(t4) / Math.LN10;
              return e4 < 0 ? -i5 : i5;
            }, n3 = i4(t3.min);
            r2 = l2 * (i4(e3) - n3) / (i4(t3.max) - n3);
          }
          return o(n2 ? i3.max - r2 : i3.min + r2, i3.min, i3.max);
        }
        function f(e3, t3, i3, n2, s2, o2, h2) {
          return c(function(e4, t4, i4, n3, s3, o3) {
            if ("number" == typeof s3) return s3;
            if ("function" == typeof s3) return s3(l({ time: 0 }, e4));
            let h3 = s3, u2 = n3.mapFunction, m2 = n3.min, p2 = n3.max, f2 = n3.within, y2;
            if ("object" == typeof s3 && (h3 = s3.mapTo, u2 = s3.mapFunction || u2, m2 = c(s3.min, m2), p2 = c(s3.max, p2), f2 = s3.within || n3.within, y2 = s3.scale), !h3) return null;
            let g2 = "-" === h3.charAt(0);
            g2 && (h3 = h3.slice(1));
            let v2 = e4.value, q2 = "value" === h3 && void 0 !== v2 && o3;
            if (!q2) {
              let t5 = s3.value;
              if (void 0 !== t5) v2 = t5;
              else {
                if (!e4.point) return null;
                v2 = e4.point[h3];
              }
              void 0 === v2 && (v2 = r(h3, e4.point));
            }
            if ("number" != typeof v2 || null === v2) return null;
            let T = null;
            if (e4.point) {
              if ("xAxis" === f2 || "yAxis" === f2) {
                let t5 = e4.point.series[f2];
                t5 && a(t5.dataMin) && a(t5.dataMax) && (T = { min: t5.dataMin, max: t5.dataMax });
              } else ("series" === f2 || i4) && e4.point.series && (T = t4.seriesExtremes[e4.point.series.index][q2 ? o3 : h3]);
            }
            if (T || (T = t4.globalExtremes[q2 ? o3 : h3]), y2) {
              let e5 = [], t5 = Math.floor(m2 / 12), i5 = Math.ceil(p2 / 12) + 1, n4 = y2.length;
              for (let s5 = t5; s5 < i5; ++s5) for (let t6 = 0; t6 < n4; ++t6) {
                let i6 = 12 * s5 + y2[t6];
                i6 >= m2 && i6 <= p2 && e5.push(i6);
              }
              let s4 = d(v2, T, { min: 0, max: e5.length - 1 }, g2, "logarithmic" === u2);
              return e5[Math.round(s4)];
            }
            return d(v2, T, { min: m2, max: p2 }, g2, "logarithmic" === u2);
          }(e3, t3, i3, l({ min: 0, max: 1, mapTo: "y", mapFunction: "linear", within: "chart" }, o2 || {}), n2, h2), s2);
        }
        function y(e3, n2, s2, o2) {
          let a2 = o2.mapping || {}, l2 = "speech" === o2.type ? new i2({ language: o2.language, name: o2.preferredVoice }) : new t2(n2, s2, { capabilities: { pan: !!a2.pan, tremolo: !!a2.tremolo, filters: !!(a2.highpass || a2.lowpass) }, synthPatch: o2.instrument, midiTrackName: o2.midiName });
          return e3.addChannel(o2.type || "instrument", l2, c(o2.showPlayMarker, true));
        }
        function g(e3, i3, n2, s2, o2, a2) {
          let r2 = (t3, i4, o3, l2) => f(e3, s2, false, (l2 || n2)[t3], i4, o3, a2), h2 = [], c2 = { noteDuration: r2("noteDuration", 200, { min: 40, max: 1e3 }), pan: r2("pan", 0, { min: -1, max: 1 }), volume: r2("volume", 1, { min: 0.1, max: 1 }) };
          n2.frequency && (c2.frequency = r2("frequency", 440, { min: 50, max: 6e3 })), n2.lowpass && (c2.lowpassFreq = r2("frequency", 2e4, { min: 0, max: 2e4 }, n2.lowpass), c2.lowpassResonance = r2("resonance", 0, { min: -6, max: 12 }, n2.lowpass)), n2.highpass && (c2.highpassFreq = r2("frequency", 2e4, { min: 0, max: 2e4 }, n2.highpass), c2.highpassResonance = r2("resonance", 0, { min: -6, max: 12 }, n2.highpass)), n2.tremolo && (c2.tremoloDepth = r2("depth", 0, { min: 0, max: 0.8 }, n2.tremolo), c2.tremoloSpeed = r2("speed", 0, { min: 0, max: 0.8 }, n2.tremolo));
          let u2 = r2("gapBetweenNotes", 150, { min: 50, max: 1e3 }), p2 = r2("playDelay", 0, { max: 200 }), d2 = (n3, r3 = 0) => {
            let d3 = n3;
            n3.mapTo ? ("string" == typeof n3.min && (d3.min = t2.noteStringToC0Distance(n3.min)), "string" == typeof n3.max && (d3.max = t2.noteStringToC0Distance(n3.max))) : "string" == typeof n3 && m(n3) && (d3 = t2.noteStringToC0Distance(n3)), c2.note = f(e3, s2, false, d3, -1, { min: 0, max: 107 }, a2), c2.note > -1 && (o2 && (c2.note = Math.round(c2.note)), h2.push(i3.addEvent({ time: e3.time + p2 + u2 * r3, relatedPoint: e3.point, instrumentEventOptions: void 0 !== r3 ? l({}, c2) : c2 })));
          };
          return n2.pitch && n2.pitch.constructor === Array ? n2.pitch.forEach(d2) : n2.pitch ? d2(n2.pitch) : n2.frequency && h2.push(i3.addEvent({ time: e3.time + p2, relatedPoint: e3.point, instrumentEventOptions: c2 })), h2;
        }
        function v(e3, t3, i3, n2, s2) {
          var o2;
          let a2 = (t4, o3, a3) => f(e3, n2, false, i3[t4], o3, a3, s2), l2 = a2("playDelay", 0, { max: 200 }), r2 = a2("pitch", 1, { min: 0.3, max: 2 }), h2 = a2("rate", 1, { min: 0.4, max: 4 }), c2 = a2("volume", 1, { min: 0.1 }), m2 = u("function" == typeof (o2 = i3.text) ? o2(e3) : o2, e3, e3.point && e3.point.series.chart);
          if (m2) return t3.addEvent({ time: e3.time + l2, relatedPoint: e3.point, speechOptions: { pitch: r2, rate: h2, volume: c2 }, message: m2 });
        }
        function q(e3, t3, i3) {
          if ("function" == typeof t3) return t3(e3);
          if ("object" == typeof t3) {
            let n2 = t3.prop, s2 = c(e3.value, e3.point && p(e3.point, n2));
            if ("number" != typeof s2) return false;
            let o2 = true, a2 = t3.crossingUp, l2 = t3.crossingDown, r2 = "number" == typeof i3;
            o2 = a2 && l2 ? r2 && (i3 < a2 && s2 >= a2 || i3 > l2 && s2 <= l2) : (void 0 === a2 || r2 && i3 < a2 && s2 >= a2) && (void 0 === l2 || r2 && i3 > l2 && s2 <= l2);
            let h2 = c(t3.max, 1 / 0), u2 = c(t3.min, -1 / 0);
            return s2 <= h2 && s2 >= u2 && o2;
          }
          return true;
        }
        return function(t3, i3, n2) {
          let s2 = n2.options.sonification || {}, o2 = s2.defaultInstrumentOptions, a2 = s2.defaultSpeechOptions, u2 = h({ enabled: true, groupTimespan: 15, algorithm: "minmax", prop: "y" }, s2.pointGrouping), T = s2.globalTracks || [], w = s2.globalContextTracks || [], x = "sequential" === s2.order, E = Math.max(50, s2.duration - 300), N = s2.afterSeriesWait, S = s2.events || {}, k = function(e3) {
            let t4 = e3.options.sonification || {}, i4 = (t4.defaultInstrumentOptions || {}).mapping || { time: "x", pitch: "y" }, n3 = t4.defaultSpeechOptions && t4.defaultSpeechOptions.mapping || {}, s3 = [], o3 = {}, a3 = (e4, t5) => {
              null !== t5 ? (s3[t5] = s3[t5] || {}, s3[t5][e4] = true) : o3[e4] = true;
            }, l2 = {}, c2 = {}, u3 = (e4, t5, i5) => {
              let n4 = (e5) => "-" === e5.charAt(0) ? e5.slice(1) : e5;
              if ("string" == typeof t5 && "text" !== e4) {
                if ("pitch" === e4 && m(t5)) return;
                "time" === e4 && (c2[t5] = true, a3(t5, i5)), l2[n4(t5)] = true;
                return;
              }
              if (t5 && t5.mapTo && "string" == typeof t5.mapTo) {
                let s4 = n4(t5.mapTo);
                "time" === e4 && a3(s4, i5), ("time" === e4 || "series" === t5.within) && (c2[s4] = true), l2[s4] = true;
                return;
              }
              ["tremolo", "lowpass", "highpass"].indexOf(e4) > -1 && "object" == typeof t5 && Object.keys(t5).forEach((e5) => u3(e5, t5[e5], i5));
            }, p2 = (e4, t5) => {
              Object.keys(e4).forEach((i5) => u3(i5, e4[i5], t5));
            }, d2 = (e4) => e4.forEach((e5) => {
              l2[e5.valueProp || "x"] = c2[e5.valueProp || "x"] = true;
            });
            p2(i4, null), p2(n3, null), d2(t4.globalContextTracks || []);
            let f2 = Object.keys(o3).length;
            return e3.series.forEach((e4) => {
              let t5 = e4.options.sonification;
              if (e4.visible && !(t5 && false === t5.enabled) && (f2 && (s3[e4.index] = h(o3)), t5)) {
                let i5 = (t5.defaultInstrumentOptions || {}).mapping, n4 = (t5.defaultSpeechOptions || {}).mapping;
                i5 && p2(i5, e4.index), n4 && p2(n4, e4.index), d2(t5.contextTracks || []), (t5.tracks || []).concat(t5.contextTracks || []).forEach((t6) => {
                  t6.mapping && p2(t6.mapping, e4.index);
                });
              }
            }), { seriesTimeProps: s3, ...function(e4, t5, i5) {
              let n4 = e4.series, s4 = t5.length, o4 = i5.length, a4 = (e5) => e5.reduce((e6, t6) => (e6[t6] = { min: 1 / 0, max: -1 / 0 }, e6), {}), l3 = (e5, t6, i6) => {
                let n5 = t6[i6];
                void 0 === n5 && (n5 = r(i6, t6)), "number" == typeof n5 && (e5[i6].min = Math.min(e5[i6].min, n5), e5[i6].max = Math.max(e5[i6].max, n5));
              }, h2 = a4(t5), c3 = n4.length, u4 = Array(c3);
              for (; c3--; ) {
                let e5 = a4(i5), r2 = n4[c3].options;
                if (!n4[c3].visible || r2 && r2.sonification && false === r2.sonification.enabled) continue;
                let m2 = n4[c3].points || [], p3 = m2.length;
                for (; p3--; ) {
                  let n5 = s4;
                  for (; n5--; ) l3(h2, m2[p3], t5[n5]);
                  for (n5 = o4; n5--; ) l3(e5, m2[p3], i5[n5]);
                }
                u4[c3] = e5;
              }
              return { globalExtremes: h2, seriesExtremes: u4 };
            }(e3, Object.keys(l2), Object.keys(c2)) };
          }(n2), P = new e2({ onPlay: S.onPlay, onEnd: S.onEnd, onStop: S.onStop, showCrosshair: s2.showCrosshair, showTooltip: s2.showTooltip }, n2);
          n2.sonification && (n2.sonification.propMetrics = k);
          let M = 0;
          return n2.series.forEach((e3, n3) => {
            let s3 = e3.options.sonification || {};
            if (e3.visible && false !== s3.enabled) {
              let r2;
              let m2 = x ? function(e4, t4, i4, n4) {
                let s4, o3;
                let a3 = t4 - (e4.chart.series.length - 1) * n4;
                if (i4.seriesTimeProps.every((e5) => {
                  let t5 = Object.keys(e5);
                  return !(t5.length > 1) && (s4 || (s4 = t5[0]), s4 === t5[0]);
                })) {
                  let t5 = i4.seriesExtremes[e4.index][s4];
                  o3 = Math.round((t5.max - t5.min) / i4.seriesExtremes.reduce((e5, t6) => t6[s4] ? e5 + t6[s4].max - t6[s4].min : e5, 0) * a3);
                } else {
                  let t5 = e4.chart.series.reduce((e5, t6) => e5 + t6.points.length, 0);
                  o3 = Math.round((e4.points || []).length / t5 * a3);
                }
                return Math.max(50, o3);
              }(e3, E, k, N) : E, C = h(o2, s3.defaultInstrumentOptions), b = h(a2, s3.defaultSpeechOptions), A = h(u2, s3.pointGrouping), O = (s3.tracks || [C]).concat(T), I = P.channels.length && !x ? s3.contextTracks || [] : (s3.contextTracks || []).concat(w), V = [];
              O.forEach((n4) => {
                let s4 = h({ pointGrouping: A, midiName: n4.midiName || e3.name }, "speech" === n4.type ? b : C, n4), o3 = s4.pointGrouping, a3 = s4.activeWhen, l2 = (e4) => {
                  "object" == typeof a3 && a3.prop && (r2 = p(e4, a3.prop));
                }, u3 = y(P, t3, i3, s4), d2 = (e4) => V.push(...function(e5, t4, i4, n5) {
                  let s5 = [];
                  if ("speech" === i4.type && i4.mapping) {
                    let o4 = v(e5, t4, i4.mapping, n5);
                    o4 && (s5 = [o4]);
                  } else i4.mapping && (s5 = g(e5, t4, i4.mapping, n5, c(i4.roundToMusicalNotes, true)));
                  return s5;
                }(e4, u3, s4, k)), T2 = [], w2 = 0, E2 = (e4) => {
                  if (1 === T2.length) d2({ point: T2[0].point, time: w2 + e4 / 2 });
                  else {
                    let t4 = function(e5, t5) {
                      let i5 = e5.algorithm || "minmax", n5 = (e6) => t5[e6] ? [t5[e6].point] : [];
                      if ("first" === i5) return n5(0);
                      if ("last" === i5) return n5(t5.length - 1);
                      if ("middle" === i5) return n5(t5.length >> 1);
                      if ("firstlast" === i5) return n5(0).concat(n5(t5.length - 1));
                      if ("minmax" === i5) {
                        let i6, n6, s5, o4;
                        let a4 = e5.prop || "y";
                        if (t5.forEach((e6) => {
                          let t6 = p(e6.point, a4);
                          void 0 !== t6 && ((!i6 || t6 < s5) && (i6 = e6, s5 = t6), (!n6 || t6 > o4) && (n6 = e6, o4 = t6));
                        }), i6 && n6) return i6.point === n6.point ? [i6.point] : i6.time > n6.time ? [n6.point, i6.point] : [i6.point, n6.point];
                      }
                      return [];
                    }(o3, T2), i4 = e4 / t4.length;
                    t4.forEach((e5, t5) => d2({ point: e5, time: w2 + i4 / 2 + i4 * t5 }));
                  }
                  T2 = [];
                };
                (e3.points || []).forEach((t4, i4) => {
                  var n5;
                  let h2 = i4 === e3.points.length - 1, c2 = (n5 = M, f({ point: t4, time: 0 }, k, x, s4.mapping && s4.mapping.time || 0, 0, { min: 0, max: m2, mapTo: "x" }) + n5), u4 = { point: t4, time: c2 };
                  if (!s4.mapping || !q(u4, a3, r2)) {
                    l2(t4), h2 && T2.length && E2(T2[T2.length - 1].time - T2[0].time);
                    return;
                  }
                  if (l2(t4), o3.enabled) {
                    let e4 = c2 - w2, t5 = o3.groupTimespan, i5 = h2 && e4 <= t5 ? e4 : t5;
                    h2 || e4 > t5 ? (e4 <= t5 && T2.push(u4), E2(i5), w2 = Math.floor(c2 / t5) * t5, h2 && e4 > t5 ? d2({ point: u4.point, time: w2 + i5 / 2 }) : T2 = [u4]) : T2.push(u4);
                  } else d2(u4);
                });
              });
              let j = V.reduce((e4, t4) => t4.time < e4.time ? t4 : e4, { time: 1 / 0 }), F = V.reduce((e4, t4) => t4.time > e4.time ? t4 : e4, { time: -1 / 0 });
              j.callback = S.onSeriesStart ? S.onSeriesStart.bind(null, { series: e3, timeline: P }) : void 0, F.callback = S.onSeriesEnd ? S.onSeriesEnd.bind(null, { series: e3, timeline: P }) : void 0, I.forEach((e4) => {
                let s4 = "speech" === e4.type ? h(a2, e4) : h(o2, { mapping: { pitch: { mapTo: "value" } } }, e4), u3 = y(P, t3, i3, s4);
                r2 = void 0;
                let { timeInterval: p2, valueInterval: f2 } = s4, T2 = s4.valueProp || "x", w2 = s4.activeWhen, x2 = k.seriesExtremes[n3][T2], E2 = (e5, t4) => {
                  if (!s4.mapping || !q({ time: e5, value: t4 }, "object" == typeof w2 ? l({ prop: T2 }, w2) : w2, r2)) {
                    r2 = t4;
                    return;
                  }
                  r2 = t4, "speech" === s4.type ? v({ time: e5, value: t4 }, u3, s4.mapping, k, T2) : g({ time: e5, value: t4 }, u3, s4.mapping, k, c(s4.roundToMusicalNotes, true), T2);
                };
                if (p2) {
                  let e5 = 0;
                  for (; e5 <= m2; ) {
                    let t4 = d(e5, { min: 0, max: m2 }, x2);
                    E2(e5 + M, t4), e5 += p2;
                  }
                }
                if (f2) {
                  let e5 = x2.min;
                  for (; e5 <= x2.max; ) E2(d(e5, x2, { min: 0, max: m2 }, false, "logarithmic" === s4.valueMapFunction) + M, e5), e5 += f2;
                }
              }), x && (M += m2 + N);
            }
          }), P;
        };
      }), i(t, "Extensions/Sonification/Sonification.js", [t["Core/Defaults.js"], t["Core/Utilities.js"], t["Core/Globals.js"], t["Extensions/Sonification/Options.js"], t["Extensions/Sonification/SonificationInstrument.js"], t["Extensions/Sonification/SonificationSpeaker.js"], t["Extensions/Sonification/SynthPatch.js"], t["Extensions/Sonification/InstrumentPresets.js"], t["Extensions/Sonification/TimelineFromChart.js"]], function(e2, t2, i2, n, s, o, a, l, r) {
        let { defaultOptions: h, getOptions: c } = e2, { addEvent: u, extend: m, fireEvent: p, merge: d, pick: f } = t2, { doc: y, win: g } = i2;
        class v {
          constructor(e3) {
            this.chart = e3, this.retryContextCounter = 0, this.lastUpdate = 0, this.unbindKeydown = u(y, "keydown", function(t3) {
              e3 && e3.sonification && ("Esc" === t3.key || "Escape" === t3.key) && e3.sonification.cancel();
            });
            try {
              this.audioContext = new g.AudioContext(), this.audioContext.suspend(), this.audioDestination = this.audioContext.destination;
            } catch (e4) {
            }
          }
          setAudioDestination(e3) {
            this.audioDestination = e3, this.update();
          }
          isPlaying() {
            return !!this.timeline && this.timeline.isPlaying;
          }
          playSegment(e3, t3) {
            this.ready(this.playSegment.bind(this, e3, t3)) && this.timeline && this.timeline.playSegment(e3, t3);
          }
          playAdjacent(e3, t3, i3) {
            if (this.ready(this.playAdjacent.bind(this, e3, t3, i3)) && this.timeline) {
              let n2 = this.chart.options.sonification, s2 = n2 && n2.events && n2.events.onBoundaryHit;
              s2 || this.initBoundaryInstrument(), this.timeline.playAdjacent(e3, t3, s2 || (() => {
                this.defaultBoundaryHit();
              }), i3);
            }
          }
          playAdjacentSeries(e3, t3 = "x", i3) {
            let n2 = this.getLastPlayedPoint();
            if (n2) {
              let s2 = n2.series.index + (e3 ? 1 : -1);
              return this.playClosestToProp(t3, n2[t3], (e4) => !!e4.relatedPoint && e4.relatedPoint.series.index === s2, i3), this.chart.series[s2] || null;
            }
            return null;
          }
          playClosestToProp(e3, t3, i3, n2) {
            if (this.ready(this.playClosestToProp.bind(this, e3, t3, i3, n2)) && this.timeline) {
              let s2 = this.chart.options.sonification, o2 = s2 && s2.events && s2.events.onBoundaryHit;
              o2 || this.initBoundaryInstrument(), this.timeline.playClosestToPropValue(e3, t3, n2, o2 || (() => this.defaultBoundaryHit()), i3);
            }
          }
          getLastPlayedPoint() {
            return this.timeline ? this.timeline.getLastPlayedPoint() : null;
          }
          playNote(e3, t3, i3 = 0) {
            if (!this.ready(this.playNote.bind(this, e3, t3))) return;
            let n2 = t3.noteDuration = t3.noteDuration || 500, o2 = new s(this.audioContext, this.audioDestination, { synthPatch: e3, capabilities: { filters: true, tremolo: true, pan: true } });
            o2.scheduleEventAtTime(i3 / 1e3, t3), setTimeout(() => o2 && o2.destroy(), i3 + n2 + 500);
          }
          speak(e3, t3, i3 = 0) {
            new o(d({ language: "en-US", rate: 1.5, volume: 0.4 }, t3 || {})).sayAtTime(i3, e3);
          }
          cancel() {
            this.timeline && this.timeline.cancel(), p(this, "cancel");
          }
          downloadMIDI() {
            this.ready(this.downloadMIDI.bind(this)) && this.timeline && (this.timeline.reset(), this.timeline.downloadMIDI());
          }
          sonifyChart(e3, t3) {
            this.ready(this.sonifyChart.bind(this, e3, t3)) && this.timeline && (this.timeline.reset(), this.beforePlay(), this.timeline.play(void 0, void 0, e3, t3));
          }
          sonifySeries(e3, t3, i3) {
            this.ready(this.sonifySeries.bind(this, e3, t3, i3)) && this.timeline && (this.timeline.reset(), this.beforePlay(), this.timeline.play((t4) => !!t4.relatedPoint && t4.relatedPoint.series === e3, void 0, t3, i3));
          }
          sonifyPoint(e3, t3) {
            this.ready(this.sonifyPoint.bind(this, e3, t3)) && this.timeline && (this.timeline.reset(), this.beforePlay(), this.timeline.anchorPlayMoment((t4) => t4.relatedPoint === e3, t3));
          }
          setMasterVolume(e3) {
            this.timeline && this.timeline.setMasterVolume(e3);
          }
          destroy() {
            this.unbindKeydown(), this.timeline && (this.timeline.destroy(), delete this.timeline), this.boundaryInstrument && this.boundaryInstrument.stop(), this.audioContext && (this.audioContext.close(), delete this.audioContext);
          }
          update() {
            let e3 = this.chart.options && this.chart.options.sonification;
            if (!this.ready(this.update.bind(this)) || !e3) return;
            let t3 = Date.now(), i3 = e3.updateInterval;
            if (t3 - this.lastUpdate < i3 && !this.forceReady) {
              clearTimeout(this.scheduledUpdate), this.scheduledUpdate = setTimeout(this.update.bind(this), i3 / 2);
              return;
            }
            let n2 = e3.events || {};
            if (n2.beforeUpdate && n2.beforeUpdate({ chart: this.chart, timeline: this.timeline }), this.lastUpdate = t3, this.timeline && this.timeline.destroy(), this.audioContext && this.audioDestination) {
              this.timeline = r(this.audioContext, this.audioDestination, this.chart);
              let e4 = this.chart.options.sonification;
              this.timeline.setMasterVolume(f(e4 && e4.masterVolume, 1));
            }
            n2.afterUpdate && n2.afterUpdate({ chart: this.chart, timeline: this.timeline });
          }
          ready(e3) {
            return !!this.audioContext && !!this.audioDestination && !!this.chart.options && (!this.chart.options.sonification || false !== this.chart.options.sonification.enabled) && ("suspended" !== this.audioContext.state || this.forceReady ? (this.retryContextCounter = 0, true) : (this.retryContextCounter++ < 20 && setTimeout(() => {
              this.audioContext && "suspended" === this.audioContext.state ? this.audioContext.resume().then(e3) : e3();
            }, 5), false));
          }
          beforePlay() {
            let e3 = this.chart.options.sonification, t3 = e3 && e3.events && e3.events.beforePlay;
            t3 && t3({ chart: this.chart, timeline: this.timeline });
          }
          initBoundaryInstrument() {
            this.boundaryInstrument || (this.boundaryInstrument = new a(this.audioContext, d(l.chop, { masterVolume: 0.3 })), this.boundaryInstrument.startSilently(), this.boundaryInstrument.connect(this.audioDestination));
          }
          defaultBoundaryHit() {
            this.boundaryInstrument && (this.boundaryInstrument.playFreqAtTime(0.1, 1, 200), this.boundaryInstrument.playFreqAtTime(0.2, 1, 200));
          }
        }
        return function(e3) {
          let t3 = [];
          function i3() {
            let t4 = this.sonification, i4 = this.options && this.options.sonification;
            i4 && i4.enabled ? t4 ? t4.update() : (this.sonification = new e3(this), this.sonification.update()) : t4 && (t4.destroy(), delete this.sonification);
          }
          function n2() {
            this && this.sonification && this.sonification.destroy();
          }
          function s2() {
            this.updateSonificationEnabled && this.updateSonificationEnabled();
          }
          function o2(e4) {
            let t4 = e4.options.sonification;
            t4 && (d(true, this.options.sonification, t4), s2.call(this));
          }
          e3.compose = function(e4, a2, l2) {
            -1 === t3.indexOf(e4) && (t3.push(e4), m(e4.prototype, { updateSonificationEnabled: i3, sonify: function(e5) {
              this.sonification && this.sonification.sonifyChart(false, e5);
            }, toggleSonify: function(e5 = true, t4) {
              if (!this.sonification) return;
              let i4 = this.sonification.timeline;
              g.speechSynthesis && g.speechSynthesis.cancel(), i4 && this.sonification.isPlaying() ? e5 ? this.sonification.cancel() : i4.pause() : i4 && i4.isPaused ? i4.resume() : this.sonification.sonifyChart(e5, t4);
            } }), u(e4, "destroy", n2), u(e4, "render", s2), u(e4, "update", o2)), -1 === t3.indexOf(a2) && (t3.push(a2), a2.prototype.sonify = function(e5) {
              this.chart.sonification && this.chart.sonification.sonifySeries(this, false, e5);
            }), -1 === t3.indexOf(l2) && (t3.push(l2), l2.prototype.sonify = function(e5) {
              this.series.chart.sonification && this.series.chart.sonification.sonifyPoint(this, e5);
            });
            let r2 = c().exporting;
            r2 && r2.buttons && r2.buttons.contextButton.menuItems && r2.buttons.contextButton.menuItems.push("separator", "downloadMIDI", "playAsSound");
          };
        }(v || (v = {})), d(true, h, n), v;
      }), i(t, "Extensions/Sonification/Scales.js", [], function() {
        return { minor: [0, 2, 3, 5, 7, 8, 10], dorian: [0, 2, 3, 5, 7, 9, 10], harmonicMinor: [0, 2, 3, 5, 7, 8, 11], phrygian: [0, 1, 3, 5, 7, 8, 11], major: [0, 2, 4, 5, 7, 9, 11], lydian: [0, 2, 4, 6, 7, 9, 11], mixolydian: [0, 2, 4, 5, 7, 9, 10], majorPentatonic: [0, 2, 4, 7, 9], minorPentatonic: [0, 3, 5, 7, 10] };
      }), i(t, "masters/modules/sonification.src.js", [t["Core/Globals.js"], t["Extensions/Sonification/Sonification.js"], t["Extensions/Sonification/SynthPatch.js"], t["Extensions/Sonification/InstrumentPresets.js"], t["Extensions/Sonification/Scales.js"], t["Extensions/Sonification/SonificationInstrument.js"], t["Extensions/Sonification/SonificationSpeaker.js"], t["Extensions/Sonification/SonificationTimeline.js"]], function(e2, t2, i2, n, s, o, a, l) {
        return e2.sonification = { InstrumentPresets: n, Scales: s, SynthPatch: i2, SonificationInstrument: o, SonificationSpeaker: a, SonificationTimeline: l, Sonification: t2 }, t2.compose(e2.Chart, e2.Series, e2.Point), e2;
      });
    });
  }
});
export default require_sonification();
//# sourceMappingURL=highcharts_modules_sonification__js.js.map
