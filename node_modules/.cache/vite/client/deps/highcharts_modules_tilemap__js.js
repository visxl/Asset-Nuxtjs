import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/highcharts/modules/tilemap.js
var require_tilemap = __commonJS({
  "node_modules/highcharts/modules/tilemap.js"(exports, module) {
    !/**
    * Highmaps JS v11.4.7 (2024-08-14)
    *
    * Tilemap module
    *
    * (c) 2010-2024 Highsoft AS
    *
    * License: www.highcharts.com/license
    */
    function(e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = e) : "function" == typeof define && define.amd ? define("highcharts/modules/tilemap", ["highcharts", "highcharts/modules/map"], function(t) {
        return e(t), e.Highcharts = t, e;
      }) : e("undefined" != typeof Highcharts ? Highcharts : void 0);
    }(function(e) {
      "use strict";
      var t = e ? e._modules : {};
      function a(t2, a2, i, s) {
        t2.hasOwnProperty(a2) || (t2[a2] = s.apply(null, i), "function" == typeof CustomEvent && e.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: a2, module: t2[a2] } })));
      }
      a(t, "Series/Tilemap/TilemapPoint.js", [t["Core/Axis/Color/ColorAxisComposition.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2, a2) {
        let { series: { prototype: { pointClass: i } }, seriesTypes: { heatmap: { prototype: { pointClass: s } } } } = t2, { extend: n } = a2;
        class r extends s {
          haloPath() {
            return this.series.tileShape.haloPath.apply(this, arguments);
          }
        }
        return n(r.prototype, { setState: i.prototype.setState, setVisible: e2.pointSetVisible }), r;
      }), a(t, "Series/Tilemap/TilemapSeriesDefaults.js", [], function() {
        return { marker: null, states: { hover: { halo: { enabled: true, size: 2, opacity: 0.5, attributes: { zIndex: 3 } } } }, pointPadding: 2, tileShape: "hexagon" };
      }), a(t, "Series/Tilemap/TilemapShapes.js", [t["Core/Globals.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function(e2, t2, a2) {
        let { noop: i } = e2, { heatmap: s, scatter: n } = t2.seriesTypes, { clamp: r, pick: l } = a2;
        function o(e3, t3, a3) {
          let i2 = e3.options;
          return { xPad: -((i2.colsize || 1) / t3), yPad: -((i2.rowsize || 1) / a3) };
        }
        return { hexagon: { alignDataLabel: n.prototype.alignDataLabel, getSeriesPadding: function(e3) {
          return o(e3, 3, 2);
        }, haloPath: function(e3) {
          if (!e3) return [];
          let t3 = this.tileEdges;
          return [["M", t3.x2 - e3, t3.y1 + e3], ["L", t3.x3 + e3, t3.y1 + e3], ["L", t3.x4 + 1.5 * e3, t3.y2], ["L", t3.x3 + e3, t3.y3 - e3], ["L", t3.x2 - e3, t3.y3 - e3], ["L", t3.x1 - 1.5 * e3, t3.y2], ["Z"]];
        }, translate: function() {
          let e3;
          let t3 = this.options, a3 = this.xAxis, i2 = this.yAxis, s2 = t3.pointPadding || 0, n2 = (t3.colsize || 1) / 3, l2 = (t3.rowsize || 1) / 2;
          for (let t4 of (this.generatePoints(), this.points)) {
            let o2 = r(Math.floor(a3.len - a3.translate(t4.x - 2 * n2, 0, 1, 0, 1)), -a3.len, 2 * a3.len), p = r(Math.floor(a3.len - a3.translate(t4.x - n2, 0, 1, 0, 1)), -a3.len, 2 * a3.len), h = r(Math.floor(a3.len - a3.translate(t4.x + n2, 0, 1, 0, 1)), -a3.len, 2 * a3.len), d = r(Math.floor(a3.len - a3.translate(t4.x + 2 * n2, 0, 1, 0, 1)), -a3.len, 2 * a3.len), u = r(Math.floor(i2.translate(t4.y - l2, 0, 1, 0, 1)), -i2.len, 2 * i2.len), g = r(Math.floor(i2.translate(t4.y, 0, 1, 0, 1)), -i2.len, 2 * i2.len), c = r(Math.floor(i2.translate(t4.y + l2, 0, 1, 0, 1)), -i2.len, 2 * i2.len), y = t4.pointPadding ?? s2, x = y * Math.abs(p - o2) / Math.abs(c - g), f = a3.reversed ? -x : x, m = a3.reversed ? -y : y, P = i2.reversed ? -y : y;
            t4.x % 2 && (e3 = e3 || Math.round(Math.abs(c - u) / 2) * (i2.reversed ? -1 : 1), u += e3, g += e3, c += e3), t4.plotX = t4.clientX = (p + h) / 2, t4.plotY = g, o2 += f + m, p += m, h -= m, d -= f + m, u -= P, c += P, t4.tileEdges = { x1: o2, x2: p, x3: h, x4: d, y1: u, y2: g, y3: c }, t4.shapeType = "path", t4.shapeArgs = { d: [["M", p, u], ["L", h, u], ["L", d, g], ["L", h, c], ["L", p, c], ["L", o2, g], ["Z"]] };
          }
          this.translateColors();
        } }, diamond: { alignDataLabel: n.prototype.alignDataLabel, getSeriesPadding: function(e3) {
          return o(e3, 2, 2);
        }, haloPath: function(e3) {
          if (!e3) return [];
          let t3 = this.tileEdges;
          return [["M", t3.x2, t3.y1 + e3], ["L", t3.x3 + e3, t3.y2], ["L", t3.x2, t3.y3 - e3], ["L", t3.x1 - e3, t3.y2], ["Z"]];
        }, translate: function() {
          let e3;
          let t3 = this.options, a3 = this.xAxis, i2 = this.yAxis, s2 = t3.pointPadding || 0, n2 = t3.colsize || 1, o2 = (t3.rowsize || 1) / 2;
          for (let t4 of (this.generatePoints(), this.points)) {
            let p = r(Math.round(a3.len - a3.translate(t4.x - n2, 0, 1, 0, 0)), -a3.len, 2 * a3.len), h = r(Math.round(a3.len - a3.translate(t4.x + n2, 0, 1, 0, 0)), -a3.len, 2 * a3.len), d = r(Math.round(i2.translate(t4.y - o2, 0, 1, 0, 0)), -i2.len, 2 * i2.len), u = r(Math.round(i2.translate(t4.y, 0, 1, 0, 0)), -i2.len, 2 * i2.len), g = r(Math.round(i2.translate(t4.y + o2, 0, 1, 0, 0)), -i2.len, 2 * i2.len), c = r(Math.round(a3.len - a3.translate(t4.x, 0, 1, 0, 0)), -a3.len, 2 * a3.len), y = l(t4.pointPadding, s2), x = y * Math.abs(c - p) / Math.abs(g - u), f = a3.reversed ? -x : x, m = i2.reversed ? -y : y;
            t4.x % 2 && (e3 = Math.abs(g - d) / 2 * (i2.reversed ? -1 : 1), d += e3, u += e3, g += e3), t4.plotX = t4.clientX = c, t4.plotY = u, p += f, h -= f, d -= m, g += m, t4.tileEdges = { x1: p, x2: c, x3: h, y1: d, y2: u, y3: g }, t4.shapeType = "path", t4.shapeArgs = { d: [["M", c, d], ["L", h, u], ["L", c, g], ["L", p, u], ["Z"]] };
          }
          this.translateColors();
        } }, circle: { alignDataLabel: n.prototype.alignDataLabel, getSeriesPadding: function(e3) {
          return o(e3, 2, 2);
        }, haloPath: function(e3) {
          return n.prototype.pointClass.prototype.haloPath.call(this, e3 + (e3 && this.radius));
        }, translate: function() {
          let e3 = this.options, t3 = this.xAxis, a3 = this.yAxis, i2 = e3.pointPadding || 0, s2 = (e3.rowsize || 1) / 2, n2 = e3.colsize || 1, l2, o2, p, h, d = false;
          for (let e4 of (this.generatePoints(), this.points)) {
            let u = r(Math.round(t3.len - t3.translate(e4.x, 0, 1, 0, 0)), -t3.len, 2 * t3.len), g = i2, c = false, y = r(Math.round(a3.translate(e4.y, 0, 1, 0, 0)), -a3.len, 2 * a3.len);
            void 0 !== e4.pointPadding && (g = e4.pointPadding, c = true, d = true), (!h || d) && (p = Math.floor(Math.sqrt((l2 = Math.abs(r(Math.floor(t3.len - t3.translate(e4.x + n2, 0, 1, 0, 0)), -t3.len, 2 * t3.len) - u)) * l2 + (o2 = Math.abs(r(Math.floor(a3.translate(e4.y + s2, 0, 1, 0, 0)), -a3.len, 2 * a3.len) - y)) * o2) / 2), h = Math.min(l2, p, o2) - g, d && !c && (d = false)), e4.x % 2 && (y += o2 * (a3.reversed ? -1 : 1)), e4.plotX = e4.clientX = u, e4.plotY = y, e4.radius = h, e4.shapeType = "circle", e4.shapeArgs = { x: u, y, r: h };
          }
          this.translateColors();
        } }, square: { alignDataLabel: s.prototype.alignDataLabel, translate: s.prototype.translate, getSeriesPadding: i, haloPath: s.prototype.pointClass.prototype.haloPath } };
      }), a(t, "Series/Tilemap/TilemapSeries.js", [t["Core/Globals.js"], t["Core/Series/SeriesRegistry.js"], t["Series/Tilemap/TilemapPoint.js"], t["Series/Tilemap/TilemapSeriesDefaults.js"], t["Series/Tilemap/TilemapShapes.js"], t["Core/Utilities.js"]], function(e2, t2, a2, i, s, n) {
        let { composed: r, noop: l } = e2, { column: o, heatmap: p, scatter: h } = t2.seriesTypes, { addEvent: d, extend: u, merge: g, pushUnique: c } = n;
        function y() {
          if (this.recomputingForTilemap || "colorAxis" === this.coll) return;
          let e3 = this, t3 = e3.series.map(function(t4) {
            return t4.getSeriesPixelPadding && t4.getSeriesPixelPadding(e3);
          }).reduce(function(e4, t4) {
            return (e4 && e4.padding) > (t4 && t4.padding) ? e4 : t4;
          }, void 0) || { padding: 0, axisLengthFactor: 1 }, a3 = Math.round(t3.padding * t3.axisLengthFactor);
          t3.padding && (e3.len -= a3, e3.recomputingForTilemap = true, e3.setAxisTranslation(), delete e3.recomputingForTilemap, e3.minPixelPadding += t3.padding, e3.len += a3);
        }
        class x extends p {
          static compose(e3) {
            c(r, "TilemapSeries") && d(e3, "afterSetAxisTranslation", y);
          }
          alignDataLabel() {
            return this.tileShape.alignDataLabel.apply(this, arguments);
          }
          drawPoints() {
            for (let e3 of (o.prototype.drawPoints.call(this), this.points)) e3.graphic && e3.graphic[this.chart.styledMode ? "css" : "animate"](this.colorAttribs(e3));
          }
          getSeriesPixelPadding(e3) {
            let t3 = e3.isXAxis, a3 = this.tileShape.getSeriesPadding(this);
            if (!a3) return { padding: 0, axisLengthFactor: 1 };
            let i2 = Math.round(e3.translate(t3 ? 2 * a3.xPad : a3.yPad, 0, 1, 0, 1)), s2 = Math.round(e3.translate(t3 ? a3.xPad : 0, 0, 1, 0, 1));
            return { padding: (e3.single ? Math.abs(i2 - s2) / 2 : Math.abs(i2 - s2)) || 0, axisLengthFactor: t3 ? 2 : 1.1 };
          }
          setOptions() {
            let e3 = super.setOptions.apply(this, arguments);
            return this.tileShape = s[e3.tileShape], e3;
          }
          translate() {
            return this.tileShape.translate.apply(this, arguments);
          }
        }
        return x.defaultOptions = g(p.defaultOptions, i), u(x.prototype, { getSymbol: l, markerAttribs: h.prototype.markerAttribs, pointAttribs: o.prototype.pointAttribs, pointClass: a2 }), t2.registerSeriesType("tilemap", x), x;
      }), a(t, "masters/modules/tilemap.src.js", [t["Core/Globals.js"], t["Series/Tilemap/TilemapSeries.js"]], function(e2, t2) {
        return t2.compose(e2.Axis), e2;
      });
    });
  }
});
export default require_tilemap();
//# sourceMappingURL=highcharts_modules_tilemap__js.js.map
